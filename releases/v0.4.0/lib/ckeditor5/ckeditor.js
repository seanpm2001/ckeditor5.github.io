var ClassicEditor = (function () {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!function (global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = (typeof module === "undefined" ? "undefined" : _typeof(module)) === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided, then outerFn.prototype instanceof Generator.
    var generator = Object.create((outerFn || Generator).prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction ||
    // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `value instanceof AwaitArgument` to determine if the yielded value is
  // meant to be awaited. Some may consider the name of this method too
  // cutesy, but they are curmudgeons.
  runtime.awrap = function (arg) {
    return new AwaitArgument(arg);
  };

  function AwaitArgument(arg) {
    this.arg = arg;
  }

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value instanceof AwaitArgument) {
          return Promise.resolve(value.arg).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
      // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
      // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          if (method === "return" || method === "throw" && delegate.iterator[method] === undefined) {
            // A return or throw (when the delegate iterator has no throw
            // method) always terminates the yield* loop.
            context.delegate = null;

            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            var returnMethod = delegate.iterator["return"];
            if (returnMethod) {
              var record = tryCatch(returnMethod, delegate.iterator, arg);
              if (record.type === "throw") {
                // If the return method threw an exception, let that
                // exception prevail over the original return or throw.
                method = "throw";
                arg = record.arg;
                continue;
              }
            }

            if (method === "return") {
              // Continue with the outer return, now that the delegate
              // iterator has been terminated.
              continue;
            }
          }

          var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;
            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = arg;
        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }
        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }
        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(arg) call above.
          method = "throw";
          arg = record.arg;
        }
      }
    };
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp[toStringTagSymbol] = "Generator";

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function stop() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }
    },

    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
}(
// Among the various tricks for obtaining a reference to the global
// object, this seems to be the most reliable technique that does not
// use indirect eval (which violates Content Security Policy).
(typeof global === "undefined" ? "undefined" : _typeof(global)) === "object" ? global : (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" ? window : (typeof self === "undefined" ? "undefined" : _typeof(self)) === "object" ? self : undefined);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Creates a spy function (ala Sinon.js) that can be used to inspect call to it.
 *
 * The following are the present features:
 *
 * * spy.called: property set to `true` if the function has been called at least once.
 *
 * @memberOf utils
 * @returns {Function} The spy function.
 */
function spy() {
  return function spy() {
    spy.called = true;
  };
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The event object passed to event callbacks. It is used to provide information about the event as well as a tool to
 * manipulate it.
 *
 * @memberOf utils
 */

var EventInfo = function EventInfo(source, name) {
	classCallCheck(this, EventInfo);

	/**
  * The object that fired the event.
  *
  * @member utils.EventInfo#source
  */
	this.source = source;

	/**
  * The event name.
  *
  * @member utils.EventInfo#name
  */
	this.name = name;

	/**
  * Path this event has followed. See {@link utils.EmitterMixin#delegate}.
  *
  * @member utils.EventInfo#path
  */
	this.path = [];

	// The following methods are defined in the constructor because they must be re-created per instance.

	/**
  * Stops the event emitter to call further callbacks for this event interaction.
  *
  * @method utils.EventInfo#stop
  */
	this.stop = spy();

	/**
  * Removes the current callback from future interactions of this event.
  *
  * @method utils.EventInfo#off
  */
	this.off = spy();
};

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Returns a unique id. This id is a number (starting from 1) which will never get repeated on successive calls
 * to this method.
 *
 * @function
 * @memberOf utils
 * @returns {Number} A number representing the id.
 */
var uid = (function () {
  var next = 1;

  return function () {
    return next++;
  };
})();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * String representing a priority value.
 *
 * @typedef {'highest'|'high'|'normal'|'low'|'lowest'} utils.PriorityString
 */

/**
 * Provides group of constants to use instead of hardcoding numeric priority values.
 *
 * @memberOf utils
 */
var priorities = {
	/**
  * Converts a string with priority name to it's numeric value. If `Number` is given, it just returns it.
  *
  * @param {utils.PriorityString|Number} priority Priority to convert.
  * @returns {Number} Converted priority.
  */
	get: function get(priority) {
		if (typeof priority != 'number') {
			return this[priority] || this.normal;
		} else {
			return priority;
		}
	},


	highest: 100000,
	high: 1000,
	normal: 0,
	low: -1000,
	lowest: -100000
};

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Mixin that injects the events API into its host.
 *
 * @mixin utils.EmitterMixin
 * @implements utils.Emitter
 */
var EmitterMixin = {
	/**
  * Registers a callback function to be executed when an event is fired. Events can be grouped in namespaces using `:`.
  * When namespaced event is fired, it additionaly fires all callbacks for that namespace.
  *
  *		myEmitter.on( 'myGroup', genericCallback );
  *		myEmitter.on( 'myGroup:myEvent', specificCallback );
  *		myEmitter.fire( 'myGroup' ); // genericCallback is fired.
  *		myEmitter.fire( 'myGroup:myEvent' ); // both genericCallback and specificCallback are fired.
  *		myEmitter.fire( 'myGroup:foo' ); // genericCallback is fired even though there are no callbacks for "foo".
  *
  * @param {String} event The name of the event.
  * @param {Function} callback The function to be called on event.
  * @param {Object} [options={}] Additional options.
  * @param {utils.PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher
  * the priority value the sooner the callback will be fired. Events having the same priority are called in the
  * order they were added.
  * @param {Object} [options.context] The object that represents `this` in the callback. Defaults to the object firing the event.
  * @method utils.EmitterMixin#on
  */
	on: function on(event, callback) {
		var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

		createEventNamespace(this, event);
		var lists = getCallbacksListsForNamespace(this, event);
		var priority = priorities.get(options.priority);

		callback = {
			callback: callback,
			context: options.context || this,
			priority: priority
		};

		// Add the callback to all callbacks list.
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = lists[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var callbacks = _step.value;

				// Add the callback to the list in the right priority position.
				var added = false;

				for (var i = 0; i < callbacks.length; i++) {
					if (callbacks[i].priority < priority) {
						callbacks.splice(i, 0, callback);
						added = true;

						break;
					}
				}

				// Add at the end, if right place was not found.
				if (!added) {
					callbacks.push(callback);
				}
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}
	},


	/**
  * Registers a callback function to be executed on the next time the event is fired only. This is similar to
  * calling {@link #on} followed by {@link #off} in the callback.
  *
  * @param {String} event The name of the event.
  * @param {Function} callback The function to be called on event.
  * @param {Object} [options={}] Additional options.
  * @param {utils.PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher
  * the priority value the sooner the callback will be fired. Events having the same priority are called in the
  * order they were added.
  * @param {Object} [options.context] The object that represents `this` in the callback. Defaults to the object firing the event.
  * @method utils.EmitterMixin#once
  */
	once: function once(event, callback, options) {
		var onceCallback = function onceCallback(event) {
			// Go off() at the first call.
			event.off();

			// Go with the original callback.
			callback.apply(this, arguments);
		};

		// Make a similar on() call, simply replacing the callback.
		this.on(event, onceCallback, options);
	},


	/**
  * Stops executing the callback on the given event.
  *
  * @param {String} event The name of the event.
  * @param {Function} callback The function to stop being called.
  * @param {Object} [context] The context object to be removed, pared with the given callback. To handle cases where
  * the same callback is used several times with different contexts.
  * @method utils.EmitterMixin#off
  */
	off: function off(event, callback, context) {
		var lists = getCallbacksListsForNamespace(this, event);

		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = lists[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var callbacks = _step2.value;

				for (var i = 0; i < callbacks.length; i++) {
					if (callbacks[i].callback == callback) {
						if (!context || context == callbacks[i].context) {
							// Remove the callback from the list (fixing the next index).
							callbacks.splice(i, 1);
							i--;
						}
					}
				}
			}
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}
	},


	/**
  * Registers a callback function to be executed when an event is fired in a specific (emitter) object.
  *
  * @param {utils.Emitter} emitter The object that fires the event.
  * @param {String} event The name of the event.
  * @param {Function} callback The function to be called on event.
  * @param {Object} [options={}] Additional options.
  * @param {utils.PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher
  * the priority value the sooner the callback will be fired. Events having the same priority are called in the
  * order they were added.
  * @param {Object} [options.context] The object that represents `this` in the callback. Defaults to the object firing the event.
  * @method utils.EmitterMixin#listenTo
  */
	listenTo: function listenTo(emitter, event, callback, options) {
		var emitters = void 0,
		    emitterId = void 0,
		    emitterInfo = void 0,
		    eventCallbacks = void 0;

		// _listeningTo contains a list of emitters that this object is listening to.
		// This list has the following format:
		//
		// _listeningTo: {
		//     emitterId: {
		//         emitter: emitter,
		//         callbacks: {
		//             event1: [ callback1, callback2, ... ]
		//             ....
		//         }
		//     },
		//     ...
		// }

		if (!(emitters = this._listeningTo)) {
			emitters = this._listeningTo = {};
		}

		if (!(emitterId = emitter._emitterId)) {
			emitterId = emitter._emitterId = uid();
		}

		if (!(emitterInfo = emitters[emitterId])) {
			emitterInfo = emitters[emitterId] = {
				emitter: emitter,
				callbacks: {}
			};
		}

		if (!(eventCallbacks = emitterInfo.callbacks[event])) {
			eventCallbacks = emitterInfo.callbacks[event] = [];
		}

		eventCallbacks.push(callback);

		// Finally register the callback to the event.
		emitter.on(event, callback, options);
	},


	/**
  * Stops listening for events. It can be used at different levels:
  *
  * * To stop listening to a specific callback.
  * * To stop listening to a specific event.
  * * To stop listening to all events fired by a specific object.
  * * To stop listening to all events fired by all object.
  *
  * @param {utils.Emitter} [emitter] The object to stop listening to. If omitted, stops it for all objects.
  * @param {String} [event] (Requires the `emitter`) The name of the event to stop listening to. If omitted, stops it
  * for all events from `emitter`.
  * @param {Function} [callback] (Requires the `event`) The function to be removed from the call list for the given
  * `event`.
  * @method utils.EmitterMixin#stopListening
  */
	stopListening: function stopListening(emitter, event, callback) {
		var emitters = this._listeningTo;
		var emitterId = emitter && emitter._emitterId;
		var emitterInfo = emitters && emitterId && emitters[emitterId];
		var eventCallbacks = emitterInfo && event && emitterInfo.callbacks[event];

		// Stop if nothing has been listened.
		if (!emitters || emitter && !emitterInfo || event && !eventCallbacks) {
			return;
		}

		// All params provided. off() that single callback.
		if (callback) {
			emitter.off(event, callback);
		}
		// Only `emitter` and `event` provided. off() all callbacks for that event.
		else if (eventCallbacks) {
				while (callback = eventCallbacks.pop()) {
					emitter.off(event, callback);
				}
				delete emitterInfo.callbacks[event];
			}
			// Only `emitter` provided. off() all events for that emitter.
			else if (emitterInfo) {
					for (event in emitterInfo.callbacks) {
						this.stopListening(emitter, event);
					}
					delete emitters[emitterId];
				}
				// No params provided. off() all emitters.
				else {
						for (emitterId in emitters) {
							this.stopListening(emitters[emitterId].emitter);
						}
						delete this._listeningTo;
					}
	},


	/**
  * Fires an event, executing all callbacks registered for it.
  *
  * The first parameter passed to callbacks is an {@link EventInfo} object, followed by the optional `args` provided in
  * the `fire()` method call.
  *
  * @param {String|utils.EventInfo} eventOrInfo The name of the event or `EventInfo` object if event is delegated.
  * @param {...*} [args] Additional arguments to be passed to the callbacks.
  * @method utils.EmitterMixin#fire
  */
	fire: function fire(eventOrInfo) {
		var eventInfo = eventOrInfo instanceof EventInfo ? eventOrInfo : new EventInfo(this, eventOrInfo);
		var event = eventInfo.name;
		var callbacks = getCallbacksForEvent(this, event);

		// Record that the event passed this emitter on its path.
		eventInfo.path.push(this);

		// Handle event listener callbacks first.

		for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			args[_key - 1] = arguments[_key];
		}

		if (callbacks) {
			// Arguments passed to each callback.
			var callbackArgs = [eventInfo].concat(args);

			// Copying callbacks array is the easiest and most secure way of preventing infinite loops, when event callbacks
			// are added while processing other callbacks. Previous solution involved adding counters (unique ids) but
			// failed if callbacks were added to the queue before currently processed callback.
			// If this proves to be too inefficient, another method is to change `.on()` so callbacks are stored if same
			// event is currently processed. Then, `.fire()` at the end, would have to add all stored events.
			callbacks = Array.from(callbacks);

			for (var i = 0; i < callbacks.length; i++) {
				callbacks[i].callback.apply(callbacks[i].context, callbackArgs);

				// Remove the callback from future requests if off() has been called.
				if (eventInfo.off.called) {
					// Remove the called mark for the next calls.
					delete eventInfo.off.called;

					this.off(event, callbacks[i].callback, callbacks[i].context);
				}

				// Do not execute next callbacks if stop() was called.
				if (eventInfo.stop.called) {
					break;
				}
			}
		}

		// Delegate event to other emitters if needed.
		if (this._delegations) {
			var destinations = this._delegations.get(event);

			if (destinations) {
				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = undefined;

				try {
					for (var _iterator3 = destinations[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						var dest = _step3.value;

						dest.fire.apply(dest, [eventInfo].concat(args));
					}
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 && _iterator3.return) {
							_iterator3.return();
						}
					} finally {
						if (_didIteratorError3) {
							throw _iteratorError3;
						}
					}
				}
			}
		}
	},


	/**
  * Delegates selected events to another {@link utils.Emitter}. For instance:
  *
  *		emitterA.delegate( 'eventX' ).to( emitterB );
  *		emitterA.delegate( 'eventX', 'eventY' ).to( emitterC );
  *
  * then `eventX` is delegated (fired by) `emitterB` and `emitterC` along with `data`:
  *
  *		emitterA.fire( 'eventX', data );
  *
  * and `eventY` is delegated (fired by) `emitterC` along with `data`:
  *
  *		emitterA.fire( 'eventY', data );
  *
  * @method utils.EmitterMixin#delegate
  * @param {...String} events Event names that will be delegated to another emitter.
  * @returns {utils.EmitterMixin.delegate#to}
  */
	delegate: function delegate() {
		var _this = this;

		for (var _len2 = arguments.length, events = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			events[_key2] = arguments[_key2];
		}

		return {
			/**
    * Selects destination for {@link utils.EmitterMixin#delegate} events.
    *
    * @method utils.EmitterMixin.delegate#to
    * @param {utils.Emitter} emitter An `EmitterMixin` instance which is the destination for delegated events.
    */
			to: function to(emitter) {
				if (!_this._delegations) {
					_this._delegations = new Map();
				}

				var _iteratorNormalCompletion4 = true;
				var _didIteratorError4 = false;
				var _iteratorError4 = undefined;

				try {
					for (var _iterator4 = events[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
						var eventName = _step4.value;

						var destinations = _this._delegations.get(eventName);

						if (!destinations) {
							_this._delegations.set(eventName, [emitter]);
						} else {
							destinations.push(emitter);
						}
					}
				} catch (err) {
					_didIteratorError4 = true;
					_iteratorError4 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion4 && _iterator4.return) {
							_iterator4.return();
						}
					} finally {
						if (_didIteratorError4) {
							throw _iteratorError4;
						}
					}
				}
			}
		};
	},


	/**
  * Stops delegating events. It can be used at different levels:
  *
  * * To stop delegating all events.
  * * To stop delegating a specific event to all emitters.
  * * To stop delegating a specific event to a specific emitter.
  *
  * @param {String} [event] The name of the event to stop delegating. If omitted, stops it all delegations.
  * @param {utils.Emitter} [emitter] (requires `event`) The object to stop delegating a particular event to. If omitted,
  * stops delegation of `event` to all emitters.
  * @method utils.EmitterMixin#stopDelegating
  */
	stopDelegating: function stopDelegating(event, emitter) {
		if (!this._delegations) {
			return;
		}

		if (!event) {
			this._delegations.clear();
		} else if (!emitter) {
			this._delegations.delete(event);
		} else {
			var destinations = this._delegations.get(event);
			var index = destinations.indexOf(emitter);

			if (index !== -1) {
				destinations.splice(index, 1);
			}
		}
	}
};

// Gets the internal `_events` property of the given object.
// `_events` property store all lists with callbacks for registered event names.
// If there were no events registered on the object, empty `_events` object is created.
function getEvents(source) {
	if (!source._events) {
		Object.defineProperty(source, '_events', {
			value: {}
		});
	}

	return source._events;
}

// Creates event node for generic-specific events relation architecture.
function makeEventNode() {
	return {
		callbacks: [],
		childEvents: []
	};
}

// Creates an architecture for generic-specific events relation.
// If needed, creates all events for given eventName, i.e. if the first registered event
// is foo:bar:abc, it will create foo:bar:abc, foo:bar and foo event and tie them together.
// It also copies callbacks from more generic events to more specific events when
// specific events are created.
function createEventNamespace(source, eventName) {
	var events = getEvents(source);

	// First, check if the event we want to add to the structure already exists.
	if (events[eventName]) {
		// If it exists, we don't have to do anything.
		return;
	}

	// In other case, we have to create the structure for the event.
	// Note, that we might need to create intermediate events too.
	// I.e. if foo:bar:abc is being registered and we only have foo in the structure,
	// we need to also register foo:bar.

	// Currently processed event name.
	var name = eventName;
	// Name of the event that is a child event for currently processed event.
	var childEventName = null;

	// Array containing all newly created specific events.
	var newEventNodes = [];

	// While loop can't check for ':' index because we have to handle generic events too.
	// In each loop, we truncate event name, going from the most specific name to the generic one.
	// I.e. foo:bar:abc -> foo:bar -> foo.
	while (name !== '') {
		if (events[name]) {
			// If the currently processed event name is already registered, we can be sure
			// that it already has all the structure created, so we can break the loop here
			// as no more events need to be registered.
			break;
		}

		// If this event is not yet registered, create a new object for it.
		events[name] = makeEventNode();
		// Add it to the array with newly created events.
		newEventNodes.push(events[name]);

		// Add previously processed event name as a child of this event.
		if (childEventName) {
			events[name].childEvents.push(childEventName);
		}

		childEventName = name;
		// If `.lastIndexOf()` returns -1, `.substr()` will return '' which will break the loop.
		name = name.substr(0, name.lastIndexOf(':'));
	}

	if (name !== '') {
		// If name is not empty, we found an already registered event that was a parent of the
		// event we wanted to register.

		// Copy that event's callbacks to newly registered events.
		var _iteratorNormalCompletion5 = true;
		var _didIteratorError5 = false;
		var _iteratorError5 = undefined;

		try {
			for (var _iterator5 = newEventNodes[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
				var node = _step5.value;

				node.callbacks = events[name].callbacks.slice();
			}

			// Add last newly created event to the already registered event.
		} catch (err) {
			_didIteratorError5 = true;
			_iteratorError5 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion5 && _iterator5.return) {
					_iterator5.return();
				}
			} finally {
				if (_didIteratorError5) {
					throw _iteratorError5;
				}
			}
		}

		events[name].childEvents.push(childEventName);
	}
}

// Gets an array containing callbacks list for a given event and it's more specific events.
// I.e. if given event is foo:bar and there is also foo:bar:abc event registered, this will
// return callback list of foo:bar and foo:bar:abc (but not foo).
// Returns empty array if given event has not been yet registered.
function getCallbacksListsForNamespace(source, eventName) {
	var eventNode = getEvents(source)[eventName];

	if (!eventNode) {
		return [];
	}

	var callbacksLists = [eventNode.callbacks];

	for (var i = 0; i < eventNode.childEvents.length; i++) {
		var childCallbacksLists = getCallbacksListsForNamespace(source, eventNode.childEvents[i]);

		callbacksLists = callbacksLists.concat(childCallbacksLists);
	}

	return callbacksLists;
}

// Get the list of callbacks for a given event, but only if there any callbacks have been registered.
// If there are no callbacks registered for given event, it checks if this is a specific event and looks
// for callbacks for it's more generic version.
function getCallbacksForEvent(source, eventName) {
	var event = void 0;

	if (!source._events || !(event = source._events[eventName]) || !event.callbacks.length) {
		// There are no callbacks registered for specified eventName.
		// But this could be a specific-type event that is in a namespace.
		if (eventName.indexOf(':') > -1) {
			// If the eventName is specific, try to find callback lists for more generic event.
			return getCallbacksForEvent(source, eventName.substr(0, eventName.lastIndexOf(':')));
		} else {
			// If this is a top-level generic event, return null;
			return null;
		}
	}

	return event.callbacks;
}

/**
 * Interface representing classes which mix in {@link utils.EmitterMixin}.
 *
 * @interface utils.Emitter
 */

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetPrototype = Object.getPrototypeOf;

/**
 * Gets the `[[Prototype]]` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {null|Object} Returns the `[[Prototype]]`.
 */
function getPrototype(value) {
  return nativeGetPrototype(Object(value));
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
}

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object,
 *  else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Handles a configuration dictionary.
 *
 * @memberOf utils
 */

var Config = function () {
	/**
  * Creates an instance of the {@link Config} class.
  *
  * @param {Object} [configurations] The initial configurations to be set.
  */
	function Config(configurations) {
		classCallCheck(this, Config);

		/**
   * Store for the whole configuration.
   *
   * @private
   * @member {Object} utils.config#_config
   */
		this._config = {};

		// Set initial configuration.
		if (configurations) {
			this._setObjectToTarget(this._config, configurations);
		}
	}

	/**
  * Set configuration values.
  *
  * It accepts both a name/value pair or an object, which properties and values will be used to set
  * configurations.
  *
  * It also accepts setting a "deep configuration" by using dots in the name. For example, `'resize.width'` sets
  * the value for the `width` configuration in the `resize` subset.
  *
  *		config.set( 'width', 500 );
  *		config.set( 'toolbar.collapsed', true );
  *
  *		// Equivalent to:
  *		config.set( {
  *			width: 500
  *			toolbar: {
  *				collapsed: true
  *			}
  *		} );
  *
  * Passing an object as the value will amend the configuration, not replace it.
  *
  *		config.set( 'toolbar', {
  *			collapsed: true,
  *		} );
  *
  *		config.set( 'toolbar', {
  *			color: 'red',
  *		} );
  *
  *		config.get( 'toolbar.collapsed' ); // true
  *		config.get( 'toolbar.color' ); // 'red'
  *
  * @param {String|Object} name The configuration name or an object from which take properties as
  * configuration entries. Configuration names are case-sensitive.
  * @param {*} value The configuration value. Used if a name is passed.
  */


	createClass(Config, [{
		key: 'set',
		value: function set(name, value) {
			this._setToTarget(this._config, name, value);
		}

		/**
   * Does exactly the same as {@link #set} with one exception – passed configuration extends
   * existing one, but does not overwrite already defined values.
   *
   * This method is supposed to be called by plugin developers to setup plugin's configurations. It would be
   * rarely used for other needs.
   *
   * @param {String|Object} name The configuration name or an object from which take properties as
   * configuration entries. Configuration names are case-sensitive.
   * @param {*} value The configuration value. Used if a name is passed.
   */

	}, {
		key: 'define',
		value: function define(name, value) {
			var isDefine = true;

			this._setToTarget(this._config, name, value, isDefine);
		}

		/**
   * Gets the value for a configuration entry.
   *
   *		config.get( 'name' );
   *
   * Deep configurations can be retrieved by separating each part with a dot.
   *
   *		config.get( 'toolbar.collapsed' );
   *
   * @param {String} name The configuration name. Configuration names are case-sensitive.
   * @returns {*} The configuration value or `undefined` if the configuration entry was not found.
   */

	}, {
		key: 'get',
		value: function get(name) {
			return this._getFromSource(this._config, name);
		}

		/**
   * Saves passed configuration to the specified target (nested object).
   *
   * @private
   * @param {Object} target Nested config object.
   * @param {String|Object} name The configuration name or an object from which take properties as
   * configuration entries. Configuration names are case-sensitive.
   * @param {*} value The configuration value. Used if a name is passed.
   * @param {Boolean} [isDefine=false] Define if passed configuration should overwrite existing one.
   */

	}, {
		key: '_setToTarget',
		value: function _setToTarget(target, name, value) {
			var isDefine = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

			// In case of an object, iterate through it and call `_setToTarget` again for each property.
			if (isPlainObject(name)) {
				this._setObjectToTarget(target, name, isDefine);

				return;
			}

			// The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].
			var parts = name.split('.');

			// Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.
			name = parts.pop();

			// Iterate over parts to check if currently stored configuration has proper structure.
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var part = _step.value;

					// If there is no object for specified part then create one.
					if (!isPlainObject(target[part])) {
						target[part] = {};
					}

					// Nested object becomes a target.
					target = target[part];
				}

				// In case of value is an object.
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			if (isPlainObject(value)) {
				// We take care of proper config structure.
				if (!isPlainObject(target[name])) {
					target[name] = {};
				}

				target = target[name];

				// And iterate through this object calling `_setToTarget` again for each property.
				this._setObjectToTarget(target, value, isDefine);

				return;
			}

			// Do nothing if we are defining configuration for non empty name.
			if (isDefine && typeof target[name] != 'undefined') {
				return;
			}

			target[name] = value;
		}

		/**
   * Get specified configuration from specified source (nested object).
   *
   * @private
   * @param {Object} source level of nested object.
   * @param {String} name The configuration name. Configuration names are case-sensitive.
   * @returns {*} The configuration value or `undefined` if the configuration entry was not found.
   */

	}, {
		key: '_getFromSource',
		value: function _getFromSource(source, name) {
			// The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].
			var parts = name.split('.');

			// Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.
			name = parts.pop();

			// Iterate over parts to check if currently stored configuration has proper structure.
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = parts[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var part = _step2.value;

					if (!isPlainObject(source[part])) {
						source = null;
						break;
					}

					// Nested object becomes a source.
					source = source[part];
				}

				// Always returns undefined for non existing configuration
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			return source ? source[name] : undefined;
		}

		/**
   * Iterate through passed object and call {@link #_setToTarget} method with object key and value for each property.
   *
   * @private
   * @param {Object} target Nested config object.
   * @param {Object} configuration Configuration data set
   * @param {Boolean} [isDefine] Defines if passed configuration is default configuration or not.
   */

	}, {
		key: '_setObjectToTarget',
		value: function _setObjectToTarget(target, configuration, isDefine) {
			var _this = this;

			Object.keys(configuration).forEach(function (key) {
				_this._setToTarget(target, key, configuration[key], isDefine);
			});
		}
	}]);
	return Config;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The CKEditor error class.
 *
 * All errors will be shortened during the minification process in order to reduce the code size.
 * Therefore, all error messages should be documented in the same way as those in {@link utils.log}.
 *
 * Read more in the {@link utils.log} module.
 *
 * @memberOf utils
 * @extends Error
 */
var CKEditorError = function (_Error) {
	inherits(CKEditorError, _Error);

	/**
  * Creates an instance of the CKEditorError class.
  *
  * Read more about error logging in the {@link utils.log} module.
  *
  * @param {String} message The error message in an `error-name: Error message.` format.
  * During the minification process the "Error message" part will be removed to limit the code size
  * and a link to this error documentation will be added to the `message`.
  * @param {Object} [data] Additional data describing the error. A stringified version of this object
  * will be appended to the error {@link #message}, so the data are quickly visible in the console. The original
  * data object will also be later available under the {@link #data} property.
  */
	function CKEditorError(message, data) {
		classCallCheck(this, CKEditorError);

		if (data) {
			message += ' ' + JSON.stringify(data);
		}

		/**
   * @member {String} utils.CKEditorError#name
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(CKEditorError).call(this, message));

		_this.name = 'CKEditorError';

		/**
   * The additional error data passed to the constructor.
   *
   * @member {Object} utils.CKEditorError#data
   */
		_this.data = data;
		return _this;
	}

	/**
  * Checks if error is an instance of CKEditorError class.
  *
  * @param {Object} error Object to check.
  * @returns {Boolean}
  */


	createClass(CKEditorError, null, [{
		key: 'isCKEditorError',
		value: function isCKEditorError(error) {
			return error instanceof CKEditorError;
		}
	}]);
	return CKEditorError;
}(Error);

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var other = { 'user': 'fred' };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$1.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    object[key] = value;
  }
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : source[key];

    assignValue(object, key, newValue);
  }
  return object;
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a
 * [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) that affects
 * Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return !!value && (type == 'object' || type == 'function');
}

var funcTag = '[object Function]';
var genTag = '[object GeneratorFunction]';
/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$1 = objectProto$3.toString;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8 which returns 'object' for typed array and weak map constructors,
  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
  var tag = isObject(value) ? objectToString$1.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length,
 *  else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value)) && !isFunction(value);
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index === 'undefined' ? 'undefined' : _typeof(index);
  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  var length = args.length;
  switch (length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$2 = objectProto$4.toString;

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && objectToString$2.call(value) == symbolTag;
}

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = isFunction(value.valueOf) ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

var INFINITY = 1 / 0;
var MAX_INTEGER = 1.7976931348623157e+308;
/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This function is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? remainder ? result - remainder : result : 0;
}

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as
 * an array.
 *
 * **Note:** This method is based on the
 * [rest parameter](https://mdn.io/rest_parameters).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.rest(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function rest(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = nativeMax(start === undefined ? func.length - 1 : toInteger(start), 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    switch (start) {
      case 0:
        return func.call(this, array);
      case 1:
        return func.call(this, args[0], array);
      case 2:
        return func.call(this, args[0], args[1], array);
    }
    var otherArgs = Array(start + 1);
    index = -1;
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return rest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$5;

  return value === proto;
}

/**
 * Checks if `value` is a global object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {null|Object} Returns `value` if it's a global object, else `null`.
 */
function checkGlobal(value) {
  return value && value.Object === Object ? value : null;
}

/** Used to determine if values are of the language type `Object`. */
var objectTypes = {
  'function': true,
  'object': true
};

/** Detect free variable `exports`. */
var freeExports = objectTypes[typeof exports === 'undefined' ? 'undefined' : _typeof(exports)] && exports && !exports.nodeType ? exports : undefined;

/** Detect free variable `module`. */
var freeModule = objectTypes[typeof module === 'undefined' ? 'undefined' : _typeof(module)] && module && !module.nodeType ? module : undefined;

/** Detect free variable `global` from Node.js. */
var freeGlobal = checkGlobal(freeExports && freeModule && (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global);

/** Detect free variable `self`. */
var freeSelf = checkGlobal(objectTypes[typeof self === 'undefined' ? 'undefined' : _typeof(self)] && self);

/** Detect free variable `window`. */
var freeWindow = checkGlobal(objectTypes[typeof window === 'undefined' ? 'undefined' : _typeof(window)] && window);

/** Detect `this` as the global object. */
var thisGlobal = checkGlobal(objectTypes[_typeof(undefined)] && undefined);

/**
 * Used as a reference to the global object.
 *
 * The `this` value is used if it's the global object to avoid Greasemonkey's
 * restricted `window` object, otherwise the `window` object is used.
 */
var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function('return this')();

/** Built-in value references. */
var Reflect = root.Reflect;

/**
 * Converts `iterator` to an array.
 *
 * @private
 * @param {Object} iterator The iterator to convert.
 * @returns {Array} Returns the converted array.
 */
function iteratorToArray(iterator) {
  var data,
      result = [];

  while (!(data = iterator.next()).done) {
    result.push(data.value);
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/** Built-in value references. */
var enumerate = Reflect ? Reflect.enumerate : undefined;
var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;
/**
 * The base implementation of `_.keysIn` which doesn't skip the constructor
 * property of prototypes or treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  object = object == null ? object : Object(object);

  var result = [];
  for (var key in object) {
    result.push(key);
  }
  return result;
}

// Fallback for IE < 9 with es6-shim.
if (enumerate && !propertyIsEnumerable$1.call({ 'valueOf': 1 }, 'valueOf')) {
  baseKeysIn = function baseKeysIn(object) {
    return iteratorToArray(enumerate(object));
  };
}

var baseKeysIn$1 = baseKeysIn;

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/** Used for built-in method references. */
var objectProto$8 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$8.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$3 = objectProto$8.toString;

/** Built-in value references. */
var propertyIsEnumerable$2 = objectProto$8.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty$3.call(value, 'callee') && (!propertyIsEnumerable$2.call(value, 'callee') || objectToString$3.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @type {Function}
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/** `Object#toString` result references. */
var stringTag = '[object String]';

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$4 = objectProto$9.toString;

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' || !isArray(value) && isObjectLike(value) && objectToString$4.call(value) == stringTag;
}

/**
 * Creates an array of index keys for `object` values of arrays,
 * `arguments` objects, and strings, otherwise `null` is returned.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array|null} Returns index keys, else `null`.
 */
function indexKeys(object) {
  var length = object ? object.length : undefined;
  if (isLength(length) && (isArray(object) || isString(object) || isArguments(object))) {
    return baseTimes(length, String);
  }
  return null;
}

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$6.hasOwnProperty;

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  var index = -1,
      isProto = isPrototype(object),
      props = baseKeysIn$1(object),
      propsLength = props.length,
      indexes = indexKeys(object),
      skipIndexes = !!indexes,
      result = indexes || [],
      length = result.length;

  while (++index < propsLength) {
    var key = props[index];
    if (!(skipIndexes && (key == 'length' || isIndex(key, length))) && !(key == 'constructor' && (isProto || !hasOwnProperty$2.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;

/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');

/**
 * This method is like `_.assign` except that it iterates over own and
 * inherited source properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extend
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assign
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * function Bar() {
 *   this.d = 4;
 * }
 *
 * Foo.prototype.c = 3;
 * Bar.prototype.e = 5;
 *
 * _.assignIn({ 'a': 1 }, new Foo, new Bar);
 * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5 }
 */
var assignIn = createAssigner(function (object, source) {
  if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keysIn(source), object);
    return;
  }
  for (var key in source) {
    assignValue(object, key, source[key]);
  }
});

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

var attributesSymbol = Symbol('attributes');
var boundObservablesSymbol = Symbol('boundObservables');
var boundAttributesSymbol = Symbol('boundAttributes');

/**
 * Mixin that injects the "observable attributes" and data binding functionality.
 * Used mainly in the {@link ui.Model} class.
 *
 * @mixin utils.ObservableMixin
 * @mixes utils.EmitterMixin
 * @implements utils.Observable
 */
var ObservableMixin = {
	/**
  * Creates and sets the value of an observable attribute of this object. Such an attribute becomes a part
  * of the state and is be observable.
  *
  * It accepts also a single object literal containing key/value pairs with attributes to be set.
  *
  * This method throws the {@link observable-set-cannot-override} error if the observable instance already
  * have a property with a given attribute name. This prevents from mistakenly overriding existing
  * properties and methods, but means that `foo.set( 'bar', 1 )` may be slightly slower than `foo.bar = 1`.
  *
  * @method utils.ObservableMixin#set
  * @param {String} name The attributes name.
  * @param {*} value The attributes value.
  */
	set: function set(name, value) {
		var _this = this;

		// If the first parameter is an Object, iterate over its properties.
		if (isObject(name)) {
			Object.keys(name).forEach(function (attr) {
				_this.set(attr, name[attr]);
			}, this);

			return;
		}

		initObservable(this);

		var attributes = this[attributesSymbol];

		if (name in this && !attributes.has(name)) {
			/**
    * Cannot override an existing property.
    *
    * This error is thrown when trying to {@link utils.Observable#set set} an attribute with
    * a name of an already existing property. For example:
    *
    *		let observable = new Model();
    *		observable.property = 1;
    *		observable.set( 'property', 2 );		// throws
    *
    *		observable.set( 'attr', 1 );
    *		observable.set( 'attr', 2 );			// ok, because this is an existing attribute.
    *
    * @error observable-set-cannot-override
    */
			throw new CKEditorError('observable-set-cannot-override: Cannot override an existing property.');
		}

		Object.defineProperty(this, name, {
			enumerable: true,
			configurable: true,

			get: function get() {
				return attributes.get(name);
			},
			set: function set(value) {
				var oldValue = attributes.get(name);

				// Allow undefined as an initial value like A.define( 'x', undefined ) (#132).
				// Note: When attributes map has no such own property, then its value is undefined.
				if (oldValue !== value || !attributes.has(name)) {
					attributes.set(name, value);
					this.fire('change:' + name, name, value, oldValue);
				}
			}
		});

		this[name] = value;
	},


	/**
  * Binds observable attributes to another objects implementing {@link ObservableMixin}
  * interface (like {@link ui.Model}).
  *
  * Once bound, the observable will immediately share the current state of attributes
  * of the observable it is bound to and react to the changes to these attributes
  * in the future.
  *
  * **Note**: To release the binding use {@link utils.ObservableMixin#unbind}.
  *
  *		A.bind( 'a' ).to( B );
  *		A.bind( 'a' ).to( B, 'b' );
  *		A.bind( 'a', 'b' ).to( B, 'c', 'd' );
  *		A.bind( 'a' ).to( B, 'b', C, 'd', ( b, d ) => b + d );
  *
  * @method utils.ObservableMixin#bind
  * @param {...String} bindAttrs Observable attributes that will be bound to another observable(s).
  * @returns {utils.BindChain}
  */
	bind: function bind() {
		for (var _len = arguments.length, bindAttrs = Array(_len), _key = 0; _key < _len; _key++) {
			bindAttrs[_key] = arguments[_key];
		}

		if (!bindAttrs.length || !isStringArray(bindAttrs)) {
			/**
    * All attributes must be strings.
    *
    * @error observable-bind-wrong-attrs
    */
			throw new CKEditorError('observable-bind-wrong-attrs: All attributes must be strings.');
		}

		if (new Set(bindAttrs).size !== bindAttrs.length) {
			/**
    * Attributes must be unique.
    *
    * @error observable-bind-duplicate-attrs
    */
			throw new CKEditorError('observable-bind-duplicate-attrs: Attributes must be unique.');
		}

		initObservable(this);

		var boundAttributes = this[boundAttributesSymbol];

		bindAttrs.forEach(function (attrName) {
			if (boundAttributes.has(attrName)) {
				/**
     * Cannot bind the same attribute more that once.
     *
     * @error observable-bind-rebind
     */
				throw new CKEditorError('observable-bind-rebind: Cannot bind the same attribute more that once.');
			}
		});

		var bindings = new Map();

		/**
   * @typedef utils.Binding
   * @type Object
   * @property {Array} attr Attribute which is bound.
   * @property {Array} to Array of observable–attribute components of the binding (`{ observable: ..., attr: .. }`).
   * @property {Array} callback A function which processes `to` components.
   */
		bindAttrs.forEach(function (a) {
			var binding = { attr: a, to: [] };

			boundAttributes.set(a, binding);
			bindings.set(a, binding);
		});

		/**
   * @typedef utils.BindChain
   * @type Object
   * @property {Function} to See {@link utils.ObservableMixin#_bindTo}.
   * @property {Observable} _observable The observable which initializes the binding.
   * @property {Array} _bindAttrs Array of `_observable` attributes to be bound.
   * @property {Array} _to Array of `to()` observable–attributes (`{ observable: toObservable, attrs: ...toAttrs }`).
   * @property {Map} _bindings Stores bindings to be kept in
   *  {@link utils.ObservableMixin#_boundAttributes}/{@link utils.ObservableMixin#_boundObservables}
   * initiated in this binding chain.
   */
		return {
			to: bindTo,

			_observable: this,
			_bindAttrs: bindAttrs,
			_to: [],
			_bindings: bindings
		};
	},


	/**
  * Removes the binding created with {@link utils.ObservableMixin#bind}.
  *
  *		A.unbind( 'a' );
  *		A.unbind();
  *
  * @method utils.ObservableMixin#unbind
  * @param {...String} [unbindAttrs] Observable attributes to be unbound. All the bindings will
  * be released if no attributes provided.
  */
	unbind: function unbind() {
		var _this2 = this;

		// Nothing to do here if not inited yet.
		if (!(attributesSymbol in this)) {
			return;
		}

		var boundAttributes = this[boundAttributesSymbol];
		var boundObservables = this[boundObservablesSymbol];

		for (var _len2 = arguments.length, unbindAttrs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			unbindAttrs[_key2] = arguments[_key2];
		}

		if (unbindAttrs.length) {
			if (!isStringArray(unbindAttrs)) {
				/**
     * Attributes must be strings.
     *
     * @error observable-unbind-wrong-attrs
     */
				throw new CKEditorError('observable-unbind-wrong-attrs: Attributes must be strings.');
			}

			unbindAttrs.forEach(function (attrName) {
				var binding = boundAttributes.get(attrName);
				var toObservable = void 0,
				    toAttr = void 0,
				    toAttrs = void 0,
				    toAttrBindings = void 0;

				binding.to.forEach(function (to) {
					// TODO: ES6 destructuring.
					toObservable = to[0];
					toAttr = to[1];
					toAttrs = boundObservables.get(toObservable);
					toAttrBindings = toAttrs[toAttr];

					toAttrBindings.delete(binding);

					if (!toAttrBindings.size) {
						delete toAttrs[toAttr];
					}

					if (!Object.keys(toAttrs).length) {
						boundObservables.delete(toObservable);
						_this2.stopListening(toObservable, 'change');
					}
				});

				boundAttributes.delete(attrName);
			});
		} else {
			boundObservables.forEach(function (bindings, boundObservable) {
				_this2.stopListening(boundObservable, 'change');
			});

			boundObservables.clear();
			boundAttributes.clear();
		}
	}
};

// Init symbol properties needed to for the observable mechanism to work.
//
// @private
// @param {ObservableMixin} observable
function initObservable(observable) {
	// Do nothing if already inited.
	if (attributesSymbol in observable) {
		return;
	}

	// The internal hash containing the observable's state.
	//
	// @private
	// @type {Map}
	Object.defineProperty(observable, attributesSymbol, {
		value: new Map()
	});

	// Map containing bindings to external observables. It shares the binding objects
	// (`{ observable: A, attr: 'a', to: ... }`) with {@link utils.ObservableMixin#_boundAttributes} and
	// it is used to observe external observables to update own attributes accordingly.
	// See {@link utils.ObservableMixin#bind}.
	//
	//		A.bind( 'a', 'b', 'c' ).to( B, 'x', 'y', 'x' );
	//		console.log( A._boundObservables );
	//
	//			Map( {
	//				B: {
	//					x: Set( [
	//						{ observable: A, attr: 'a', to: [ [ B, 'x' ] ] },
	//						{ observable: A, attr: 'c', to: [ [ B, 'x' ] ] }
	//					] ),
	//					y: Set( [
	//						{ observable: A, attr: 'b', to: [ [ B, 'y' ] ] },
	//					] )
	//				}
	//			} )
	//
	//		A.bind( 'd' ).to( B, 'z' ).to( C, 'w' ).as( callback );
	//		console.log( A._boundObservables );
	//
	//			Map( {
	//				B: {
	//					x: Set( [
	//						{ observable: A, attr: 'a', to: [ [ B, 'x' ] ] },
	//						{ observable: A, attr: 'c', to: [ [ B, 'x' ] ] }
	//					] ),
	//					y: Set( [
	//						{ observable: A, attr: 'b', to: [ [ B, 'y' ] ] },
	//					] ),
	//					z: Set( [
	//						{ observable: A, attr: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }
	//					] )
	//				},
	//				C: {
	//					w: Set( [
	//						{ observable: A, attr: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }
	//					] )
	//				}
	//			} )
	//
	// @private
	// @type {Map}
	Object.defineProperty(observable, boundObservablesSymbol, {
		value: new Map()
	});

	// Object that stores which attributes of this observable are bound and how. It shares
	// the binding objects (`{ observable: A, attr: 'a', to: ... }`) with {@link utils.ObservableMixin#_boundObservables}.
	// This data structure is a reverse of {@link utils.ObservableMixin#_boundObservables} and it is helpful for
	// {@link utils.ObservableMixin#unbind}.
	//
	// See {@link utils.ObservableMixin#bind}.
	//
	//		A.bind( 'a', 'b', 'c' ).to( B, 'x', 'y', 'x' );
	//		console.log( A._boundAttributes );
	//
	//			Map( {
	//				a: { observable: A, attr: 'a', to: [ [ B, 'x' ] ] },
	//				b: { observable: A, attr: 'b', to: [ [ B, 'y' ] ] },
	//				c: { observable: A, attr: 'c', to: [ [ B, 'x' ] ] }
	//			} )
	//
	//		A.bind( 'd' ).to( B, 'z' ).to( C, 'w' ).as( callback );
	//		console.log( A._boundAttributes );
	//
	//			Map( {
	//				a: { observable: A, attr: 'a', to: [ [ B, 'x' ] ] },
	//				b: { observable: A, attr: 'b', to: [ [ B, 'y' ] ] },
	//				c: { observable: A, attr: 'c', to: [ [ B, 'x' ] ] },
	//				d: { observable: A, attr: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }
	//			} )
	//
	// @private
	// @type {Map}
	Object.defineProperty(observable, boundAttributesSymbol, {
		value: new Map()
	});
}

// A chaining for {@link utils.ObservableMixin#bind} providing `.to()` interface.
//
// @private
// @param {...[Observable|String|Function]} args Arguments of the `.to( args )` binding.
function bindTo() {
	var _this3 = this;

	/* jshint validthis: true */
	var parsedArgs = parseBindToArgs.apply(undefined, arguments);
	var bindingsKeys = Array.from(this._bindings.keys());
	var numberOfBindings = bindingsKeys.length;

	// Eliminate A.bind( 'x' ).to( B, C )
	if (!parsedArgs.callback && parsedArgs.to.length > 1) {
		/**
   * Binding multiple observables only possible with callback.
   *
   * @error observable-bind-no-callback
   */
		throw new CKEditorError('observable-bind-to-no-callback: Binding multiple observables only possible with callback.');
	}

	// Eliminate A.bind( 'x', 'y' ).to( B, callback )
	if (numberOfBindings > 1 && parsedArgs.callback) {
		/**
   * Cannot bind multiple attributes and use a callback in one binding.
   *
   * @error observable-bind-to-extra-callback
   */
		throw new CKEditorError('observable-bind-to-extra-callback: Cannot bind multiple attributes and use a callback in one binding.');
	}

	parsedArgs.to.forEach(function (to) {
		// Eliminate A.bind( 'x', 'y' ).to( B, 'a' )
		if (to.attrs.length && to.attrs.length !== numberOfBindings) {
			/**
    * The number of attributes must match.
    *
    * @error observable-bind-to-attrs-length
    */
			throw new CKEditorError('observable-bind-to-attrs-length: The number of attributes must match.');
		}

		// When no to.attrs specified, observing source attributes instead i.e.
		// A.bind( 'x', 'y' ).to( B ) -> Observe B.x and B.y
		if (!to.attrs.length) {
			to.attrs = _this3._bindAttrs;
		}
	});

	this._to = parsedArgs.to;

	// Fill {@link BindChain#_bindings} with callback. When the callback is set there's only one binding.
	if (parsedArgs.callback) {
		this._bindings.get(bindingsKeys[0]).callback = parsedArgs.callback;
	}

	attachBindToListeners(this._observable, this._to);

	// Update observable._boundAttributes and observable._boundObservables.
	updateBindToBound(this);

	// Set initial values of bound attributes.
	this._bindAttrs.forEach(function (attrName) {
		updateBoundObservableAttr(_this3._observable, attrName);
	});
}

// Check if all entries of the array are of `String` type.
//
// @private
// @param {Array} arr An array to be checked.
// @returns {Boolean}
function isStringArray(arr) {
	return arr.every(function (a) {
		return typeof a == 'string';
	});
}

// Parses and validates {@link Observable#bind}`.to( args )` arguments and returns
// an object with a parsed structure. For example
//
//		A.bind( 'x' ).to( B, 'a', C, 'b', call );
//
// becomes
//
//		{
//			to: [
//				{ observable: B, attrs: [ 'a' ] },
//				{ observable: C, attrs: [ 'b' ] },
//			],
//			callback: call
// 		}
//
// @private
// @param {...*} args Arguments of {@link Observable#bind}`.to( args )`.
// @returns {Object}
function parseBindToArgs() {
	for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
		args[_key3] = arguments[_key3];
	}

	// Eliminate A.bind( 'x' ).to()
	if (!args.length) {
		/**
   * Invalid argument syntax in `to()`.
   *
   * @error observable-bind-to-parse-error
   */
		throw new CKEditorError('observable-bind-to-parse-error: Invalid argument syntax in `to()`.');
	}

	var parsed = { to: [] };
	var lastObservable = void 0;

	if (typeof args[args.length - 1] == 'function') {
		parsed.callback = args.pop();
	}

	args.forEach(function (a) {
		if (typeof a == 'string') {
			lastObservable.attrs.push(a);
		} else if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) == 'object') {
			lastObservable = { observable: a, attrs: [] };
			parsed.to.push(lastObservable);
		} else {
			throw new CKEditorError('observable-bind-to-parse-error: Invalid argument syntax in `to()`.');
		}
	});

	return parsed;
}

// Synchronizes {@link Observable#_boundObservables} with {@link Binding}.
//
// @private
// @param {Binding} binding A binding to store in {@link Observable#_boundObservables}.
// @param {Observable} toObservable A observable, which is a new component of `binding`.
// @param {String} toAttrName A name of `toObservable`'s attribute, a new component of the `binding`.
function updateBoundObservables(observable, binding, toObservable, toAttrName) {
	var boundObservables = observable[boundObservablesSymbol];
	var bindingsToObservable = boundObservables.get(toObservable);
	var bindings = bindingsToObservable || {};

	if (!bindings[toAttrName]) {
		bindings[toAttrName] = new Set();
	}

	// Pass the binding to a corresponding Set in `observable._boundObservables`.
	bindings[toAttrName].add(binding);

	if (!bindingsToObservable) {
		boundObservables.set(toObservable, bindings);
	}
}

// Synchronizes {@link Observable#_boundAttributes} and {@link Observable#_boundObservables}
// with {@link BindChain}.
//
// Assuming the following binding being created
//
// 		A.bind( 'a', 'b' ).to( B, 'x', 'y' );
//
// the following bindings were initialized by {@link Observable#bind} in {@link BindChain#_bindings}:
//
// 		{
// 			a: { observable: A, attr: 'a', to: [] },
// 			b: { observable: A, attr: 'b', to: [] },
// 		}
//
// Iterate over all bindings in this chain and fill their `to` properties with
// corresponding to( ... ) arguments (components of the binding), so
//
// 		{
// 			a: { observable: A, attr: 'a', to: [ B, 'x' ] },
// 			b: { observable: A, attr: 'b', to: [ B, 'y' ] },
// 		}
//
// Then update the structure of {@link Observable#_boundObservables} with updated
// binding, so it becomes:
//
// 		Map( {
// 			B: {
// 				x: Set( [
// 					{ observable: A, attr: 'a', to: [ [ B, 'x' ] ] }
// 				] ),
// 				y: Set( [
// 					{ observable: A, attr: 'b', to: [ [ B, 'y' ] ] },
// 				] )
//			}
// 		} )
//
// @private
// @param {BindChain} chain The binding initialized by {@link Observable#bind}.
function updateBindToBound(chain) {
	var toAttr = void 0;

	chain._bindings.forEach(function (binding, attrName) {
		// Note: For a binding without a callback, this will run only once
		// like in A.bind( 'x', 'y' ).to( B, 'a', 'b' )
		// TODO: ES6 destructuring.
		chain._to.forEach(function (to) {
			toAttr = to.attrs[binding.callback ? 0 : chain._bindAttrs.indexOf(attrName)];

			binding.to.push([to.observable, toAttr]);
			updateBoundObservables(chain._observable, binding, to.observable, toAttr);
		});
	});
}

// Updates an attribute of a {@link Observable} with a value
// determined by an entry in {@link Observable#_boundAttributes}.
//
// @private
// @param {Observable} observable A observable which attribute is to be updated.
// @param {String} attrName An attribute to be updated.
function updateBoundObservableAttr(observable, attrName) {
	var boundAttributes = observable[boundAttributesSymbol];
	var binding = boundAttributes.get(attrName);
	var attrValue = void 0;

	// When a binding with callback is created like
	//
	// 		A.bind( 'a' ).to( B, 'b', C, 'c', callback );
	//
	// collect B.b and C.c, then pass them to callback to set A.a.
	if (binding.callback) {
		attrValue = binding.callback.apply(observable, binding.to.map(function (to) {
			return to[0][to[1]];
		}));
	} else {
		attrValue = binding.to[0];
		attrValue = attrValue[0][attrValue[1]];
	}

	if (observable.hasOwnProperty(attrName)) {
		observable[attrName] = attrValue;
	} else {
		observable.set(attrName, attrValue);
	}
}

// Starts listening to changes in {@link BindChain._to} observables to update
// {@link BindChain._observable} {@link BindChain._bindAttrs}. Also sets the
// initial state of {@link BindChain._observable}.
//
// @private
// @param {BindChain} chain The chain initialized by {@link Observable#bind}.
function attachBindToListeners(observable, toBindings) {
	toBindings.forEach(function (to) {
		var boundObservables = observable[boundObservablesSymbol];
		var bindings = void 0;

		// If there's already a chain between the observables (`observable` listens to
		// `to.observable`), there's no need to create another `change` event listener.
		if (!boundObservables.get(to.observable)) {
			observable.listenTo(to.observable, 'change', function (evt, attrName) {
				bindings = boundObservables.get(to.observable)[attrName];

				// Note: to.observable will fire for any attribute change, react
				// to changes of attributes which are bound only.
				if (bindings) {
					bindings.forEach(function (binding) {
						updateBoundObservableAttr(observable, binding.attr);
					});
				}
			});
		}
	});
}

assignIn(ObservableMixin, EmitterMixin);

/**
 * Fired when an attribute changed value.
 *
 * @event utils.ObservableMixin#change:{attribute}
 * @param {String} name The attribute name.
 * @param {*} value The new attribute value.
 * @param {*} oldValue The previous attribute value.
 */

/**
 * Interface representing classes which mix in {@link utils.ObservableMixin}.
 *
 * @interface utils.Observable
 */

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Copies enumerable properties and symbols from the objects given as 2nd+ parameters to the
 * prototype of first object (a constructor).
 *
 *		class Editor {
 *			...
 *		}
 *
 *		const SomeMixin = {
 *			a() {
 *				return 'a';
 *			}
 *		};
 *
 *		mix( Editor, SomeMixin, ... );
 *
 *		new Editor().a(); // -> 'a'
 *
 * Note: Properties which already exist in the base class will not be overriden.
 *
 * @memberOf utils
 * @param {Function} [baseClass] Class which prototype will be extended.
 * @param {Object} [...mixins] Objects from which to get properties.
 */
function mix(baseClass) {
  for (var _len = arguments.length, mixins = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    mixins[_key - 1] = arguments[_key];
  }

  mixins.forEach(function (mixin) {
    Object.getOwnPropertyNames(mixin).concat(Object.getOwnPropertySymbols(mixin)).forEach(function (key) {
      if (key in baseClass.prototype) {
        return;
      }

      var sourceDescriptor = Object.getOwnPropertyDescriptor(mixin, key);
      sourceDescriptor.enumerable = false;

      Object.defineProperty(baseClass.prototype, key, sourceDescriptor);
    });
  });
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The base class for CKEditor plugin classes.
 *
 * @memberOf core
 * @mixes utils.ObservaleMixin
 */

var Plugin = function () {
	/**
  * Creates a new Plugin instance.
  *
  * @param {core.editor.Editor} editor
  */
	function Plugin(editor) {
		classCallCheck(this, Plugin);

		/**
   * @readonly
   * @member {core.editor.Editor} core.Plugin#editor
   */
		this.editor = editor;
	}

	/**
  * An array of plugins required by this plugin.
  *
  * To keep a plugin class definition tight it's recommended to define this property as a static getter:
  *
  *		import Image from './image.js';
  *
  *		export default class ImageCaption extends Feature {
     *			static get requires() {
     *				return [ Image ];
     *			}
  *		}
  *
  * @static
  * @member {Function[]} core.Plugin.requires
  */

	/**
  * @returns {null|Promise}
  */


	createClass(Plugin, [{
		key: 'init',
		value: function init() {}

		/**
   * Destroys the plugin.
   *
   * @returns {null|Promise}
   */

	}, {
		key: 'destroy',
		value: function destroy() {}
	}]);
	return Plugin;
}();

mix(Plugin, ObservableMixin);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* global console */

/**
 * The logging module.
 *
 * This object features two functions that should be used across CKEditor code base to log errors and warnings.
 * Despite being an overridable interface for native `console.*` this module serves also the goal to limit the
 * code size of a minified CKEditor package. During minification process the messages will be shortened and
 * links to their documentation will be logged to the console.
 *
 * All errors and warning should be documented in the following way:
 *
 *		/**
 *		 * Error thrown when a plugin cannot be loaded due to JavaScript errors, lack of plugins with a given name, etc.
 *		 *
 *		 * @error plugin-load
 *		 * @param pluginName The name of the plugin that could not be loaded.
 *		 * @param moduleName The name of the module which tried to load this plugin.
 *		 * /
 *		log.error( 'plugin-load: It was not possible to load the "{$pluginName}" plugin in module "{$moduleName}', {
 *			pluginName: 'foo',
 *			moduleName: 'bar'
 *		} );
 *
 * ### Warning vs Error vs Throw
 *
 * * Whenever a potentially incorrect situation occurs, which does not directly lead to an incorrect behavior,
 * log a warning.
 * * Whenever an incorrect situation occurs, but the app may continue working (although perhaps incorrectly),
 * log an error.
 * * Whenever it's really bad and it does not make sense to continue working, throw a {@link utils.CKEditorError}.
 *
 * @namespace utils.log
 */
var log = {
  /**
   * Logs an error to the console.
   *
   * Read more about error logging in the {@link utils.log} module.
   *
   * @param {String} message The error message in an `error-name: Error message.` format.
   * During the minification process the "Error message" part will be removed to limit the code size
   * and a link to this error documentation will be logged to the console.
   * @param {Object} [data] Additional data describing the error.
   * @method utils.log.error
   */
  error: function error(message, data) {
    console.error(message, data);
  },


  /**
   * Logs a warning to the console.
   *
   * Read more about error logging in the {@link utils.log} module.
   *
   * @param {String} message The warning message in a `warning-name: Warning message.` format.
   * During the minification process the "Warning message" part will be removed to limit the code size
   * and a link to this error documentation will be logged to the console.
   * @param {Object} [data] Additional data describing the warning.
   * @method utils.log.warn
   */
  warn: function warn(message, data) {
    console.warn(message, data);
  }
};

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Manages a list of CKEditor plugins, including loading, resolving dependencies and initialization.
 *
 * @memberOf core
 */

var PluginCollection = function () {
	/**
  * Creates an instance of the PluginCollection class, initializing it with a set of plugins.
  *
  * @param {core.editor.Editor} editor
  */
	function PluginCollection(editor) {
		classCallCheck(this, PluginCollection);

		/**
   * @protected
   * @member {core.editor.Editor} core.PluginCollection#_editor
   */
		this._editor = editor;

		/**
   * @protected
   * @member {Map} core.PluginCollection#_plugins
   */
		this._plugins = new Map();
	}

	/**
  * Collection iterator. Returns `[ PluginConstructor, pluginInstance ]` pairs.
  */


	createClass(PluginCollection, [{
		key: Symbol.iterator,
		value: function value() {
			return this._plugins[Symbol.iterator]();
		}

		/**
   * Gets the plugin instance by its constructor.
   *
   * @param {Function} key The plugin constructor.
   * @returns {core.Plugin}
   */

	}, {
		key: 'get',
		value: function get(key) {
			return this._plugins.get(key);
		}

		/**
   * Loads a set of plugins and add them to the collection.
   *
   * @param {Function[]} plugins An array of {@link core.Plugin plugin constructors}.
   * @returns {Promise} A promise which gets resolved once all plugins are loaded and available into the
   * collection.
   * @param {core.Plugin[]} returns.loadedPlugins The array of loaded plugins.
   */

	}, {
		key: 'load',
		value: function load(plugins) {
			var that = this;
			var editor = this._editor;
			var loading = new Set();
			var loaded = [];

			return Promise.all(plugins.map(loadPlugin)).then(function () {
				return loaded;
			});

			function loadPlugin(PluginConstructor) {
				// The plugin is already loaded or being loaded - do nothing.
				if (that.get(PluginConstructor) || loading.has(PluginConstructor)) {
					return;
				}

				return instantiatePlugin(PluginConstructor).catch(function (err) {
					/**
      * It was not possible to load the plugin.
      *
      * @error plugincollection-load
      * @param {String} plugin The name of the plugin that could not be loaded.
      */
					log.error('plugincollection-load: It was not possible to load the plugin.', { plugin: PluginConstructor });

					throw err;
				});
			}

			function instantiatePlugin(PluginConstructor) {
				return new Promise(function (resolve) {
					loading.add(PluginConstructor);

					assertIsPlugin(PluginConstructor);

					if (PluginConstructor.requires) {
						PluginConstructor.requires.forEach(loadPlugin);
					}

					var plugin = new PluginConstructor(editor);
					that._add(PluginConstructor, plugin);
					loaded.push(plugin);

					resolve();
				});
			}

			function assertIsPlugin(PluginConstructor) {
				if (!(PluginConstructor.prototype instanceof Plugin)) {
					/**
      * The loaded plugin module is not an instance of Plugin.
      *
      * @error plugincollection-instance
      * @param {*} plugin The constructor which is meant to be loaded as a plugin.
      */
					throw new CKEditorError('plugincollection-instance: The loaded plugin module is not an instance of Plugin.', { plugin: PluginConstructor });
				}
			}
		}

		/**
   * Adds the plugin to the collection. Exposed mainly for testing purposes.
   *
   * @protected
   * @param {Function} key The plugin constructor.
   * @param {core.Plugin} plugin The instance of the plugin.
   */

	}, {
		key: '_add',
		value: function _add(key, plugin) {
			this._plugins.set(key, plugin);
		}
	}]);
	return PluginCollection;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Represents the localization services.
 *
 * @memberOf utils
 */
var Locale = function () {
	/**
  * Creates a new instance of the Locale class. {@link Foo#bar}
  *
  * @param {String} [lang='en'] The language code in [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.
  */
	function Locale(lang) {
		var _this = this;

		classCallCheck(this, Locale);

		/**
   * The language code in [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.
   *
   * @readonly
   * @member {String} utils.Locale#lang
   */
		this.lang = lang || 'en';

		/**
   * Translates the given string to the {@link #lang}. This method is also availble in {@link Editor#t} and
   * {@link ui.View#t}.
   *
   * The strings may contain placeholders (`%<index>`) for values which are passed as the second argument.
   * `<index>` is the index in the `values` array.
   *
   *		editor.t( 'Created file "%0" in %1ms.', [ fileName, timeTaken ] );
   *
   * This method's context is statically bound to Locale instance,
   * so it can be called as a function:
   *
   *		const t = this.t;
   *		t( 'Label' );
   *
   * @method utils.Locale#t
   * @param {String} str The string to translate.
   * @param {String[]} values Values that should be used to interpolate the string.
   */
		this.t = function () {
			return _this._t.apply(_this, arguments);
		};
	}

	/**
  * Base for the {@link #t} method.
  *
  * @private
  */


	createClass(Locale, [{
		key: '_t',
		value: function _t(str, values) {
			if (values) {
				str = str.replace(/\%(\d+)/g, function (match, index) {
					return index < values.length ? values[index] : match;
				});
			}

			return str;
		}
	}]);
	return Locale;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Transforms object to map.
 *
 *		const map = objectToMap( { 'foo': 1, 'bar': 2 } );
 *		map.get( 'foo' ); // 1
 *
 * @memberOf utils
 * @param {Object} obj Object to transform.
 * @returns {Map} Map created from object.
 */
function objectToMap(obj) {
  var map = new Map();

  for (var key in obj) {
    map.set(key, obj[key]);
  }

  return map;
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Transforms object or iterable to map. Iterable needs to be in the format acceptable by the `Map` constructor.
 *
 *		map = toMap( { 'foo': 1, 'bar': 2 } );
 *		map = toMap( [ [ 'foo', 1 ], [ 'bar', 2 ] ] );
 *		map = toMap( anotherMap );
 *
 * @memberOf utils
 * @param {Object|Iterable} data Object or iterable to transform.
 * @returns {Map} Map created from data.
 */
function toMap(data) {
  if (isPlainObject(data)) {
    return objectToMap(data);
  } else {
    return new Map(data);
  }
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Model node. Most basic structure of model tree.
 *
 * This is an abstract class that is a base for other classes representing different nodes in model.
 *
 * **Note:** If a node is detached from the model tree, you can manipulate it using it's API.
 * However, it is **very important** that nodes already attached to model tree should be only changed through
 * {@link engine.model.Document#batch Batch API}.
 *
 * Changes done by `Node` methods, like {@link engine.model.Node#insertChildren insertChildren} or
 * {@link engine.model.Node#setAttribute setAttribute} do not generate {@link engine.model.operation.Operation operations}
 * which are essential for correct editor work if you modify nodes in {@link engine.model.Document document} root.
 *
 * The flow of working on `Node` (and classes that inherits from it) is as such:
 * 1. You can create a `Node` instance, modify it using it's API.
 * 2. Add `Node` to the model using `Batch` API.
 * 3. Change `Node` that was already added to the model using `Batch` API.
 *
 * Similarly, you cannot use `Batch` API on a node that has not been added to the model tree, with the exception
 * of {@link engine.model.Batch#insert inserting} that node to the model tree.
 *
 * Be aware that using {@link engine.model.Batch#remove remove from Batch API} does not allow to use `Node` API because
 * the information about `Node` is still kept in model document.
 *
 * In case of {@link engine.model.Element element node}, adding and removing children also counts as changing a node and
 * follows same rules.
 *
 * @memberOf engine.model
 */

var Node$1 = function () {
	/**
  * Creates a model node.
  *
  * This is an abstract class, so this constructor should not be used directly.
  *
  * @abstract
  * @param {Object} [attrs] Node's attributes. See {@link utils.toMap} for a list of accepted values.
  */
	function Node(attrs) {
		classCallCheck(this, Node);

		/**
   * Parent of this node. It could be {@link engine.model.Element} or {@link engine.model.DocumentFragment}.
   * Equals to `null` if the node has no parent.
   *
   * @readonly
   * @member {engine.model.Element|engine.model.DocumentFragment|null} engine.model.Node#parent
   */
		this.parent = null;

		/**
   * Attributes set on this node.
   *
   * @private
   * @member {Map} engine.model.Node#_attrs
   */
		this._attrs = toMap(attrs);
	}

	/**
  * Index of this node in it's parent or `null` if the node has no parent.
  *
  * Accessing this property throws an error if this node's parent element does not contain it.
  * This means that model tree got broken.
  *
  * @readonly
  * @type {Number|null}
  */


	createClass(Node, [{
		key: 'clone',


		/**
   * Creates a copy of this node, that is a node with exactly same attributes, and returns it.
   *
   * @returns {engine.model.Node} Node with same attributes as this node.
   */
		value: function clone() {
			return new Node(this._attrs);
		}

		/**
   * Gets path to the node. The path is an array containing starting offsets of consecutive ancestors of this node,
   * beginning from {@link engine.model.Node#root root}, down to this node's starting offset. The path can be used to
   * create {@link engine.model.Position Position} instance.
   *
   *		const abc = new Text( 'abc' );
   *		const foo = new Text( 'foo' );
   *		const h1 = new Element( 'h1', null, new Text( 'header' ) );
   *		const p = new Element( 'p', null, [ abc, foo ] );
   *		const div = new Element( 'div', null, [ h1, p ] );
   *		foo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.
   *		h1.getPath(); // Returns [ 0 ].
   *		div.getPath(); // Returns [].
   *
   * @returns {Array.<Number>} The path.
   */

	}, {
		key: 'getPath',
		value: function getPath() {
			var path = [];
			var node = this;

			while (node.parent) {
				path.unshift(node.startOffset);
				node = node.parent;
			}

			return path;
		}

		/**
   * Returns ancestors array of this node.
   *
   * @param {Object} options Options object.
   * @param {Boolean} [options.includeNode=false] When set to `true` this node will be also included in parent's array.
   * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from node's parent to root element,
   * otherwise root element will be the first item in the array.
   * @returns {Array} Array with ancestors.
   */

	}, {
		key: 'getAncestors',
		value: function getAncestors() {
			var options = arguments.length <= 0 || arguments[0] === undefined ? { includeNode: false, parentFirst: false } : arguments[0];

			var ancestors = [];
			var parent = options.includeNode ? this : this.parent;

			while (parent) {
				ancestors[options.parentFirst ? 'push' : 'unshift'](parent);
				parent = parent.parent;
			}

			return ancestors;
		}

		/**
   * Removes this node from it's parent.
   */

	}, {
		key: 'remove',
		value: function remove() {
			this.parent.removeChildren(this.index);
		}

		/**
   * Checks if the node has an attribute with given key.
   *
   * @param {String} key Key of attribute to check.
   * @returns {Boolean} `true` if attribute with given key is set on node, `false` otherwise.
   */

	}, {
		key: 'hasAttribute',
		value: function hasAttribute(key) {
			return this._attrs.has(key);
		}

		/**
   * Gets an attribute value for given key or `undefined` if that attribute is not set on node.
   *
   * @param {String} key Key of attribute to look for.
   * @returns {*} Attribute value or `undefined`.
   */

	}, {
		key: 'getAttribute',
		value: function getAttribute(key) {
			return this._attrs.get(key);
		}

		/**
   * Returns iterator that iterates over this node's attributes.
   *
   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
   *
   * @returns {Iterable.<*>}
   */

	}, {
		key: 'getAttributes',
		value: function getAttributes() {
			return this._attrs.entries();
		}

		/**
   * Returns iterator that iterates over this node's attribute keys.
   *
   * @returns {Iterator.<String>}
   */

	}, {
		key: 'getAttributeKeys',
		value: function getAttributeKeys() {
			return this._attrs.keys();
		}

		/**
   * Sets attribute on the node. If attribute with the same key already is set, it's value is overwritten.
   *
   * @param {String} key Key of attribute to set.
   * @param {*} value Attribute value.
   */

	}, {
		key: 'setAttribute',
		value: function setAttribute(key, value) {
			this._attrs.set(key, value);
		}

		/**
   * Removes all attributes from the node and sets given attributes.
   *
   * @param {Object} [attrs] Attributes to set. See {@link utils.toMap} for a list of accepted values.
   */

	}, {
		key: 'setAttributesTo',
		value: function setAttributesTo(attrs) {
			this._attrs = toMap(attrs);
		}

		/**
   * Removes an attribute with given key from the node.
   *
   * @param {String} key Key of attribute to remove.
   * @returns {Boolean} `true` if the attribute was set on the element, `false` otherwise.
   */

	}, {
		key: 'removeAttribute',
		value: function removeAttribute(key) {
			return this._attrs.delete(key);
		}

		/**
   * Removes all attributes from the node.
   */

	}, {
		key: 'clearAttributes',
		value: function clearAttributes() {
			this._attrs.clear();
		}

		/**
   * Converts `Node` to plain object and returns it.
   *
   * @returns {Object} `Node` converted to plain object.
   */

	}, {
		key: 'toJSON',
		value: function toJSON() {
			var json = {};

			if (this._attrs.size) {
				json.attributes = [].concat(toConsumableArray(this._attrs));
			}

			return json;
		}
	}, {
		key: 'index',
		get: function get() {
			var pos = void 0;

			if (!this.parent) {
				return null;
			}

			if ((pos = this.parent.getChildIndex(this)) === null) {
				/**
     * The node's parent does not contain this node.
     *
     * @error node-not-found-in-parent
     */
				throw new CKEditorError('model-node-not-found-in-parent: The node\'s parent does not contain this node.');
			}

			return pos;
		}

		/**
   * Offset at which this node starts in it's parent. It is equal to the sum of {@link engine.model.Node#offsetSize offsetSize}
   * of all it's previous siblings. Equals to `null` if node has no parent.
   *
   * Accessing this property throws an error if this node's parent element does not contain it.
   * This means that model tree got broken.
   *
   * @readonly
   * @type {Number|Null}
   */

	}, {
		key: 'startOffset',
		get: function get() {
			var pos = void 0;

			if (!this.parent) {
				return null;
			}

			if ((pos = this.parent.getChildStartOffset(this)) === null) {
				/**
     * The node's parent does not contain this node.
     *
     * @error node-not-found-in-parent
     */
				throw new CKEditorError('model-node-not-found-in-parent: The node\'s parent does not contain this node.');
			}

			return pos;
		}

		/**
   * Offset size of this node. Represents how much "offset space" is occupied by the node in it's parent.
   * It is important for {@link engine.model.Position position}. When node has `offsetSize` greater than `1`, position
   * can be placed between that node start and end. `offsetSize` greater than `1` is for nodes that represents more
   * than one entity, i.e. {@link engine.model.Text text node}.
   *
   * @readonly
   * @type {Number}
   */

	}, {
		key: 'offsetSize',
		get: function get() {
			return 1;
		}

		/**
   * Offset at which this node ends in it's parent. It is equal to the sum of this node's
   * {@link engine.model.Node#startOffset start offset} and {@link engine.model.Node#offsetSize offset size}. Equals
   * to `null` if the node has no parent.
   *
   * @readonly
   * @type {Number|null}
   */

	}, {
		key: 'endOffset',
		get: function get() {
			if (!this.parent) {
				return null;
			}

			return this.startOffset + this.offsetSize;
		}

		/**
   * Node's next sibling or `null` if the node is a last child of it's parent or if the node has no parent.
   *
   * @readonly
   * @type {engine.model.Node|null}
   */

	}, {
		key: 'nextSibling',
		get: function get() {
			var index = this.index;

			return index !== null && this.parent.getChild(index + 1) || null;
		}

		/**
   * Node's previous sibling or `null` if the node is a first child of it's parent or if the node has no parent.
   *
   * @readonly
   * @type {engine.model.Node|null}
   */

	}, {
		key: 'previousSibling',
		get: function get() {
			var index = this.index;

			return index !== null && this.parent.getChild(index - 1) || null;
		}

		/**
   * The top-most ancestor of the node. If node has no parent it is the root itself. If the node is a part
   * of {@link engine.model.DocumentFragment}, it's `root` is equal to that `DocumentFragment`.
   *
   * @readonly
   * @type {engine.model.Node|engine.model.DocumentFragment}
   */

	}, {
		key: 'root',
		get: function get() {
			var root = this;

			while (root.parent) {
				root = root.parent;
			}

			return root;
		}

		/**
   * {@link engine.model.Document Document} that owns this node or `null` if the node has no parent or is inside
   * a {@link engine.model.DocumentFragment DocumentFragment}.
   *
   * @readonly
   * @type {engine.model.Document|null}
   */

	}, {
		key: 'document',
		get: function get() {
			// This is a top element of a sub-tree.
			if (this.root == this) {
				return null;
			}

			// Root may be `DocumentFragment` which does not have document property.
			return this.root.document || null;
		}
	}]);
	return Node;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Provides an interface to operate on a list of {@link engine.model.Node nodes}. `NodeList` is used internally
 * in classes like {@link engine.model.Element Element} or {@link engine.model.DocumentFragment DocumentFragment}.
 */

var NodeList = function () {
	/**
  * Creates an empty node list.
  *
  * @param {Iterable.<engine.model.Node>} nodes Nodes contained in this node list.
  */
	function NodeList(nodes) {
		classCallCheck(this, NodeList);

		/**
   * Nodes contained in this node list.
   *
   * @private
   * @member {Array.<engine.model.Node>} engine.model.NodeList#_nodes
   */
		this._nodes = [];

		if (nodes) {
			this.insertNodes(0, nodes);
		}
	}

	/**
  * Returns an iterator that iterates over all nodes contained inside this node list.
  *
  * @returns {Iterator.<engine.model.Node>}
  */


	createClass(NodeList, [{
		key: Symbol.iterator,
		value: function value() {
			return this._nodes[Symbol.iterator]();
		}

		/**
   * Number of nodes contained inside this node list.
   *
   * @readonly
   * @type {Number}
   */

	}, {
		key: 'getNode',


		/**
   * Gets the node at the given index. Returns `null` if incorrect index was passed.
   *
   * @param {Number} index Index of node.
   * @returns {engine.model.Node|null} Node at given index.
   */
		value: function getNode(index) {
			return this._nodes[index] || null;
		}

		/**
   * Returns an index of the given node. Returns `null` if given node is not inside this node list.
   *
   * @param {engine.model.Node} node Child node to look for.
   * @returns {Number|null} Child node's index.
   */

	}, {
		key: 'getNodeIndex',
		value: function getNodeIndex(node) {
			var index = this._nodes.indexOf(node);

			return index == -1 ? null : index;
		}

		/**
   * Returns the starting offset of given node. Starting offset is equal to the sum of
   * {engine.model.Node#offsetSize offset sizes} of all nodes that are before this node in this node list.
   *
   * @param {engine.model.Node} node Node to look for.
   * @returns {Number|null} Node's starting offset.
   */

	}, {
		key: 'getNodeStartOffset',
		value: function getNodeStartOffset(node) {
			var index = this.getNodeIndex(node);

			return index === null ? null : this._nodes.slice(0, index).reduce(function (sum, node) {
				return sum + node.offsetSize;
			}, 0);
		}

		/**
   * Converts index to offset in node list.
   *
   * Returns starting offset of a node that is at given index. Throws {@link utils.CKEditorError CKEditorError}
   * `model-nodelist-index-out-of-bounds` if given index is less than `0` or more than {@link engine.model.NodeList#length}.
   *
   * @param {Number} index Node's index.
   * @returns {Number} Node's starting offset.
   */

	}, {
		key: 'indexToOffset',
		value: function indexToOffset(index) {
			if (index == this._nodes.length) {
				return this.maxOffset;
			}

			var node = this._nodes[index];

			if (!node) {
				/**
     * Given index cannot be found in the node list.
     *
     * @error nodelist-index-out-of-bounds
     */
				throw new CKEditorError('model-nodelist-index-out-of-bounds: Given index cannot be found in the node list.');
			}

			return this.getNodeStartOffset(node);
		}

		/**
   * Converts offset in node list to index.
   *
   * Returns index of a node that occupies given offset. Throws {@link utils.CKEditorError CKEditorError}
   * `model-nodelist-offset-out-of-bounds` if given offset is less than `0` or more than {@link engine.model.NodeList#getMaxOffset}.
   *
   * @param {Number} offset Offset to look for.
   * @returns {Number} Index of a node that occupies given offset.
   */

	}, {
		key: 'offsetToIndex',
		value: function offsetToIndex(offset) {
			var totalOffset = 0;

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = this._nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var node = _step.value;

					if (offset >= totalOffset && offset < totalOffset + node.offsetSize) {
						return this.getNodeIndex(node);
					}

					totalOffset += node.offsetSize;
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			if (totalOffset != offset) {
				/**
     * Given offset cannot be found in the node list.
     *
     * @error nodelist-offset-out-of-bounds
     */
				throw new CKEditorError('model-nodelist-offset-out-of-bounds: Given offset cannot be found in the node list.');
			}

			return this.length;
		}

		/**
   * Inserts given nodes at given index.
   *
   * @param {Number} index Index at which nodes should be inserted.
   * @param {Iterable.<engine.model.Node>} nodes Nodes to be inserted.
   */

	}, {
		key: 'insertNodes',
		value: function insertNodes(index, nodes) {
			var _nodes;

			// Validation.
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = nodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var node = _step2.value;

					if (!(node instanceof Node$1)) {
						/**
       * Trying to insert an object which is not a Node instance.
       *
       * @error nodelist-insertNodes-not-node
       */
						throw new CKEditorError('model-nodelist-insertNodes-not-node: Trying to insert an object which is not a Node instance.');
					}
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			(_nodes = this._nodes).splice.apply(_nodes, [index, 0].concat(toConsumableArray(nodes)));
		}

		/**
   * Removes one or more nodes starting at the given index.
   *
   * @param {Number} indexStart Index of the first node to remove.
   * @param {Number} [howMany=1] Number of nodes to remove.
   * @returns {Array.<engine.model.Node>} Array containing removed nodes.
   */

	}, {
		key: 'removeNodes',
		value: function removeNodes(indexStart) {
			var howMany = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

			return this._nodes.splice(indexStart, howMany);
		}

		/**
   * Converts `NodeList` instance to an array containing nodes that were inserted in the node list. Nodes
   * are also converted to their plain object representation.
   *
   * @returns {Array.<engine.model.Node>} `NodeList` instance converted to `Array`.
   */

	}, {
		key: 'toJSON',
		value: function toJSON() {
			return this._nodes.map(function (node) {
				return node.toJSON();
			});
		}
	}, {
		key: 'length',
		get: function get() {
			return this._nodes.length;
		}

		/**
   * Sum of {@link engine.model.Node#offsetSize offset sizes} of all nodes contained inside this node list.
   *
   * @readonly
   * @type {Number}
   */

	}, {
		key: 'maxOffset',
		get: function get() {
			return this._nodes.reduce(function (sum, node) {
				return sum + node.offsetSize;
			}, 0);
		}
	}]);
	return NodeList;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Model text node. Type of {@link engine.model.Node node} that contains {@link engine.model.Text#data text data}.
 *
 * **Important:** see {@link engine.model.Node} to read about restrictions using `Text` and `Node` API.
 *
 * **Note:** keep in mind that `Text` instances might indirectly got removed from model tree when model is changed.
 * This happens when {@link engine.model.writer model writer} is used to change model and the text node is merged with
 * another text node. Then, both text nodes are removed and a new text node is inserted into the model. Because of
 * this behavior, keeping references to `Text` is not recommended. Instead, consider creating
 * {@link engine.model.LivePosition live position} placed before the text node.
 *
 * @memberOf engine.model
 */

var Text$1 = function (_Node) {
	inherits(Text, _Node);

	/**
  * Creates a text node.
  *
  * @param {String} data Node's text.
  * @param {Object} [attrs] Node's attributes. See {@link utils.toMap} for a list of accepted values.
  */
	function Text(data, attrs) {
		classCallCheck(this, Text);

		/**
   * Text data contained in this text node.
   *
   * @type {String}
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(Text).call(this, attrs));

		_this.data = data || '';
		return _this;
	}

	/**
  * @inheritDoc
  */


	createClass(Text, [{
		key: 'clone',


		/**
   * Creates a copy of this text node and returns it. Created text node has same text data and attributes as original text node.
   */
		value: function clone() {
			return new Text(this.data, this.getAttributes());
		}

		/**
   * Converts `Text` instance to plain object and returns it.
   *
   * @returns {Object} `Text` instance converted to plain object.
   */

	}, {
		key: 'toJSON',
		value: function toJSON() {
			var json = get(Object.getPrototypeOf(Text.prototype), 'toJSON', this).call(this);

			json.data = this.data;

			return json;
		}

		/**
   * Creates a `Text` instance from given plain object (i.e. parsed JSON string).
   *
   * @param {Object} json Plain object to be converted to `Text`.
   * @returns {engine.model.Text} `Text` instance created using given plain object.
   */

	}, {
		key: 'offsetSize',
		get: function get() {
			return this.data.length;
		}
	}], [{
		key: 'fromJSON',
		value: function fromJSON(json) {
			return new Text(json.data, json.attributes);
		}
	}]);
	return Text;
}(Node$1);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Checks if value implements iterator interface.
 *
 * @memberOf utils
 * @param {*} value The value to check.
 * @returns {Boolean} True if value implements iterator interface.
 */
function isIterable(value) {
  return !!(value && value[Symbol.iterator]);
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Model element. Type of {@link engine.model.Node node} that has a {@link engine.model.Element#name name} and
 * {@link engine.model.Element#getChildren child nodes}.
 *
 * **Important**: see {@link engine.model.Node} to read about restrictions using `Element` and `Node` API.
 *
 * @memberOf engine.model
 */

var Element = function (_Node) {
	inherits(Element, _Node);

	/**
  * Creates a model element.
  *
  * @param {String} name Element's name.
  * @param {Object} [attrs] Element's attributes. See {@link utils.toMap} for a list of accepted values.
  * @param {engine.model.Node|Iterable.<engine.model.Node>} [children] One or more nodes to be inserted as children of
  * created element.
  */
	function Element(name, attrs, children) {
		classCallCheck(this, Element);

		/**
   * Element name.
   *
   * @member {String} engine.model.Element#name
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(Element).call(this, attrs));

		_this.name = name;

		/**
   * List of children nodes.
   *
   * @private
   * @member {engine.model.NodeList} engine.model.Element#_children
   */
		_this._children = new NodeList();

		if (children) {
			_this.insertChildren(0, children);
		}
		return _this;
	}

	/**
  * Number of this element's children.
  *
  * @readonly
  * @type {Number}
  */


	createClass(Element, [{
		key: 'getChild',


		/**
   * Gets the child at the given index.
   *
   * @param {Number} index Index of child.
   * @returns {engine.model.Node} Child node.
   */
		value: function getChild(index) {
			return this._children.getNode(index);
		}

		/**
   * Returns an iterator that iterates over all of this element's children.
   *
   * @returns {Iterable.<engine.model.Node>}
   */

	}, {
		key: 'getChildren',
		value: function getChildren() {
			return this._children[Symbol.iterator]();
		}

		/**
   * Returns an index of the given child node. Returns `null` if given node is not a child of this element.
   *
   * @param {engine.model.Node} node Child node to look for.
   * @returns {Number} Child node's index in this element.
   */

	}, {
		key: 'getChildIndex',
		value: function getChildIndex(node) {
			return this._children.getNodeIndex(node);
		}

		/**
   * Returns the starting offset of given child. Starting offset is equal to the sum of
   * {engine.model.Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if
   * given node is not a child of this element.
   *
   * @param {engine.model.Node} node Child node to look for.
   * @returns {Number} Child node's starting offset.
   */

	}, {
		key: 'getChildStartOffset',
		value: function getChildStartOffset(node) {
			return this._children.getNodeStartOffset(node);
		}

		/**
   * Creates a copy of this element and returns it. Created element has same name and attributes as original element.
   * If clone is not deep, children of copied element are references to the same nodes as in original element.
   * If clone is deep, original element's children are also cloned.
   *
   * @param {Boolean} [deep=false] Decides whether children of this element should also be cloned (`true`) or not (`false`).
   */

	}, {
		key: 'clone',
		value: function clone() {
			var deep = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

			var children = deep ? Array.from(this._children).map(function (node) {
				return node.clone();
			}) : Array.from(this._children);

			return new Element(this.name, this.getAttributes(), children);
		}

		/**
   * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is
   * too high, returns {@link engine.model.Element#getChildCount index after last child}.
   *
   *		const textNode = new Text( 'foo' );
   *		const pElement = new Element( 'p' );
   *		const divElement = new Element( [ textNode, pElement ] );
   *		divElement.offsetToIndex( -1 ); // Returns 0, because offset is too low.
   *		divElement.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.
   *		divElement.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.
   *		divElement.offsetToIndex( 2 ); // Returns 0.
   *		divElement.offsetToIndex( 3 ); // Returns 1.
   *		divElement.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.
   *
   * @param {Number} offset Offset to look for.
   * @returns {Number}
   */

	}, {
		key: 'offsetToIndex',
		value: function offsetToIndex(offset) {
			return this._children.offsetToIndex(offset);
		}

		/**
   * {@link engine.model.Element#insertChildren Inserts} one or more nodes at the end of this element.
   *
   * @param {engine.model.Node|Iterable.<engine.model.Node>} nodes Nodes to be inserted.
   */

	}, {
		key: 'appendChildren',
		value: function appendChildren(nodes) {
			this.insertChildren(this.childCount, nodes);
		}

		/**
   * Inserts one or more nodes at the given index and sets {@link engine.model.Node#parent parent} of these nodes
   * to this element.
   *
   * @param {Number} index Index at which nodes should be inserted.
   * @param {engine.model.Node|Iterable.<engine.model.Node>} nodes Nodes to be inserted.
   */

	}, {
		key: 'insertChildren',
		value: function insertChildren(index, nodes) {
			nodes = normalize$1(nodes);

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var node = _step.value;

					node.parent = this;
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			this._children.insertNodes(index, nodes);
		}

		/**
   * Removes one or more nodes starting at the given index and sets {@link engine.model.Node#parent parent} of these nodes to `null`.
   *
   * @param {Number} index Index of the first node to remove.
   * @param {Number} [howMany=1] Number of nodes to remove.
   * @returns {Array.<engine.model.Node>} Array containing removed nodes.
   */

	}, {
		key: 'removeChildren',
		value: function removeChildren(index) {
			var howMany = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

			var nodes = this._children.removeNodes(index, howMany);

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = nodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var node = _step2.value;

					node.parent = null;
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			return nodes;
		}

		/**
   * Converts `Element` instance to plain object and returns it. Takes care of converting all of this element's children.
   *
   * @returns {Object} `Element` instance converted to plain object.
   */

	}, {
		key: 'toJSON',
		value: function toJSON() {
			var json = get(Object.getPrototypeOf(Element.prototype), 'toJSON', this).call(this);

			json.name = this.name;

			if (this._children.length > 0) {
				json.children = [];

				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = undefined;

				try {
					for (var _iterator3 = this._children[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						var node = _step3.value;

						json.children.push(node.toJSON());
					}
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 && _iterator3.return) {
							_iterator3.return();
						}
					} finally {
						if (_didIteratorError3) {
							throw _iteratorError3;
						}
					}
				}
			}

			return json;
		}

		/**
   * Creates an `Element` instance from given plain object (i.e. parsed JSON string).
   * Converts `Element` children to proper nodes.
   *
   * @param {Object} json Plain object to be converted to `Element`.
   * @returns {engine.model.Element} `Element` instance created using given plain object.
   */

	}, {
		key: 'childCount',
		get: function get() {
			return this._children.length;
		}

		/**
   * Sum of {engine.model.Node#offsetSize offset sizes} of all of this element's children.
   *
   * @readonly
   * @type {Number}
   */

	}, {
		key: 'maxOffset',
		get: function get() {
			return this._children.maxOffset;
		}

		/**
   * Is `true` if there are no nodes inside this element, `false` otherwise.
   *
   * @readonly
   * @type {Boolean}
   */

	}, {
		key: 'isEmpty',
		get: function get() {
			return this.childCount === 0;
		}
	}], [{
		key: 'fromJSON',
		value: function fromJSON(json) {
			var children = null;

			if (json.children) {
				children = [];

				var _iteratorNormalCompletion4 = true;
				var _didIteratorError4 = false;
				var _iteratorError4 = undefined;

				try {
					for (var _iterator4 = json.children[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
						var child = _step4.value;

						if (child.name) {
							// If child has name property, it is an Element.
							children.push(Element.fromJSON(child));
						} else {
							// Otherwise, it is a Text node.
							children.push(Text$1.fromJSON(child));
						}
					}
				} catch (err) {
					_didIteratorError4 = true;
					_iteratorError4 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion4 && _iterator4.return) {
							_iterator4.return();
						}
					} finally {
						if (_didIteratorError4) {
							throw _iteratorError4;
						}
					}
				}
			}

			return new Element(json.name, json.attributes, children);
		}
	}]);
	return Element;
}(Node$1);

function normalize$1(nodes) {
	// Separate condition because string is iterable.
	if (typeof nodes == 'string') {
		return [new Text$1(nodes)];
	}

	if (!isIterable(nodes)) {
		nodes = [nodes];
	}

	// Array.from to enable .map() on non-arrays.
	return Array.from(nodes).map(function (node) {
		return typeof node == 'string' ? new Text$1(node) : node;
	});
}

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * DocumentFragment represents a part of model which does not have a common root but it's top-level nodes
 * can be seen as siblings. In other words, it is a detached part of model tree, without a root.
 *
 * @memberOf engine.model
 */

var DocumentFragment = function () {
	/**
  * Creates an empty `DocumentFragment`.
  *
  * @param {engine.model.Node|Iterable.<engine.model.Node>} [children] Nodes to be contained inside the `DocumentFragment`.
  */
	function DocumentFragment(children) {
		classCallCheck(this, DocumentFragment);

		/**
   * List of nodes contained inside the document fragment.
   *
   * @private
   * @member {engine.model.NodeList} engine.model.DocumentFragment#_children
   */
		this._children = new NodeList();

		if (children) {
			this.insertChildren(0, children);
		}
	}

	/**
  * Returns an iterator that iterates over all nodes contained inside this document fragment.
  *
  * @returns {Iterator.<engine.model.Node>}
  */


	createClass(DocumentFragment, [{
		key: Symbol.iterator,
		value: function value() {
			return this.getChildren();
		}

		/**
   * Number of this document fragment's children.
   *
   * @readonly
   * @type {Number}
   */

	}, {
		key: 'getChild',


		/**
   * Gets the child at the given index. Returns `null` if incorrect index was passed.
   *
   * @param {Number} index Index of child.
   * @returns {engine.model.Node|null} Child node.
   */
		value: function getChild(index) {
			return this._children.getNode(index);
		}

		/**
   * Returns an iterator that iterates over all of this document fragment's children.
   *
   * @returns {Iterable.<engine.model.Node>}
   */

	}, {
		key: 'getChildren',
		value: function getChildren() {
			return this._children[Symbol.iterator]();
		}

		/**
   * Returns an index of the given child node. Returns `null` if given node is not a child of this document fragment.
   *
   * @param {engine.model.Node} node Child node to look for.
   * @returns {Number|null} Child node's index.
   */

	}, {
		key: 'getChildIndex',
		value: function getChildIndex(node) {
			return this._children.getNodeIndex(node);
		}

		/**
   * Returns the starting offset of given child. Starting offset is equal to the sum of
   * {engine.model.Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if
   * given node is not a child of this document fragment.
   *
   * @param {engine.model.Node} node Child node to look for.
   * @returns {Number|null} Child node's starting offset.
   */

	}, {
		key: 'getChildStartOffset',
		value: function getChildStartOffset(node) {
			return this._children.getNodeStartOffset(node);
		}

		/**
   * Returns path to a `DocumentFragment`, which is an empty array. Added for compatibility reasons.
   *
   * @returns {Array}
   */

	}, {
		key: 'getPath',
		value: function getPath() {
			return [];
		}

		/**
   * Converts offset "position" to index "position".
   *
   * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is
   * too high, returns {@link engine.model.DocumentFragment#getChildCount index after last child}.
   *
   *		const textNode = new Text( 'foo' );
   *		const pElement = new Element( 'p' );
   *		const docFrag = new DocumentFragment( [ textNode, pElement ] );
   *		docFrag.offsetToIndex( -1 ); // Returns 0, because offset is too low.
   *		docFrag.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.
   *		docFrag.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.
   *		docFrag.offsetToIndex( 2 ); // Returns 0.
   *		docFrag.offsetToIndex( 3 ); // Returns 1.
   *		docFrag.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.
   *
   * @param {Number} offset Offset to look for.
   * @returns {Number} Index of a node that occupies given offset.
   */

	}, {
		key: 'offsetToIndex',
		value: function offsetToIndex(offset) {
			return this._children.offsetToIndex(offset);
		}

		/**
   * {@link engine.model.DocumentFragment#insertChildren Inserts} one or more nodes at the end of this document fragment.
   *
   * @param {engine.model.Node|Iterable.<engine.model.Node>} nodes Nodes to be inserted.
   */

	}, {
		key: 'appendChildren',
		value: function appendChildren(nodes) {
			this.insertChildren(this.childCount, nodes);
		}

		/**
   * Inserts one or more nodes at the given index and sets {@link engine.model.Node#parent parent} of these nodes
   * to this document fragment.
   *
   * @param {Number} index Index at which nodes should be inserted.
   * @param {engine.model.Node|Iterable.<engine.model.Node>} nodes Nodes to be inserted.
   */

	}, {
		key: 'insertChildren',
		value: function insertChildren(index, nodes) {
			nodes = normalize(nodes);

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var node = _step.value;

					node.parent = this;
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			this._children.insertNodes(index, nodes);
		}

		/**
   * Removes one or more nodes starting at the given index and sets {@link engine.model.Node#parent parent} of these nodes to `null`.
   *
   * @param {Number} index Index of the first node to remove.
   * @param {Number} [howMany=1] Number of nodes to remove.
   * @returns {Array.<engine.model.Node>} Array containing removed nodes.
   */

	}, {
		key: 'removeChildren',
		value: function removeChildren(index) {
			var howMany = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

			var nodes = this._children.removeNodes(index, howMany);

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = nodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var node = _step2.value;

					node.parent = null;
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			return nodes;
		}

		/**
   * Converts `DocumentFragment` instance to plain object and returns it.
   * Takes care of converting all of this document fragment's children.
   *
   * @returns {Object} `DocumentFragment` instance converted to plain object.
   */

	}, {
		key: 'toJSON',
		value: function toJSON() {
			var json = [];

			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = this._children[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var node = _step3.value;

					json.push(node.toJSON());
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}

			return json;
		}

		/**
   * Creates a `DocumentFragment` instance from given plain object (i.e. parsed JSON string).
   * Converts `DocumentFragment` children to proper nodes.
   *
   * @param {Object} json Plain object to be converted to `DocumentFragment`.
   * @returns {engine.model.DocumentFragment} `DocumentFragment` instance created using given plain object.
   */

	}, {
		key: 'childCount',
		get: function get() {
			return this._children.length;
		}

		/**
   * Sum of {engine.model.Node#offsetSize offset sizes} of all of this document fragment's children.
   *
   * @readonly
   * @type {Number}
   */

	}, {
		key: 'maxOffset',
		get: function get() {
			return this._children.maxOffset;
		}

		/**
   * Is `true` if there are no nodes inside this document fragment, `false` otherwise.
   *
   * @readonly
   * @type {Boolean}
   */

	}, {
		key: 'isEmpty',
		get: function get() {
			return this.childCount === 0;
		}

		/**
   * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.
   *
   * @readonly
   * @type {engine.model.DocumentFragment}
   */

	}, {
		key: 'root',
		get: function get() {
			return this;
		}

		/**
   * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
   *
   * @readonly
   * @type {null}
   */

	}, {
		key: 'parent',
		get: function get() {
			return null;
		}
	}], [{
		key: 'fromJSON',
		value: function fromJSON(json) {
			var children = [];

			var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
				for (var _iterator4 = json[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var child = _step4.value;

					if (child.name) {
						// If child has name property, it is an Element.
						children.push(Element.fromJSON(child));
					} else {
						// Otherwise, it is a Text node.
						children.push(Text$1.fromJSON(child));
					}
				}
			} catch (err) {
				_didIteratorError4 = true;
				_iteratorError4 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion4 && _iterator4.return) {
						_iterator4.return();
					}
				} finally {
					if (_didIteratorError4) {
						throw _iteratorError4;
					}
				}
			}

			return new DocumentFragment(children);
		}
	}]);
	return DocumentFragment;
}();

function normalize(nodes) {
	// Separate condition because string is iterable.
	if (typeof nodes == 'string') {
		return [new Text$1(nodes)];
	}

	if (!isIterable(nodes)) {
		nodes = [nodes];
	}

	// Array.from to enable .map() on non-arrays.
	return Array.from(nodes).map(function (node) {
		return typeof node == 'string' ? new Text$1(node) : node;
	});
}

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array ? array.length : 0;
  return length ? array[length - 1] : undefined;
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Compares how given arrays relate to each other. One array can be: same as another array, prefix of another array
 * or completely different. If arrays are different, first index at which they differ is returned. Otherwise,
 * a flag specifying the relation is returned. Flags are negative numbers, so whenever a number >= 0 is returned
 * it means that arrays differ.
 *
 *		compareArrays( [ 0, 2 ], [ 0, 2 ] );		// 'same'
 *		compareArrays( [ 0, 2 ], [ 0, 2, 1 ] );		// 'prefix'
 *		compareArrays( [ 0, 2 ], [ 0 ] );			// 'extension'
 *		compareArrays( [ 0, 2 ], [ 1, 2 ] );		// 0
 *		compareArrays( [ 0, 2 ], [ 0, 1 ] );		// 1
 *
 * @memberOf utils
 * @param {Array} a Array that is compared.
 * @param {Array} b Array to compare with.
 * @returns {utils.ArrayRelation} How array `a` is related to `b`.
 */
function compareArrays(a, b) {
  var minLen = Math.min(a.length, b.length);

  for (var i = 0; i < minLen; i++) {
    if (a[i] != b[i]) {
      // The arrays are different.
      return i;
    }
  }

  // Both arrays were same at all points.
  if (a.length == b.length) {
    // If their length is also same, they are the same.
    return 'same';
  } else if (a.length < b.length) {
    // Compared array is shorter so it is a prefix of the other array.
    return 'prefix';
  } else {
    // Compared array is longer so it is an extension of the other array.
    return 'extension';
  }
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Represents a position in the model tree.
 *
 * **Note:** Position is based on offsets, not indexes. This means that position in element containing two text nodes
 * with data `foo` and `bar`, position between them has offset `3`, not `1`. See {@link engine.model.Position#path} for more.
 *
 * Since position in a model is represented by a {@link engine.model.Position#root position root} and
 * {@link engine.model.Position#path position path} it is possible to create positions placed in non-existing elements.
 * This requirement is important for {@link engine.model.operation.transfrom operational transformation}.
 *
 * Also, {@link engine.model.operation.Operation operations} kept in {@link engine.model.Document#history document history}
 * are storing positions (and ranges) which were correct when those operations were applied, but may not be correct
 * after document got changed.
 *
 * When changes are applied to model, it may also happen that {@link engine.model.Position#parent position parent} will change
 * even if position path has not changed. Keep in mind, that if a position leads to non-existing element,
 * {@link engine.model.Position#parent} and some other properties and methods will throw errors.
 *
 * In most cases, position with wrong path is caused by an error in code, but it is sometimes needed, as described above.
 *
 * @memberOf engine.model
 */

var Position = function () {
	/**
  * Creates a position.
  *
  * @param {engine.model.Element|engine.model.DocumentFragment} root Root of the position.
  * @param {Array.<Number>} path Position path. See {@link engine.model.Position#path}.
  */
	function Position(root, path) {
		classCallCheck(this, Position);

		if (!(root instanceof Element) && !(root instanceof DocumentFragment)) {
			/**
    * Position root invalid.
    *
    * @error position-root-invalid.
    */
			throw new CKEditorError('model-position-root-invalid: Position root invalid.');
		}

		if (!(path instanceof Array) || path.length === 0) {
			/**
    * Position path must be an Array with at least one item.
    *
    * @error position-path-incorrect
    * @param path
    */
			throw new CKEditorError('model-position-path-incorrect: Position path must be an Array with at least one item.', { path: path });
		}

		// Normalize the root and path (if element was passed).
		path = root.getPath().concat(path);
		root = root.root;

		/**
   * Root of the position path.
   *
   * @readonly
   * @member {engine.model.Element|engine.model.DocumentFragment} engine.model.Position#root
   */
		this.root = root;

		/**
   * Position of the node it the tree. Path is described through offsets, not indexes.
   *
   * Position can be placed before, after or in a {@link engine.model.Node node} if that node has
   * {@link engine.model.Node#offsetSize} greater than `1`. Items in position path are
   * {@link engine.model.Node#startOffset starting offsets} of position ancestors, starting from direct root children,
   * down to the position offset in it's parent.
   *
   *		 ROOT
   *		  |- P            before: [ 0 ]         after: [ 1 ]
   *		  |- UL           before: [ 1 ]         after: [ 2 ]
   *		     |- LI        before: [ 1, 0 ]      after: [ 1, 1 ]
   *		     |  |- foo    before: [ 1, 0, 0 ]   after: [ 1, 0, 3 ]
   *		     |- LI        before: [ 1, 1 ]      after: [ 1, 2 ]
   *		        |- bar    before: [ 1, 1, 0 ]   after: [ 1, 1, 3 ]
   *
   * `foo` and `bar` are representing {@link engine.model.Text text nodes}. Since text nodes has offset size
   * greater than `1` you can place position offset between their start and end:
   *
   *		 ROOT
   *		  |- P
   *		  |- UL
   *		     |- LI
   *		     |  |- f^o|o  ^ has path: [ 1, 0, 1 ]   | has path: [ 1, 0, 2 ]
   *		     |- LI
   *		        |- b^a|r  ^ has path: [ 1, 1, 1 ]   | has path: [ 1, 1, 2 ]
   *
   * @member {Array.<Number>} engine.model.Position#path
   */
		this.path = path;
	}

	/**
  * Offset at which this position is located in its {@link engine.model.Position#parent parent}. It is equal
  * to the last item in position {@link engine.model.Position#path path}.
  *
  * @type {Number}
  */


	createClass(Position, [{
		key: 'compareWith',


		/**
   * Checks whether this position is before or after given position.
   *
   * @param {engine.model.Position} otherPosition Position to compare with.
   * @returns {engine.model.PositionRelation}
   */
		value: function compareWith(otherPosition) {
			if (this.root != otherPosition.root) {
				return 'different';
			}

			var result = compareArrays(this.path, otherPosition.path);

			switch (result) {
				case 'same':
					return 'same';

				case 'prefix':
					return 'before';

				case 'extension':
					return 'after';

				default:
					if (this.path[result] < otherPosition.path[result]) {
						return 'before';
					} else {
						return 'after';
					}
			}
		}

		/**
   * Returns a path to this position's parent. Parent path is equal to position {@link engine.model.Position#path path}
   * but without the last item.
   *
   * This method returns the parent path even if the parent does not exists.
   *
   * @returns {Array.<Number>} Path to the parent.
   */

	}, {
		key: 'getParentPath',
		value: function getParentPath() {
			return this.path.slice(0, -1);
		}

		/**
   * Returns ancestors array of this position, that is this position's parent and it's ancestors.
   *
   * @returns {Array.<engine.model.Item>} Array with ancestors.
   */

	}, {
		key: 'getAncestors',
		value: function getAncestors() {
			return this.parent.getAncestors({ includeNode: true, parentFirst: true });
		}

		/**
   * Returns a new instance of `Position`, that has same {@link engine.model.Position#parent parent} but it's offset
   * is shifted by `shift` value (can be a negative value).
   *
   * @param {Number} shift Offset shift. Can be a negative value.
   * @returns {engine.model.Position} Shifted position.
   */

	}, {
		key: 'getShiftedBy',
		value: function getShiftedBy(shift) {
			var shifted = Position.createFromPosition(this);

			var offset = shifted.offset + shift;
			shifted.offset = offset < 0 ? 0 : offset;

			return shifted;
		}

		/**
   * Checks whether this position is after given position.
   *
   * @see engine.model.Position#isBefore
   *
   * @param {engine.model.Position} otherPosition Position to compare with.
   * @returns {Boolean} True if this position is after given position.
   */

	}, {
		key: 'isAfter',
		value: function isAfter(otherPosition) {
			return this.compareWith(otherPosition) == 'after';
		}

		/**
   * Checks whether this position is before given position.
   *
   * **Note:** watch out when using negation of the value returned by this method, because the negation will also
   * be `true` if positions are in different roots and you might not expect this. You should probably use
   * `a.isAfter( b ) || a.isEqual( b )` or `!a.isBefore( p ) && a.root == b.root` in most scenarios. If your
   * condition uses multiple `isAfter` and `isBefore` checks, build them so they do not use negated values, i.e.:
   *
   *		if ( a.isBefore( b ) && c.isAfter( d ) ) {
   *			// do A.
   *		} else {
   *			// do B.
   *		}
   *
   * or, if you have only one if-branch:
   *
   *		if ( !( a.isBefore( b ) && c.isAfter( d ) ) {
   *			// do B.
   *		}
   *
   * rather than:
   *
   *		if ( !a.isBefore( b ) || && !c.isAfter( d ) ) {
   *			// do B.
   *		} else {
   *			// do A.
   *		}
   *
   * @param {engine.model.Position} otherPosition Position to compare with.
   * @returns {Boolean} True if this position is before given position.
   */

	}, {
		key: 'isBefore',
		value: function isBefore(otherPosition) {
			return this.compareWith(otherPosition) == 'before';
		}

		/**
   * Checks whether this position is equal to given position.
   *
   * @param {engine.model.Position} otherPosition Position to compare with.
   * @returns {Boolean} True if positions are same.
   */

	}, {
		key: 'isEqual',
		value: function isEqual(otherPosition) {
			return this.compareWith(otherPosition) == 'same';
		}

		/**
   * Checks whether this position is touching given position. Positions touch when there are no text nodes
   * or empty nodes in a range between them. Technically, those positions are not equal but in many cases
   * they are very similar or even indistinguishable.
   *
   * @param {engine.model.Position} otherPosition Position to compare with.
   * @returns {Boolean} True if positions touch.
   */

	}, {
		key: 'isTouching',
		value: function isTouching(otherPosition) {
			var left = null;
			var right = null;
			var compare = this.compareWith(otherPosition);

			switch (compare) {
				case 'same':
					return true;

				case 'before':
					left = Position.createFromPosition(this);
					right = Position.createFromPosition(otherPosition);
					break;

				case 'after':
					left = Position.createFromPosition(otherPosition);
					right = Position.createFromPosition(this);
					break;

				default:
					return false;
			}

			// Cached for optimization purposes.
			var leftParent = left.parent;

			while (left.path.length + right.path.length) {
				if (left.isEqual(right)) {
					return true;
				}

				if (left.path.length > right.path.length) {
					if (left.offset !== leftParent.maxOffset) {
						return false;
					}

					left.path = left.path.slice(0, -1);
					leftParent = leftParent.parent;
					left.offset++;
				} else {
					if (right.offset !== 0) {
						return false;
					}

					right.path = right.path.slice(0, -1);
				}
			}
		}

		/**
   * Returns a copy of this position that is updated by removing `howMany` nodes starting from `deletePosition`.
   * It may happen that this position is in a removed node. If that is the case, `null` is returned instead.
   *
   * @protected
   * @param {engine.model.Position} deletePosition Position before the first removed node.
   * @param {Number} howMany How many nodes are removed.
   * @returns {engine.model.Position|null} Transformed position or `null`.
   */

	}, {
		key: '_getTransformedByDeletion',
		value: function _getTransformedByDeletion(deletePosition, howMany) {
			var transformed = Position.createFromPosition(this);

			// This position can't be affected if deletion was in a different root.
			if (this.root != deletePosition.root) {
				return transformed;
			}

			if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == 'same') {
				// If nodes are removed from the node that is pointed by this position...
				if (deletePosition.offset < this.offset) {
					// And are removed from before an offset of that position...
					if (deletePosition.offset + howMany > this.offset) {
						// Position is in removed range, it's no longer in the tree.
						return null;
					} else {
						// Decrement the offset accordingly.
						transformed.offset -= howMany;
					}
				}
			} else if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == 'prefix') {
				// If nodes are removed from a node that is on a path to this position...
				var i = deletePosition.path.length - 1;

				if (deletePosition.offset <= this.path[i]) {
					// And are removed from before next node of that path...
					if (deletePosition.offset + howMany > this.path[i]) {
						// If the next node of that path is removed return null
						// because the node containing this position got removed.
						return null;
					} else {
						// Otherwise, decrement index on that path.
						transformed.path[i] -= howMany;
					}
				}
			}

			return transformed;
		}

		/**
   * Returns a copy of this position that is updated by inserting `howMany` nodes at `insertPosition`.
   *
   * @protected
   * @param {engine.model.Position} insertPosition Position where nodes are inserted.
   * @param {Number} howMany How many nodes are inserted.
   * @param {Boolean} insertBefore Flag indicating whether nodes are inserted before or after `insertPosition`.
   * This is important only when `insertPosition` and this position are same. If that is the case and the flag is
   * set to `true`, this position will get transformed. If the flag is set to `false`, it won't.
   * @returns {engine.model.Position} Transformed position.
   */

	}, {
		key: '_getTransformedByInsertion',
		value: function _getTransformedByInsertion(insertPosition, howMany, insertBefore) {
			var transformed = Position.createFromPosition(this);

			// This position can't be affected if insertion was in a different root.
			if (this.root != insertPosition.root) {
				return transformed;
			}

			if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == 'same') {
				// If nodes are inserted in the node that is pointed by this position...
				if (insertPosition.offset < this.offset || insertPosition.offset == this.offset && insertBefore) {
					// And are inserted before an offset of that position...
					// "Push" this positions offset.
					transformed.offset += howMany;
				}
			} else if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == 'prefix') {
				// If nodes are inserted in a node that is on a path to this position...
				var i = insertPosition.path.length - 1;

				if (insertPosition.offset <= this.path[i]) {
					// And are inserted before next node of that path...
					// "Push" the index on that path.
					transformed.path[i] += howMany;
				}
			}

			return transformed;
		}

		/**
   * Returns a copy of this position that is updated by moving `howMany` nodes from `sourcePosition` to `targetPosition`.
   *
   * @protected
   * @param {engine.model.Position} sourcePosition Position before the first element to move.
   * @param {engine.model.Position} targetPosition Position where moved elements will be inserted.
   * @param {Number} howMany How many consecutive nodes to move, starting from `sourcePosition`.
   * @param {Boolean} insertBefore Flag indicating whether moved nodes are pasted before or after `insertPosition`.
   * This is important only when `targetPosition` and this position are same. If that is the case and the flag is
   * set to `true`, this position will get transformed by range insertion. If the flag is set to `false`, it won't.
   * @param {Boolean} [sticky] Flag indicating whether this position "sticks" to range, that is if it should be moved
   * with the moved range if it is equal to one of range's boundaries.
   * @returns {engine.model.Position} Transformed position.
   */

	}, {
		key: '_getTransformedByMove',
		value: function _getTransformedByMove(sourcePosition, targetPosition, howMany, insertBefore, sticky) {
			// Moving a range removes nodes from their original position. We acknowledge this by proper transformation.
			var transformed = this._getTransformedByDeletion(sourcePosition, howMany);

			// Then we update target position, as it could be affected by nodes removal too.
			targetPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);

			if (transformed === null || sticky && transformed.isEqual(sourcePosition)) {
				// This position is inside moved range (or sticks to it).
				// In this case, we calculate a combination of this position, move source position and target position.
				transformed = this._getCombined(sourcePosition, targetPosition);
			} else {
				// This position is not inside a removed range.
				// In next step, we simply reflect inserting `howMany` nodes, which might further affect the position.
				transformed = transformed._getTransformedByInsertion(targetPosition, howMany, insertBefore);
			}

			return transformed;
		}

		/**
   * Returns a new position that is a combination of this position and given positions.
   *
   * The combined position is a copy of this position transformed by moving a range starting at `source` position
   * to the `target` position. It is expected that this position is inside the moved range.
   *
   * Example:
   *
   *		let original = new Position( root, [ 2, 3, 1 ] );
   *		let source = new Position( root, [ 2, 2 ] );
   *		let target = new Position( otherRoot, [ 1, 1, 3 ] );
   *		original._getCombined( source, target ); // path is [ 1, 1, 4, 1 ], root is `otherRoot`
   *
   * Explanation:
   *
   * We have a position `[ 2, 3, 1 ]` and move some nodes from `[ 2, 2 ]` to `[ 1, 1, 3 ]`. The original position
   * was inside moved nodes and now should point to the new place. The moved nodes will be after
   * positions `[ 1, 1, 3 ]`, `[ 1, 1, 4 ]`, `[ 1, 1, 5 ]`. Since our position was in the second moved node,
   * the transformed position will be in a sub-tree of a node at `[ 1, 1, 4 ]`. Looking at original path, we
   * took care of `[ 2, 3 ]` part of it. Now we have to add the rest of the original path to the transformed path.
   * Finally, the transformed position will point to `[ 1, 1, 4, 1 ]`.
   *
   * @protected
   * @param {engine.model.Position} source Beginning of the moved range.
   * @param {engine.model.Position} target Position where the range is moved.
   * @returns {engine.model.Position} Combined position.
   */

	}, {
		key: '_getCombined',
		value: function _getCombined(source, target) {
			var i = source.path.length - 1;

			// The first part of a path to combined position is a path to the place where nodes were moved.
			var combined = Position.createFromPosition(target);

			// Then we have to update the rest of the path.

			// Fix the offset because this position might be after `from` position and we have to reflect that.
			combined.offset = combined.offset + this.path[i] - source.offset;

			// Then, add the rest of the path.
			// If this position is at the same level as `from` position nothing will get added.
			combined.path = combined.path.concat(this.path.slice(i + 1));

			return combined;
		}

		/**
   * Creates position at the given location. The location can be specified as:
   *
   * * a {@link engine.model.Position position},
   * * parent element and offset (offset defaults to `0`),
   * * parent element and `'end'` (sets position at the end of that element),
   * * {@link engine.model.Item model item} and `'before'` or `'after'` (sets position before or after given model item).
   *
   * This method is a shortcut to other constructors such as:
   *
   * * {@link engine.model.Position.createBefore},
   * * {@link engine.model.Position.createAfter},
   * * {@link engine.model.Position.createFromParentAndOffset},
   * * {@link engine.model.Position.createFromPosition}.
   *
   * @param {engine.model.Item|engine.model.Position} itemOrPosition
   * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when
   * first parameter is a {@link engine.model.Item model item}.
   */

	}, {
		key: 'offset',
		get: function get() {
			return last(this.path);
		}

		/**
   * @param {Number} newOffset
   */
		,
		set: function set(newOffset) {
			this.path[this.path.length - 1] = newOffset;
		}

		/**
   * Parent element of this position.
   *
   * Keep in mind that `parent` value is calculated when the property is accessed. If {@link engine.model.Position#path position path}
   * leads to a non-existing element, `parent` property will throw error.
   *
   * Also it is a good idea to cache `parent` property if it is used frequently in an algorithm (i.e. in a long loop).
   *
   * @readonly
   * @type {engine.model.Element}
   */

	}, {
		key: 'parent',
		get: function get() {
			var parent = this.root;

			for (var i = 0; i < this.path.length - 1; i++) {
				parent = parent.getChild(parent.offsetToIndex(this.path[i]));
			}

			return parent;
		}

		/**
   * Position {@link engine.model.Position#offset offset} converted to an index in position's parent node. It is
   * equal to the {@link engine.model.Node#getIndex index} of a node after this position. If position is placed
   * in text node, position index is equal to the index of that text node.
   *
   * @readonly
   * @type {Number}
   */

	}, {
		key: 'index',
		get: function get() {
			return this.parent.offsetToIndex(this.offset);
		}

		/**
   * Returns {@link engine.model.Text text node} instance in which this position is placed or `null` if this
   * position is not in a text node.
   *
   * @readonly
   * @type {engine.model.Text|null}
   */

	}, {
		key: 'textNode',
		get: function get() {
			var node = this.parent.getChild(this.index);

			return node instanceof Text$1 && node.startOffset < this.offset ? node : null;
		}

		/**
   * Node directly after this position or `null` if this position is in text node.
   *
   * @readonly
   * @type {engine.model.Node|null}
   */

	}, {
		key: 'nodeAfter',
		get: function get() {
			return this.textNode === null ? this.parent.getChild(this.index) : null;
		}

		/**
   * Node directly before this position or `null` if this position is in text node.
   *
   * @readonly
   * @type {Node}
   */

	}, {
		key: 'nodeBefore',
		get: function get() {
			return this.textNode === null ? this.parent.getChild(this.index - 1) : null;
		}

		/**
   * Is `true` if position is at the beginning of its {@link engine.model.Position#parent parent}, `false` otherwise.
   *
   * @readonly
   * @type {Boolean}
   */

	}, {
		key: 'isAtStart',
		get: function get() {
			return this.offset === 0;
		}

		/**
   * Is `true` if position is at the end of its {@link engine.model.Position#parent parent}, `false` otherwise.
   *
   * @readonly
   * @type {Boolean}
   */

	}, {
		key: 'isAtEnd',
		get: function get() {
			return this.offset == this.parent.maxOffset;
		}
	}], [{
		key: 'createAt',
		value: function createAt(itemOrPosition, offset) {
			if (itemOrPosition instanceof Position) {
				return this.createFromPosition(itemOrPosition);
			} else {
				var node = itemOrPosition;

				if (offset == 'end') {
					offset = node.maxOffset;
				} else if (offset == 'before') {
					return this.createBefore(node);
				} else if (offset == 'after') {
					return this.createAfter(node);
				} else if (!offset) {
					offset = 0;
				}

				return this.createFromParentAndOffset(node, offset);
			}
		}

		/**
   * Creates a new position, after given {@link engine.model.Item model item}.
   *
   * @param {engine.model.Item} item Item after which the position should be placed.
   * @returns {engine.model.Position}
   */

	}, {
		key: 'createAfter',
		value: function createAfter(item) {
			if (!item.parent) {
				/**
     * You can not make position after root.
     *
     * @error position-after-root
     * @param {engine.model.Item} root
     */
				throw new CKEditorError('model-position-after-root: You can not make position after root.', { root: item });
			}

			return this.createFromParentAndOffset(item.parent, item.endOffset);
		}

		/**
   * Creates a new position, before the given {@link engine.model.Item model item}.
   *
   * @param {engine.model.Item} item Item before which the position should be placed.
   * @returns {engine.model.Position}
   */

	}, {
		key: 'createBefore',
		value: function createBefore(item) {
			if (!item.parent) {
				/**
     * You can not make position before root.
     *
     * @error position-before-root
     * @param {engine.model.Item} root
     */
				throw new CKEditorError('model-position-before-root: You can not make position before root.', { root: item });
			}

			return this.createFromParentAndOffset(item.parent, item.startOffset);
		}

		/**
   * Creates a new position from the parent element and an offset in that element.
   *
   * @param {engine.model.Element|engine.model.DocumentFragment} parent Position's parent.
   * @param {Number} offset Position's offset.
   * @returns {engine.model.Position}
   */

	}, {
		key: 'createFromParentAndOffset',
		value: function createFromParentAndOffset(parent, offset) {
			if (!(parent instanceof Element || parent instanceof DocumentFragment)) {
				/**
     * Position parent have to be a model element or model document fragment.
     *
     * @error position-parent-incorrect
     */
				throw new CKEditorError('model-position-parent-incorrect: Position parent have to be a element or document fragment.');
			}

			var path = parent.getPath();

			path.push(offset);

			return new this(parent.root, path);
		}

		/**
   * Creates a new position, which is equal to passed position.
   *
   * @param {engine.model.Position} position Position to be cloned.
   * @returns {engine.model.Position}
   */

	}, {
		key: 'createFromPosition',
		value: function createFromPosition(position) {
			return new this(position.root, position.path.slice());
		}

		/**
   * Creates a `Position` instance from given plain object (i.e. parsed JSON string).
   *
   * @param {Object} json Plain object to be converted to `Position`.
   * @returns {engine.model.Position} `Position` instance created using given plain object.
   */

	}, {
		key: 'fromJSON',
		value: function fromJSON(json, doc) {
			if (json.root === '$graveyard') {
				return new Position(doc.graveyard, json.path);
			}

			if (!doc.hasRoot(json.root)) {
				/**
     * Cannot create position for document. Root with specified name does not exist.
     *
     * @error position-fromjson-no-root
     * @param {String} rootName
     */
				throw new CKEditorError('model-position-fromjson-no-root: Cannot create position for document. Root with specified name does not exist.', { rootName: json.root });
			}

			return new Position(doc.getRoot(json.root), json.path);
		}
	}]);
	return Position;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * `TextProxy` represents a part of {@link engine.model.Text text node}.
 *
 * Since {@link engine.model.Position positions} can be placed between characters of a text node,
 * {@link engine.model.Range ranges} may contain only parts of text nodes. When {@link engine.model.Range#getItems getting items}
 * contained in such range, we need to represent a part of that text node, since returning the whole text node would be incorrect.
 * `TextProxy` solves this issue.
 *
 * `TextProxy` has an API similar to {@link engine.model.Text Text} and allows to do most of the common tasks performed
 * on model nodes.
 *
 * **Note:** Some `TextProxy` instances may represent whole text node, not just a part of it.
 * See {@link engine.model.TextProxy#isPartial}.
 *
 * **Note:** `TextProxy` is not an instance of {@link engine.model.Node node}. Keep this in mind when using it as a
 * parameter of methods.
 *
 * **Note:** `TextProxy` is a readonly interface. If you want to perform changes on model data represented by a `TextProxy`
 * use {@link engine.model.writer model writer API}.
 *
 * **Note:** `TextProxy` instances are created on the fly, basing on the current state of model. Because of this, it is
 * highly unrecommended to store references to `TextProxy` instances. `TextProxy` instances are not refreshed when
 * model changes, so they might get invalidated. Instead, consider creating {@link engine.model.LivePosition live position}.
 *
 * `TextProxy` instances are created by {@link engine.model.TreeWalker model tree walker}. You should not need to create
 * an instance of this class by your own.
 *
 * @memberOf engine.model
 */

var TextProxy = function () {
	/**
  * Creates a text proxy.
  *
  * @protected
  * @param {engine.model.Text} textNode Text node which part is represented by this text proxy.
  * @param {Number} offsetInText Offset in {@link engine.model.TextProxy#textNode text node} from which the text proxy starts.
  * @param {Number} length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.
  * @constructor
  */
	function TextProxy(textNode, offsetInText, length) {
		classCallCheck(this, TextProxy);

		/**
   * Text node which part is represented by this text proxy.
   *
   * @readonly
   * @member {engine.model.Text} engine.model.TextProxy#textNode
   */
		this.textNode = textNode;

		if (offsetInText < 0 || offsetInText > textNode.offsetSize) {
			/**
    * Given offsetInText value is incorrect.
    *
    * @error model-textproxy-wrong-offsetintext
    */
			throw new CKEditorError('model-textproxy-wrong-offsetintext: Given offsetInText value is incorrect.');
		}

		if (length < 0 || offsetInText + length > textNode.offsetSize) {
			/**
    * Given length value is incorrect.
    *
    * @error model-textproxy-wrong-length
    */
			throw new CKEditorError('model-textproxy-wrong-length: Given length value is incorrect.');
		}
		/**
   * Text data represented by this text proxy.
   *
   * @readonly
   * @member {String} engine.model.TextProxy#data
   */
		this.data = textNode.data.substring(offsetInText, offsetInText + length);

		/**
   * Offset in {@link engine.model.TextProxy#textNode text node} from which the text proxy starts.
   *
   * @readonly
   * @member {Number} engine.model.TextProxy#offsetInText
   */
		this.offsetInText = offsetInText;
	}

	/**
  * Offset at which this text proxy starts in it's parent.
  *
  * @see engine.model.Node#startOffset
  * @readonly
  * @type {Number}
  */


	createClass(TextProxy, [{
		key: 'getPath',


		/**
   * Gets path to this text proxy.
   *
   * @see engine.model.Node#getPath
   * @returns {Array.<Number>}
   */
		value: function getPath() {
			var path = this.textNode.getPath();

			if (path.length > 0) {
				path[path.length - 1] += this.offsetInText;
			}

			return path;
		}

		/**
   * Returns ancestors array of this text proxy.
   *
   * @param {Object} options Options object.
   * @param {Boolean} [options.includeNode=false] When set to `true` this text proxy will be also included in parent's array.
   * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from text proxy parent to root element,
   * otherwise root element will be the first item in the array.
   * @returns {Array} Array with ancestors.
   */

	}, {
		key: 'getAncestors',
		value: function getAncestors() {
			var options = arguments.length <= 0 || arguments[0] === undefined ? { includeNode: false, parentFirst: false } : arguments[0];

			var ancestors = [];
			var parent = options.includeNode ? this : this.parent;

			while (parent) {
				ancestors[options.parentFirst ? 'push' : 'unshift'](parent);
				parent = parent.parent;
			}

			return ancestors;
		}

		/**
   * Checks if this text proxy has an attribute for given key.
   *
   * @param {String} key Key of attribute to check.
   * @returns {Boolean} `true` if attribute with given key is set on text proxy, `false` otherwise.
   */

	}, {
		key: 'hasAttribute',
		value: function hasAttribute(key) {
			return this.textNode.hasAttribute(key);
		}

		/**
   * Gets an attribute value for given key or `undefined` if that attribute is not set on text proxy.
   *
   * @param {String} key Key of attribute to look for.
   * @returns {*} Attribute value or `undefined`.
   */

	}, {
		key: 'getAttribute',
		value: function getAttribute(key) {
			return this.textNode.getAttribute(key);
		}

		/**
   * Returns iterator that iterates over this node's attributes. Attributes are returned as arrays containing two
   * items. First one is attribute key and second is attribute value.
   *
   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
   *
   * @returns {Iterable.<*>}
   */

	}, {
		key: 'getAttributes',
		value: function getAttributes() {
			return this.textNode.getAttributes();
		}

		/**
   * Returns iterator that iterates over this node's attribute keys.
   *
   * @returns {Iterator.<String>}
   */

	}, {
		key: 'getAttributeKeys',
		value: function getAttributeKeys() {
			return this.textNode.getAttributeKeys();
		}
	}, {
		key: 'startOffset',
		get: function get() {
			return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null;
		}

		/**
   * Offset size of this text proxy. Equal to the number of characters represented by the text proxy.
   *
   * @see engine.model.Node#offsetSize
   * @readonly
   * @type {Number}
   */

	}, {
		key: 'offsetSize',
		get: function get() {
			return this.data.length;
		}

		/**
   * Offset at which this text proxy ends in it's parent.
   *
   * @see engine.model.Node#endOffset
   * @readonly
   * @type {Number}
   */

	}, {
		key: 'endOffset',
		get: function get() {
			return this.startOffset !== null ? this.startOffset + this.offsetSize : null;
		}

		/**
   * Flag indicating whether `TextProxy` instance covers only part of the original {@link engine.model.Text text node}
   * (`true`) or the whole text node (`false`).
   *
   * This is `false` when text proxy starts at the very beginning of {@link engine.model.TextProxy#textNode textNode}
   * ({@link engine.model.TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to
   * text node size.
   *
   * @readonly
   * @type {Boolean}
   */

	}, {
		key: 'isPartial',
		get: function get() {
			return this.offsetSize !== this.textNode.offsetSize;
		}

		/**
   * Parent of this text proxy, which is same as parent of text node represented by this text proxy.
   *
   * @readonly
   * @type {engine.model.Element|engine.model.DocumentFragment|null}
   */

	}, {
		key: 'parent',
		get: function get() {
			return this.textNode.parent;
		}

		/**
   * Root of this text proxy, which is same as root of text node represented by this text proxy.
   *
   * @readonly
   * @type {engine.model.Node|engine.model.DocumentFragment}
   */

	}, {
		key: 'root',
		get: function get() {
			return this.textNode.root;
		}

		/**
   * {@link engine.model.Document Document} that owns text node represented by this text proxy or `null` if the text node
   * has no parent or is inside a {@link engine.model.DocumentFragment DocumentFragment}.
   *
   * @readonly
   * @type {engine.model.Document|null}
   */

	}, {
		key: 'document',
		get: function get() {
			return this.textNode.document;
		}
	}]);
	return TextProxy;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Position iterator class. It allows to iterate forward and backward over the document.
 *
 * @memberOf engine.model
 */

var TreeWalker = function () {
	/**
  * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
  *
  * @constructor
  * @param {Object} [options={}] Object with configuration.
  * @param {'forward'|'backward'} [options.direction='forward'] Walking direction.
  * @param {engine.model.Range} [options.boundaries=null] Range to define boundaries of the iterator.
  * @param {engine.model.Position} [options.startPosition] Starting position.
  * @param {Boolean} [options.singleCharacters=false] Flag indicating whether all consecutive characters with the same attributes
  * should be returned one by one as multiple {@link engine.model.CharacterProxy} (`true`) objects or as one
  * {@link engine.model.TextProxy} (`false`).
  * @param {Boolean} [options.shallow=false] Flag indicating whether iterator should enter elements or not. If the
  * iterator is shallow child nodes of any iterated node will not be returned along with `elementEnd` tag.
  * @param {Boolean} [options.ignoreElementEnd=false] Flag indicating whether iterator should ignore `elementEnd`
  * tags. If the option is true walker will not return a parent node of start position. If this option is `true`
  * each {@link engine.model.Element} will be returned once, while if the option is `false` they might be returned
  * twice: for `'elementStart'` and `'elementEnd'`.
  */
	function TreeWalker() {
		var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
		classCallCheck(this, TreeWalker);

		if (!options.boundaries && !options.startPosition) {
			/**
    * Neither boundaries nor starting position have been defined.
    *
    * @error tree-walker-no-start-position
    */
			throw new CKEditorError('model-tree-walker-no-start-position: Neither boundaries nor starting position have been defined.');
		}

		var direction = options.direction || 'forward';

		if (direction != 'forward' && direction != 'backward') {
			throw new CKEditorError('model-tree-walker-unknown-direction: Only `backward` and `forward` direction allowed.', { direction: direction });
		}

		/**
   * Walking direction. Defaults `'forward'`.
   *
   * @readonly
   * @member {'backward'|'forward'} engine.model.TreeWalker#direction
   */
		this.direction = direction;

		/**
   * Iterator boundaries.
   *
   * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`
   * on the start of boundary, then `{ done: true }` is returned.
   *
   * If boundaries are not defined they are set before first and after last child of the root node.
   *
   * @readonly
   * @member {engine.model.Range} engine.model.TreeWalker#boundaries
   */
		this.boundaries = options.boundaries || null;

		/**
   * Iterator position. This is always static position, even if the initial position was a
   * {@link engine.model.LivePosition live position}. If start position is not defined then position depends
   * on {@link #direction}. If direction is `'forward'` position starts form the beginning, when direction
   * is `'backward'` position starts from the end.
   *
   * @readonly
   * @member {engine.model.Position} engine.model.TreeWalker#position
   */
		if (options.startPosition) {
			this.position = Position.createFromPosition(options.startPosition);
		} else {
			this.position = Position.createFromPosition(this.boundaries[this.direction == 'backward' ? 'end' : 'start']);
		}

		/**
   * Flag indicating whether all consecutive characters with the same attributes should be
   * returned as one {@link engine.model.CharacterProxy} (`true`) or one by one (`false`).
   *
   * @readonly
   * @member {Boolean} engine.model.TreeWalker#singleCharacters
   */
		this.singleCharacters = !!options.singleCharacters;

		/**
   * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any
   * iterated node will not be returned along with `elementEnd` tag.
   *
   * @readonly
   * @member {Boolean} engine.model.TreeWalker#shallow
   */
		this.shallow = !!options.shallow;

		/**
   * Flag indicating whether iterator should ignore `elementEnd` tags. If the option is true walker will not
   * return a parent node of the start position. If this option is `true` each {@link engine.model.Element} will
   * be returned once, while if the option is `false` they might be returned twice:
   * for `'elementStart'` and `'elementEnd'`.
   *
   * @readonly
   * @member {Boolean} engine.model.TreeWalker#ignoreElementEnd
   */
		this.ignoreElementEnd = !!options.ignoreElementEnd;

		/**
   * Start boundary cached for optimization purposes.
   *
   * @private
   * @member {engine.model.Element} engine.model.TreeWalker#_boundaryStartParent
   */
		this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;

		/**
   * End boundary cached for optimization purposes.
   *
   * @private
   * @member {engine.model.Element} engine.model.TreeWalker#_boundaryEndParent
   */
		this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;

		/**
   * Parent of the most recently visited node. Cached for optimization purposes.
   *
   * @private
   * @member {engine.model.Element|engine.model.DocumentFragment} engine.model.TreeWalker#_visitedParent
   */
		this._visitedParent = this.position.parent;
	}

	/**
  * Iterator interface.
  */


	createClass(TreeWalker, [{
		key: Symbol.iterator,
		value: function value() {
			return this;
		}

		/**
   * Iterator interface method.
   * Detects walking direction and makes step forward or backward.
   *
   * @returns {Object} Object implementing iterator interface, returning information about taken step.
   */

	}, {
		key: 'next',
		value: function next() {
			if (this.direction == 'forward') {
				return this._next();
			} else {
				return this._previous();
			}
		}

		/**
   * Makes a step forward in model. Moves the {@link #position} to the next position and returns the encountered value.
   *
   * @private
   * @returns {Object}
   * @returns {Boolean} return.done True if iterator is done.
   * @returns {engine.model.TreeWalkerValue} return.value Information about taken step.
   */

	}, {
		key: '_next',
		value: function _next() {
			var previousPosition = this.position;
			var position = Position.createFromPosition(this.position);
			var parent = this._visitedParent;

			// We are at the end of the root.
			if (parent.parent === null && position.offset === parent.maxOffset) {
				return { done: true };
			}

			// We reached the walker boundary.
			if (parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {
				return { done: true };
			}

			var node = position.textNode ? position.textNode : position.nodeAfter;

			if (node instanceof Element) {
				if (!this.shallow) {
					// Manual operations on path internals for optimization purposes. Here and in the rest of the method.
					position.path.push(0);
					this._visitedParent = node;
				} else {
					position.offset++;
				}

				this.position = position;

				return formatReturnValue('elementStart', node, previousPosition, position, 1);
			} else if (node instanceof Text$1) {
				var charactersCount = void 0,
				    offsetInTextNode = void 0;

				if (this.singleCharacters) {
					charactersCount = 1;
				} else {
					var offset = node.endOffset;

					if (this._boundaryEndParent == parent && this.boundaries.end.offset < offset) {
						offset = this.boundaries.end.offset;
					}

					charactersCount = offset - position.offset;
				}

				offsetInTextNode = position.offset - node.startOffset;

				var item = new TextProxy(node, offsetInTextNode, charactersCount);

				position.offset += charactersCount;
				this.position = position;

				return formatReturnValue('text', item, previousPosition, position, charactersCount);
			} else {
				// `node` is not set, we reached the end of current `parent`.
				position.path.pop();
				position.offset++;
				this.position = position;
				this._visitedParent = parent.parent;

				if (this.ignoreElementEnd) {
					return this._next();
				} else {
					return formatReturnValue('elementEnd', parent, previousPosition, position);
				}
			}
		}

		/**
   * Makes a step backward in model. Moves the {@link #position} to the previous position and returns the encountered value.
   *
   * @private
   * @returns {Object}
   * @returns {Boolean} return.done True if iterator is done.
   * @returns {engine.model.TreeWalkerValue} return.value Information about taken step.
   */

	}, {
		key: '_previous',
		value: function _previous() {
			var previousPosition = this.position;
			var position = Position.createFromPosition(this.position);
			var parent = this._visitedParent;

			// We are at the beginning of the root.
			if (parent.parent === null && position.offset === 0) {
				return { done: true };
			}

			// We reached the walker boundary.
			if (parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {
				return { done: true };
			}

			// Get node just before current position
			var node = position.textNode ? position.textNode : position.nodeBefore;

			if (node instanceof Element) {
				position.offset--;

				if (!this.shallow) {
					position.path.push(node.maxOffset);
					this.position = position;
					this._visitedParent = node;

					if (this.ignoreElementEnd) {
						return this._previous();
					} else {
						return formatReturnValue('elementEnd', node, previousPosition, position);
					}
				} else {
					this.position = position;

					return formatReturnValue('elementStart', node, previousPosition, position, 1);
				}
			} else if (node instanceof Text$1) {
				var charactersCount = void 0,
				    offsetInTextNode = void 0;

				if (this.singleCharacters) {
					charactersCount = 1;
				} else {
					var offset = node.startOffset;

					if (this._boundaryStartParent == parent && this.boundaries.start.offset > offset) {
						offset = this.boundaries.start.offset;
					}

					charactersCount = position.offset - offset;
				}

				offsetInTextNode = position.offset - node.startOffset;

				var item = new TextProxy(node, offsetInTextNode - charactersCount, charactersCount);

				position.offset -= charactersCount;
				this.position = position;

				return formatReturnValue('text', item, previousPosition, position, charactersCount);
			} else {
				// `node` is not set, we reached the beginning of current `parent`.
				position.path.pop();
				this.position = position;
				this._visitedParent = parent.parent;

				return formatReturnValue('elementStart', parent, previousPosition, position, 1);
			}
		}
	}]);
	return TreeWalker;
}();

function formatReturnValue(type, item, previousPosition, nextPosition, length) {
	return {
		done: false,
		value: {
			type: type,
			item: item,
			previousPosition: previousPosition,
			nextPosition: nextPosition,
			length: length
		}
	};
}

/**
 * Type of the step made by {@link engine.model.TreeWalker}.
 * Possible values: `'elementStart'` if walker is at the beginning of a node, `'elementEnd'` if walker is at the end of node,
 * `'character'` if walker traversed over a character, or `'text'` if walker traversed over multiple characters (available in
 * character merging mode, see {@link engine.model.TreeWalker#constructor}).
 *
 * @typedef {String} engine.model.TreeWalkerValueType
 */

/**
 * Object returned by {@link engine.model.TreeWalker} when traversing tree model.
 *
 * @typedef {Object} engine.model.TreeWalkerValue
 * @property {engine.model.TreeWalkerValueType} type
 * @property {engine.model.Item} item Item between old and new positions of {@link engine.model.TreeWalker}.
 * @property {engine.model.Position} previousPosition Previous position of the iterator.
 * * Forward iteration: For `'elementEnd'` it is the last position inside the element. For all other types it is the
 * position before the item. Note that it is more efficient to use this position then calculate the position before
 * the node using {@link engine.model.Position.createBefore}. It is also more efficient to get the
 * position after node by shifting `previousPosition` by `length`, using {@link engine.model.Position#getShiftedBy},
 * then calculate the position using {@link engine.model.Position.createAfter}.
 * * Backward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is
 * the position after item.
 * @property {engine.model.Position} nextPosition Next position of the iterator.
 * * Forward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is
 * the position after the item.
 * * Backward iteration: For `'elementEnd'` it is last position inside element. For all other types it is the position
 * before the item.
 * @property {Number} [length] Length of the item. For `'elementStart'` and `'character'` it is 1. For `'text'` it is
 * the length of the text. For `'elementEnd'` it is undefined.
 */

/**
 * Tree walking directions.
 *
 * @typedef {'forward'|'backward'} engine.view.TreeWalkerDirection
 */

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Range class. Range is iterable.
 *
 * @memberOf engine.model
 */

var Range$1 = function () {
	/**
  * Creates a range spanning from `start` position to `end` position.
  *
  * **Note:** Constructor creates it's own {@link engine.model.Position Position} instances basing on passed values.
  *
  * @param {engine.model.Position} start Start position.
  * @param {engine.model.Position} [end] End position. If not set, range will be collapsed at `start` position.
  */
	function Range(start) {
		var end = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
		classCallCheck(this, Range);

		/**
   * Start position.
   *
   * @readonly
   * @member {engine.model.Position} engine.model.Range#start
   */
		this.start = Position.createFromPosition(start);

		/**
   * End position.
   *
   * @readonly
   * @member {engine.model.Position} engine.model.Range#end
   */
		this.end = end ? Position.createFromPosition(end) : Position.createFromPosition(start);
	}

	/**
  * Returns an iterator that iterates over all {@link engine.model.Item items} that are in this range and returns
  * them together with additional information like length or {@link engine.model.Position positions},
  * grouped as {@link engine.model.TreeWalkerValue}. It iterates over all {@link engine.model.TextProxy text contents}
  * that are inside the range and all the {@link engine.model.Element}s that are entered into when iterating over this range.
  *
  * This iterator uses {@link engine.model.TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option
  * set to `true`.
  *
  * @returns {Iterable.<engine.model.TreeWalkerValue>}
  */


	createClass(Range, [{
		key: Symbol.iterator,
		value: regeneratorRuntime.mark(function value() {
			return regeneratorRuntime.wrap(function value$(_context) {
				while (1) {
					switch (_context.prev = _context.next) {
						case 0:
							return _context.delegateYield(new TreeWalker({ boundaries: this, ignoreElementEnd: true }), 't0', 1);

						case 1:
						case 'end':
							return _context.stop();
					}
				}
			}, value, this);
		})

		/**
   * Returns whether the range is collapsed, that is if {@link engine.model.Range#start start} and
   * {@link engine.model.Range#end end} positions are equal.
   *
   * @type {Boolean}
   */

	}, {
		key: 'containsPosition',


		/**
   * Checks whether this range contains given {@link engine.model.Position position}.
   *
   * @param {engine.model.Position} position Position to check.
   * @returns {Boolean} `true` if given {@link engine.model.Position position} is contained in this range, `false` otherwise.
   */
		value: function containsPosition(position) {
			return position.isAfter(this.start) && position.isBefore(this.end);
		}

		/**
   * Checks whether this range contains given {@link engine.model.Range range}.
   *
   * @param {engine.model.Range} otherRange Range to check.
   * @returns {Boolean} `true` if given {@link engine.model.Range range} boundaries are contained by this range, `false` otherwise.
   */

	}, {
		key: 'containsRange',
		value: function containsRange(otherRange) {
			return this.containsPosition(otherRange.start) && this.containsPosition(otherRange.end);
		}

		/**
   * Two ranges are equal if their {@link engine.model.Range#start start} and
   * {@link engine.model.Range#end end} positions are equal.
   *
   * @param {engine.model.Range} otherRange Range to compare with.
   * @returns {Boolean} `true` if ranges are equal, `false` otherwise.
   */

	}, {
		key: 'isEqual',
		value: function isEqual(otherRange) {
			return this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);
		}

		/**
   * Checks and returns whether this range intersects with given range.
   *
   * @param {engine.model.Range} otherRange Range to compare with.
   * @returns {Boolean} `true` if ranges intersect, `false` otherwise.
   */

	}, {
		key: 'isIntersecting',
		value: function isIntersecting(otherRange) {
			return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);
		}

		/**
   * Computes which part(s) of this {@link engine.model.Range range} is not a part of given {@link engine.model.Range range}.
   * Returned array contains zero, one or two {@link engine.model.Range ranges}.
   *
   * Examples:
   *
   *		let range = new Range( new Position( root, [ 2, 7 ] ), new Position( root, [ 4, 0, 1 ] ) );
   *		let otherRange = new Range( new Position( root, [ 1 ] ), new Position( root, [ 5 ] ) );
   *		let transformed = range.getDifference( otherRange );
   *		// transformed array has no ranges because `otherRange` contains `range`
   *
   *		otherRange = new Range( new Position( root, [ 1 ] ), new Position( root, [ 3 ] ) );
   *		transformed = range.getDifference( otherRange );
   *		// transformed array has one range: from [ 3 ] to [ 4, 0, 1 ]
   *
   *		otherRange = new Range( new Position( root, [ 3 ] ), new Position( root, [ 4 ] ) );
   *		transformed = range.getDifference( otherRange );
   *		// transformed array has two ranges: from [ 2, 7 ] to [ 3 ] and from [ 4 ] to [ 4, 0, 1 ]
   *
   * @param {engine.model.Range} otherRange Range to differentiate against.
   * @returns {Array.<engine.model.Range>} The difference between ranges.
   */

	}, {
		key: 'getDifference',
		value: function getDifference(otherRange) {
			var ranges = [];

			if (this.isIntersecting(otherRange)) {
				// Ranges intersect.

				if (this.containsPosition(otherRange.start)) {
					// Given range start is inside this range. This means that we have to
					// add shrunken range - from the start to the middle of this range.
					ranges.push(new Range(this.start, otherRange.start));
				}

				if (this.containsPosition(otherRange.end)) {
					// Given range end is inside this range. This means that we have to
					// add shrunken range - from the middle of this range to the end.
					ranges.push(new Range(otherRange.end, this.end));
				}
			} else {
				// Ranges do not intersect, return the original range.
				ranges.push(Range.createFromRange(this));
			}

			return ranges;
		}

		/**
   * Returns an intersection of this {@link engine.model.Range range} and given {@link engine.model.Range range}.
   * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.
   *
   * Examples:
   *
   *		let range = new Range( new Position( root, [ 2, 7 ] ), new Position( root, [ 4, 0, 1 ] ) );
   *		let otherRange = new Range( new Position( root, [ 1 ] ), new Position( root, [ 2 ] ) );
   *		let transformed = range.getIntersection( otherRange ); // null - ranges have no common part
   *
   *		otherRange = new Range( new Position( root, [ 3 ] ), new Position( root, [ 5 ] ) );
   *		transformed = range.getIntersection( otherRange ); // range from [ 3 ] to [ 4, 0, 1 ]
   *
   * @param {engine.model.Range} otherRange Range to check for intersection.
   * @returns {engine.model.Range|null} A common part of given ranges or `null` if ranges have no common part.
   */

	}, {
		key: 'getIntersection',
		value: function getIntersection(otherRange) {
			if (this.isIntersecting(otherRange)) {
				// Ranges intersect, so a common range will be returned.
				// At most, it will be same as this range.
				var commonRangeStart = this.start;
				var commonRangeEnd = this.end;

				if (this.containsPosition(otherRange.start)) {
					// Given range start is inside this range. This means thaNt we have to
					// shrink common range to the given range start.
					commonRangeStart = otherRange.start;
				}

				if (this.containsPosition(otherRange.end)) {
					// Given range end is inside this range. This means that we have to
					// shrink common range to the given range end.
					commonRangeEnd = otherRange.end;
				}

				return new Range(commonRangeStart, commonRangeEnd);
			}

			// Ranges do not intersect, so they do not have common part.
			return null;
		}

		/**
   * Computes and returns the smallest set of {@link engine.model.Range#isFlat flat} ranges, that covers this range in whole.
   *
   * See an example of model structure (`[` and `]` are range boundaries):
   *
   *		root                                                            root
   *		 |- element DIV                         DIV             P2              P3             DIV
   *		 |   |- element H                   H        P1        f o o           b a r       H         P4
   *		 |   |   |- "fir[st"             fir[st     lorem                               se]cond     ipsum
   *		 |   |- element P1
   *		 |   |   |- "lorem"                                              ||
   *		 |- element P2                                                   ||
   *		 |   |- "foo"                                                    VV
   *		 |- element P3
   *		 |   |- "bar"                                                   root
   *		 |- element DIV                         DIV             [P2             P3]             DIV
   *		 |   |- element H                   H       [P1]       f o o           b a r        H         P4
   *		 |   |   |- "se]cond"            fir[st]    lorem                               [se]cond     ipsum
   *		 |   |- element P4
   *		 |   |   |- "ipsum"
   *
   * As it can be seen, letters contained in the range are: `stloremfoobarse`, spread across different parents.
   * We are looking for minimal set of flat ranges that contains the same nodes.
   *
   * Minimal flat ranges for above range `( [ 0, 0, 3 ], [ 3, 0, 2 ] )` will be:
   *
   *		( [ 0, 0, 3 ], [ 0, 0, 5 ] ) = "st"
   *		( [ 0, 1 ], [ 0, 2 ] ) = element P1 ("lorem")
   *		( [ 1 ], [ 3 ] ) = element P2, element P3 ("foobar")
   *		( [ 3, 0, 0 ], [ 3, 0, 2 ] ) = "se"
   *
   * **Note:** if an {@link engine.model.Element element} is not contained wholly in this range, it won't be returned
   * in any of returned flat ranges. See in an example, how `H` elements at the beginning and at the end of the range
   * were omitted. Only it's parts that were wholly in the range were returned.
   *
   * **Note:** this method is not returning flat ranges that contain no nodes.
   *
   * @returns {Array.<engine.model.Range>} Array of flat ranges covering this range.
   */

	}, {
		key: 'getMinimalFlatRanges',
		value: function getMinimalFlatRanges() {
			var ranges = [];

			// We find on which tree-level start and end have the lowest common ancestor
			var cmp = compareArrays(this.start.path, this.end.path);
			// If comparison returned string it means that arrays are same.
			var diffAt = typeof cmp == 'string' ? Math.min(this.start.path.length, this.end.path.length) : cmp;

			var pos = Position.createFromPosition(this.start);
			var posParent = pos.parent;

			// Go up.
			while (pos.path.length > diffAt + 1) {
				var howMany = posParent.maxOffset - pos.offset;

				if (howMany !== 0) {
					ranges.push(new Range(pos, pos.getShiftedBy(howMany)));
				}

				pos.path = pos.path.slice(0, -1);
				pos.offset++;
				posParent = posParent.parent;
			}

			// Go down.
			while (pos.path.length <= this.end.path.length) {
				var offset = this.end.path[pos.path.length - 1];
				var _howMany = offset - pos.offset;

				if (_howMany !== 0) {
					ranges.push(new Range(pos, pos.getShiftedBy(_howMany)));
				}

				pos.offset = offset;
				pos.path.push(0);
			}

			return ranges;
		}

		/**
   * Creates a {@link engine.model.TreeWalker TreeWalker} instance with this range as a boundary.
   *
   * @param {Object} options Object with configuration options. See {@link engine.model.TreeWalker}.
   * @param {engine.model.Position} [options.startPosition]
   * @param {Boolean} [options.singleCharacters=false]
   * @param {Boolean} [options.shallow=false]
   * @param {Boolean} [options.ignoreElementEnd=false]
   */

	}, {
		key: 'getWalker',
		value: function getWalker() {
			var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

			options.boundaries = this;

			return new TreeWalker(options);
		}

		/**
   * Returns an iterator that iterates over all {@link engine.model.Item items} that are in this range and returns
   * them.
   *
   * This method uses {@link engine.model.TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option
   * set to `true`. However it returns only {@link engine.model.Item model items}, not {@link engine.model.TreeWalkerValue}.
   *
   * You may specify additional options for the tree walker. See {@link engine.model.TreeWalker} for
   * a full list of available options.
   *
   * @param {Object} options Object with configuration options. See {@link engine.model.TreeWalker}.
   * @returns {Iterable.<engine.model.Item>}
   */

	}, {
		key: 'getItems',
		value: regeneratorRuntime.mark(function getItems() {
			var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

			var treeWalker, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value;

			return regeneratorRuntime.wrap(function getItems$(_context2) {
				while (1) {
					switch (_context2.prev = _context2.next) {
						case 0:
							options.boundaries = this;
							options.ignoreElementEnd = true;

							treeWalker = new TreeWalker(options);
							_iteratorNormalCompletion = true;
							_didIteratorError = false;
							_iteratorError = undefined;
							_context2.prev = 6;
							_iterator = treeWalker[Symbol.iterator]();

						case 8:
							if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
								_context2.next = 15;
								break;
							}

							_value = _step.value;
							_context2.next = 12;
							return _value.item;

						case 12:
							_iteratorNormalCompletion = true;
							_context2.next = 8;
							break;

						case 15:
							_context2.next = 21;
							break;

						case 17:
							_context2.prev = 17;
							_context2.t0 = _context2['catch'](6);
							_didIteratorError = true;
							_iteratorError = _context2.t0;

						case 21:
							_context2.prev = 21;
							_context2.prev = 22;

							if (!_iteratorNormalCompletion && _iterator.return) {
								_iterator.return();
							}

						case 24:
							_context2.prev = 24;

							if (!_didIteratorError) {
								_context2.next = 27;
								break;
							}

							throw _iteratorError;

						case 27:
							return _context2.finish(24);

						case 28:
							return _context2.finish(21);

						case 29:
						case 'end':
							return _context2.stop();
					}
				}
			}, getItems, this, [[6, 17, 21, 29], [22,, 24, 28]]);
		})

		/**
   * Returns an iterator that iterates over all {@link engine.model.Position positions} that are boundaries or
   * contained in this range.
   *
   * This method uses {@link engine.model.TreeWalker} with `boundaries` set to this range. However it returns only
   * {@link engine.model.Position positions}, not {@link engine.model.TreeWalkerValue}.
   *
   * You may specify additional options for the tree walker. See {@link engine.model.TreeWalker} for
   * a full list of available options.
   *
   * @param {Object} options Object with configuration options. See {@link engine.model.TreeWalker}.
   * @returns {Iterable.<engine.model.Position>}
   */

	}, {
		key: 'getPositions',
		value: regeneratorRuntime.mark(function getPositions() {
			var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

			var treeWalker, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2;

			return regeneratorRuntime.wrap(function getPositions$(_context3) {
				while (1) {
					switch (_context3.prev = _context3.next) {
						case 0:
							options.boundaries = this;

							treeWalker = new TreeWalker(options);
							_context3.next = 4;
							return treeWalker.position;

						case 4:
							_iteratorNormalCompletion2 = true;
							_didIteratorError2 = false;
							_iteratorError2 = undefined;
							_context3.prev = 7;
							_iterator2 = treeWalker[Symbol.iterator]();

						case 9:
							if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
								_context3.next = 16;
								break;
							}

							_value2 = _step2.value;
							_context3.next = 13;
							return _value2.nextPosition;

						case 13:
							_iteratorNormalCompletion2 = true;
							_context3.next = 9;
							break;

						case 16:
							_context3.next = 22;
							break;

						case 18:
							_context3.prev = 18;
							_context3.t0 = _context3['catch'](7);
							_didIteratorError2 = true;
							_iteratorError2 = _context3.t0;

						case 22:
							_context3.prev = 22;
							_context3.prev = 23;

							if (!_iteratorNormalCompletion2 && _iterator2.return) {
								_iterator2.return();
							}

						case 25:
							_context3.prev = 25;

							if (!_didIteratorError2) {
								_context3.next = 28;
								break;
							}

							throw _iteratorError2;

						case 28:
							return _context3.finish(25);

						case 29:
							return _context3.finish(22);

						case 30:
						case 'end':
							return _context3.stop();
					}
				}
			}, getPositions, this, [[7, 18, 22, 30], [23,, 25, 29]]);
		})

		/**
   * Returns an array containing one or two {@link engine.model.Range ranges} that are a result of transforming this
   * {@link engine.model.Range range} by inserting `howMany` nodes at `insertPosition`. Two {@link engine.model.Range ranges} are
   * returned if the insertion was inside this {@link engine.model.Range range} and `spread` is set to `true`.
   *
   * Examples:
   *
   *		let range = new Range( new Position( root, [ 2, 7 ] ), new Position( root, [ 4, 0, 1 ] ) );
   *		let transformed = range._getTransformedByInsertion( new Position( root, [ 1 ] ), 2 );
   *		// transformed array has one range from [ 4, 7 ] to [ 6, 0, 1 ]
   *
   *		transformed = range._getTransformedByInsertion( new Position( root, [ 4, 0, 0 ] ), 4 );
   *		// transformed array has one range from [ 2, 7 ] to [ 4, 0, 5 ]
   *
   *		transformed = range._getTransformedByInsertion( new Position( root, [ 3, 2 ] ), 4 );
   *		// transformed array has one range, which is equal to original range
   *
   *		transformed = range._getTransformedByInsertion( new Position( root, [ 3, 2 ] ), 4, true );
   *		// transformed array has two ranges: from [ 2, 7 ] to [ 3, 2 ] and from [ 3, 6 ] to [ 4, 0, 1 ]
   *
   *		transformed = range._getTransformedByInsertion( new Position( root, [ 4, 0, 1 ] ), 4, false, false );
   *		// transformed array has one range which is equal to original range because insertion is after the range boundary
   *
   *		transformed = range._getTransformedByInsertion( new Position( root, [ 4, 0, 1 ] ), 4, false, true );
   *		// transformed array has one range: from [ 2, 7 ] to [ 4, 0, 5 ] because range was expanded
   *
   * @protected
   * @param {engine.model.Position} insertPosition Position where nodes are inserted.
   * @param {Number} howMany How many nodes are inserted.
   * @param {Boolean} [spread] Flag indicating whether this {engine.model.Range range} should be spread if insertion
   * was inside the range. Defaults to `false`.
   * @param {Boolean} [isSticky] Flag indicating whether insertion should expand a range if it is in a place of
   * range boundary. Defaults to `false`.
   * @returns {Array.<engine.model.Range>} Result of the transformation.
   */

	}, {
		key: '_getTransformedByInsertion',
		value: function _getTransformedByInsertion(insertPosition, howMany) {
			var spread = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
			var isSticky = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

			if (spread && this.containsPosition(insertPosition)) {
				// Range has to be spread. The first part is from original start to the spread point.
				// The other part is from spread point to the original end, but transformed by
				// insertion to reflect insertion changes.

				return [new Range(this.start, insertPosition), new Range(insertPosition._getTransformedByInsertion(insertPosition, howMany, true), this.end._getTransformedByInsertion(insertPosition, howMany, this.isCollapsed))];
			} else {
				var range = Range.createFromRange(this);

				var insertBeforeStart = range.isCollapsed ? isSticky : !isSticky;
				var insertBeforeEnd = isSticky;

				range.start = range.start._getTransformedByInsertion(insertPosition, howMany, insertBeforeStart);
				range.end = range.end._getTransformedByInsertion(insertPosition, howMany, insertBeforeEnd);

				return [range];
			}
		}

		/**
   * Returns an array containing {@link engine.model.Range ranges} that are a result of transforming this
   * {@link engine.model.Range range} by moving `howMany` nodes from `sourcePosition` to `targetPosition`.
   *
   * @protected
   * @param {engine.model.Position} sourcePosition Position from which nodes are moved.
   * @param {engine.model.Position} targetPosition Position to where nodes are moved.
   * @param {Number} howMany How many nodes are moved.
   * @param {Boolean} [spread] Flag indicating whether this {engine.model.Range range} should be spread if insertion
   * was inside the range. Defaults to `false`.
   * @returns {Array.<engine.model.Range>} Result of the transformation.
   */

	}, {
		key: '_getTransformedByMove',
		value: function _getTransformedByMove(sourcePosition, targetPosition, howMany, spread) {
			var isSticky = arguments.length <= 4 || arguments[4] === undefined ? false : arguments[4];

			var result = void 0;

			var moveRange = new Range(sourcePosition, sourcePosition.getShiftedBy(howMany));

			var differenceSet = this.getDifference(moveRange);
			var difference = void 0;

			if (differenceSet.length == 1) {
				difference = new Range(differenceSet[0].start._getTransformedByDeletion(sourcePosition, howMany), differenceSet[0].end._getTransformedByDeletion(sourcePosition, howMany));
			} else if (differenceSet.length == 2) {
				// This means that ranges were moved from the inside of this range.
				// So we can operate on this range positions and we don't have to transform starting position.
				difference = new Range(this.start, this.end._getTransformedByDeletion(sourcePosition, howMany));
			} else {
				// 0.
				difference = null;
			}

			var insertPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);

			if (difference) {
				result = difference._getTransformedByInsertion(insertPosition, howMany, spread, isSticky);
			} else {
				result = [];
			}

			var common = this.getIntersection(moveRange);

			// Add common part of the range only if there is any and only if it is not
			// already included in `difference` part.
			if (common && (spread || difference === null || !difference.containsPosition(insertPosition))) {
				result.push(new Range(common.start._getCombined(moveRange.start, insertPosition), common.end._getCombined(moveRange.start, insertPosition)));
			}

			return result;
		}

		/**
   * Creates a new range, spreading from specified {@link engine.model.Position position} to a position moved by
   * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.
   *
   * @param {engine.model.Position} position Beginning of the range.
   * @param {Number} shift How long the range should be.
   * @returns {engine.model.Range}
   */

	}, {
		key: 'isCollapsed',
		get: function get() {
			return this.start.isEqual(this.end);
		}

		/**
   * Returns whether this range is flat, that is if {@link engine.model.Range#start start} position and
   * {@link engine.model.Range#end end} position are in the same {@link engine.model.Position#parent parent}.
   *
   * @type {Boolean}
   */

	}, {
		key: 'isFlat',
		get: function get() {
			return this.start.parent === this.end.parent;
		}

		/**
   * Returns whether this range has no nodes in it, that is if {@link engine.model.Range#start start} position and
   * {@link engine.model.Range#end end} position are {@link engine.model.Position#isTouching touching}.
   *
   * **Note:** A range may be empty, but not {@link engine.model.Range#isCollapsed collapsed}.
   *
   * @type {Boolean}
   */

	}, {
		key: 'isEmpty',
		get: function get() {
			return this.start.isTouching(this.end);
		}

		/**
   * Range root element.
   *
   * @type {engine.model.Element|engine.model.DocumentFragment}
   */

	}, {
		key: 'root',
		get: function get() {
			return this.start.root;
		}
	}], [{
		key: 'createFromPositionAndShift',
		value: function createFromPositionAndShift(position, shift) {
			var start = position;
			var end = position.getShiftedBy(shift);

			return shift > 0 ? new this(start, end) : new this(end, start);
		}

		/**
   * Creates a range from given parents and offsets.
   *
   * @param {engine.model.Element} startElement Start position parent element.
   * @param {Number} startOffset Start position offset.
   * @param {engine.model.Element} endElement End position parent element.
   * @param {Number} endOffset End position offset.
   * @returns {engine.model.Range}
   */

	}, {
		key: 'createFromParentsAndOffsets',
		value: function createFromParentsAndOffsets(startElement, startOffset, endElement, endOffset) {
			return new this(Position.createFromParentAndOffset(startElement, startOffset), Position.createFromParentAndOffset(endElement, endOffset));
		}

		/**
   * Creates a new instance of `Range` which is equal to passed range.
   *
   * @param {engine.model.Range} range Range to clone.
   * @returns {engine.model.Range}
   */

	}, {
		key: 'createFromRange',
		value: function createFromRange(range) {
			return new this(range.start, range.end);
		}

		/**
   * Creates a range inside an {@link engine.model.Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * @param {engine.model.Element} element Element which is a parent for the range.
   * @returns {engine.model.Range}
   */

	}, {
		key: 'createIn',
		value: function createIn(element) {
			return this.createFromParentsAndOffsets(element, 0, element, element.maxOffset);
		}

		/**
   * Creates a range that starts before given {@link engine.model.Item model item} and ends after it.
   *
   * @param {engine.model.Item} item
   * @returns {engine.model.Range}
   */

	}, {
		key: 'createOn',
		value: function createOn(item) {
			return this.createFromPositionAndShift(Position.createBefore(item), item.offsetSize);
		}

		/**
   * Creates a `Range` instance from given plain object (i.e. parsed JSON string).
   *
   * @param {Object} json Plain object to be converted to `Range`.
   * @param {engine.model.Document} doc Document object that will be range owner.
   * @returns {engine.model.Element} `Range` instance created using given plain object.
   */

	}, {
		key: 'fromJSON',
		value: function fromJSON(json, doc) {
			return new this(Position.fromJSON(json.start, doc), Position.fromJSON(json.end, doc));
		}
	}]);
	return Range;
}();

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Abstract tree view node class.
 *
 * @abstract
 * @memberOf engine.view
 */

var Node$2 = function () {
	/**
  * Creates a tree view node.
  *
  * This is an abstract class, so this constructor should not be used directly.
  */
	function Node() {
		classCallCheck(this, Node);

		/**
   * Parent element. Null by default. Set by {@link engine.view.Element#insertChildren}.
   *
   * @readonly
   * @member {engine.view.Element|engine.view.DocumentFragment|null} engine.view.Node#parent
   */
		this.parent = null;
	}

	/**
  * Index of the node in the parent element or null if the node has no parent.
  *
  * Accessing this property throws an error if this node's parent element does not contain it.
  * This means that view tree got broken.
  *
  * @readonly
  * @type {Number|null}
  */


	createClass(Node, [{
		key: 'getAncestors',


		/**
   * Returns ancestors array of this node.
   *
   * @param {Object} options Options object.
   * @param {Boolean} [options.includeNode=false] When set to `true` this node will be also included in parent's array.
   * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from node's parent to root element,
   * otherwise root element will be the first item in the array.
   * @returns {Array} Array with ancestors.
   */
		value: function getAncestors() {
			var options = arguments.length <= 0 || arguments[0] === undefined ? { includeNode: false, parentFirst: false } : arguments[0];

			var ancestors = [];
			var parent = options.includeNode ? this : this.parent;

			while (parent) {
				ancestors[options.parentFirst ? 'push' : 'unshift'](parent);
				parent = parent.parent;
			}

			return ancestors;
		}

		/**
   * Removes node from parent.
   */

	}, {
		key: 'remove',
		value: function remove() {
			this.parent.removeChildren(this.index);
		}

		/**
   * @param {engine.view.ChangeType} type Type of the change.
   * @param {engine.view.Node} node Changed node.
   * @fires engine.view.Node#change
   */

	}, {
		key: '_fireChange',
		value: function _fireChange(type, node) {
			this.fire('change:' + type, node);

			if (this.parent) {
				this.parent._fireChange(type, node);
			}
		}

		/**
   * Clones this node.
   *
   * @method view.Node#clone
   * @returns {view.Node} Clone of this node.
   */

		/**
   * Checks if provided node is similar to this node.
   *
   * @method view.Node#isSimilar
   * @returns {Boolean} True if nodes are similar.
   */

		/**
   * Fired when list of {@link engine.view.Element elements} children changes.
   *
   * Change event is bubbled – it is fired on all ancestors.
   *
   * @event engine.view.Node#change:children
   * @param {engine.view.Node} Changed node.
   */

		/**
   * Fired when list of {@link engine.view.Element elements} attributes changes.
   *
   * Change event is bubbled – it is fired on all ancestors.
   *
   * @event engine.view.Node#change:attributes
   * @param {engine.view.Node} Changed node.
   */

		/**
   * Fired when {@link engine.view.Text text nodes} data changes.
   *
   * Change event is bubbled – it is fired on all ancestors.
   *
   * @event engine.view.Node#change:text
   * @param {engine.view.Node} Changed node.
   */

	}, {
		key: 'index',
		get: function get() {
			var pos = void 0;

			if (!this.parent) {
				return null;
			}

			// No parent or child doesn't exist in parent's children.
			if ((pos = this.parent.getChildIndex(this)) == -1) {
				/**
     * The node's parent does not contain this node. It means that the document tree is corrupted.
     *
     * @error view-node-not-found-in-parent
     */
				throw new CKEditorError('view-node-not-found-in-parent: The node\'s parent does not contain this node.');
			}

			return pos;
		}

		/**
   * Node's next sibling, or `null` if it is the last child.
   *
   * @readonly
   * @type {engine.view.Node|null}
   */

	}, {
		key: 'nextSibling',
		get: function get() {
			var index = this.index;

			return index !== null && this.parent.getChild(index + 1) || null;
		}

		/**
   * Node's previous sibling, or `null` if it is the first child.
   *
   * @readonly
   * @type {engine.view.Node|null}
   */

	}, {
		key: 'previousSibling',
		get: function get() {
			var index = this.index;

			return index !== null && this.parent.getChild(index - 1) || null;
		}

		/**
   * Top-most ancestor of the node. If the node has no parent it is the root itself.
   *
   * @readonly
   * @type {engine.view.Node|engine.view.DocumentFragment}
   */

	}, {
		key: 'root',
		get: function get() {
			var root = this;

			while (root.parent) {
				root = root.parent;
			}

			return root;
		}

		/**
   * {@link engine.view.Document View document} that owns this node, or `null` if the node is inside
   * {@link engine.view.DocumentFragment document fragment}.
   *
   * @readonly
   * @type {engine.view.Document|null}
   */

	}, {
		key: 'document',
		get: function get() {
			// Parent might be Node, null or DocumentFragment.
			if (this.parent instanceof Node) {
				return this.parent.document;
			} else {
				return null;
			}
		}
	}]);
	return Node;
}();

mix(Node$2, EmitterMixin);

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Tree view text node.
 *
 * @memberOf engine.view
 * @extends engine.view.Node
 */

var Text$2 = function (_Node) {
	inherits(Text, _Node);

	/**
  * Creates a tree view text node.
  *
  * @param {String} data Text.
  */
	function Text(data) {
		classCallCheck(this, Text);

		/**
   * The text content.
   *
   * Setting the data fires the {@link engine.view.Node#event:change change event}.
   *
   * @private
   * @member {String} engine.view.Text#_data
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(Text).call(this));

		_this._data = data;
		return _this;
	}

	/**
  * Clones this node.
  *
  * @returns {engine.view.Text} Text node that is a clone of this node.
  */


	createClass(Text, [{
		key: 'clone',
		value: function clone() {
			return new Text(this.data);
		}

		/**
   * The text content.
   *
   * Setting the data fires the {@link view.Node#change change event}.
   */

	}, {
		key: 'isSimilar',


		/**
   * Checks if this text node is similar to other text node.
   * Both nodes should have the same data to be considered as similar.
   *
   * @param {engine.view.Text} otherNode Node to check if it is same as this node.
   * @returns {Boolean}
   */
		value: function isSimilar(otherNode) {
			if (!(otherNode instanceof Text)) {
				return false;
			}

			return this === otherNode || this.data === otherNode.data;
		}
	}, {
		key: 'data',
		get: function get() {
			return this._data;
		},
		set: function set(data) {
			this._fireChange('text', this);

			this._data = data;
		}
	}]);
	return Text;
}(Node$2);

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * TextProxy is a wrapper for substring of {@link engine.view.Text}. Instance of this class is created by
 * {@link engine.view.TreeWalker} when only a part of {@link engine.view.Text} needs to be returned.
 *
 * `TextProxy` has an API similar to {@link engine.view.Text Text} and allows to do most of the common tasks performed
 * on view nodes.
 *
 * **Note:** Some `TextProxy` instances may represent whole text node, not just a part of it.
 * See {@link engine.view.TextProxy#isPartial}.
 *
 * **Note:** `TextProxy` is a readonly interface.
 *
 * **Note:** `TextProxy` instances are created on the fly basing on the current state of parent {@link engine.view.Text}.
 * Because of this it is highly unrecommended to store references to `TextProxy instances because they might get
 * invalidated due to operations on Document. Also TextProxy is not a {@link engine.view.Node} so it can not be
 * inserted as a child of {@link engine.view.Element}.
 *
 * `TextProxy` instances are created by {@link engine.view.TreeWalker view tree walker}. You should not need to create
 * an instance of this class by your own.
 *
 * @memberOf engine.view
 */

var TextProxy$1 = function () {
	/**
  * Creates a text proxy.
  *
  * @protected
  * @param {engine.view.Text} textNode Text node which part is represented by this text proxy.
  * @param {Number} offsetInText Offset in {@link engine.view.TextProxy#textNode text node} from which the text proxy starts.
  * @param {Number} length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.
  * @constructor
  */
	function TextProxy(textNode, offsetInText, length) {
		classCallCheck(this, TextProxy);

		/**
   * Reference to the {@link engine.view.Text} element which TextProxy is a substring.
   *
   * @readonly
   * @member {engine.view.Text} engine.view.TextProxy#textNode
   */
		this.textNode = textNode;

		if (offsetInText < 0 || offsetInText > textNode.data.length) {
			/**
    * Given offsetInText value is incorrect.
    *
    * @error view-textproxy-wrong-offsetintext
    */
			throw new CKEditorError('view-textproxy-wrong-offsetintext: Given offsetInText value is incorrect.');
		}

		if (length < 0 || offsetInText + length > textNode.data.length) {
			/**
    * Given length value is incorrect.
    *
    * @error view-textproxy-wrong-length
    */
			throw new CKEditorError('view-textproxy-wrong-length: Given length value is incorrect.');
		}
		/**
   * Text data represented by this text proxy.
   *
   * @readonly
   * @member {String} engine.view.TextProxy#data
   */
		this.data = textNode.data.substring(offsetInText, offsetInText + length);

		/**
   * Offset in the `textNode` where this `TextProxy` instance starts.
   *
   * @readonly
   * @member {Number} engine.view.TextProxy#offsetInText
   */
		this.offsetInText = offsetInText;
	}

	/**
  * Flag indicating whether `TextProxy` instance covers only part of the original {@link engine.view.Text text node}
  * (`true`) or the whole text node (`false`).
  *
  * This is `false` when text proxy starts at the very beginning of {@link engine.view.TextProxy#textNode textNode}
  * ({@link engine.view.TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to
  * text node size.
  *
  * @readonly
  * @type {Boolean}
  */


	createClass(TextProxy, [{
		key: 'getAncestors',


		/**
   * Returns ancestors array of this text proxy.
   *
   * @param {Object} options Options object.
   * @param {Boolean} [options.includeNode=false] When set to `true` {#textNode} will be also included in parent's array.
   * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from text proxy parent to
   * root element, otherwise root element will be the first item in the array.
   * @returns {Array} Array with ancestors.
   */
		value: function getAncestors() {
			var options = arguments.length <= 0 || arguments[0] === undefined ? { includeNode: false, parentFirst: false } : arguments[0];

			var ancestors = [];
			var parent = options.includeNode ? this.textNode : this.parent;

			while (parent !== null) {
				ancestors[options.parentFirst ? 'push' : 'unshift'](parent);
				parent = parent.parent;
			}

			return ancestors;
		}
	}, {
		key: 'isPartial',
		get: function get() {
			return this.data.length !== this.textNode.data.length;
		}

		/**
   * Parent of this text proxy, which is same as parent of text node represented by this text proxy.
   *
   * @readonly
   * @type {engine.view.Element|engine.view.DocumentFragment|null}
   */

	}, {
		key: 'parent',
		get: function get() {
			return this.textNode.parent;
		}

		/**
   * Root of this text proxy, which is same as root of text node represented by this text proxy.
   *
   * @readonly
   * @type {engine.view.Node|engine.view.DocumentFragment}
   */

	}, {
		key: 'root',
		get: function get() {
			return this.textNode.root;
		}

		/**
   * {@link engine.view.Document View document} that owns this text proxy, or `null` if the text proxy is inside
   * {@link engine.view.DocumentFragment document fragment}.
   *
   * @readonly
   * @type {engine.view.Document|null}
   */

	}, {
		key: 'document',
		get: function get() {
			return this.textNode.document;
		}
	}]);
	return TextProxy;
}();

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Tree view element.
 *
 * Editing engine does not define fixed HTML DTD. This is why the type of the {@link engine.view.Element} need to
 * be defined by the feature developer. Creating an element you should use {@link engine.view.ContainerElement}
 * class or {@link engine.view.AttributeElement}.
 *
 * Note that for view elements which are not created from model, like elements from mutations, paste or
 * {@link engine.controller.DataController#set data.set} it is not possible to define the type of the element, so
 * these will be instances of the {@link engine.view.Element}.
 *
 * @memberOf engine.view
 * @extends engine.view.Node
 */

var Element$1 = function (_Node) {
	inherits(Element, _Node);

	/**
  * Creates a tree view element.
  *
  * Attributes can be passed in various formats:
  *
  *		new Element( 'div', { 'class': 'editor', 'contentEditable': 'true' } ); // object
  *		new Element( 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator
  *		new Element( 'div', mapOfAttributes ); // map
  *
  * @param {String} name Node name.
  * @param {Object|Iterable} [attrs] Collection of attributes.
  * @param {engine.view.Node|Iterable.<engine.view.Node>} [children] List of nodes to be inserted into created element.
  */
	function Element(name, attrs, children) {
		classCallCheck(this, Element);

		/**
   * Name of the element.
   *
   * @readonly
   * @member {String} engine.view.Element#name
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(Element).call(this));

		_this.name = name;

		/**
   * Map of attributes, where attributes names are keys and attributes values are values.
   *
   * @protected
   * @member {Map} engine.view.Element#_attrs
   */
		if (isPlainObject(attrs)) {
			_this._attrs = objectToMap(attrs);
		} else {
			_this._attrs = new Map(attrs);
		}

		/**
   * Array of child nodes.
   *
   * @protected
   * @member {Array.<engine.view.Node>} engine.view.Element#_children
   */
		_this._children = [];

		if (children) {
			_this.insertChildren(0, children);
		}

		/**
   * Set of classes associated with element instance.
   *
   * @protected
   * @member {Set} engine.view.Element#_classes
   */
		_this._classes = new Set();

		if (_this._attrs.has('class')) {
			// Remove class attribute and handle it by class set.
			var classString = _this._attrs.get('class');
			parseClasses(_this._classes, classString);
			_this._attrs.delete('class');
		}

		/**
   * Map of styles.
   *
   * @protected
   * @member {Set} engine.view.Element#_styles
   */
		_this._styles = new Map();

		if (_this._attrs.has('style')) {
			// Remove style attribute and handle it by styles map.
			parseInlineStyles(_this._styles, _this._attrs.get('style'));
			_this._attrs.delete('style');
		}
		return _this;
	}

	/**
  * Number of element's children.
  *
  * @readonly
  * @type {Number}
  */


	createClass(Element, [{
		key: 'clone',


		/**
   * Clones provided element.
   *
   * @param {Boolean} deep If set to `true` clones element and all its children recursively. When set to `false`,
   * element will be cloned without any children.
   * @returns {engine.view.Element} Clone of this element.
   */
		value: function clone(deep) {
			var childrenClone = [];

			if (deep) {
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = this.getChildren()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var child = _step.value;

						childrenClone.push(child.clone(deep));
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
			}

			// ContainerElement and AttributeElement should be also cloned properly.
			var cloned = new this.constructor(this.name, this._attrs, childrenClone);

			// Classes and styles are cloned separately - this solution is faster than adding them back to attributes and
			// parse once again in constructor.
			cloned._classes = new Set(this._classes);
			cloned._styles = new Map(this._styles);

			return cloned;
		}

		/**
   * {@link engine.view.Element#insert Insert} a child node or a list of child nodes at the end of this node and sets
   * the parent of these nodes to this element.
   *
   * @fires engine.view.Node#change
   * @param {engine.view.Node|Iterable.<engine.view.Node>} nodes Node or the list of nodes to be inserted.
   * @returns {Number} Number of appended nodes.
   */

	}, {
		key: 'appendChildren',
		value: function appendChildren(nodes) {
			return this.insertChildren(this.childCount, nodes);
		}

		/**
   * Gets child at the given index.
   *
   * @param {Number} index Index of child.
   * @returns {engine.view.Node} Child node.
   */

	}, {
		key: 'getChild',
		value: function getChild(index) {
			return this._children[index];
		}

		/**
   * Gets index of the given child node. Returns `-1` if child node is not found.
   *
   * @param {engine.view.Node} node Child node.
   * @returns {Number} Index of the child node.
   */

	}, {
		key: 'getChildIndex',
		value: function getChildIndex(node) {
			return this._children.indexOf(node);
		}

		/**
   * Gets child nodes iterator.
   *
   * @returns {Iterable.<engine.view.Node>} Child nodes iterator.
   */

	}, {
		key: 'getChildren',
		value: function getChildren() {
			return this._children[Symbol.iterator]();
		}

		/**
   * Returns an iterator that contains the keys for attributes. Order of inserting attributes is not preserved.
   *
   * @returns {Iterator.<String>} Keys for attributes.
   */

	}, {
		key: 'getAttributeKeys',
		value: regeneratorRuntime.mark(function getAttributeKeys() {
			var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, key;

			return regeneratorRuntime.wrap(function getAttributeKeys$(_context) {
				while (1) {
					switch (_context.prev = _context.next) {
						case 0:
							if (!(this._classes.size > 0)) {
								_context.next = 3;
								break;
							}

							_context.next = 3;
							return 'class';

						case 3:
							if (!(this._styles.size > 0)) {
								_context.next = 6;
								break;
							}

							_context.next = 6;
							return 'style';

						case 6:

							// This is not an optimal solution because of https://github.com/ckeditor/ckeditor5-engine/issues/454.
							// It can be simplified to `yield* this._attrs.keys();`.
							_iteratorNormalCompletion2 = true;
							_didIteratorError2 = false;
							_iteratorError2 = undefined;
							_context.prev = 9;
							_iterator2 = this._attrs.keys()[Symbol.iterator]();

						case 11:
							if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
								_context.next = 18;
								break;
							}

							key = _step2.value;
							_context.next = 15;
							return key;

						case 15:
							_iteratorNormalCompletion2 = true;
							_context.next = 11;
							break;

						case 18:
							_context.next = 24;
							break;

						case 20:
							_context.prev = 20;
							_context.t0 = _context['catch'](9);
							_didIteratorError2 = true;
							_iteratorError2 = _context.t0;

						case 24:
							_context.prev = 24;
							_context.prev = 25;

							if (!_iteratorNormalCompletion2 && _iterator2.return) {
								_iterator2.return();
							}

						case 27:
							_context.prev = 27;

							if (!_didIteratorError2) {
								_context.next = 30;
								break;
							}

							throw _iteratorError2;

						case 30:
							return _context.finish(27);

						case 31:
							return _context.finish(24);

						case 32:
						case 'end':
							return _context.stop();
					}
				}
			}, getAttributeKeys, this, [[9, 20, 24, 32], [25,, 27, 31]]);
		})

		/**
   * Returns iterator that iterates over this element's attributes.
   *
   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
   *
   * @returns {Iterable.<*>}
   */

	}, {
		key: 'getAttributes',
		value: regeneratorRuntime.mark(function getAttributes() {
			return regeneratorRuntime.wrap(function getAttributes$(_context2) {
				while (1) {
					switch (_context2.prev = _context2.next) {
						case 0:
							return _context2.delegateYield(this._attrs.entries(), 't0', 1);

						case 1:
							if (!(this._classes.size > 0)) {
								_context2.next = 4;
								break;
							}

							_context2.next = 4;
							return ['class', this.getAttribute('class')];

						case 4:
							if (!(this._styles.size > 0)) {
								_context2.next = 7;
								break;
							}

							_context2.next = 7;
							return ['style', this.getAttribute('style')];

						case 7:
						case 'end':
							return _context2.stop();
					}
				}
			}, getAttributes, this);
		})

		/**
   * Gets attribute by key. If attribute is not present - returns undefined.
   *
   * @param {String} key Attribute key.
   * @returns {String|undefined} Attribute value.
   */

	}, {
		key: 'getAttribute',
		value: function getAttribute(key) {
			if (key == 'class') {
				if (this._classes.size > 0) {
					return [].concat(toConsumableArray(this._classes)).join(' ');
				}

				return undefined;
			}

			if (key == 'style') {
				if (this._styles.size > 0) {
					var styleString = '';

					var _iteratorNormalCompletion3 = true;
					var _didIteratorError3 = false;
					var _iteratorError3 = undefined;

					try {
						for (var _iterator3 = this._styles[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
							var _step3$value = slicedToArray(_step3.value, 2);

							var property = _step3$value[0];
							var value = _step3$value[1];

							styleString += property + ':' + value + ';';
						}
					} catch (err) {
						_didIteratorError3 = true;
						_iteratorError3 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion3 && _iterator3.return) {
								_iterator3.return();
							}
						} finally {
							if (_didIteratorError3) {
								throw _iteratorError3;
							}
						}
					}

					return styleString;
				}

				return undefined;
			}

			return this._attrs.get(key);
		}

		/**
   * Returns a boolean indicating whether an attribute with the specified key exists in the element.
   *
   * @param {String} key Attribute key.
   * @returns {Boolean} `true` if attribute with the specified key exists in the element, false otherwise.
   */

	}, {
		key: 'hasAttribute',
		value: function hasAttribute(key) {
			if (key == 'class') {
				return this._classes.size > 0;
			}

			if (key == 'style') {
				return this._styles.size > 0;
			}

			return this._attrs.has(key);
		}

		/**
   * Adds or overwrite attribute with a specified key and value.
   *
   * @param {String} key Attribute key.
   * @param {String} value Attribute value.
   * @fires engine.view.Node#change
   */

	}, {
		key: 'setAttribute',
		value: function setAttribute(key, value) {
			this._fireChange('attributes', this);

			if (key == 'class') {
				parseClasses(this._classes, value);
			} else if (key == 'style') {
				parseInlineStyles(this._styles, value);
			} else {
				this._attrs.set(key, value);
			}
		}

		/**
   * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
   * this element.
   *
   * @param {Number} index Position where nodes should be inserted.
   * @param {engine.view.Node|Iterable.<engine.view.Node>} nodes Node or the list of nodes to be inserted.
   * @fires engine.view.Node#change
   * @returns {Number} Number of inserted nodes.
   */

	}, {
		key: 'insertChildren',
		value: function insertChildren(index, nodes) {
			this._fireChange('children', this);
			var count = 0;

			nodes = normalize$2(nodes);

			var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
				for (var _iterator4 = nodes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var node = _step4.value;

					node.parent = this;

					this._children.splice(index, 0, node);
					index++;
					count++;
				}
			} catch (err) {
				_didIteratorError4 = true;
				_iteratorError4 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion4 && _iterator4.return) {
						_iterator4.return();
					}
				} finally {
					if (_didIteratorError4) {
						throw _iteratorError4;
					}
				}
			}

			return count;
		}

		/**
   * Removes attribute from the element.
   *
   * @param {String} key Attribute key.
   * @returns {Boolean} Returns true if an attribute existed and has been removed.
   * @fires engine.view.Node#change
   */

	}, {
		key: 'removeAttribute',
		value: function removeAttribute(key) {
			this._fireChange('attributes', this);

			// Remove class attribute.
			if (key == 'class') {
				if (this._classes.size > 0) {
					this._classes.clear();

					return true;
				}

				return false;
			}

			// Remove style attribute.
			if (key == 'style') {
				if (this._styles.size > 0) {
					this._styles.clear();

					return true;
				}

				return false;
			}

			// Remove other attributes.
			return this._attrs.delete(key);
		}

		/**
   * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
   *
   * @param {Number} index Number of the first node to remove.
   * @param {Number} [howMany=1] Number of nodes to remove.
   * @returns {Array.<engine.view.Node>} The array of removed nodes.
   * @fires engine.view.Node#change
   */

	}, {
		key: 'removeChildren',
		value: function removeChildren(index) {
			var howMany = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

			this._fireChange('children', this);

			for (var i = index; i < index + howMany; i++) {
				this._children[i].parent = null;
			}

			return this._children.splice(index, howMany);
		}

		/**
   * Checks if this element is similar to other element.
   * Both elements should have the same name and attributes to be considered as similar. Two similar elements
   * can contain different set of children nodes.
   *
   * @param {engine.view.Element} otherElement
   * @returns {Boolean}
   */

	}, {
		key: 'isSimilar',
		value: function isSimilar(otherElement) {
			if (!(otherElement instanceof Element)) {
				return false;
			}

			// If exactly the same Element is provided - return true immediately.
			if (this === otherElement) {
				return true;
			}

			// Check element name.
			if (this.name != otherElement.name) {
				return false;
			}

			// Check number of attributes, classes and styles.
			if (this._attrs.size !== otherElement._attrs.size || this._classes.size !== otherElement._classes.size || this._styles.size !== otherElement._styles.size) {
				return false;
			}

			// Check if attributes are the same.
			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = this._attrs[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var _step5$value = slicedToArray(_step5.value, 2);

					var key = _step5$value[0];
					var value = _step5$value[1];

					if (!otherElement._attrs.has(key) || otherElement._attrs.get(key) !== value) {
						return false;
					}
				}

				// Check if classes are the same.
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5.return) {
						_iterator5.return();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}

			var _iteratorNormalCompletion6 = true;
			var _didIteratorError6 = false;
			var _iteratorError6 = undefined;

			try {
				for (var _iterator6 = this._classes[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
					var className = _step6.value;

					if (!otherElement._classes.has(className)) {
						return false;
					}
				}

				// Check if styles are the same.
			} catch (err) {
				_didIteratorError6 = true;
				_iteratorError6 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion6 && _iterator6.return) {
						_iterator6.return();
					}
				} finally {
					if (_didIteratorError6) {
						throw _iteratorError6;
					}
				}
			}

			var _iteratorNormalCompletion7 = true;
			var _didIteratorError7 = false;
			var _iteratorError7 = undefined;

			try {
				for (var _iterator7 = this._styles[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
					var _step7$value = slicedToArray(_step7.value, 2);

					var property = _step7$value[0];
					var value = _step7$value[1];

					if (!otherElement._styles.has(property) || otherElement._styles.get(property) !== value) {
						return false;
					}
				}
			} catch (err) {
				_didIteratorError7 = true;
				_iteratorError7 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion7 && _iterator7.return) {
						_iterator7.return();
					}
				} finally {
					if (_didIteratorError7) {
						throw _iteratorError7;
					}
				}
			}

			return true;
		}

		/**
   * Adds specified class.
   *
   *		element.addClass( 'foo' ); // Adds 'foo' class.
   *		element.addClass( 'foo', 'bar' ); // Adds 'foo' and 'bar' classes.
   *
   * @param {...String} className
   * @fires engine.view.Node#change
   */

	}, {
		key: 'addClass',
		value: function addClass() {
			var _this2 = this;

			this._fireChange('attributes', this);

			for (var _len = arguments.length, className = Array(_len), _key = 0; _key < _len; _key++) {
				className[_key] = arguments[_key];
			}

			className.forEach(function (name) {
				return _this2._classes.add(name);
			});
		}

		/**
   * Removes specified class.
   *
  	 *		element.removeClass( 'foo' );  // Removes 'foo' class.
   *		element.removeClass( 'foo', 'bar' ); // Removes both 'foo' and 'bar' classes.
   *
   * @param {...String} className
   * @fires engine.view.Node#change
   */

	}, {
		key: 'removeClass',
		value: function removeClass() {
			var _this3 = this;

			this._fireChange('attributes', this);

			for (var _len2 = arguments.length, className = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				className[_key2] = arguments[_key2];
			}

			className.forEach(function (name) {
				return _this3._classes.delete(name);
			});
		}

		/**
   * Returns true if class is present.
   * If more then one class is provided - returns true only when all classes are present.
   *
   *		element.hasClass( 'foo' ); // Returns true if 'foo' class is present.
   *		element.hasClass( 'foo', 'bar' ); // Returns true if 'foo' and 'bar' classes are both present.
   *
   * @param {...String} className
   */

	}, {
		key: 'hasClass',
		value: function hasClass() {
			for (var _len3 = arguments.length, className = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
				className[_key3] = arguments[_key3];
			}

			var _iteratorNormalCompletion8 = true;
			var _didIteratorError8 = false;
			var _iteratorError8 = undefined;

			try {
				for (var _iterator8 = className[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
					var name = _step8.value;

					if (!this._classes.has(name)) {
						return false;
					}
				}
			} catch (err) {
				_didIteratorError8 = true;
				_iteratorError8 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion8 && _iterator8.return) {
						_iterator8.return();
					}
				} finally {
					if (_didIteratorError8) {
						throw _iteratorError8;
					}
				}
			}

			return true;
		}

		/**
   * Returns iterator that contains all class names.
   *
   * @returns {Iterator.<String>}
   */

	}, {
		key: 'getClassNames',
		value: function getClassNames() {
			return this._classes.keys();
		}

		/**
   * Adds style to the element.
   *
   *		element.setStyle( 'color', 'red' );
   *		element.setStyle( {
   *			color: 'red',
   *			position: 'fixed'
   *		} );
   *
   * @param {String|Object} property Property name or object with key - value pairs.
   * @param {String} [value] Value to set. This parameter is ignored if object is provided as the first parameter.
   * @fires engine.view.Node#change
   */

	}, {
		key: 'setStyle',
		value: function setStyle(property, value) {
			this._fireChange('attributes', this);

			if (isPlainObject(property)) {
				var keys = Object.keys(property);

				var _iteratorNormalCompletion9 = true;
				var _didIteratorError9 = false;
				var _iteratorError9 = undefined;

				try {
					for (var _iterator9 = keys[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
						var key = _step9.value;

						this._styles.set(key, property[key]);
					}
				} catch (err) {
					_didIteratorError9 = true;
					_iteratorError9 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion9 && _iterator9.return) {
							_iterator9.return();
						}
					} finally {
						if (_didIteratorError9) {
							throw _iteratorError9;
						}
					}
				}
			} else {
				this._styles.set(property, value);
			}
		}

		/**
   * Returns style value for given property.
   * Undefined is returned if style does not exist.
   *
   * @param {String} property
   * @returns {String|undefined}
   */

	}, {
		key: 'getStyle',
		value: function getStyle(property) {
			return this._styles.get(property);
		}

		/**
   * Returns iterator that contains all style names.
   *
   * @returns {Iterator.<String>}
   */

	}, {
		key: 'getStyleNames',
		value: function getStyleNames() {
			return this._styles.keys();
		}

		/**
   * Returns true if style keys are present.
   * If more then one style property is provided - returns true only when all properties are present.
   *
   *		element.hasStyle( 'color' ); // Returns true if 'border-top' style is present.
   *		element.hasStyle( 'color', 'border-top' ); // Returns true if 'color' and 'border-top' styles are both present.
   *
   * @param {...String} property
   */

	}, {
		key: 'hasStyle',
		value: function hasStyle() {
			for (var _len4 = arguments.length, property = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
				property[_key4] = arguments[_key4];
			}

			var _iteratorNormalCompletion10 = true;
			var _didIteratorError10 = false;
			var _iteratorError10 = undefined;

			try {
				for (var _iterator10 = property[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
					var name = _step10.value;

					if (!this._styles.has(name)) {
						return false;
					}
				}
			} catch (err) {
				_didIteratorError10 = true;
				_iteratorError10 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion10 && _iterator10.return) {
						_iterator10.return();
					}
				} finally {
					if (_didIteratorError10) {
						throw _iteratorError10;
					}
				}
			}

			return true;
		}

		/**
   * Removes specified style.
   *
   *		element.removeStyle( 'color' );  // Removes 'color' style.
   *		element.removeStyle( 'color', 'border-top' ); // Removes both 'color' and 'border-top' styles.
   *
   * @param {...String} property
   * @fires engine.view.Node#change
   */

	}, {
		key: 'removeStyle',
		value: function removeStyle() {
			var _this4 = this;

			this._fireChange('attributes', this);

			for (var _len5 = arguments.length, property = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
				property[_key5] = arguments[_key5];
			}

			property.forEach(function (name) {
				return _this4._styles.delete(name);
			});
		}
	}, {
		key: 'childCount',
		get: function get() {
			return this._children.length;
		}

		/**
   * Is `true` if there are no nodes inside this element, `false` otherwise.
   *
   * @readonly
   * @type {Boolean}
   */

	}, {
		key: 'isEmpty',
		get: function get() {
			return this._children.length === 0;
		}
	}]);
	return Element;
}(Node$2);

function parseInlineStyles(stylesMap, stylesString) {
	var regex = /\s*([^:;\s]+)\s*:\s*([^;]+)\s*(?=;|$)/g;
	var matchStyle = void 0;
	stylesMap.clear();

	while ((matchStyle = regex.exec(stylesString)) !== null) {
		stylesMap.set(matchStyle[1], matchStyle[2].trim());
	}
}

// Parses class attribute and puts all classes into classes set.
// Classes set s cleared before insertion.
//
// @param {Set.<String>} classesSet Set to insert parsed classes.
// @param {String} classesString String with classes to parse.
function parseClasses(classesSet, classesString) {
	var classArray = classesString.split(/\s+/);
	classesSet.clear();
	classArray.forEach(function (name) {
		return classesSet.add(name);
	});
}

// Converts strings to Text and non-iterables to arrays.
//
// @param {String|engine.view.Node|Iterable.<String|engine.view.Node>}
// @return {Iterable.<engine.view.Node>}
function normalize$2(nodes) {
	// Separate condition because string is iterable.
	if (typeof nodes == 'string') {
		return [new Text$2(nodes)];
	}

	if (!isIterable(nodes)) {
		nodes = [nodes];
	}

	// Array.from to enable .map() on non-arrays.
	return Array.from(nodes).map(function (node) {
		return typeof node == 'string' ? new Text$2(node) : node;
	});
}

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Containers are elements which define document structure. They define boundaries for
 * {@link engine.view.AttributeElement attributes}. They are mostly use for block elements like `<p>` or `<div>`.
 *
 * Editing engine does not define fixed HTML DTD. This is why the type of the {@link engine.view.Element} need to
 * be defined by the feature developer.
 *
 * Creating an element you should use `ContainerElement` class or {@link engine.view.AttributeElement}. This is
 * important to define the type of the element because of two reasons:
 *
 * Firstly, {@link engine.view.DomConverter} needs the information what is an editable block to convert elements to
 * DOM properly. {@link engine.view.DomConverter} will ensure that `ContainerElement` is editable and it is possible
 * to put caret inside it, even if the container is empty.
 *
 * Secondly, {@link engine.view.writer view writer} uses this information.
 * Nodes {@link engine.view.writer.breakAttributes breaking} and {@link engine.view.writer.mergeAttributes merging}
 * is performed only in a bounds of a container nodes.
 *
 * For instance if `<p>` is an container and `<b>` is attribute:
 *
 *		<p><b>fo^o</b></p>
 *
 * {@link engine.view.writer.breakAttributes breakAttributes} will create:
 *
 *		<p><b>fo</b><b>o</b></p>
 *
 * There might be a need to mark `<span>` element as a container node, for example in situation when it will be a
 * container of an inline widget:
 *
 *		<span color="red">foobar</span>		// attribute
 *		<span data-widget>foobar</span>		// container
 *
 * @memberOf engine.view
 * @extends engine.view.Element
 */

var ContainerElement = function (_Element) {
  inherits(ContainerElement, _Element);

  /**
   * Creates a container element.
   *
   * @see engine.view.Element
   */
  function ContainerElement(name, attrs, children) {
    classCallCheck(this, ContainerElement);
    return possibleConstructorReturn(this, Object.getPrototypeOf(ContainerElement).call(this, name, attrs, children));
  }

  /**
   * Returns block {@link engine.view.filler filler} offset or `null` if block filler is not needed.
   *
   * @returns {Number|null} Block filler offset or `null` if block filler is not needed.
   */


  createClass(ContainerElement, [{
    key: 'getFillerOffset',
    value: function getFillerOffset() {
      return this.childCount === 0 ? 0 : null;
    }
  }]);
  return ContainerElement;
}(Element$1);

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Editable element which can be a {@link view.engine.RootEditableElement root} or nested editable area in the editor.
 *
 * @memberOf engine.view
 * @extends engine.view.ContainerElement
 * @mixes utils.ObservaleMixin
 */

var EditableElement = function (_ContainerElement) {
	inherits(EditableElement, _ContainerElement);

	/**
  * Creates an editable element.
  */
	function EditableElement(document, name, attrs, children) {
		classCallCheck(this, EditableElement);

		/**
   * {@link engine.view.Document} that is an owner of this root.
   *
   * @private
   * @member {engine.view.Document} engine.view.RootEditableElement#_document
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(EditableElement).call(this, name, attrs, children));

		_this._document = document;

		/**
   * Whether the editable is in read-write or read-only mode.
   *
   * @observable
   * @member {Boolean} engine.view.EditableElement#isReadOnly
   */
		_this.set('isReadOnly', false);

		/**
   * Whether the editable is focused.
   *
   * This property updates when {@link engine.view.Document#isFocused document.isFocused} is changed and after each
   * {@link engine.view.Document#render render} method call.
   *
   * @readonly
   * @observable
   * @member {Boolean} engine.view.EditableElement#isFocused
   */
		_this.bind('isFocused').to(document, 'isFocused', function (isFocused) {
			return isFocused && document.selection.editableElement == _this;
		});

		// Update focus state after each rendering. Selection might be moved to different editable before rendering,
		// but this does not mean that editable has focus - it will be placed there after rendering.
		_this.listenTo(document, 'render', function () {
			_this.isFocused = document.isFocused && document.selection.editableElement == _this;
		}, { priority: 'low' });
		return _this;
	}

	/**
  * {@link engine.view.Document View document} reference that owns this editable element.
  *
  * @type {engine.view.Document|null}
  */


	createClass(EditableElement, [{
		key: 'document',
		get: function get() {
			return this._document;
		}
	}]);
	return EditableElement;
}(ContainerElement);

mix(EditableElement, ObservableMixin);

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Position in the tree. Position is always located before or after a node.
 *
 * @memberOf engine.view
 */

var Position$1 = function () {
	/**
  * Creates a position.
  *
  * @param {engine.view.Node} parent Position parent node.
  * @param {Number} offset Position offset.
  */
	function Position(parent, offset) {
		classCallCheck(this, Position);

		/**
   * Position parent node.
   *
   * @member {engine.view.Node} engine.view.Position#parent
   */
		this.parent = parent;

		/**
   * Position offset.
   *
   * @member {Number} engine.view.Position#offset
   */
		this.offset = offset;
	}

	/**
  * Node directly after the position. Equals `null` when there is no node after position or position is located
  * inside text node.
  *
  * @readonly
  * @type {engine.view.Node|null}
  */


	createClass(Position, [{
		key: 'getShiftedBy',


		/**
   * Returns a new instance of Position with offset incremented by `shift` value.
   *
   * @param {Number} shift How position offset should get changed. Accepts negative values.
   * @returns {engine.view.Position} Shifted position.
   */
		value: function getShiftedBy(shift) {
			var shifted = Position.createFromPosition(this);

			var offset = shifted.offset + shift;
			shifted.offset = offset < 0 ? 0 : offset;

			return shifted;
		}

		/**
   * Returns ancestors array of this position, that is this position's parent and it's ancestors.
   *
   * @returns {Array} Array with ancestors.
   */

	}, {
		key: 'getAncestors',
		value: function getAncestors() {
			return this.parent.getAncestors({ includeNode: true, parentFirst: true });
		}

		/**
   * Checks whether this position equals given position.
   *
   * @param {engine.view.Position} otherPosition Position to compare with.
   * @returns {Boolean} True if positions are same.
   */

	}, {
		key: 'isEqual',
		value: function isEqual(otherPosition) {
			return this == otherPosition || this.parent == otherPosition.parent && this.offset == otherPosition.offset;
		}

		/**
   * Checks whether this position is located before given position. When method returns `false` it does not mean that
   * this position is after give one. Two positions may be located inside separate roots and in that situation this
   * method will still return `false`.
   *
   * @see engine.view.Position#isAfter
   * @see engine.view.Position#compareWith
   * @param {engine.view.Position} otherPosition Position to compare with.
   * @returns {Boolean} Returns `true` if this position is before given position.
   */

	}, {
		key: 'isBefore',
		value: function isBefore(otherPosition) {
			return this.compareWith(otherPosition) == 'before';
		}

		/**
   * Checks whether this position is located after given position. When method returns `false` it does not mean that
   * this position is before give one. Two positions may be located inside separate roots and in that situation this
   * method will still return `false`.
   *
   * @see engine.view.Position#isBefore
   * @see engine.view.Position#compareWith
   * @param {engine.view.Position} otherPosition Position to compare with.
   * @returns {Boolean} Returns `true` if this position is after given position.
   */

	}, {
		key: 'isAfter',
		value: function isAfter(otherPosition) {
			return this.compareWith(otherPosition) == 'after';
		}

		/**
   * Checks whether this position is before, after or in same position that other position. Two positions may be also
   * different when they are located in separate roots.
   *
   * @param {engine.view.Position} otherPosition Position to compare with.
   * @returns {engine.view.PositionRelation}
   */

	}, {
		key: 'compareWith',
		value: function compareWith(otherPosition) {
			if (this.isEqual(otherPosition)) {
				return 'same';
			}

			// If positions have same parent.
			if (this.parent === otherPosition.parent) {
				return this.offset - otherPosition.offset < 0 ? 'before' : 'after';
			}

			// Get path from root to position's parent element.
			var path = this.parent.getAncestors({ includeNode: true });
			var otherPath = otherPosition.parent.getAncestors({ includeNode: true });

			// Compare both path arrays to find common ancestor.
			var result = compareArrays(path, otherPath);

			var commonAncestorIndex = void 0;

			switch (result) {
				case 0:
					// No common ancestors found.
					return 'different';

				case 'prefix':
					commonAncestorIndex = path.length - 1;
					break;

				case 'extension':
					commonAncestorIndex = otherPath.length - 1;
					break;

				default:
					commonAncestorIndex = result - 1;
			}

			// Common ancestor of two positions.
			var commonAncestor = path[commonAncestorIndex];
			var nextAncestor1 = path[commonAncestorIndex + 1];
			var nextAncestor2 = otherPath[commonAncestorIndex + 1];

			// Check if common ancestor is not one of the parents.
			if (commonAncestor === this.parent) {
				var _index = this.offset - nextAncestor2.index;

				return _index <= 0 ? 'before' : 'after';
			} else if (commonAncestor === otherPosition.parent) {
				var _index2 = nextAncestor1.index - otherPosition.offset;

				return _index2 < 0 ? 'before' : 'after';
			}

			var index = nextAncestor1.index - nextAncestor2.index;

			// Compare indexes of next ancestors inside common one.
			return index < 0 ? 'before' : 'after';
		}

		/**
   * Creates position at the given location. The location can be specified as:
   *
   * * a {@link engine.view.Position position},
   * * parent element and offset (offset defaults to `0`),
   * * parent element and `'end'` (sets position at the end of that element),
   * * {@link engine.view.Item view item} and `'before'` or `'after'` (sets position before or after given view item).
   *
   * This method is a shortcut to other constructors such as:
   *
   * * {@link engine.view.Position.createBefore},
   * * {@link engine.view.Position.createAfter},
   * * {@link engine.view.Position.createFromPosition}.
   *
   * @param {engine.view.Item|engine.model.Position} itemOrPosition
   * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when
   * first parameter is a {@link engine.view.Item view item}.
   */

	}, {
		key: 'nodeAfter',
		get: function get() {
			if (this.parent instanceof Text$2) {
				return null;
			}

			return this.parent.getChild(this.offset) || null;
		}

		/**
   * Node directly before the position. Equals `null` when there is no node before position or position is located
   * inside text node.
   *
   * @readonly
   * @type {engine.view.Node|null}
   */

	}, {
		key: 'nodeBefore',
		get: function get() {
			if (this.parent instanceof Text$2) {
				return null;
			}

			return this.parent.getChild(this.offset - 1) || null;
		}

		/**
   * Is `true` if position is at the beginning of its {@link engine.view.Position#parent parent}, `false` otherwise.
   *
   * @readonly
   * @type {Boolean}
   */

	}, {
		key: 'isAtStart',
		get: function get() {
			return this.offset === 0;
		}

		/**
   * Is `true` if position is at the end of its {@link engine.view.Position#parent parent}, `false` otherwise.
   *
   * @readonly
   * @type {Boolean}
   */

	}, {
		key: 'isAtEnd',
		get: function get() {
			var endOffset = this.parent instanceof Text$2 ? this.parent.data.length : this.parent.childCount;

			return this.offset === endOffset;
		}

		/**
   * Position's root, that is the root of the position's parent element.
   *
   * @readonly
   * @type {engine.view.Node|engine.view.DocumentFragment}
   */

	}, {
		key: 'root',
		get: function get() {
			return this.parent.root;
		}

		/**
   * {@link engine.view.EditableElement EditableElement} instance that contains this position, or `null` if
   * position is not inside an editable element.
   *
   * @type {engine.view.EditableElement|null}
   */

	}, {
		key: 'editableElement',
		get: function get() {
			var editable = this.parent;

			while (!(editable instanceof EditableElement)) {
				if (editable.parent) {
					editable = editable.parent;
				} else {
					return null;
				}
			}

			return editable;
		}
	}], [{
		key: 'createAt',
		value: function createAt(itemOrPosition, offset) {
			if (itemOrPosition instanceof Position) {
				return this.createFromPosition(itemOrPosition);
			} else {
				var node = itemOrPosition;

				if (offset == 'end') {
					offset = node instanceof Text$2 ? node.data.length : node.childCount;
				} else if (offset == 'before') {
					return this.createBefore(node);
				} else if (offset == 'after') {
					return this.createAfter(node);
				} else if (!offset) {
					offset = 0;
				}

				return new Position(node, offset);
			}
		}

		/**
   * Creates a new position after given view item.
   *
   * @param {engine.view.Item} item View item after which the position should be located.
   * @returns {engine.view.Position}
   */

	}, {
		key: 'createAfter',
		value: function createAfter(item) {
			// TextProxy is not a instance of Node so we need do handle it in specific way.
			if (item instanceof TextProxy$1) {
				return new Position(item.textNode, item.offsetInText + item.data.length);
			}

			if (!item.parent) {
				/**
     * You can not make a position after a root.
     *
     * @error position-after-root
     * @param {engine.view.Node} root
     */
				throw new CKEditorError('view-position-after-root: You can not make position after root.', { root: item });
			}

			return new Position(item.parent, item.index + 1);
		}

		/**
   * Creates a new position before given view item.
   *
   * @param {engine.view.Item} item View item before which the position should be located.
   * @returns {engine.view.Position}
   */

	}, {
		key: 'createBefore',
		value: function createBefore(item) {
			// TextProxy is not a instance of Node so we need do handle it in specific way.
			if (item instanceof TextProxy$1) {
				return new Position(item.textNode, item.offsetInText);
			}

			if (!item.parent) {
				/**
     * You cannot make a position before a root.
     *
     * @error position-before-root
     * @param {engine.view.Node} root
     */
				throw new CKEditorError('view-position-before-root: You can not make position before root.', { root: item });
			}

			return new Position(item.parent, item.index);
		}

		/**
   * Creates and returns a new instance of `Position`, which is equal to the passed position.
   *
   * @param {engine.view.Position} position Position to be cloned.
   * @returns {engine.view.Position}
   */

	}, {
		key: 'createFromPosition',
		value: function createFromPosition(position) {
			return new this(position.parent, position.offset);
		}
	}]);
	return Position;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Position iterator class. It allows to iterate forward and backward over the document.
 *
 * @memberOf engine.view
 */

var TreeWalker$1 = function () {
	/**
  * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
  *
  * @constructor
  * @param {Object} options Object with configuration.
  * @param {engine.view.Range} [options.boundaries=null] Range to define boundaries of the iterator.
  * @param {engine.view.Position} [options.startPosition] Starting position.
  * @param {'forward'|'backward'} [options.direction='forward'] Walking direction.
  * @param {Boolean} [options.singleCharacters=false] Flag indicating whether all characters from
  * {@link engine.view.Text} should be returned as one {@link engine.view.Text} (`false`) ore one by one as
  * {@link engine.view.TextProxy} (`true`).
  * @param {Boolean} [options.shallow=false] Flag indicating whether iterator should enter elements or not. If the
  * iterator is shallow child nodes of any iterated node will not be returned along with `elementEnd` tag.
  * @param {Boolean} [options.ignoreElementEnd=false] Flag indicating whether iterator should ignore `elementEnd`
  * tags. If the option is true walker will not return a parent node of start position. If this option is `true`
  * each {@link engine.view.Element} will be returned once, while if the option is `false` they might be returned
  * twice: for `'elementStart'` and `'elementEnd'`.
  */
	function TreeWalker() {
		var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
		classCallCheck(this, TreeWalker);

		if (!options.boundaries && !options.startPosition) {
			/**
    * Neither boundaries nor starting position have been defined.
    *
    * @error tree-walker-no-start-position
    */
			throw new CKEditorError('view-tree-walker-no-start-position: Neither boundaries nor starting position have been defined.');
		}

		if (options.direction && options.direction != 'forward' && options.direction != 'backward') {
			throw new CKEditorError('view-tree-walker-unknown-direction: Only `backward` and `forward` direction allowed.', { direction: options.direction });
		}

		/**
   * Iterator boundaries.
   *
   * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`
   * on the start of boundary, then `{ done: true }` is returned.
   *
   * If boundaries are not defined they are set before first and after last child of the root node.
   *
   * @readonly
   * @member {engine.view.Range} engine.view.TreeWalker#boundaries
   */
		this.boundaries = options.boundaries || null;

		/**
   * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is
   * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.
   *
   * @readonly
   * @member {engine.view.Position} engine.view.TreeWalker#position
   */
		if (options.startPosition) {
			this.position = Position$1.createFromPosition(options.startPosition);
		} else {
			this.position = Position$1.createFromPosition(options.boundaries[options.direction == 'backward' ? 'end' : 'start']);
		}

		/**
   * Walking direction. Defaults `'forward'`.
   *
   * @readonly
   * @member {'backward'|'forward'} engine.view.TreeWalker#direction
   */
		this.direction = options.direction || 'forward';

		/**
   * Flag indicating whether all characters from {@link engine.view.Text} should be returned as one
   * {@link engine.view.Text} or one by one as {@link engine.view.TextProxy}.
   *
   * @readonly
   * @member {Boolean} engine.view.TreeWalker#singleCharacters
   */
		this.singleCharacters = !!options.singleCharacters;

		/**
   * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any
   * iterated node will not be returned along with `elementEnd` tag.
   *
   * @readonly
   * @member {Boolean} engine.view.TreeWalker#shallow
   */
		this.shallow = !!options.shallow;

		/**
   * Flag indicating whether iterator should ignore `elementEnd` tags. If set to `true`, walker will not
   * return a parent node of the start position. Each {@link engine.view.Element} will be returned once.
   * When set to `false` each element might be returned twice: for `'elementStart'` and `'elementEnd'`.
   *
   * @readonly
   * @member {Boolean} engine.view.TreeWalker#ignoreElementEnd
   */
		this.ignoreElementEnd = !!options.ignoreElementEnd;

		/**
   * Start boundary parent.
   *
   * @private
   * @member {engine.view.Node} engine.view.TreeWalker#_boundaryStartParent
   */
		this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;

		/**
   * End boundary parent.
   *
   * @private
   * @member {engine.view.Node} engine.view.TreeWalker#_boundaryEndParent
   */
		this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
	}

	/**
  * Iterator interface.
  */


	createClass(TreeWalker, [{
		key: Symbol.iterator,
		value: function value() {
			return this;
		}

		/**
   * Iterator interface method.
   * Detects walking direction and makes step forward or backward.
   *
   * @returns {Object} Object implementing iterator interface, returning information about taken step.
   */

	}, {
		key: 'next',
		value: function next() {
			if (this.direction == 'forward') {
				return this._next();
			} else {
				return this._previous();
			}
		}

		/**
   * Makes a step forward in view. Moves the {@link #position} to the next position and returns the encountered value.
   *
   * @private
   * @returns {Object}
   * @returns {Boolean} return.done `true` if iterator is done, `false` otherwise.
   * @returns {engine.view.TreeWalkerValue} return.value Information about taken step.
   */

	}, {
		key: '_next',
		value: function _next() {
			var position = Position$1.createFromPosition(this.position);
			var previousPosition = this.position;
			var parent = position.parent;

			// We are at the end of the root.
			if (parent.parent === null && position.offset === parent.childCount) {
				return { done: true };
			}

			// We reached the walker boundary.
			if (parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {
				return { done: true };
			}

			// Get node just after current position.
			var node = void 0;

			// Text is a specific parent because it contains string instead of child nodes.
			if (parent instanceof Text$2) {
				node = parent.data[position.offset];
			} else {
				node = parent.getChild(position.offset);
			}

			if (node instanceof Element$1) {
				if (!this.shallow) {
					position = new Position$1(node, 0);
				} else {
					position.offset++;
				}

				this.position = position;

				return this._formatReturnValue('elementStart', node, previousPosition, position, 1);
			} else if (node instanceof Text$2) {
				if (this.singleCharacters) {
					position = new Position$1(node, 0);
					this.position = position;

					return this._next();
				} else {
					var charactersCount = node.data.length;
					var item = node;

					// If text stick out of walker range, we need to cut it and wrap by TextProxy.
					if (node == this._boundaryEndParent) {
						charactersCount = this.boundaries.end.offset;
						item = new TextProxy$1(node, 0, charactersCount);
						position = Position$1.createAfter(item);
					} else {
						// If not just keep moving forward.
						position.offset++;
					}

					this.position = position;

					return this._formatReturnValue('text', item, previousPosition, position, charactersCount);
				}
			} else if (typeof node == 'string') {
				var textLength = void 0;

				if (this.singleCharacters) {
					textLength = 1;
				} else {
					// Check if text stick out of walker range.
					var endOffset = parent === this._boundaryEndParent ? this.boundaries.end.offset : parent.data.length;

					textLength = endOffset - position.offset;
				}

				var textProxy = new TextProxy$1(parent, position.offset, textLength);

				position.offset += textLength;
				this.position = position;

				return this._formatReturnValue('text', textProxy, previousPosition, position, textLength);
			} else {
				// `node` is not set, we reached the end of current `parent`.
				position = Position$1.createAfter(parent);
				this.position = position;

				if (this.ignoreElementEnd) {
					return this._next();
				} else {
					return this._formatReturnValue('elementEnd', parent, previousPosition, position);
				}
			}
		}

		/**
   * Makes a step backward in view. Moves the {@link #position} to the previous position and returns the encountered value.
   *
   * @private
   * @returns {Object}
   * @returns {Boolean} return.done True if iterator is done.
   * @returns {engine.view.TreeWalkerValue} return.value Information about taken step.
   */

	}, {
		key: '_previous',
		value: function _previous() {
			var position = Position$1.createFromPosition(this.position);
			var previousPosition = this.position;
			var parent = position.parent;

			// We are at the beginning of the root.
			if (parent.parent === null && position.offset === 0) {
				return { done: true };
			}

			// We reached the walker boundary.
			if (parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {
				return { done: true };
			}

			// Get node just before current position.
			var node = void 0;

			// Text {@link engine.view.Text} element is a specific parent because contains string instead of child nodes.
			if (parent instanceof Text$2) {
				node = parent.data[position.offset - 1];
			} else {
				node = parent.getChild(position.offset - 1);
			}

			if (node instanceof Element$1) {
				if (!this.shallow) {
					position = new Position$1(node, node.childCount);
					this.position = position;

					if (this.ignoreElementEnd) {
						return this._previous();
					} else {
						return this._formatReturnValue('elementEnd', node, previousPosition, position);
					}
				} else {
					position.offset--;
					this.position = position;

					return this._formatReturnValue('elementStart', node, previousPosition, position, 1);
				}
			} else if (node instanceof Text$2) {
				if (this.singleCharacters) {
					position = new Position$1(node, node.data.length);
					this.position = position;

					return this._previous();
				} else {
					var charactersCount = node.data.length;
					var item = node;

					// If text stick out of walker range, we need to cut it and wrap by TextProxy.
					if (node == this._boundaryStartParent) {
						var offset = this.boundaries.start.offset;

						item = new TextProxy$1(node, offset, node.data.length - offset);
						charactersCount = item.data.length;
						position = Position$1.createBefore(item);
					} else {
						// If not just keep moving backward.
						position.offset--;
					}

					this.position = position;

					return this._formatReturnValue('text', item, previousPosition, position, charactersCount);
				}
			} else if (typeof node == 'string') {
				var textLength = void 0;

				if (!this.singleCharacters) {
					// Check if text stick out of walker range.
					var startOffset = parent === this._boundaryStartParent ? this.boundaries.start.offset : 0;

					textLength = position.offset - startOffset;
				} else {
					textLength = 1;
				}

				position.offset -= textLength;

				var textProxy = new TextProxy$1(parent, position.offset, textLength);

				this.position = position;

				return this._formatReturnValue('text', textProxy, previousPosition, position, textLength);
			} else {
				// `node` is not set, we reached the beginning of current `parent`.
				position = Position$1.createBefore(parent);
				this.position = position;

				return this._formatReturnValue('elementStart', parent, previousPosition, position, 1);
			}
		}

		/**
   * Format returned data and adjust `previousPosition` and `nextPosition` if reach the bound of the {@link engine.view.Text}.
   *
   * @private
   * @param {engine.view.TreeWalkerValueType} type Type of step.
   * @param {engine.view.Item} item Item between old and new position.
   * @param {engine.view.Position} previousPosition Previous position of iterator.
   * @param {engine.view.Position} nextPosition Next position of iterator.
   * @param {Number} [length] Length of the item.
   * @returns {engine.view.TreeWalkerValue}
   */

	}, {
		key: '_formatReturnValue',
		value: function _formatReturnValue(type, item, previousPosition, nextPosition, length) {
			// Text is a specific parent, because contains string instead of childs.
			// Walker doesn't enter to the Text except situations when walker is iterating over every single character,
			// or the bound starts/ends inside the Text. So when the position is at the beginning or at the end of the Text
			// we move it just before or just after Text.
			if (item instanceof TextProxy$1) {
				// Position is at the end of Text.
				if (item.offsetInText + item.data.length == item.textNode.data.length) {
					if (this.direction == 'forward' && !(this.boundaries && this.boundaries.end.isEqual(this.position))) {
						nextPosition = Position$1.createAfter(item.textNode);
						// When we change nextPosition of returned value we need also update walker current position.
						this.position = nextPosition;
					} else {
						previousPosition = Position$1.createAfter(item.textNode);
					}
				}

				// Position is at the begining ot the text.
				if (item.offsetInText === 0) {
					if (this.direction == 'backward' && !(this.boundaries && this.boundaries.start.isEqual(this.position))) {
						nextPosition = Position$1.createBefore(item.textNode);
						// When we change nextPosition of returned value we need also update walker current position.
						this.position = nextPosition;
					} else {
						previousPosition = Position$1.createBefore(item.textNode);
					}
				}
			}

			return {
				done: false,
				value: {
					type: type,
					item: item,
					previousPosition: previousPosition,
					nextPosition: nextPosition,
					length: length
				}
			};
		}
	}]);
	return TreeWalker;
}();

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Tree view range.
 *
 * @memberOf engine.view
 */

var Range$2 = function () {
	/**
  * Creates a range spanning from `start` position to `end` position.
  *
  * **Note:** Constructor creates it's own {@link engine.view.Position} instances basing on passed values.
  *
  * @param {engine.view.Position} start Start position.
  * @param {engine.view.Position} [end] End position. If not set, range will be collapsed at `start` position.
  */
	function Range(start) {
		var end = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
		classCallCheck(this, Range);

		/**
   * Start position.
   *
   * @member engine.view.Range#start
   * @type {engine.view.Position}
   */
		this.start = Position$1.createFromPosition(start);

		/**
   * End position.
   *
   * @member engine.view.Range#end
   * @type {engine.view.Position}
   */
		this.end = end ? Position$1.createFromPosition(end) : Position$1.createFromPosition(start);
	}

	/**
  * Returns an iterator that iterates over all {@link engine.view.Item view items} that are in this range and returns
  * them together with additional information like length or {@link engine.view.Position positions},
  * grouped as {@link engine.view.TreeWalkerValue}.
  *
  * This iterator uses {@link engine.view.TreeWalker TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option
  * set to `true`.
  *
  * @returns {Iterable.<engine.view.TreeWalkerValue>}
  */


	createClass(Range, [{
		key: Symbol.iterator,
		value: regeneratorRuntime.mark(function value() {
			return regeneratorRuntime.wrap(function value$(_context) {
				while (1) {
					switch (_context.prev = _context.next) {
						case 0:
							return _context.delegateYield(new TreeWalker$1({ boundaries: this, ignoreElementEnd: true }), 't0', 1);

						case 1:
						case 'end':
							return _context.stop();
					}
				}
			}, value, this);
		})

		/**
   * Returns whether the range is collapsed, that is it start and end positions are equal.
   *
   * @type {Boolean}
   */

	}, {
		key: 'isEqual',


		/**
   * Two ranges are equal if their start and end positions are equal.
   *
   * @param {engine.view.Range} otherRange Range to compare with.
   * @returns {Boolean} `true` if ranges are equal, `false` otherwise
   */
		value: function isEqual(otherRange) {
			return this == otherRange || this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);
		}

		/**
   * Checks whether this range contains given {@link engine.view.Position position}.
   *
   * @param {engine.view.Position} position Position to check.
   * @returns {Boolean} `true` if given {@link engine.view.Position position} is contained in this range, `false` otherwise.
   */

	}, {
		key: 'containsPosition',
		value: function containsPosition(position) {
			return position.isAfter(this.start) && position.isBefore(this.end);
		}

		/**
   * Checks whether this range contains given {@link engine.view.Range range}.
   *
   * @param {engine.view.Range} otherRange Range to check.
   * @returns {Boolean} `true` if given {@link engine.view.Range range} boundaries are contained by this range, `false` otherwise.
   */

	}, {
		key: 'containsRange',
		value: function containsRange(otherRange) {
			return this.containsPosition(otherRange.start) && this.containsPosition(otherRange.end);
		}

		/**
   * Computes which part(s) of this {@link engine.view.Range range} is not a part of given {@link engine.view.Range range}.
   * Returned array contains zero, one or two {@link engine.view.Range ranges}.
   *
   * Examples:
   *
   *		let foo = new Text( 'foo' );
   *		let img = new ContainerElement( 'img' );
   *		let bar = new Text( 'bar' );
   *		let p = new ContainerElement( 'p', null, [ foo, img, bar ] );
   *
   *		let range = new Range( new Position( foo, 2 ), new Position( bar, 1 ); // "o", img, "b" are in range.
   *		let otherRange = new Range( new Position( foo, 1 ), new Position( bar, 2 ); "oo", img, "ba" are in range.
   *		let transformed = range.getDifference( otherRange );
   *		// transformed array has no ranges because `otherRange` contains `range`
   *
   *		otherRange = new Range( new Position( foo, 1 ), new Position( p, 2 ); // "oo", img are in range.
   *		transformed = range.getDifference( otherRange );
   *		// transformed array has one range: from ( p, 2 ) to ( bar, 1 )
   *
   *		otherRange = new Range( new Position( p, 1 ), new Position( p, 2 ) ); // img is in range.
   *		transformed = range.getDifference( otherRange );
   *		// transformed array has two ranges: from ( foo, 1 ) to ( p, 1 ) and from ( p, 2 ) to ( bar, 1 )
   *
   * @param {engine.view.Range} otherRange Range to differentiate against.
   * @returns {Array.<engine.view.Range>} The difference between ranges.
   */

	}, {
		key: 'getDifference',
		value: function getDifference(otherRange) {
			var ranges = [];

			if (this.isIntersecting(otherRange)) {
				// Ranges intersect.

				if (this.containsPosition(otherRange.start)) {
					// Given range start is inside this range. This means that we have to
					// add shrunken range - from the start to the middle of this range.
					ranges.push(new Range(this.start, otherRange.start));
				}

				if (this.containsPosition(otherRange.end)) {
					// Given range end is inside this range. This means that we have to
					// add shrunken range - from the middle of this range to the end.
					ranges.push(new Range(otherRange.end, this.end));
				}
			} else {
				// Ranges do not intersect, return the original range.
				ranges.push(Range.createFromRange(this));
			}

			return ranges;
		}

		/**
   * Returns an intersection of this {@link engine.view.Range range} and given {@link engine.view.Range range}.
   * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.
   *
   * Examples:
   *
   *		let foo = new Text( 'foo' );
   *		let img = new ContainerElement( 'img' );
   *		let bar = new Text( 'bar' );
   *		let p = new ContainerElement( 'p', null, [ foo, img, bar ] );
   *
   *		let range = new Range( new Position( foo, 2 ), new Position( bar, 1 ); // "o", img, "b" are in range.
   *		let otherRange = new Range( new Position( foo, 1 ), new Position( p, 2 ); // "oo", img are in range.
   *		let transformed = range.getIntersection( otherRange ); // range from ( foo, 1 ) to ( p, 2 ).
   *
   *		otherRange = new Range( new Position( bar, 1 ), new Position( bar, 3 ); "ar" is in range.
   *		transformed = range.getIntersection( otherRange ); // null - no common part.
   *
   * @param {engine.view.Range} otherRange Range to check for intersection.
   * @returns {engine.view.Range|null} A common part of given ranges or `null` if ranges have no common part.
   */

	}, {
		key: 'getIntersection',
		value: function getIntersection(otherRange) {
			if (this.isIntersecting(otherRange)) {
				// Ranges intersect, so a common range will be returned.
				// At most, it will be same as this range.
				var commonRangeStart = this.start;
				var commonRangeEnd = this.end;

				if (this.containsPosition(otherRange.start)) {
					// Given range start is inside this range. This means thaNt we have to
					// shrink common range to the given range start.
					commonRangeStart = otherRange.start;
				}

				if (this.containsPosition(otherRange.end)) {
					// Given range end is inside this range. This means that we have to
					// shrink common range to the given range end.
					commonRangeEnd = otherRange.end;
				}

				return new Range(commonRangeStart, commonRangeEnd);
			}

			// Ranges do not intersect, so they do not have common part.
			return null;
		}

		/**
   * Creates a {@link engine.view.TreeWalker TreeWalker} instance with this range as a boundary.
   *
   * @param {Object} options Object with configuration options. See {@link engine.view.TreeWalker}.
   * @param {engine.view.Position} [options.startPosition]
   * @param {Boolean} [options.singleCharacters=false]
   * @param {Boolean} [options.shallow=false]
   * @param {Boolean} [options.ignoreElementEnd=false]
   */

	}, {
		key: 'getWalker',
		value: function getWalker() {
			var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

			options.boundaries = this;

			return new TreeWalker$1(options);
		}

		/**
   * Returns an iterator that iterates over all {@link engine.view.Items view items} that are in this range and returns
   * them.
   *
   * This method uses {@link engine.view.TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option
   * set to `true`. However it returns only {@link engine.view.Item items}, not {@link engine.view.TreeWalkerValue}.
   *
   * You may specify additional options for the tree walker. See {@link engine.view.TreeWalker} for
   * a full list of available options.
   *
   * @param {Object} options Object with configuration options. See {@link engine.view.TreeWalker}.
   * @returns {Iterable.<engine.view.Item>}
   */

	}, {
		key: 'getItems',
		value: regeneratorRuntime.mark(function getItems() {
			var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

			var treeWalker, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value;

			return regeneratorRuntime.wrap(function getItems$(_context2) {
				while (1) {
					switch (_context2.prev = _context2.next) {
						case 0:
							options.boundaries = this;
							options.ignoreElementEnd = true;

							treeWalker = new TreeWalker$1(options);
							_iteratorNormalCompletion = true;
							_didIteratorError = false;
							_iteratorError = undefined;
							_context2.prev = 6;
							_iterator = treeWalker[Symbol.iterator]();

						case 8:
							if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
								_context2.next = 15;
								break;
							}

							_value = _step.value;
							_context2.next = 12;
							return _value.item;

						case 12:
							_iteratorNormalCompletion = true;
							_context2.next = 8;
							break;

						case 15:
							_context2.next = 21;
							break;

						case 17:
							_context2.prev = 17;
							_context2.t0 = _context2['catch'](6);
							_didIteratorError = true;
							_iteratorError = _context2.t0;

						case 21:
							_context2.prev = 21;
							_context2.prev = 22;

							if (!_iteratorNormalCompletion && _iterator.return) {
								_iterator.return();
							}

						case 24:
							_context2.prev = 24;

							if (!_didIteratorError) {
								_context2.next = 27;
								break;
							}

							throw _iteratorError;

						case 27:
							return _context2.finish(24);

						case 28:
							return _context2.finish(21);

						case 29:
						case 'end':
							return _context2.stop();
					}
				}
			}, getItems, this, [[6, 17, 21, 29], [22,, 24, 28]]);
		})

		/**
   * Returns an iterator that iterates over all {@link engine.view.Position positions} that are boundaries or
   * contained in this range.
   *
   * This method uses {@link engine.view.TreeWalker} with `boundaries` set to this range. However it returns only
   * {@link engine.view.Position positions}, not {@link engine.view.TreeWalkerValue}.
   *
   * You may specify additional options for the tree walker. See {@link engine.view.TreeWalker} for
   * a full list of available options.
   *
   * @param {Object} options Object with configuration options. See {@link engine.view.TreeWalker}.
   * @returns {Iterable.<engine.view.Position>}
   */

	}, {
		key: 'getPositions',
		value: regeneratorRuntime.mark(function getPositions() {
			var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

			var treeWalker, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2;

			return regeneratorRuntime.wrap(function getPositions$(_context3) {
				while (1) {
					switch (_context3.prev = _context3.next) {
						case 0:
							options.boundaries = this;

							treeWalker = new TreeWalker$1(options);
							_context3.next = 4;
							return treeWalker.position;

						case 4:
							_iteratorNormalCompletion2 = true;
							_didIteratorError2 = false;
							_iteratorError2 = undefined;
							_context3.prev = 7;
							_iterator2 = treeWalker[Symbol.iterator]();

						case 9:
							if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
								_context3.next = 16;
								break;
							}

							_value2 = _step2.value;
							_context3.next = 13;
							return _value2.nextPosition;

						case 13:
							_iteratorNormalCompletion2 = true;
							_context3.next = 9;
							break;

						case 16:
							_context3.next = 22;
							break;

						case 18:
							_context3.prev = 18;
							_context3.t0 = _context3['catch'](7);
							_didIteratorError2 = true;
							_iteratorError2 = _context3.t0;

						case 22:
							_context3.prev = 22;
							_context3.prev = 23;

							if (!_iteratorNormalCompletion2 && _iterator2.return) {
								_iterator2.return();
							}

						case 25:
							_context3.prev = 25;

							if (!_didIteratorError2) {
								_context3.next = 28;
								break;
							}

							throw _iteratorError2;

						case 28:
							return _context3.finish(25);

						case 29:
							return _context3.finish(22);

						case 30:
						case 'end':
							return _context3.stop();
					}
				}
			}, getPositions, this, [[7, 18, 22, 30], [23,, 25, 29]]);
		})

		/**
   * Checks and returns whether this range intersects with given range.
   *
   * @param {engine.view.Range} otherRange Range to compare with.
   * @returns {Boolean} True if ranges intersect.
   */

	}, {
		key: 'isIntersecting',
		value: function isIntersecting(otherRange) {
			return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);
		}

		/**
   * Creates a range from given parents and offsets.
   *
   * @param {engine.view.Element} startElement Start position parent element.
   * @param {Number} startOffset Start position offset.
   * @param {engine.view.Element} endElement End position parent element.
   * @param {Number} endOffset End position offset.
   * @returns {engine.view.Range} Created range.
   */

	}, {
		key: 'isCollapsed',
		get: function get() {
			return this.start.isEqual(this.end);
		}

		/**
   * Returns whether this range is flat, that is if {@link engine.view.Range#start start} position and
   * {@link engine.view.Range#end end} position are in the same {@link engine.view.Position#parent parent}.
   *
   * @type {Boolean}
   */

	}, {
		key: 'isFlat',
		get: function get() {
			return this.start.parent === this.end.parent;
		}

		/**
   * Range root element.
   *
   * @type {engine.view.Element|engine.view.DocumentFragment}
   */

	}, {
		key: 'root',
		get: function get() {
			return this.start.root;
		}
	}], [{
		key: 'createFromParentsAndOffsets',
		value: function createFromParentsAndOffsets(startElement, startOffset, endElement, endOffset) {
			return new this(new Position$1(startElement, startOffset), new Position$1(endElement, endOffset));
		}

		/**
   * Creates and returns a new instance of Range which is equal to passed range.
   *
   * @param {engine.view.Range} range Range to clone.
   * @returns {engine.view.Range}
   */

	}, {
		key: 'createFromRange',
		value: function createFromRange(range) {
			return new this(range.start, range.end);
		}

		/**
   * Creates a new range, spreading from specified {@link engine.view.Position position} to a position moved by
   * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.
   *
   * @param {engine.view.Position} position Beginning of the range.
   * @param {Number} shift How long the range should be.
   * @returns {engine.view.Range}
   */

	}, {
		key: 'createFromPositionAndShift',
		value: function createFromPositionAndShift(position, shift) {
			var start = position;
			var end = position.getShiftedBy(shift);

			return shift > 0 ? new this(start, end) : new this(end, start);
		}

		/**
   * Creates a range inside an {@link engine.view.Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * @param {engine.view.Element} element Element which is a parent for the range.
   * @returns {engine.view.Range}
   */

	}, {
		key: 'createIn',
		value: function createIn(element) {
			return this.createFromParentsAndOffsets(element, 0, element, element.childCount);
		}

		/**
   * Creates a range that starts before given {@link engine.view.Item view item} and ends after it.
   *
   * @param {engine.view.Item} item
   * @returns {engine.view.Range}
   */

	}, {
		key: 'createOn',
		value: function createOn(item) {
			return this.createFromPositionAndShift(Position$1.createBefore(item), 1);
		}
	}]);
	return Range;
}();

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Maps elements and positions between {@link engine.view.Document view} and {@link engine.model model}.
 *
 * Mapper use bound elements to find corresponding elements and positions, so, to get proper results,
 * all model elements should be {@link engine.conversion.Mapper#bindElements bound}.
 *
 * To map complex model to/from view relations, you may provide custom callbacks for
 * {@link engine.conversion.Mapper#event:modelToViewPosition modelToViewPosition event} and
 * {@link engine.conversion.Mapper#event:viewToModelPosition viewToModelPosition event} that are fired whenever
 * a position mapping request occurs. Those events are fired by {@link engine.conversion.Mapper#toViewPosition toViewPosition}
 * and {@link engine.conversion.Mapper#toModelPosition toModelPosition} methods. `Mapper` adds it's own default callbacks
 * with `'lowest'` priority. To override default `Mapper` mapping, add custom callback with higher priority and
 * stop the event.
 *
 * @memberOf engine.conversion
 */

var Mapper = function () {
	/**
  * Creates an instance of the mapper.
  */
	function Mapper() {
		var _this = this;

		classCallCheck(this, Mapper);

		/**
   * Model element to view element mapping.
   *
   * @private
   * @member {WeakMap} engine.conversion.Mapper#_modelToViewMapping
   */
		this._modelToViewMapping = new WeakMap();

		/**
   * View element to model element mapping.
   *
   * @private
   * @member {WeakMap} engine.conversion.Mapper#_viewToModelMapping
   */
		this._viewToModelMapping = new WeakMap();

		/**
   * A map containing callbacks between view element names and functions evaluating length of view elements
   * in model.
   *
   * @private
   * @member {Map} engine.conversion.Mapper#_viewToModelLengthCallbacks
   */
		this._viewToModelLengthCallbacks = new Map();

		// Add default callback for model to view position mapping.
		this.on('modelToViewPosition', function (evt, data) {
			var viewContainer = _this._modelToViewMapping.get(data.modelPosition.parent);

			data.viewPosition = _this._findPositionIn(viewContainer, data.modelPosition.offset);
		}, { priority: 'lowest' });

		// Add default callback for view to model position mapping.
		this.on('viewToModelPosition', function (evt, data) {
			var viewBlock = data.viewPosition.parent;
			var modelParent = _this._viewToModelMapping.get(viewBlock);

			while (!modelParent) {
				viewBlock = viewBlock.parent;
				modelParent = _this._viewToModelMapping.get(viewBlock);
			}

			var modelOffset = _this._toModelOffset(data.viewPosition.parent, data.viewPosition.offset, viewBlock);

			data.modelPosition = Position.createFromParentAndOffset(modelParent, modelOffset);
		}, { priority: 'lowest' });
	}

	/**
  * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using
  * the {@link engine.conversion.Mapper#toModelElement toModelElement} and
  * {@link engine.conversion.Mapper#toViewElement toViewElement} methods.
  * The information that elements are bound is also used to translate positions.
  *
  * @param {engine.model.Element} modelElement Model element.
  * @param {engine.view.Element} viewElement View element.
  */


	createClass(Mapper, [{
		key: 'bindElements',
		value: function bindElements(modelElement, viewElement) {
			this._modelToViewMapping.set(modelElement, viewElement);
			this._viewToModelMapping.set(viewElement, modelElement);
		}

		/**
   * Unbinds given {@link engine.view.Element view element} from the map.
   *
   * @param {engine.view.Element} viewElement View element to unbind.
   */

	}, {
		key: 'unbindViewElement',
		value: function unbindViewElement(viewElement) {
			var modelElement = this.toModelElement(viewElement);

			this._unbindElements(modelElement, viewElement);
		}

		/**
   * Unbinds given {@link engine.model.Element model element} from the map.
   *
   * @param {engine.model.Element} modelElement Model element to unbind.
   */

	}, {
		key: 'unbindModelElement',
		value: function unbindModelElement(modelElement) {
			var viewElement = this.toViewElement(modelElement);

			this._unbindElements(modelElement, viewElement);
		}

		/**
   * Removes all model to view and view to model bindings.
   */

	}, {
		key: 'clearBindings',
		value: function clearBindings() {
			this._modelToViewMapping = new WeakMap();
			this._viewToModelMapping = new WeakMap();
		}

		/**
   * Gets the corresponding model element.
   *
   * @param {engine.view.Element} viewElement View element.
   * @returns {engine.model.Element|undefined} Corresponding model element or `undefined` if not found.
   */

	}, {
		key: 'toModelElement',
		value: function toModelElement(viewElement) {
			return this._viewToModelMapping.get(viewElement);
		}

		/**
   * Gets the corresponding view element.
   *
   * @param {engine.model.Element} modelElement Model element.
   * @returns {engine.view.Element|undefined} Corresponding view element or `undefined` if not found.
   */

	}, {
		key: 'toViewElement',
		value: function toViewElement(modelElement) {
			return this._modelToViewMapping.get(modelElement);
		}

		/**
   * Gets the corresponding model range.
   *
   * @param {engine.view.Range} viewRange View range.
   * @returns {engine.model.Range} Corresponding model range.
   */

	}, {
		key: 'toModelRange',
		value: function toModelRange(viewRange) {
			return new Range$1(this.toModelPosition(viewRange.start), this.toModelPosition(viewRange.end));
		}

		/**
   * Gets the corresponding view range.
   *
   * @param {engine.model.Range} modelRange Model range.
   * @returns {engine.view.Range} Corresponding view range.
   */

	}, {
		key: 'toViewRange',
		value: function toViewRange(modelRange) {
			return new Range$2(this.toViewPosition(modelRange.start), this.toViewPosition(modelRange.end));
		}

		/**
   * Gets the corresponding model position.
   *
   * @fires engine.conversion.Mapper#event:viewToModelPosition
   * @param {engine.view.Position} viewPosition View position.
   * @returns {engine.model.Position} Corresponding model position.
   */

	}, {
		key: 'toModelPosition',
		value: function toModelPosition(viewPosition) {
			var data = {
				viewPosition: viewPosition,
				modelPosition: null,
				mapper: this
			};

			this.fire('viewToModelPosition', data);

			return data.modelPosition;
		}

		/**
   * Gets the corresponding view position.
   *
   * @fires engine.conversion.Mapper#event:modelToViewPosition
   * @param {engine.model.Position} modelPosition Model position.
   * @returns {engine.view.Position} Corresponding view position.
   */

	}, {
		key: 'toViewPosition',
		value: function toViewPosition(modelPosition) {
			var data = {
				viewPosition: null,
				modelPosition: modelPosition,
				mapper: this
			};

			this.fire('modelToViewPosition', data);

			return data.viewPosition;
		}

		/**
   * Registers a callback that evaluates the length in the model of a view element with given name.
   *
   * The callback is fired with one argument, which is a view element instance. The callback is expected to return
   * a number representing the length of view element in model.
   *
   *		// List item in view may contain nested list, which have other list items. In model though,
   *		// the lists are represented by flat structure. Because of those differences, length of list view element
   *		// may be greater than one. In the callback it's checked how many nested list items are in evaluated list item.
   *
   *		function getViewListItemLength( element ) {
   *			let length = 1;
   *
   *			for ( let child of element.getChildren() ) {
   *				if ( child.name == 'ul' || child.name == 'ol' ) {
   *					for ( let item of child.getChildren() ) {
   *						length += getViewListItemLength( item );
   *					}
   *				}
   *			}
   *
   *			return length;
   *		}
   *
   *		mapper.registerViewToModelLength( 'li', getViewListItemLength );
   *
   * @param {String} viewElementName Name of view element for which callback is registered.
   * @param {Function} lengthCallback Function return a length of view element instance in model.
   */

	}, {
		key: 'registerViewToModelLength',
		value: function registerViewToModelLength(viewElementName, lengthCallback) {
			this._viewToModelLengthCallbacks.set(viewElementName, lengthCallback);
		}

		/**
   * Calculates model offset based on the view position and the block element.
   *
   * Example:
   *
   *		<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5
   *
   * Is a sum of:
   *
   *		<p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3
   *		<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2
   *
   * @private
   * @param {engine.view.Element} viewParent Position parent.
   * @param {Number} viewOffset Position offset.
   * @param {engine.view.Element} viewBlock Block used as a base to calculate offset.
   * @returns {Number} Offset in the model.
   */

	}, {
		key: '_toModelOffset',
		value: function _toModelOffset(viewParent, viewOffset, viewBlock) {
			if (viewBlock != viewParent) {
				// See example.
				var offsetToParentStart = this._toModelOffset(viewParent.parent, viewParent.index, viewBlock);
				var offsetInParent = this._toModelOffset(viewParent, viewOffset, viewParent);

				return offsetToParentStart + offsetInParent;
			}

			// viewBlock == viewParent, so we need to calculate the offset in the parent element.

			// If the position is a text it is simple ("ba|r" -> 2).
			if (viewParent instanceof Text$2) {
				return viewOffset;
			}

			// If the position is in an element we need to sum lengths of siblings ( <b> bar </b> foo | -> 3 + 3 = 6 ).
			var modelOffset = 0;

			for (var i = 0; i < viewOffset; i++) {
				modelOffset += this.getModelLength(viewParent.getChild(i));
			}

			return modelOffset;
		}

		/**
   * Removes binding between given elements.
   *
   * @private
   * @param {engine.model.Element} modelElement Model element to unbind.
   * @param {engine.view.Element} viewElement View element to unbind.
   */

	}, {
		key: '_unbindElements',
		value: function _unbindElements(modelElement, viewElement) {
			this._viewToModelMapping.delete(viewElement);
			this._modelToViewMapping.delete(modelElement);
		}

		/**
   * Gets the length of the view element in the model.
   *
   * The length is calculated as follows:
   * * length of a {@link engine.view.Text text node} is equal to the length of it's {@link engine.view.Text#data data},
   * * length of a mapped {@link engine.view.Element element} is equal to 1 or to the value evaluated by the callback
   * added through {@link engine.conversion.Mapper#registerViewToModelLength},
   * * length of a not-mapped {@link engine.view.Element element} is equal to the length of it's children.
   *
   * Examples:
   *
   *		foo                     -> 3 // Text length is equal to it's data length.
   *		<p>foo</p>              -> 1 // Length of an element which is mapped is by default equal to 1.
   *		<b>foo</b>              -> 3 // Length of an element which is not mapped is a length of its children.
   *		<div><p>x</p><p>y</p>   -> 2 // Assuming that <div> is not mapped and <p> are mapped.
   *
   * @param {engine.view.Element} viewNode View node.
   * @returns {Number} Length of the node in the tree model.
   */

	}, {
		key: 'getModelLength',
		value: function getModelLength(viewNode) {
			if (this._viewToModelMapping.has(viewNode)) {
				var callback = this._viewToModelLengthCallbacks.get(viewNode.name);

				return callback ? callback(viewNode) : 1;
			} else if (viewNode instanceof Text$2) {
				return viewNode.data.length;
			} else {
				var len = 0;

				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = viewNode.getChildren()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var child = _step.value;

						len += this.getModelLength(child);
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}

				return len;
			}
		}

		/**
   * Finds the position in the view node (or its children) with the expected model offset.
   *
   * Example:
   *
   *		<p>fo<b>bar</b>bom</p> -> expected offset: 4
   *
   *		_findPositionIn( p, 4 ):
   *		<p>|fo<b>bar</b>bom</p> -> expected offset: 4, actual offset: 0
   *		<p>fo|<b>bar</b>bom</p> -> expected offset: 4, actual offset: 2
   *		<p>fo<b>bar</b>|bom</p> -> expected offset: 4, actual offset: 5 -> we are too far
   *
   *		_findPositionIn( b, 4 - ( 5 - 3 ) ):
   *		<p>fo<b>|bar</b>bom</p> -> expected offset: 2, actual offset: 0
   *		<p>fo<b>bar|</b>bom</p> -> expected offset: 2, actual offset: 3 -> we are too far
   *
   *		_findPositionIn( bar, 2 - ( 3 - 3 ) ):
   *		We are in the text node so we can simple find the offset.
   *		<p>fo<b>ba|r</b>bom</p> -> expected offset: 2, actual offset: 2 -> position found
   *
   * @private
   * @param {engine.view.Element} viewParent Tree view element in which we are looking for the position.
   * @param {Number} expectedOffset Expected offset.
   * @returns {engine.view.Position} Found position.
   */

	}, {
		key: '_findPositionIn',
		value: function _findPositionIn(viewParent, expectedOffset) {
			// Last scanned view node.
			var viewNode = void 0;
			// Length of the last scanned view node.
			var lastLength = 0;

			var modelOffset = 0;
			var viewOffset = 0;

			// In the text node it is simple: offset in the model equals offset in the text.
			if (viewParent instanceof Text$2) {
				return new Position$1(viewParent, expectedOffset);
			}

			// In other cases we add lengths of child nodes to find the proper offset.

			// If it is smaller we add the length.
			while (modelOffset < expectedOffset) {
				viewNode = viewParent.getChild(viewOffset);
				lastLength = this.getModelLength(viewNode);
				modelOffset += lastLength;
				viewOffset++;
			}

			// If it equals we found the position.
			if (modelOffset == expectedOffset) {
				return this._moveViewPositionToTextNode(new Position$1(viewParent, viewOffset));
			}
			// If it is higher we need to enter last child.
			else {
					// ( modelOffset - lastLength ) is the offset to the child we enter,
					// so we subtract it from the expected offset to fine the offset in the child.
					return this._findPositionIn(viewNode, expectedOffset - (modelOffset - lastLength));
				}
		}

		/**
   * Because we prefer positions in text nodes over positions next to text node moves view position to the text node
   * if it was next to it.
   *
   *		<p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text
   *		<p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node
   *		<p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node
   *
   * @private
   * @param {engine.view.Position} viewPosition Position potentially next to text node.
   * @returns {engine.view.Position} Position in text node if possible.
   */

	}, {
		key: '_moveViewPositionToTextNode',
		value: function _moveViewPositionToTextNode(viewPosition) {
			// If the position is just after text node, put it at the end of that text node.
			// If the position is just before text node, put it at the beginning of that text node.
			var nodeBefore = viewPosition.nodeBefore;
			var nodeAfter = viewPosition.nodeAfter;

			if (nodeBefore instanceof Text$2) {
				return new Position$1(nodeBefore, nodeBefore.data.length);
			} else if (nodeAfter instanceof Text$2) {
				return new Position$1(nodeAfter, 0);
			}

			// Otherwise, just return the given position.
			return viewPosition;
		}
	}]);
	return Mapper;
}();

mix(Mapper, EmitterMixin);

/**
 * Fired for each model-to-view position mapping request. The purpose of this event is to enable custom model-to-view position
 * mapping. Callbacks added to this event take {@link engine.model.Position model position} and are expected to calculate
 * {@link engine.view.Position view position}. Calculated view position should be added as `viewPosition` value in
 * `data` object that is passed as one of parameters to the event callback.
 *
 * 		// Assume that "captionedImage" model element is converted to <img> and following <span> elements in view,
 * 		// and the model element is bound to <img> element. Force mapping model positions inside "captionedImage" to that <span> element.
 *		mapper.on( 'modelToViewPosition', ( evt, data ) => {
 *			const positionParent = modelPosition.parent;
 *
 *			if ( positionParent.name == 'captionedImage' ) {
 *				const viewImg = mapper.toViewElement( positionParent );
 *				const viewCaption = viewImg.nextSibling; // The <span> element.
 *
 *				data.viewPosition = new ViewPosition( viewCaption, modelPosition.offset );
 *				evt.stop();
 *			}
 *		} );
 *
 * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position
 * mapping between given model and view elements is unsolvable using just elements mapping and default algorithm. Also,
 * the condition that checks if special case scenario happened should be as simple as possible.
 *
 * @event engine.conversion.Mapper.modelToViewPosition
 * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add
 * `viewPosition` value to that object with calculated {@link engine.view.Position view position}.
 * @param {engine.model.Position} data.modelPosition Model position to be mapped.
 * @param {engine.conversion.Mapper} data.mapper Mapper instance that fired the event.
 */

/**
 * Fired for each view-to-model position mapping request. See {@link engine.conversion.Mapper#event:modelToViewPosition}.
 *
 * 		// See example in `modelToViewPosition` event description.
 * 		// This custom mapping will map positions from <span> element next to <img> to the "captionedImage" element.
 *		mapper.on( 'viewToModelPosition', ( evt, data ) => {
 *			const positionParent = viewPosition.parent;
 *
 *			if ( positionParent.hasClass( 'image-caption' ) ) {
 *				const viewImg = positionParent.previousSibling;
 *				const modelImg = mapper.toModelElement( viewImg );
 *
 *				data.modelPosition = new ModelPosition( modelImg, viewPosition.offset );
 *				evt.stop();
 *			}
 *		} );
 *
 * @event engine.conversion.Mapper.viewToModelPosition
 * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add
 * `modelPosition` value to that object with calculated {@link engine.model.Position model position}.
 * @param {engine.view.Position} data.viewPosition View position to be mapped.
 * @param {engine.conversion.Mapper} data.mapper Mapper instance that fired the event.
 */

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Manages a list of consumable values for {@link engine.model.Item model items}.
 *
 * Consumables are various aspects of the model. A model item can be broken down into singular properties that might be
 * taken into consideration when converting that item.
 *
 * `ModelConsumable` is used by {@link engine.conversion.ModelConversionDispatcher} while analyzing changed
 * parts of {@link engine.model.Document the document}. The added / changed / removed model items are broken down
 * into singular properties (the item itself and it's attributes). All those parts are saved in `ModelConsumable`. Then,
 * during conversion, when given part of model item is converted (i.e. the view element has been inserted into the view,
 * but without attributes), consumable value is removed from `ModelConsumable`.
 *
 * For model items, `ModelConsumable` stores consumable values of one of following types: `insert`, `addAttribute:<attributeKey>`,
 * `changeAttribute:<attributeKey>`, `removeAttribute:<attributeKey>`.
 *
 * In most cases, it is enough to let {@link engine.conversion.ModelConversionDispatcher} gather consumable values, so
 * there is no need to use {@link engine.conversion.ModelConsumable#add add method} directly. However, it is important to
 * understand how consumable values can be {@link engine.conversion.ModelConsumable#consume consumed}. See
 * {@link engine.conversion.modelToView default model to view converters} for more information.
 *
 * Keep in mind, that one conversion event may have multiple callbacks (converters) attached to it. Each of those is
 * able to convert one or more parts of the model. However, when one of those callbacks actually converts
 * something, other should not, because they would duplicate the results. Using `ModelConsumable` helps avoiding
 * this situation, because callbacks should only convert those values, which were not yet consumed from `ModelConsumable`.
 *
 * Consuming multiple values in a single callback:
 *
 *		// Converter for custom `image` element that might have a `caption` element inside which changes
 *		// how the image is displayed in the view:
 *		//
 *		// Model:
 *		//
 *		// [image]
 *		//   └─ [caption]
 *		//       └─ foo
 *		//
 *		// View:
 *		//
 *		// <figure>
 *		//   ├─ <img />
 *		//   └─ <caption>
 *		//       └─ foo
 *		modelConversionDispatcher.on( 'insert:image', ( evt, data, consumable, conversionApi ) => {
 *			// First, consume the `image` element.
 *			consumable.consume( data.item, 'insert' );
 *
 *			// Just create normal image element for the view.
 *			// Maybe it will be "decorated" later.
 *			const viewImage = new ViewElement( 'img' );
 *			const insertPosition = conversionApi.mapper.toViewPosition( data.range.start );
 *
 *			// Check if the `image` element has children.
 *			if ( data.item.childCount > 0 ) {
 *				const modelCaption = data.item.getChild( 0 );
 *
 *				// `modelCaption` insertion change is consumed from consumable values.
 *				// It will not be converted by other converters, but it's children (probably some text) will be.
 *				// Through mapping, converters for text will know where to insert contents of `modelCaption`.
 *				if ( consumable.consume( modelCaption, 'insert' ) ) {
 *					const viewCaption = new ViewElement( 'figcaption' );
 *
 *					const viewImageHolder = new ViewElement( 'figure', null, [ viewImage, viewCaption ] );
 *
 *					conversionApi.mapper.bindElements( modelCaption, viewCaption );
 *					conversionApi.mapper.bindElements( data.item, viewImageHolder );
 *					viewWriter.insert( insertPosition, viewImageHolder );
 *				}
 *			} else {
 *				conversionApi.mapper.bindElements( data.item, viewImage );
 *				viewWriter.insert( insertPosition, viewImage );
 *			}
 *
 *			evt.stop();
 *		} );
 *
 * @memberOf engine.conversion
 */

var ModelConsumable = function () {
	/**
  * Creates an empty consumables list.
  */
	function ModelConsumable() {
		classCallCheck(this, ModelConsumable);

		/**
   * Contains list of consumable values.
   *
   * @private
   * @member {Map} engine.conversion.ModelConsumable#_consumable
   */
		this._consumable = new Map();

		/**
   * For each {@link engine.model.TextProxy} added to `ModelConsumable`, this registry holds parent
   * of that `TextProxy` and start and end indices of that `TextProxy`. This allows identification of `TextProxy`
   * instances that points to the same part of the model but are different instances. Each distinct `TextProxy`
   * is given unique `Symbol` which is then registered as consumable. This process is transparent for `ModelConsumable`
   * API user because whenever `TextProxy` is added, tested, consumed or reverted, internal mechanisms of
   * `ModelConsumable` translates `TextProxy` to that unique `Symbol`.
   *
   * @private
   * @member {Map} engine.conversion.ModelConsumable#_textProxyRegistry
   */
		this._textProxyRegistry = new Map();
	}

	/**
  * Adds a consumable value to the consumables list and links it with given model item.
  *
  *		modelConsumable.add( modelElement, 'insert' ); // Add `modelElement` insertion change to consumable values.
  *		modelConsumable.add( modelElement, 'addAttribute:bold' ); // Add `bold` attribute insertion on `modelElement` change.
  *		modelConsumable.add( modelElement, 'removeAttribute:bold' ); // Add `bold` attribute removal on `modelElement` change.
  *		modelConsumable.add( modelSelection, 'selection' ); // Add `modelSelection` to consumable values.
  *		modelConsumable.add( modelSelection, 'selectionAttribute:bold' ); // Add `bold` attribute on `modelSelection` to consumables.
  *
  * @param {engine.model.Item|engine.model.Selection} item Model item or selection that has the consumable.
  * @param {String} type Consumable type.
  */


	createClass(ModelConsumable, [{
		key: 'add',
		value: function add(item, type) {
			if (item instanceof TextProxy) {
				item = this._getSymbolForTextProxy(item);
			}

			if (!this._consumable.has(item)) {
				this._consumable.set(item, new Map());
			}

			this._consumable.get(item).set(type, true);
		}

		/**
   * Removes given consumable value from given model item.
   *
   *		modelConsumable.consume( modelElement, 'insert' ); // Remove `modelElement` insertion change from consumable values.
   *		modelConsumable.consume( modelElement, 'addAttribute:bold' ); // Remove `bold` attribute insertion on `modelElement` change.
   *		modelConsumable.consume( modelElement, 'removeAttribute:bold' ); // Remove `bold` attribute removal on `modelElement` change.
   *		modelConsumable.consume( modelSelection, 'selection' ); // Remove `modelSelection` from consumable values.
   *		modelConsumable.consume( modelSelection, 'selectionAttribute:bold' ); // Remove `bold` on `modelSelection` from consumables.
   *
   * @param {engine.model.Item|engine.model.Selection} item Model item or selection from which consumable will be consumed.
   * @param {String} type Consumable type.
   * @returns {Boolean} `true` if consumable value was available and was consumed, `false` otherwise.
   */

	}, {
		key: 'consume',
		value: function consume(item, type) {
			if (item instanceof TextProxy) {
				item = this._getSymbolForTextProxy(item);
			}

			if (this.test(item, type)) {
				this._consumable.get(item).set(type, false);

				return true;
			} else {
				return false;
			}
		}

		/**
   * Tests whether there is a consumable value of given type connected with given model item.
   *
   *		modelConsumable.test( modelElement, 'insert' ); // Check for `modelElement` insertion change.
   *		modelConsumable.test( modelElement, 'addAttribute:bold' ); // Check for `bold` attribute insertion on `modelElement` change.
   *		modelConsumable.test( modelElement, 'removeAttribute:bold' ); // Check for `bold` attribute removal on `modelElement` change.
   *		modelConsumable.test( modelSelection, 'selection' ); // Check if `modelSelection` is consumable.
   *		modelConsumable.test( modelSelection, 'selectionAttribute:bold' ); // Check if `bold` on `modelSelection` is consumable.
   *
   * @param {engine.model.Item|engine.model.Selection} item Model item or selection that will be tested.
   * @param {String} type Consumable type.
   * @returns {null|Boolean} `null` if such consumable was never added, `false` if the consumable values was
   * already consumed or `true` if it was added and not consumed yet.
   */

	}, {
		key: 'test',
		value: function test(item, type) {
			if (item instanceof TextProxy) {
				item = this._getSymbolForTextProxy(item);
			}

			var itemConsumables = this._consumable.get(item);

			if (itemConsumables === undefined) {
				return null;
			}

			var value = itemConsumables.get(type);

			if (value === undefined) {
				return null;
			}

			return value;
		}

		/**
   * Reverts consuming of consumable value.
   *
   *		modelConsumable.revert( modelElement, 'insert' ); // Revert consuming `modelElement` insertion change.
   *		modelConsumable.revert( modelElement, 'addAttribute:bold' ); // Revert consuming `bold` attribute insert from `modelElement`.
   *		modelConsumable.revert( modelElement, 'removeAttribute:bold' ); // Revert consuming `bold` attribute remove from `modelElement`.
   *		modelConsumable.revert( modelSelection, 'selection' ); // Revert consuming `modelSelection`.
   *		modelConsumable.revert( modelSelection, 'selectionAttribute:bold' ); // Revert consuming `bold` from `modelSelection`.
   *
   * @param {engine.model.Item|engine.model.Selection} item Model item or selection that will be reverted.
   * @param {String} type Consumable type.
   * @returns {null|Boolean} `true` if consumable has been reversed, `false` otherwise. `null` if the consumable has
   * never been added.
   */

	}, {
		key: 'revert',
		value: function revert(item, type) {
			if (item instanceof TextProxy) {
				item = this._getSymbolForTextProxy(item);
			}

			var test = this.test(item, type);

			if (test === false) {
				this._consumable.get(item).set(type, true);

				return true;
			} else if (test === true) {
				return false;
			}

			return null;
		}

		/**
   * Gets a unique symbol for passed {@link engine.model.TextProxy} instance. All `TextProxy` instances that
   * have same parent, same start index and same end index will get the same symbol.
   *
   * Used internally to correctly consume `TextProxy` instances.
   *
   * @private
   * @param {engine.model.TextProxy} textProxy `TextProxy` instance to get a symbol for.
   * @returns {Symbol} Symbol representing all equal instances of `TextProxy`.
   */

	}, {
		key: '_getSymbolForTextProxy',
		value: function _getSymbolForTextProxy(textProxy) {
			var symbol = null;

			var startMap = this._textProxyRegistry.get(textProxy.startOffset);

			if (startMap) {
				var endMap = startMap.get(textProxy.endOffset);

				if (endMap) {
					symbol = endMap.get(textProxy.parent);
				}
			}

			if (!symbol) {
				symbol = this._addSymbolForTextProxy(textProxy.startOffset, textProxy.endOffset, textProxy.parent);
			}

			return symbol;
		}

		/**
   * Adds a symbol for given properties that characterizes a {@link engine.model.TextProxy} instance.
   *
   * Used internally to correctly consume `TextProxy` instances.
   *
   * @private
   * @param {Number} startIndex Text proxy start index in it's parent.
   * @param {Number} endIndex Text proxy end index in it's parent.
   * @param {engine.model.Element} parent Text proxy parent.
   * @returns {Symbol} Symbol generated for given properties.
   */

	}, {
		key: '_addSymbolForTextProxy',
		value: function _addSymbolForTextProxy(start, end, parent) {
			var symbol = Symbol();
			var startMap = void 0,
			    endMap = void 0;

			startMap = this._textProxyRegistry.get(start);

			if (!startMap) {
				startMap = new Map();
				this._textProxyRegistry.set(start, startMap);
			}

			endMap = startMap.get(end);

			if (!endMap) {
				endMap = new Map();
				startMap.set(end, endMap);
			}

			endMap.set(parent, symbol);

			return symbol;
		}
	}]);
	return ModelConsumable;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * `ModelConversionDispatcher` is a central point of {@link engine.model model} conversion, which is
 * a process of reacting to changes in the model and reflecting them by listeners that listen to those changes.
 * In default application, {@link engine.model model} is converted to {@link engine.view view}. This means
 * that changes in the model are reflected by changing the view (i.e. adding view nodes or changing attributes on view elements).
 *
 * During conversion process, `ModelConversionDispatcher` fires data-manipulation events, basing on state of the model and prepares
 * data for those events. It is important to note that the events are connected with "change actions" like "inserting"
 * or "removing" so one might say that we are converting "changes". This is in contrary to view to model conversion,
 * where we convert view nodes (the structure, not "changes" to the view). Note, that because changes are converted
 * and not the structure itself, there is a need to have a mapping between model and the structure on which changes are
 * reflected. To map elements during model to view conversion use {@link engine.conversion.Mapper}.
 *
 * The main use for this class is to listen to {@link engine.model.Document.change Document change event}, process it
 * and then fire specific events telling what exactly has changed. For those events, `ModelConversionDispatcher`
 * creates {@link engine.conversion.ModelConsumable list of consumable values} that should be handled by event
 * callbacks. Those events are listened to by model-to-view converters which convert changes done in the
 * {@link engine.model model} to changes in the {@link engine.view view}. `ModelConversionController` also checks
 * the current state of consumables, so it won't fire events for parts of model that were already consumed. This is
 * especially important in callbacks that consume multiple values. See {@link engine.conversion.ModelConsumable}
 * for an example of such callback.
 *
 * Although the primary usage for this class is the model-to-view conversion, `ModelConversionDispatcher` can be used
 * to build custom data processing pipelines that converts model to anything that is needed. Existing model structure can
 * be used to generate events (listening to {@link engine.model.Document.change Document change event} is not required)
 * and custom callbacks can be added to the events (these does not have to be limited to changes in the view).
 *
 * When providing your own event listeners for `ModelConversionDispatcher` keep in mind that any callback that had
 * {@link engine.conversion.ModelConsumable#consume consumed} a value from consumable (and did some changes, i.e. to
 * the view) should also stop the event. This is because whenever a callback is fired it is assumed that there is something
 * to be consumed. Thanks to that approach, you do not have to test whether there is anything to consume at the beginning
 * of your listener callback.
 *
 * Example of providing a converter for `ModelConversionDispatcher`:
 *
 *		// We will convert inserting "paragraph" model element into the model.
 *		modelDispatcher.on( 'insert:paragraph', ( evt, data, consumable, conversionApi ) => {
 *			// Remember to consume the part of consumable.
 *			consumable.consume( data.item, 'insert' );
 *
 *			// Translate position in model to position in the view.
 *			const viewPosition = conversionApi.mapper.toViewPosition( data.range.start );
 *
 *			// Create a P element (note that this converter is for inserting P elements -> 'insert:paragraph').
 *			const viewElement = new ViewElement( 'p' );
 *
 *			// Bind the newly created view element to model element so positions will map accordingly in future.
 *			conversionApi.mapper.bindElements( data.item, viewElement );
 *
 *			// Add the newly created view element to the view.
 *			viewWriter.insert( viewPosition, viewElement );
 *
 *			// Remember to stop the event propagation if the data.item was consumed.
 *			evt.stop();
 *		} );
 *
 * Callback that "overrides" other callback:
 *
 *		// Special converter for `linkHref` attribute added on custom `quote` element. Note, that this
 *		// attribute may be the same as the attribute added by other features (link feature in this case).
 *		// It might be even added by that feature! It makes sense that a part of content that is a quote is linked
 *		// to an external source so it makes sense that link feature works on the custom quote element.
 *		// However, we have to make sure that the attributes added by link feature are correctly converted.
 *		// To block default `linkHref` conversion we have to:
 *		// 1) add this callback with higher priority than link feature callback,
 *		// 2) consume `linkHref` attribute add change.
 *		modelConversionDispatcher.on( 'addAttribute:linkHref:quote', ( evt, data, consumable, conversionApi ) => {
 *			consumable.consume( data.item, 'addAttribute:linkHref' );
 *
 *			// Create a button that will represent the `linkHref` attribute.
 *			let viewSourceBtn = new ViewElement( 'a', {
 *				href: data.item.getAttribute( 'linkHref' ),
 *				title: 'source'
 *			} );
 *
 *			// Add a class for the button.
 *			viewSourceBtn.addClass( 'source' );
 *
 *			// Insert the button using writer API.
 *			// If `addAttribute` event is fired by `engine.conversion.ModelConversionDispatcher#convertInsert` it is fired
 *			// after `data.item` insert conversion was done. If the event is fired due to attribute insertion coming from
 *			// different source, `data.item` already existed. This means we are safe to get `viewQuote` from mapper.
 *			const viewQuote = conversionApi.mapper.toViewElement( data.item );
 *			const position = new ViewPosition( viewQuote, viewQuote.childCount );
 *			viewWriter.insert( position, viewSourceBtn );
 *
 *			evt.stop();
 *		}, { priority: 'high' } );
 *
 * @memberOf engine.conversion
 */

var ModelConversionDispatcher = function () {
	/**
  * Creates a `ModelConversionDispatcher` that operates using passed API.
  *
  * @param {Object} [conversionApi] Interface passed by dispatcher to the events callbacks.
  */
	function ModelConversionDispatcher() {
		var conversionApi = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
		classCallCheck(this, ModelConversionDispatcher);

		/**
   * Interface passed by dispatcher to the events callbacks.
   *
   * @member {Object} engine.conversion.ModelConversionDispatcher#conversionApi
   */
		this.conversionApi = assignIn({ dispatcher: this }, conversionApi);
	}

	/**
  * Prepares data and fires a proper event.
  *
  * The method is crafted to take use of parameters passed in {@link engine.model.Document.change Document change event}.
  *
  * @see engine.model.Document.change
  * @fires engine.conversion.ModelConversionDispatcher#insert
  * @fires engine.conversion.ModelConversionDispatcher#move
  * @fires engine.conversion.ModelConversionDispatcher#remove
  * @fires engine.conversion.ModelConversionDispatcher#rename
  * @fires engine.conversion.ModelConversionDispatcher#addAttribute
  * @fires engine.conversion.ModelConversionDispatcher#removeAttribute
  * @fires engine.conversion.ModelConversionDispatcher#changeAttribute
  * @param {String} type Change type.
  * @param {Object} data Additional information about the change.
  */


	createClass(ModelConversionDispatcher, [{
		key: 'convertChange',
		value: function convertChange(type, data) {
			// Do not convert changes if they happen in graveyard.
			// Graveyard is a special root that has no view / no other representation and changes done in it should not be converted.
			if (type !== 'remove' && data.range && data.range.root.rootName == '$graveyard') {
				return;
			}

			if (type == 'insert' || type == 'reinsert') {
				this.convertInsertion(data.range);
			} else if (type == 'move') {
				this.convertMove(data.sourcePosition, data.range);
			} else if (type == 'remove') {
				this.convertRemove(data.sourcePosition, data.range);
			} else if (type == 'addAttribute' || type == 'removeAttribute' || type == 'changeAttribute') {
				this.convertAttribute(type, data.range, data.key, data.oldValue, data.newValue);
			} else if (type == 'rename') {
				this.convertRename(data.element, data.oldName);
			}
		}

		/**
   * Analyzes given range and fires insertion-connected events with data based on that range.
   *
   * **Note**: This method will fire separate events for node insertion and attributes insertion. All
   * attributes that are set on inserted nodes are treated like they were added just after node insertion.
   *
   * @fires engine.conversion.ModelConversionDispatcher#insert
   * @fires engine.conversion.ModelConversionDispatcher#addAttribute
   * @param {engine.model.Range} range Inserted range.
   */

	}, {
		key: 'convertInsertion',
		value: function convertInsertion(range) {
			// Create a list of things that can be consumed, consisting of nodes and their attributes.
			var consumable = this._createInsertConsumable(range);

			// Fire a separate insert event for each node and text fragment contained in the range.
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = range[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var value = _step.value;

					var item = value.item;
					var itemRange = Range$1.createFromPositionAndShift(value.previousPosition, value.length);
					var data = {
						item: item,
						range: itemRange
					};

					this._testAndFire('insert', data, consumable);

					// Fire a separate addAttribute event for each attribute that was set on inserted items.
					// This is important because most attributes converters will listen only to add/change/removeAttribute events.
					// If we would not add this part, attributes on inserted nodes would not be converted.
					var _iteratorNormalCompletion2 = true;
					var _didIteratorError2 = false;
					var _iteratorError2 = undefined;

					try {
						for (var _iterator2 = item.getAttributeKeys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
							var key = _step2.value;

							data.attributeKey = key;
							data.attributeOldValue = null;
							data.attributeNewValue = item.getAttribute(key);

							this._testAndFire('addAttribute:' + key, data, consumable);
						}
					} catch (err) {
						_didIteratorError2 = true;
						_iteratorError2 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion2 && _iterator2.return) {
								_iterator2.return();
							}
						} finally {
							if (_didIteratorError2) {
								throw _iteratorError2;
							}
						}
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		}

		/**
   * Fires move event with data based on passed values.
   *
   * @fires engine.conversion.ModelConversionDispatcher#move
   * @param {engine.model.Position} sourcePosition Position from where the range has been moved.
   * @param {engine.model.Range} range Moved range (after move).
   */

	}, {
		key: 'convertMove',
		value: function convertMove(sourcePosition, range) {
			// Keep in mind that move dispatcher expects flat range.
			var consumable = this._createConsumableForRange(range, 'move');

			var items = Array.from(range.getItems({ shallow: true }));
			var rangeSize = range.end.offset - range.start.offset;
			var inSameParent = sourcePosition.parent == range.start.parent;

			var offset = 0;

			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = items[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var item = _step3.value;

					var data = {
						sourcePosition: sourcePosition,
						targetPosition: inSameParent ? range.start.getShiftedBy(rangeSize) : range.start.getShiftedBy(offset),
						item: item
					};

					offset += data.item.offsetSize;

					this._testAndFire('move', data, consumable);
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}
		}

		/**
   * Fires remove event with data based on passed values.
   *
   * @fires engine.conversion.ModelConversionDispatcher#remove
   * @param {engine.model.Position} sourcePosition Position from where the range has been removed.
   * @param {engine.model.Range} range Removed range (after remove, in {@link engine.model.Document#graveyard graveyard root}).
   */

	}, {
		key: 'convertRemove',
		value: function convertRemove(sourcePosition, range) {
			var consumable = this._createConsumableForRange(range, 'remove');

			var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
				for (var _iterator4 = range.getItems({ shallow: true })[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var item = _step4.value;

					var data = {
						sourcePosition: sourcePosition,
						item: item
					};

					this._testAndFire('remove', data, consumable);
				}
			} catch (err) {
				_didIteratorError4 = true;
				_iteratorError4 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion4 && _iterator4.return) {
						_iterator4.return();
					}
				} finally {
					if (_didIteratorError4) {
						throw _iteratorError4;
					}
				}
			}
		}

		/**
   * Analyzes given attribute change and fires attributes-connected events with data based on passed values.
   *
   * @fires engine.conversion.ModelConversionDispatcher#addAttribute
   * @fires engine.conversion.ModelConversionDispatcher#removeAttribute
   * @fires engine.conversion.ModelConversionDispatcher#changeAttribute
   * @param {String} type Change type. Possible values: `addAttribute`, `removeAttribute`, `changeAttribute`.
   * @param {engine.model.Range} range Changed range.
   * @param {String} key Attribute key.
   * @param {*} oldValue Attribute value before the change or `null` if attribute has not been set.
   * @param {*} newValue New attribute value or `null` if attribute has been removed.
   */

	}, {
		key: 'convertAttribute',
		value: function convertAttribute(type, range, key, oldValue, newValue) {
			// Create a list with attributes to consume.
			var consumable = this._createConsumableForRange(range, type + ':' + key);

			// Create a separate attribute event for each node in the range.
			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = range[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var value = _step5.value;

					var item = value.item;
					var itemRange = Range$1.createFromPositionAndShift(value.previousPosition, value.length);
					var data = {
						item: item,
						range: itemRange,
						attributeKey: key,
						attributeOldValue: oldValue,
						attributeNewValue: newValue
					};

					this._testAndFire(type + ':' + key, data, consumable, this.conversionApi);
				}
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5.return) {
						_iterator5.return();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}
		}

		/**
   * Fires rename event with data based on passed values.
   *
   * @fires engine.conversion.ModelConversionDispatcher#event:rename
   * @param {engine.view.Element} element Renamed element.
   * @param {String} oldName Name of the renamed element before it was renamed.
   */

	}, {
		key: 'convertRename',
		value: function convertRename(element, oldName) {
			var consumable = new ModelConsumable();
			consumable.add(element, 'rename');

			var data = { element: element, oldName: oldName };
			this.fire('rename:' + element.name + ':' + oldName, data, consumable, this.conversionApi);
		}

		/**
   * Fires events for given {@link engine.model.Selection selection} to start selection conversion.
   *
   * @fires engine.conversion.ModelConversionDispatcher#selection
   * @fires engine.conversion.ModelConversionDispatcher#selectionAttribute
   * @param {engine.model.Selection} selection Selection to convert.
   */

	}, {
		key: 'convertSelection',
		value: function convertSelection(selection) {
			var consumable = this._createSelectionConsumable(selection);
			var data = {
				selection: selection
			};

			this.fire('selection', data, consumable, this.conversionApi);

			var _iteratorNormalCompletion6 = true;
			var _didIteratorError6 = false;
			var _iteratorError6 = undefined;

			try {
				for (var _iterator6 = selection.getAttributeKeys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
					var key = _step6.value;

					data.key = key;
					data.value = selection.getAttribute(key);

					// Do not fire event if the attribute has been consumed.
					if (consumable.test(selection, 'selectionAttribute:' + data.key)) {
						this.fire('selectionAttribute:' + data.key, data, consumable, this.conversionApi);
					}
				}
			} catch (err) {
				_didIteratorError6 = true;
				_iteratorError6 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion6 && _iterator6.return) {
						_iterator6.return();
					}
				} finally {
					if (_didIteratorError6) {
						throw _iteratorError6;
					}
				}
			}
		}

		/**
   * Creates {@link engine.conversion.ModelConsumable} with values to consume from given range, assuming that
   * given range has just been inserted to the model.
   *
   * @private
   * @param {engine.model.Range} range Inserted range.
   * @returns {engine.conversion.ModelConsumable} Values to consume.
   */

	}, {
		key: '_createInsertConsumable',
		value: function _createInsertConsumable(range) {
			var consumable = new ModelConsumable();

			var _iteratorNormalCompletion7 = true;
			var _didIteratorError7 = false;
			var _iteratorError7 = undefined;

			try {
				for (var _iterator7 = range[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
					var value = _step7.value;

					var item = value.item;

					consumable.add(item, 'insert');

					var _iteratorNormalCompletion8 = true;
					var _didIteratorError8 = false;
					var _iteratorError8 = undefined;

					try {
						for (var _iterator8 = item.getAttributeKeys()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
							var key = _step8.value;

							consumable.add(item, 'addAttribute:' + key);
						}
					} catch (err) {
						_didIteratorError8 = true;
						_iteratorError8 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion8 && _iterator8.return) {
								_iterator8.return();
							}
						} finally {
							if (_didIteratorError8) {
								throw _iteratorError8;
							}
						}
					}
				}
			} catch (err) {
				_didIteratorError7 = true;
				_iteratorError7 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion7 && _iterator7.return) {
						_iterator7.return();
					}
				} finally {
					if (_didIteratorError7) {
						throw _iteratorError7;
					}
				}
			}

			return consumable;
		}

		/**
   * Creates {@link engine.conversion.ModelConsumable} with values of given `type` for each item from given `range`.
   *
   * @private
   * @param {engine.conversion.Range} range Affected range.
   * @param {String} type Consumable type.
   * @returns {engine.conversion.ModelConsumable} Values to consume.
   */

	}, {
		key: '_createConsumableForRange',
		value: function _createConsumableForRange(range, type) {
			var consumable = new ModelConsumable();

			var _iteratorNormalCompletion9 = true;
			var _didIteratorError9 = false;
			var _iteratorError9 = undefined;

			try {
				for (var _iterator9 = range.getItems()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
					var item = _step9.value;

					consumable.add(item, type);
				}
			} catch (err) {
				_didIteratorError9 = true;
				_iteratorError9 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion9 && _iterator9.return) {
						_iterator9.return();
					}
				} finally {
					if (_didIteratorError9) {
						throw _iteratorError9;
					}
				}
			}

			return consumable;
		}

		/**
   * Creates {@link engine.conversion.ModelConsumable} with selection consumable values.
   *
   * @private
   * @param {engine.model.Selection} selection Selection to create consumable from.
   * @returns {engine.conversion.ModelConsumable} Values to consume.
   */

	}, {
		key: '_createSelectionConsumable',
		value: function _createSelectionConsumable(selection) {
			var consumable = new ModelConsumable();

			consumable.add(selection, 'selection');

			var _iteratorNormalCompletion10 = true;
			var _didIteratorError10 = false;
			var _iteratorError10 = undefined;

			try {
				for (var _iterator10 = selection.getAttributeKeys()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
					var key = _step10.value;

					consumable.add(selection, 'selectionAttribute:' + key);
				}
			} catch (err) {
				_didIteratorError10 = true;
				_iteratorError10 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion10 && _iterator10.return) {
						_iterator10.return();
					}
				} finally {
					if (_didIteratorError10) {
						throw _iteratorError10;
					}
				}
			}

			return consumable;
		}

		/**
   * Tests passed `consumable` to check whether given event can be fired and if so, fires it.
   *
   * @private
   * @fires engine.conversion.ModelConversionDispatcher#insert
   * @fires engine.conversion.ModelConversionDispatcher#addAttribute
   * @fires engine.conversion.ModelConversionDispatcher#removeAttribute
   * @fires engine.conversion.ModelConversionDispatcher#changeAttribute
   * @param {String} type Event type.
   * @param {Object} data Event data.
   * @param {engine.conversion.ModelConsumable} consumable Values to consume.
   */

	}, {
		key: '_testAndFire',
		value: function _testAndFire(type, data, consumable) {
			if (!consumable.test(data.item, type)) {
				// Do not fire event if the item was consumed.
				return;
			}

			if (type === 'insert' || type === 'remove' || type == 'move') {
				if (data.item instanceof TextProxy) {
					// Example: insert:$text.
					this.fire(type + ':$text', data, consumable, this.conversionApi);
				} else {
					// Example: insert:paragraph.
					this.fire(type + ':' + data.item.name, data, consumable, this.conversionApi);
				}
			} else {
				// Example addAttribute:alt:img.
				// Example addAttribute:bold:$text.
				var name = data.item.name || '$text';

				this.fire(type + ':' + name, data, consumable, this.conversionApi);
			}
		}

		/**
   * Fired for inserted nodes.
   *
   * `insert` is a namespace for a class of events. Names of actually called events follow this pattern:
   * `insert:<type>:<elementName>`. `type` is either `text` when one or more characters has been inserted or `element`
   * when {@link engine.model.Element} has been inserted. If `type` is `element`, `elementName` is added and is
   * equal to the {@link engine.model.Element#name name} of inserted element. This way listeners can either
   * listen to very general `insert` event or, i.e., very specific `insert:paragraph` event, which is fired only for
   * model elements with name `paragraph`.
   *
   * @event engine.conversion.ModelConversionDispatcher.insert
   * @param {Object} data Additional information about the change.
   * @param {engine.model.Item} data.item Inserted item.
   * @param {engine.model.Range} data.range Range spanning over inserted item.
   * @param {engine.conversion.ModelConsumable} consumable Values to consume.
   * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
   */

		/**
   * Fired for moved nodes.
   *
   * @event engine.conversion.ModelConversionDispatcher.move
   * @param {Object} data Additional information about the change.
   * @param {engine.model.Position} data.sourcePosition Position from where the range has been moved.
   * @param {engine.model.Range} data.range Moved range (after move).
   * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
   */

		/**
   * Fired for removed nodes.
   *
   * @event engine.conversion.ModelConversionDispatcher.remove
   * @param {Object} data Additional information about the change.
   * @param {engine.model.Position} data.sourcePosition Position from where the range has been removed.
   * @param {engine.model.Range} data.range Removed range (in {@link engine.model.Document#graveyard graveyard root}).
   * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
   */

		/**
   * Fired for renamed element.
   *
   * @event engine.conversion.ModelConversionDispatcher.rename
   * @param {Object} data Additional information about the change.
   * @param {engine.model.Element} data.element Renamed element.
   * @param {String} data.oldName Old name of the renamed element.
   * @param {engine.conversion.ModelConsumable} consumable Values to consume.
   * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
   */

		/**
   * Fired when attribute has been added on a node.
   *
   * `addAttribute` is a namespace for a class of events. Names of actually called events follow this pattern:
   * `addAttribute:<attributeKey>:<elementName>`. `attributeKey` is the key of added attribute. `elementName` is
   * equal to the {@link engine.model.Element#name name} of the element which got the attribute. This way listeners
   * can either listen to adding certain attribute, i.e. `addAttribute:bold`, or be more specific, i.e. `addAttribute:link:img`.
   *
   * @event engine.conversion.ModelConversionDispatcher.addAttribute
   * @param {Object} data Additional information about the change.
   * @param {engine.model.Item} data.item Changed item.
   * @param {engine.model.Range} data.range Range spanning over changed item.
   * @param {String} data.attributeKey Attribute key.
   * @param {null} data.attributeOldValue Attribute value before the change - always `null`. Kept for the sake of unifying events.
   * @param {*} data.attributeNewValue New attribute value.
   * @param {engine.conversion.ModelConsumable} consumable Values to consume.
   * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
   */

		/**
   * Fired when attribute has been removed from a node.
   *
   * `removeAttribute` is a namespace for a class of events. Names of actually called events follow this pattern:
   * `removeAttribute:<attributeKey>:<elementName>`. `attributeKey` is the key of removed attribute. `elementName` is
   * equal to the {@link engine.model.Element#name name} of the element which got the attribute removed. This way listeners
   * can either listen to removing certain attribute, i.e. `removeAttribute:bold`, or be more specific, i.e. `removeAttribute:link:img`.
   *
   * @event engine.conversion.ModelConversionDispatcher.removeAttribute
   * @param {Object} data Additional information about the change.
   * @param {engine.model.Item} data.item Changed item.
   * @param {engine.model.Range} data.range Range spanning over changed item.
   * @param {String} data.attributeKey Attribute key.
   * @param {*} data.attributeOldValue Attribute value before it was removed.
   * @param {null} data.attributeNewValue New attribute value - always `null`. Kept for the sake of unifying events.
   * @param {engine.conversion.ModelConsumable} consumable Values to consume.
   * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
   */

		/**
   * Fired when attribute of a node has been changed.
   *
   * `changeAttribute` is a namespace for a class of events. Names of actually called events follow this pattern:
   * `changeAttribute:<attributeKey>:<elementName>`. `attributeKey` is the key of changed attribute. `elementName` is
   * equal to the {@link engine.model.Element#name name} of the element which got the attribute changed. This way listeners
   * can either listen to changing certain attribute, i.e. `changeAttribute:link`, or be more specific, i.e. `changeAttribute:link:img`.
   *
   * @event engine.conversion.ModelConversionDispatcher.changeAttribute
   * @param {Object} data Additional information about the change.
   * @param {engine.model.Item} data.item Changed item.
   * @param {engine.model.Range} data.range Range spanning over changed item.
   * @param {String} data.attributeKey Attribute key.
   * @param {*} data.attributeOldValue Attribute value before the change.
   * @param {*} data.attributeNewValue New attribute value.
   * @param {engine.conversion.ModelConsumable} consumable Values to consume.
   * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
   */

		/**
   * Fired for {@link engine.model.Selection selection} changes.
   *
   * @event engine.conversion.ModelConversionDispatcher.selection
   * @param {engine.model.Selection} selection `Selection` instance that is converted.
   * @param {engine.conversion.ModelConsumable} consumable Values to consume.
   * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
   */

		/**
   * Fired for {@link engine.model.Selection selection} attributes changes.
   *
   * `selectionAttribute` is a namespace for a class of events. Names of actually called events follow this pattern:
   * `selectionAttribute:<attributeKey>`. `attributeKey` is the key of selection attribute. This way listen can listen to
   * certain attribute, i.e. `addAttribute:bold`.
   *
   * @event engine.conversion.ModelConversionDispatcher.selectionAttribute
   * @param {Object} data Additional information about the change.
   * @param {engine.model.Selection} data.selection Selection that is converted.
   * @param {String} data.attributeKey Key of changed attribute.
   * @param {*} data.attributeValue Value of changed attribute.
   * @param {engine.conversion.ModelConsumable} consumable Values to consume.
   * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
   */

	}]);
	return ModelConversionDispatcher;
}();

mix(ModelConversionDispatcher, EmitterMixin);

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

// Default attribute priority.
var DEFAULT_PRIORITY = 10;

/**
 * Attributes are elements which define document presentation. They are mostly elements like `<b>` or `<span>`.
 * Attributes can be broken and merged by the {@link engine.view.writer view writer}.
 *
 * Editing engine does not define fixed HTML DTD. This is why the type of the {@link engine.view.Element} need to
 * be defined by the feature developer. Creating an element you should use {@link engine.view.ContainerElement}
 * class or `AttributeElement`.
 *
 * @memberOf engine.view
 * @extends engine.view.Element
 */

var AttributeElement = function (_Element) {
	inherits(AttributeElement, _Element);

	/**
  * Creates a attribute element.
  *
  * @see engine.view.Element
  */
	function AttributeElement(name, attrs, children) {
		classCallCheck(this, AttributeElement);

		/**
   * Element priority. Attributes have to have the same priority to be
   * {@link engine.view.Element#isSimilar similar}. Setting different priorities on similar
  	 * nodes may prevent merging, e.g. two `<abbr>` nodes next each other shouldn't be merged.
   *
   * @member {Number} engine.view.AttributeElement#priority
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(AttributeElement).call(this, name, attrs, children));

		_this.priority = DEFAULT_PRIORITY;
		return _this;
	}

	/**
  * Clones provided element with priority.
  *
  * @param {Boolean} deep If set to `true` clones element and all its children recursively. When set to `false`,
  * element will be cloned without any children.
  * @returns {engine.view.AttributeElement} Clone of this element.
  */


	createClass(AttributeElement, [{
		key: 'clone',
		value: function clone(deep) {
			var cloned = get(Object.getPrototypeOf(AttributeElement.prototype), 'clone', this).call(this, deep);

			// Clone priority too.
			cloned.priority = this.priority;

			return cloned;
		}

		/**
   * Checks if this element is similar to other element.
   * Both elements should have the same name, attributes and priority to be considered as similar.
   * Two similar elements can contain different set of children nodes.
   *
   * @param {engine.view.Element} otherElement
   * @returns {Boolean}
   */

	}, {
		key: 'isSimilar',
		value: function isSimilar(otherElement) {
			return get(Object.getPrototypeOf(AttributeElement.prototype), 'isSimilar', this).call(this, otherElement) && this.priority == otherElement.priority;
		}

		/**
   * Returns block {@link engine.view.filler filler} offset or `null` if a block filler is not needed.
   *
   * @returns {Number|null} Block filler offset or `null` if block filler is not needed.
   */

	}, {
		key: 'getFillerOffset',
		value: function getFillerOffset() {
			// <b>foo</b> does not need filler.
			if (this.childCount) {
				return null;
			}

			var element = this.parent;

			// <p><b></b></p> needs filler -> <p><b><br></b></p>
			while (element instanceof AttributeElement) {
				if (element.childCount > 1) {
					return null;
				}

				element = element.parent;
			}

			if (!element || element.childCount > 1) {
				return null;
			}

			return 0;
		}
	}]);
	return AttributeElement;
}(Element$1);

AttributeElement.DEFAULT_PRIORITY = DEFAULT_PRIORITY;

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * DocumentFragment class.
 *
 * @memberOf engine.view
 */

var DocumentFragment$1 = function () {
	/**
  * Creates new DocumentFragment instance.
  *
  * @param {engine.view.Node|Iterable.<engine.view.Node>} [children] List of nodes to be inserted into
  * created document fragment.
  */
	function DocumentFragment(children) {
		classCallCheck(this, DocumentFragment);

		/**
   * Array of child nodes.
   *
   * @protected
   * @member {Array.<engine.view.Element>} engine.view.DocumentFragment#_children
   */
		this._children = [];

		if (children) {
			this.insertChildren(0, children);
		}
	}

	/**
  * Iterates over nodes added to this DocumentFragment.
  */


	createClass(DocumentFragment, [{
		key: Symbol.iterator,
		value: function value() {
			return this._children[Symbol.iterator]();
		}

		/**
   * Number of child nodes in this document fragment.
   *
   * @readonly
   * @type {Number}
   */

	}, {
		key: 'getAncestors',


		/**
   * Returns ancestor elements of `DocumentFragment`, which is an empty array. Added for compatibility reasons.
   *
   * @returns {Array}
   */
		value: function getAncestors() {
			return [];
		}

		/**
   * {@link engine.view.DocumentFragment#insertChildren Insert} a child node or a list of child nodes at the end
   * and sets the parent of these nodes to this fragment.
   *
   * @param {engine.view.Node|Iterable.<engine.view.Node>} nodes Node or the list of nodes to be inserted.
   * @returns {Number} Number of appended nodes.
   */

	}, {
		key: 'appendChildren',
		value: function appendChildren(nodes) {
			return this.insertChildren(this.childCount, nodes);
		}

		/**
   * Gets child at the given index.
   *
   * @param {Number} index Index of child.
   * @returns {engine.view.Node} Child node.
   */

	}, {
		key: 'getChild',
		value: function getChild(index) {
			return this._children[index];
		}

		/**
   * Gets index of the given child node. Returns `-1` if child node is not found.
   *
   * @param {engine.view.Node} node Child node.
   * @returns {Number} Index of the child node.
   */

	}, {
		key: 'getChildIndex',
		value: function getChildIndex(node) {
			return this._children.indexOf(node);
		}

		/**
   * Gets child nodes iterator.
   *
   * @returns {Iterable.<engine.view.Node>} Child nodes iterator.
   */

	}, {
		key: 'getChildren',
		value: function getChildren() {
			return this._children[Symbol.iterator]();
		}

		/**
   * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
   * this fragment.
   *
   * @param {Number} index Position where nodes should be inserted.
   * @param {engine.view.Node|Iterable.<engine.view.Node>} nodes Node or list of nodes to be inserted.
   * @returns {Number} Number of inserted nodes.
   */

	}, {
		key: 'insertChildren',
		value: function insertChildren(index, nodes) {
			this._fireChange('children', this);
			var count = 0;

			nodes = normalize$3(nodes);

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var node = _step.value;

					node.parent = this;

					this._children.splice(index, 0, node);
					index++;
					count++;
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			return count;
		}

		/**
   * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
   *
   * @param {Number} index Number of the first node to remove.
   * @param {Number} [howMany=1] Number of nodes to remove.
   * @returns {Array.<engine.view.Node>} The array of removed nodes.
   */

	}, {
		key: 'removeChildren',
		value: function removeChildren(index) {
			var howMany = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

			this._fireChange('children', this);

			for (var i = index; i < index + howMany; i++) {
				this._children[i].parent = null;
			}

			return this._children.splice(index, howMany);
		}

		/**
   * Fires `change` event with given type of the change.
   *
   * @private
   * @param {engine.view.ChangeType} type Type of the change.
   * @param {engine.view.Node} node Changed node.
   * @fires engine.view.Node#change
   */

	}, {
		key: '_fireChange',
		value: function _fireChange(type, node) {
			this.fire('change:' + type, node);
		}
	}, {
		key: 'childCount',
		get: function get() {
			return this._children.length;
		}

		/**
   * Is `true` if there are no nodes inside this document fragment, `false` otherwise.
   *
   * @readonly
   * @type {Boolean}
   */

	}, {
		key: 'isEmpty',
		get: function get() {
			return this.childCount === 0;
		}

		/**
   * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.
   *
   * @readonly
   * @type {engine.model.DocumentFragment}
   */

	}, {
		key: 'root',
		get: function get() {
			return this;
		}

		/**
   * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
   *
   * @readonly
   * @type {null}
   */

	}, {
		key: 'parent',
		get: function get() {
			return null;
		}
	}]);
	return DocumentFragment;
}();

mix(DocumentFragment$1, EmitterMixin);

// Converts strings to Text and non-iterables to arrays.
//
// @param {String|engine.view.Node|Iterable.<String|engine.view.Node>}
// @return {Iterable.<engine.view.Node>}
function normalize$3(nodes) {
	// Separate condition because string is iterable.
	if (typeof nodes == 'string') {
		return [new Text$2(nodes)];
	}

	if (!isIterable(nodes)) {
		nodes = [nodes];
	}

	// Array.from to enable .map() on non-arrays.
	return Array.from(nodes).map(function (node) {
		return typeof node == 'string' ? new Text$2(node) : node;
	});
}

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Contains functions used for composing view tree.
 *
 * @namespace engine.view.writer
 */

var viewWriter = {
	breakAttributes: breakAttributes,
	breakContainer: breakContainer,
	mergeAttributes: mergeAttributes,
	mergeContainers: mergeContainers,
	insert: insert,
	remove: remove$1,
	move: move$1,
	wrap: wrap$1,
	wrapPosition: wrapPosition,
	unwrap: unwrap$1,
	rename: rename$1
};

/**
 * Breaks attribute nodes at provided position or at boundaries of provided range. It breaks attribute elements inside
 * up to a container element.
 *
 * In following examples `<p>` is a container, `<b>` and `<u>` are attribute nodes:
 *
 *		<p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>
 *		<p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>
 *		<p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>
 *		<p><b>fo{o</b><u>ba}r</u></p> -> <p><b>fo</b><b>o</b><u>ba</u><u>r</u></b></p>
 *
 * **Note:** {@link engine.view.DocumentFragment DocumentFragment} is treated like a container.
 *
 * **Note:** Difference between {@link engine.view.writer.breakAttributes breakAttributes} and
 * {@link engine.view.writer.breakContainer breakContainer} is that `breakAttributes` breaks all
 * {@link engine.view.AttributeElement attribute elements} that are ancestors of given `position`, up to the first
 * encountered {@link engine.view.ContainerElement container element}. `breakContainer` assumes that given `position`
 * is directly in container element and breaks that container element.
 *
 * Throws {@link utils.CKEditorError CKEditorError} `view-writer-invalid-range-container` when {@link engine.view.Range#start start}
 * and {@link engine.view.Range#end end} positions of a passed range are not placed inside same parent container.
 *
 * @see engine.view.AttributeElement
 * @see engine.view.ContainerElement
 * @see engine.view.writer.breakContainer
 * @function engine.view.writer.breakAttributes
 * @param {engine.view.Position|engine.view.Range} positionOrRange Position where to break attribute elements.
 * @returns {engine.view.Position|engine.view.Range} New position or range, after breaking the attribute elements.
 */
function breakAttributes(positionOrRange) {
	if (positionOrRange instanceof Position$1) {
		return _breakAttributes(positionOrRange);
	} else {
		return _breakAttributesRange(positionOrRange);
	}
}

/**
 * Breaks {@link engine.view.ContainerElement container view element} into two, at the given position. Position
 * has to be directly inside container element and cannot be in root. Does not break if position is at the beginning
 * or at the end of it's parent element.
 *
 *		<p>foo^bar</p> -> <p>foo</p><p>bar</p>
 *		<div><p>foo</p>^<p>bar</p></div> -> <div><p>foo</p></div><div><p>bar</p></div>
 *		<p>^foobar</p> -> ^<p>foobar</p>
 *		<p>foobar^</p> -> <p>foobar</p>^
 *
 * **Note:** Difference between {@link engine.view.writer.breakAttributes breakAttributes} and
 * {@link engine.view.writer.breakContainer breakContainer} is that `breakAttributes` breaks all
 * {@link engine.view.AttributeElement attribute elements} that are ancestors of given `position`, up to the first
 * encountered {@link engine.view.ContainerElement container element}. `breakContainer` assumes that given `position`
 * is directly in container element and breaks that container element.
 *
 * @see engine.view.AttributeElement
 * @see engine.view.ContainerElement
 * @see engine.view.writer.breakAttributes
 * @function engine.view.writer.breakContainer
 * @param {engine.view.Position} position Position where to break element.
 * @returns {engine.view.Position} Position between broken elements. If element has not been broken, the returned position
 * is placed either before it or after it.
 */
function breakContainer(position) {
	var element = position.parent;

	if (!(element instanceof ContainerElement)) {
		/**
   * Trying to break an element which is not a container element.
   *
   * @error view-writer-break-non-container-element
   */
		throw new CKEditorError('view-writer-break-non-container-element: Trying to break an element which is not a container element.');
	}

	if (!element.parent) {
		/**
   * Trying to break root element.
   *
   * @error view-writer-break-root
   */
		throw new CKEditorError('view-writer-break-root: Trying to break root element.');
	}

	if (position.isAtStart) {
		return Position$1.createBefore(element);
	} else if (!position.isAtEnd) {
		var newElement = element.clone(false);

		insert(Position$1.createAfter(element), newElement);

		var sourceRange = new Range$2(position, Position$1.createAt(element, 'end'));
		var targetPosition = new Position$1(newElement, 0);

		move$1(sourceRange, targetPosition);
	}

	return Position$1.createAfter(element);
}

/**
 * Merges {@link engine.view.AttributeElement attribute elements}. It also merges text nodes if needed.
 * Only {@link engine.view.AttributeElement#isSimilar similar} attribute elements can be merged.
 *
 * In following examples `<p>` is a container and `<b>` is an attribute element:
 *
 *		<p>foo[]bar</p> -> <p>foo{}bar</p>
 *		<p><b>foo</b>[]<b>bar</b> -> <p><b>foo{}bar</b></b>
 *		<p><b foo="bar">a</b>[]<b foo="baz">b</b> -> <p><b foo="bar">a</b>[]<b foo="baz">b</b>
 *
 * It will also take care about empty attributes when merging:
 *
 *		<p><b>[]</b></p> -> <p>[]</p>
 *		<p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>
 *
 * **Note:** Difference between {@link engine.view.writer.mergeAttributes mergeAttributes} and
 * {@link engine.view.writer.mergeContainers mergeContainers} is that `mergeAttributes` merges two
 * {@link engine.view.AttributeElement attribute elements} or {@link engine.view.Text text nodes}
 * while `mergeContainer` merges two {@link engine.view.ContainerElement container elements}.
 *
 * @see engine.view.AttributeElement
 * @see engine.view.ContainerElement
 * @see engine.view.writer.mergeContainers
 * @function engine.view.writer.mergeAttributes
 * @param {engine.view.Position} position Merge position.
 * @returns {engine.view.Position} Position after merge.
 */
function mergeAttributes(position) {
	var positionOffset = position.offset;
	var positionParent = position.parent;

	// When inside text node - nothing to merge.
	if (positionParent instanceof Text$2) {
		return position;
	}

	// When inside empty attribute - remove it.
	if (positionParent instanceof AttributeElement && positionParent.childCount === 0) {
		var parent = positionParent.parent;
		var offset = positionParent.index;
		positionParent.remove();

		return mergeAttributes(new Position$1(parent, offset));
	}

	var nodeBefore = positionParent.getChild(positionOffset - 1);
	var nodeAfter = positionParent.getChild(positionOffset);

	// Position should be placed between two nodes.
	if (!nodeBefore || !nodeAfter) {
		return position;
	}

	// When one or both nodes are containers - no attributes to merge.
	if (nodeBefore instanceof ContainerElement || nodeAfter instanceof ContainerElement) {
		return position;
	}

	// When position is between two text nodes.
	if (nodeBefore instanceof Text$2 && nodeAfter instanceof Text$2) {
		return mergeTextNodes(nodeBefore, nodeAfter);
	}

	// When selection is between same nodes.
	else if (nodeBefore.isSimilar(nodeAfter)) {
			// Move all children nodes from node placed after selection and remove that node.
			var count = nodeBefore.childCount;
			nodeBefore.appendChildren(nodeAfter.getChildren());
			nodeAfter.remove();

			// New position is located inside the first node, before new nodes.
			// Call this method recursively to merge again if needed.
			return mergeAttributes(new Position$1(nodeBefore, count));
		}

	return position;
}

/**
 * Merges two {@link engine.view.ContainerElement container elements} that are before and after given position.
 * Precisely, the element after the position is removed and it's contents are moved to element before the position.
 *
 *		<p>foo</p>^<p>bar</p> -> <p>foo^bar</p>
 *		<div>foo</div>^<p>bar</p> -> <div>foo^bar</div>
 *
 * **Note:** Difference between {@link engine.view.writer.mergeAttributes mergeAttributes} and
 * {@link engine.view.writer.mergeContainers mergeContainers} is that `mergeAttributes` merges two
 * {@link engine.view.AttributeElement attribute elements} or {@link engine.view.Text text nodes}
 * while `mergeContainer` merges two {@link engine.view.ContainerElement container elements}.
 *
 * @see engine.view.AttributeElement
 * @see engine.view.ContainerElement
 * @see engine.view.writer.mergeAttributes
 * @function engine.view.writer.mergeContainers
 * @param {engine.view.Position} position Merge position.
 * @returns {engine.view.Position} Position after merge.
 */
function mergeContainers(position) {
	var prev = position.nodeBefore;
	var next = position.nodeAfter;

	if (!prev || !next || !(prev instanceof ContainerElement) || !(next instanceof ContainerElement)) {
		/**
   * Element before and after given position cannot be merged.
   *
   * @error view-writer-merge-containers-invalid-position
   */
		throw new CKEditorError('view-writer-merge-containers-invalid-position: ' + 'Element before and after given position cannot be merged.');
	}

	var lastChild = prev.getChild(prev.childCount - 1);
	var newPosition = lastChild instanceof Text$2 ? Position$1.createAt(lastChild, 'end') : Position$1.createAt(prev, 'end');

	move$1(Range$2.createIn(next), Position$1.createAt(prev, 'end'));
	remove$1(Range$2.createOn(next));

	return newPosition;
}

/**
 * Insert node or nodes at specified position. Takes care about breaking attributes before insertion
 * and merging them afterwards.
 *
 * Throws {@link utils.CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert
 * contains instances that are not {@link engine.view.Text Texts},
 * {@link engine.view.AttributeElement AttributeElements} or
 * {@link engine.view.ContainerElement ContainerElements}.
 *
 * @function engine.view.writer.insert
 * @param {engine.view.Position} position Insertion position.
 * @param {engine.view.Text|engine.view.AttributeElement|engine.view.ContainerElement
 * |Iterable.<engine.view.Text|engine.view.AttributeElement|engine.view.ContainerElement>} nodes Node or
 * nodes to insert.
 * @returns {engine.view.Range} Range around inserted nodes.
 */
function insert(position, nodes) {
	nodes = isIterable(nodes) ? [].concat(toConsumableArray(nodes)) : [nodes];

	// Check if nodes to insert are instances of AttributeElements, ContainerElements or Text.
	validateNodesToInsert(nodes);

	var container = getParentContainer(position);

	if (!container) {
		/**
   * Position's parent container cannot be found.
   *
   * @error view-writer-invalid-position-container
   */
		throw new CKEditorError('view-writer-invalid-position-container');
	}

	var insertionPosition = _breakAttributes(position, true);

	var length = container.insertChildren(insertionPosition.offset, nodes);
	var endPosition = insertionPosition.getShiftedBy(length);
	var start = mergeAttributes(insertionPosition);

	// When no nodes were inserted - return collapsed range.
	if (length === 0) {
		return new Range$2(start, start);
	} else {
		// If start position was merged - move end position.
		if (!start.isEqual(insertionPosition)) {
			endPosition.offset--;
		}

		var end = mergeAttributes(endPosition);

		return new Range$2(start, end);
	}
}

/**
 * Removes provided range from the container.
 *
 * Throws {@link utils.CKEditorError CKEditorError} `view-writer-invalid-range-container` when
 * {@link engine.view.Range#start start} and {@link engine.view.Range#end end} positions are not placed inside
 * same parent container.
 *
 * @function engine.view.writer.remove
 * @param {engine.view.Range} range Range to remove from container. After removing, it will be updated
 * to a collapsed range showing the new position.
 * @returns {engine.view.DocumentFragment} Document fragment containing removed nodes.
 */
function remove$1(range) {
	validateRangeContainer(range);

	// If range is collapsed - nothing to remove.
	if (range.isCollapsed) {
		return new DocumentFragment$1();
	}

	// Break attributes at range start and end.

	var _breakAttributesRange2 = _breakAttributesRange(range, true);

	var breakStart = _breakAttributesRange2.start;
	var breakEnd = _breakAttributesRange2.end;

	var parentContainer = breakStart.parent;

	var count = breakEnd.offset - breakStart.offset;

	// Remove nodes in range.
	var removed = parentContainer.removeChildren(breakStart.offset, count);

	// Merge after removing.
	var mergePosition = mergeAttributes(breakStart);
	range.start = mergePosition;
	range.end = Position$1.createFromPosition(mergePosition);

	// Return removed nodes.
	return new DocumentFragment$1(removed);
}

/**
 * Moves nodes from provided range to target position.
 *
 * Throws {@link utils.CKEditorError CKEditorError} `view-writer-invalid-range-container` when
 * {@link engine.view.Range#start start} and {@link engine.view.Range#end end} positions are not placed inside
 * same parent container.
 *
 * @function engine.view.writer.move
 * @param {engine.view.Range} sourceRange Range containing nodes to move.
 * @param {engine.view.Position} targetPosition Position to insert.
 * @returns {engine.view.Range} Range in target container. Inserted nodes are placed between
 * {@link engine.view.Range#start start} and {@link engine.view.Range#end end} positions.
 */
function move$1(sourceRange, targetPosition) {
	if (sourceRange.start.parent == targetPosition.parent) {
		targetPosition.offset -= sourceRange.end.offset - sourceRange.start.offset;
	}

	var nodes = remove$1(sourceRange);

	return insert(targetPosition, nodes);
}

/**
 * Wraps elements within range with provided {@link engine.view.AttributeElement AttributeElement}.
 *
 * Throws {@link utils.CKEditorError} `view-writer-invalid-range-container` when {@link engine.view.Range#start}
 * and {@link engine.view.Range#end} positions are not placed inside same parent container.
 * Throws {@link utils.CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
 * an instance of {engine.view.AttributeElement AttributeElement}.
 *
 * @function engine.view.writer.wrap
 * @param {engine.view.Range} range Range to wrap.
 * @param {engine.view.AttributeElement} attribute Attribute element to use as wrapper.
 */
function wrap$1(range, attribute) {
	if (!(attribute instanceof AttributeElement)) {
		/**
   * Attribute element need to be instance of attribute element.
   *
   * @error view-writer-wrap-invalid-attribute
   */
		throw new CKEditorError('view-writer-wrap-invalid-attribute');
	}

	validateRangeContainer(range);

	// If range is collapsed - nothing to wrap.
	if (range.isCollapsed) {
		return range;
	}

	// Range around one element.
	if (range.end.isEqual(range.start.getShiftedBy(1))) {
		var node = range.start.nodeAfter;

		if (node instanceof AttributeElement && wrapAttributeElement(attribute, node)) {
			return range;
		}
	}

	// Range is inside single attribute and spans on all children.
	if (rangeSpansOnAllChildren(range) && wrapAttributeElement(attribute, range.start.parent)) {
		var parent = range.start.parent.parent;
		var index = range.start.parent.index;

		return Range$2.createFromParentsAndOffsets(parent, index, parent, index + 1);
	}

	// Break attributes at range start and end.

	var _breakAttributesRange3 = _breakAttributesRange(range, true);

	var breakStart = _breakAttributesRange3.start;
	var breakEnd = _breakAttributesRange3.end;

	var parentContainer = breakStart.parent;

	// Unwrap children located between break points.
	var unwrappedRange = unwrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute);

	// Wrap all children with attribute.
	var newRange = wrapChildren(parentContainer, unwrappedRange.start.offset, unwrappedRange.end.offset, attribute);

	// Merge attributes at the both ends and return a new range.
	var start = mergeAttributes(newRange.start);

	// If start position was merged - move end position back.
	if (!start.isEqual(newRange.start)) {
		newRange.end.offset--;
	}
	var end = mergeAttributes(newRange.end);

	return new Range$2(start, end);
}

/**
 * Wraps position with provided attribute. Returns new position after wrapping. This method will also merge newly
 * added attribute with its siblings whenever possible.
 *
 * Throws {@link utils.CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
 * an instance of {engine.view.AttributeElement AttributeElement}.
 *
 * @function engine.view.writer.wrapPosition
 * @param {engine.view.Position} position
 * @param {engine.view.AttributeElement} attribute
 * @returns {Position} New position after wrapping.
 */
function wrapPosition(position, attribute) {
	if (!(attribute instanceof AttributeElement)) {
		/**
   * Attribute element need to be instance of attribute element.
   *
   * @error view-writer-wrap-invalid-attribute
   */
		throw new CKEditorError('view-writer-wrap-invalid-attribute');
	}

	// Return same position when trying to wrap with attribute similar to position parent.
	if (attribute.isSimilar(position.parent)) {
		return movePositionToTextNode(Position$1.createFromPosition(position));
	}

	// When position is inside text node - break it and place new position between two text nodes.
	if (position.parent instanceof Text$2) {
		position = breakTextNode(position);
	}

	// Create fake element that will represent position, and will not be merged with other attributes.
	var fakePosition = new AttributeElement();
	fakePosition.priority = Number.POSITIVE_INFINITY;
	fakePosition.isSimilar = function () {
		return false;
	};

	// Insert fake element in position location.
	position.parent.insertChildren(position.offset, fakePosition);

	// Range around inserted fake attribute element.
	var wrapRange = new Range$2(position, position.getShiftedBy(1));

	// Wrap fake element with attribute (it will also merge if possible).
	wrap$1(wrapRange, attribute);

	// Remove fake element and place new position there.
	var newPosition = new Position$1(fakePosition.parent, fakePosition.index);
	fakePosition.remove();

	// If position is placed between text nodes - merge them and return position inside.
	var nodeBefore = newPosition.nodeBefore;
	var nodeAfter = newPosition.nodeAfter;

	if (nodeBefore instanceof Text$2 && nodeAfter instanceof Text$2) {
		return mergeTextNodes(nodeBefore, nodeAfter);
	}

	// If position is next to text node - move position inside.
	return movePositionToTextNode(newPosition);
}

/**
 * Unwraps nodes within provided range from attribute element.
 *
 * Throws {@link utils.CKEditorError CKEditorError} `view-writer-invalid-range-container` when
 * {@link engine.view.Range#start start} and {@link engine.view.Range#end end} positions are not placed inside
 * same parent container.
 *
 * @function engine.view.writer.unwrap
 * @param {engine.view.Range} range
 * @param {engine.view.AttributeElement} element
 */
function unwrap$1(range, attribute) {
	if (!(attribute instanceof AttributeElement)) {
		/**
   * Attribute element need to be instance of attribute element.
   *
   * @error view-writer-unwrap-invalid-attribute
   */
		throw new CKEditorError('view-writer-unwrap-invalid-attribute');
	}

	validateRangeContainer(range);

	// If range is collapsed - nothing to unwrap.
	if (range.isCollapsed) {
		return range;
	}

	// Range around one element - check if AttributeElement can be unwrapped partially when it's not similar.
	// For example:
	// <b class="foo bar" title="baz"></b> unwrap with:	<b class="foo"></p> result: <b class"bar" title="baz"></b>
	if (range.end.isEqual(range.start.getShiftedBy(1))) {
		var node = range.start.nodeAfter;

		// Unwrap single attribute element.
		if (!attribute.isSimilar(node) && node instanceof AttributeElement && unwrapAttributeElement(attribute, node)) {
			return range;
		}
	}

	// Break attributes at range start and end.

	var _breakAttributesRange4 = _breakAttributesRange(range, true);

	var breakStart = _breakAttributesRange4.start;
	var breakEnd = _breakAttributesRange4.end;

	var parentContainer = breakStart.parent;

	// Unwrap children located between break points.
	var newRange = unwrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute);

	// Merge attributes at the both ends and return a new range.
	var start = mergeAttributes(newRange.start);

	// If start position was merged - move end position back.
	if (!start.isEqual(newRange.start)) {
		newRange.end.offset--;
	}
	var end = mergeAttributes(newRange.end);

	return new Range$2(start, end);
}

/**
 * Renames element by creating a copy of renamed element but with changed name and then moving contents of the
 * old element to the new one. Keep in mind that this will invalidate all {@link engine.view.Position positions} which
 * has renamed element as {@link engine.view.Position#parent a parent}.
 *
 * New element has to be created because `Element#tagName` property in DOM is readonly.
 *
 * Since this function creates a new element and removes the given one, the new element is returned to keep reference.
 *
 * @param {engine.view.ContainerElement} viewElement Element to be renamed.
 * @param {String} newName New name for element.
 */
function rename$1(viewElement, newName) {
	var newElement = new ContainerElement(newName, viewElement.getAttributes());

	insert(Position$1.createAfter(viewElement), newElement);
	move$1(Range$2.createIn(viewElement), Position$1.createAt(newElement));
	remove$1(Range$2.createOn(viewElement));

	return newElement;
}

// Returns first parent container of specified {@link engine.view.Position Position}.
// Position's parent node is checked as first, then next parents are checked.
// Note that {@link engine.view.DocumentFragment DocumentFragment} is treated like a container.
//
// @param {engine.view.Position} position Position used as a start point to locate parent container.
// @returns {engine.view.ContainerElement|engine.view.DocumentFragment|undefined} Parent container element or
// `undefined` if container is not found.
function getParentContainer(position) {
	var parent = position.parent;

	while (!isContainerOrFragment(parent)) {
		if (!parent) {
			return undefined;
		}
		parent = parent.parent;
	}

	return parent;
}

// Function used by both public breakAttributes (without splitting text nodes) and by other methods (with
// splitting text nodes).
//
// @param {engine.view.Range} range Range which `start` and `end` positions will be used to break attributes.
// @param {Boolean} [forceSplitText = false] If set to `true`, will break text nodes even if they are directly in
// container element. This behavior will result in incorrect view state, but is needed by other view writing methods
// which then fixes view state. Defaults to `false`.
// @returns {engine.view.Range} New range with located at break positions.
function _breakAttributesRange(range) {
	var forceSplitText = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

	var rangeStart = range.start;
	var rangeEnd = range.end;

	validateRangeContainer(range);

	// Break at the collapsed position. Return new collapsed range.
	if (range.isCollapsed) {
		var position = _breakAttributes(range.start, forceSplitText);

		return new Range$2(position, position);
	}

	var breakEnd = _breakAttributes(rangeEnd, forceSplitText);
	var count = breakEnd.parent.childCount;
	var breakStart = _breakAttributes(rangeStart, forceSplitText);

	// Calculate new break end offset.
	breakEnd.offset += breakEnd.parent.childCount - count;

	return new Range$2(breakStart, breakEnd);
}

// Function used by public breakAttributes (without splitting text nodes) and by other methods (with
// splitting text nodes).
//
// @param {engine.view.Position} position Position where to break attributes.
// @param {Boolean} [forceSplitText = false] If set to `true`, will break text nodes even if they are directly in
// container element. This behavior will result in incorrect view state, but is needed by other view writing methods
// which then fixes view state. Defaults to `false`.
// @returns {engine.view.Position} New position after breaking the attributes.
function _breakAttributes(position) {
	var forceSplitText = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

	var positionOffset = position.offset;
	var positionParent = position.parent;

	// There are no attributes to break and text nodes breaking is not forced.
	if (!forceSplitText && positionParent instanceof Text$2 && isContainerOrFragment(positionParent.parent)) {
		return Position$1.createFromPosition(position);
	}

	// Position's parent is container, so no attributes to break.
	if (isContainerOrFragment(positionParent)) {
		return Position$1.createFromPosition(position);
	}

	// Break text and start again in new position.
	if (positionParent instanceof Text$2) {
		return _breakAttributes(breakTextNode(position), forceSplitText);
	}

	var length = positionParent.childCount;

	// <p>foo<b><u>bar{}</u></b></p>
	// <p>foo<b><u>bar</u>[]</b></p>
	// <p>foo<b><u>bar</u></b>[]</p>
	if (positionOffset == length) {
		var newPosition = new Position$1(positionParent.parent, positionParent.index + 1);

		return _breakAttributes(newPosition, forceSplitText);
	} else
		// <p>foo<b><u>{}bar</u></b></p>
		// <p>foo<b>[]<u>bar</u></b></p>
		// <p>foo{}<b><u>bar</u></b></p>
		if (positionOffset === 0) {
			var _newPosition = new Position$1(positionParent.parent, positionParent.index);

			return _breakAttributes(_newPosition, forceSplitText);
		}
		// <p>foo<b><u>b{}ar</u></b></p>
		// <p>foo<b><u>b[]ar</u></b></p>
		// <p>foo<b><u>b</u>[]<u>ar</u></b></p>
		// <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>
		else {
				var offsetAfter = positionParent.index + 1;

				// Break element.
				var clonedNode = positionParent.clone();

				// Insert cloned node to position's parent node.
				positionParent.parent.insertChildren(offsetAfter, clonedNode);

				// Get nodes to move.
				var count = positionParent.childCount - positionOffset;
				var nodesToMove = positionParent.removeChildren(positionOffset, count);

				// Move nodes to cloned node.
				clonedNode.appendChildren(nodesToMove);

				// Create new position to work on.
				var _newPosition2 = new Position$1(positionParent.parent, offsetAfter);

				return _breakAttributes(_newPosition2, forceSplitText);
			}
}

// Unwraps children from provided `attribute`. Only children contained in `parent` element between
// `startOffset` and `endOffset` will be unwrapped.
//
// @param {engine.view.Element} parent
// @param {Number} startOffset
// @param {Number} endOffset
// @param {engine.view.Element} attribute
function unwrapChildren(parent, startOffset, endOffset, attribute) {
	var i = startOffset;
	var unwrapPositions = [];

	// Iterate over each element between provided offsets inside parent.
	while (i < endOffset) {
		var child = parent.getChild(i);

		// If attributes are the similar, then unwrap.
		if (child.isSimilar(attribute)) {
			var unwrapped = child.getChildren();
			var count = child.childCount;

			// Replace wrapper element with its children
			child.remove();
			parent.insertChildren(i, unwrapped);

			// Save start and end position of moved items.
			unwrapPositions.push(new Position$1(parent, i), new Position$1(parent, i + count));

			// Skip elements that were unwrapped. Assuming that there won't be another element to unwrap in child
			// elements.
			i += count;
			endOffset += count - 1;
		} else {
			// If other nested attribute is found start unwrapping there.
			if (child instanceof AttributeElement) {
				unwrapChildren(child, 0, child.childCount, attribute);
			}

			i++;
		}
	}

	// Merge at each unwrap.
	var offsetChange = 0;

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = unwrapPositions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var position = _step.value;

			position.offset -= offsetChange;

			// Do not merge with elements outside selected children.
			if (position.offset == startOffset || position.offset == endOffset) {
				continue;
			}

			var newPosition = mergeAttributes(position);

			// If nodes were merged - other merge offsets will change.
			if (!newPosition.isEqual(position)) {
				offsetChange++;
				endOffset--;
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return Range$2.createFromParentsAndOffsets(parent, startOffset, parent, endOffset);
}

// Wraps children with provided `attribute`. Only children contained in `parent` element between
// `startOffset` and `endOffset` will be wrapped.
//
// @param {engine.view.Element} parent
// @param {Number} startOffset
// @param {Number} endOffset
// @param {engine.view.Element} attribute
function wrapChildren(parent, startOffset, endOffset, attribute) {
	var i = startOffset;
	var wrapPositions = [];

	while (i < endOffset) {
		var child = parent.getChild(i);
		var isText = child instanceof Text$2;
		var isAttribute = child instanceof AttributeElement;

		// Wrap text or attributes with higher or equal priority.
		if (isText || isAttribute && attribute.priority <= child.priority) {
			// Clone attribute.
			var newAttribute = attribute.clone();

			// Wrap current node with new attribute;
			child.remove();
			newAttribute.appendChildren(child);
			parent.insertChildren(i, newAttribute);

			wrapPositions.push(new Position$1(parent, i));
		} else {
			// If other nested attribute is found start wrapping there.
			if (child instanceof AttributeElement) {
				wrapChildren(child, 0, child.childCount, attribute);
			}
		}

		i++;
	}

	// Merge at each wrap.
	var offsetChange = 0;

	var _iteratorNormalCompletion2 = true;
	var _didIteratorError2 = false;
	var _iteratorError2 = undefined;

	try {
		for (var _iterator2 = wrapPositions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
			var position = _step2.value;

			// Do not merge with elements outside selected children.
			if (position.offset == startOffset) {
				continue;
			}

			var newPosition = mergeAttributes(position);

			// If nodes were merged - other merge offsets will change.
			if (!newPosition.isEqual(position)) {
				offsetChange++;
				endOffset--;
			}
		}
	} catch (err) {
		_didIteratorError2 = true;
		_iteratorError2 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion2 && _iterator2.return) {
				_iterator2.return();
			}
		} finally {
			if (_didIteratorError2) {
				throw _iteratorError2;
			}
		}
	}

	return Range$2.createFromParentsAndOffsets(parent, startOffset, parent, endOffset);
}

// Returns new position that is moved to near text node. Returns same position if there is no text node before of after
// specified position.
//
//		<p>foo[]</p>  ->  <p>foo{}</p>
//		<p>[]foo</p>  ->  <p>{}foo</p>
//
// @param {engine.view.Position} position
// @returns {engine.view.Position} Position located inside text node or same position if there is no text nodes
// before or after position location.
function movePositionToTextNode(position) {
	var nodeBefore = position.nodeBefore;

	if (nodeBefore && nodeBefore instanceof Text$2) {
		return new Position$1(nodeBefore, nodeBefore.data.length);
	}

	var nodeAfter = position.nodeAfter;

	if (nodeAfter && nodeAfter instanceof Text$2) {
		return new Position$1(nodeAfter, 0);
	}

	return position;
}

// Breaks text node into two text nodes when possible.
//
//		<p>foo{}bar</p> -> <p>foo[]bar</p>
//		<p>{}foobar</p> -> <p>[]foobar</p>
//		<p>foobar{}</p> -> <p>foobar[]</p>
//
// @param {engine.view.Position} position Position that need to be placed inside text node.
// @returns {engine.view.Position} New position after breaking text node.
function breakTextNode(position) {
	if (position.offset == position.parent.data.length) {
		return new Position$1(position.parent.parent, position.parent.index + 1);
	}

	if (position.offset === 0) {
		return new Position$1(position.parent.parent, position.parent.index);
	}

	// Get part of the text that need to be moved.
	var textToMove = position.parent.data.slice(position.offset);

	// Leave rest of the text in position's parent.
	position.parent.data = position.parent.data.slice(0, position.offset);

	// Insert new text node after position's parent text node.
	position.parent.parent.insertChildren(position.parent.index + 1, new Text$2(textToMove));

	// Return new position between two newly created text nodes.
	return new Position$1(position.parent.parent, position.parent.index + 1);
}

// Merges two text nodes into first node. Removes second node and returns merge position.
//
// @param {engine.view.Text} t1 First text node to merge. Data from second text node will be moved at the end of
// this text node.
// @param {engine.view.Text} t2 Second text node to merge. This node will be removed after merging.
// @returns {engine.view.Position} Position after merging text nodes.
function mergeTextNodes(t1, t2) {
	// Merge text data into first text node and remove second one.
	var nodeBeforeLength = t1.data.length;
	t1.data += t2.data;
	t2.remove();

	return new Position$1(t1, nodeBeforeLength);
}

// Wraps one {@link engine.view.AttributeElement AttributeElement} into another by merging them if possible.
// Two AttributeElements can be merged when there is no attribute or style conflicts between them.
// When merging is possible - all attributes, styles and classes are moved from wrapper element to element being
// wrapped.
//
// @param {engine.view.AttributeElement} wrapper Wrapper AttributeElement.
// @param {engine.view.AttributeElement} toWrap AttributeElement to wrap using wrapper element.
// @returns {Boolean} Returns `true` if elements are merged.
function wrapAttributeElement(wrapper, toWrap) {
	// Can't merge if name or priority differs.
	if (wrapper.name !== toWrap.name || wrapper.priority !== toWrap.priority) {
		return false;
	}

	// Check if attributes can be merged.
	var _iteratorNormalCompletion3 = true;
	var _didIteratorError3 = false;
	var _iteratorError3 = undefined;

	try {
		for (var _iterator3 = wrapper.getAttributeKeys()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
			var key = _step3.value;

			// Classes and styles should be checked separately.
			if (key === 'class' || key === 'style') {
				continue;
			}

			// If some attributes are different we cannot wrap.
			if (toWrap.hasAttribute(key) && toWrap.getAttribute(key) !== wrapper.getAttribute(key)) {
				return false;
			}
		}

		// Check if styles can be merged.
	} catch (err) {
		_didIteratorError3 = true;
		_iteratorError3 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion3 && _iterator3.return) {
				_iterator3.return();
			}
		} finally {
			if (_didIteratorError3) {
				throw _iteratorError3;
			}
		}
	}

	var _iteratorNormalCompletion4 = true;
	var _didIteratorError4 = false;
	var _iteratorError4 = undefined;

	try {
		for (var _iterator4 = wrapper.getStyleNames()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
			var _key = _step4.value;

			if (toWrap.hasStyle(_key) && toWrap.getStyle(_key) !== wrapper.getStyle(_key)) {
				return false;
			}
		}

		// Move all attributes/classes/styles from wrapper to wrapped AttributeElement.
	} catch (err) {
		_didIteratorError4 = true;
		_iteratorError4 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion4 && _iterator4.return) {
				_iterator4.return();
			}
		} finally {
			if (_didIteratorError4) {
				throw _iteratorError4;
			}
		}
	}

	var _iteratorNormalCompletion5 = true;
	var _didIteratorError5 = false;
	var _iteratorError5 = undefined;

	try {
		for (var _iterator5 = wrapper.getAttributeKeys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
			var _key2 = _step5.value;

			// Classes and styles should be checked separately.
			if (_key2 === 'class' || _key2 === 'style') {
				continue;
			}

			// Move only these attributes that are not present - other are similar.
			if (!toWrap.hasAttribute(_key2)) {
				toWrap.setAttribute(_key2, wrapper.getAttribute(_key2));
			}
		}
	} catch (err) {
		_didIteratorError5 = true;
		_iteratorError5 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion5 && _iterator5.return) {
				_iterator5.return();
			}
		} finally {
			if (_didIteratorError5) {
				throw _iteratorError5;
			}
		}
	}

	var _iteratorNormalCompletion6 = true;
	var _didIteratorError6 = false;
	var _iteratorError6 = undefined;

	try {
		for (var _iterator6 = wrapper.getStyleNames()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
			var _key3 = _step6.value;

			if (!toWrap.hasStyle(_key3)) {
				toWrap.setStyle(_key3, wrapper.getStyle(_key3));
			}
		}
	} catch (err) {
		_didIteratorError6 = true;
		_iteratorError6 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion6 && _iterator6.return) {
				_iterator6.return();
			}
		} finally {
			if (_didIteratorError6) {
				throw _iteratorError6;
			}
		}
	}

	var _iteratorNormalCompletion7 = true;
	var _didIteratorError7 = false;
	var _iteratorError7 = undefined;

	try {
		for (var _iterator7 = wrapper.getClassNames()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
			var _key4 = _step7.value;

			if (!toWrap.hasClass(_key4)) {
				toWrap.addClass(_key4);
			}
		}
	} catch (err) {
		_didIteratorError7 = true;
		_iteratorError7 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion7 && _iterator7.return) {
				_iterator7.return();
			}
		} finally {
			if (_didIteratorError7) {
				throw _iteratorError7;
			}
		}
	}

	return true;
}

// Unwraps {@link engine.view.AttributeElement AttributeElement} from another by removing corresponding attributes,
// classes and styles. All attributes, classes and styles from wrapper should be present inside element being unwrapped.
//
// @param {engine.view.AttributeElement} wrapper Wrapper AttributeElement.
// @param {engine.view.AttributeElement} toUnwrap AttributeElement to unwrap using wrapper element.
// @returns {Boolean} Returns `true` if elements are unwrapped.
function unwrapAttributeElement(wrapper, toUnwrap) {
	// Can't unwrap if name or priority differs.
	if (wrapper.name !== toUnwrap.name || wrapper.priority !== toUnwrap.priority) {
		return false;
	}

	// Check if AttributeElement has all wrapper attributes.
	var _iteratorNormalCompletion8 = true;
	var _didIteratorError8 = false;
	var _iteratorError8 = undefined;

	try {
		for (var _iterator8 = wrapper.getAttributeKeys()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
			var key = _step8.value;

			// Classes and styles should be checked separately.
			if (key === 'class' || key === 'style') {
				continue;
			}

			// If some attributes are missing or different we cannot unwrap.
			if (!toUnwrap.hasAttribute(key) || toUnwrap.getAttribute(key) !== wrapper.getAttribute(key)) {
				return false;
			}
		}

		// Check if AttributeElement has all wrapper classes.
	} catch (err) {
		_didIteratorError8 = true;
		_iteratorError8 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion8 && _iterator8.return) {
				_iterator8.return();
			}
		} finally {
			if (_didIteratorError8) {
				throw _iteratorError8;
			}
		}
	}

	if (!toUnwrap.hasClass.apply(toUnwrap, toConsumableArray(wrapper.getClassNames()))) {
		return false;
	}

	// Check if AttributeElement has all wrapper styles.
	var _iteratorNormalCompletion9 = true;
	var _didIteratorError9 = false;
	var _iteratorError9 = undefined;

	try {
		for (var _iterator9 = wrapper.getStyleNames()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
			var _key5 = _step9.value;

			// If some styles are missing or different we cannot unwrap.
			if (!toUnwrap.hasStyle(_key5) || toUnwrap.getStyle(_key5) !== wrapper.getStyle(_key5)) {
				return false;
			}
		}

		// Remove all wrapper's attributes from unwrapped element.
	} catch (err) {
		_didIteratorError9 = true;
		_iteratorError9 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion9 && _iterator9.return) {
				_iterator9.return();
			}
		} finally {
			if (_didIteratorError9) {
				throw _iteratorError9;
			}
		}
	}

	var _iteratorNormalCompletion10 = true;
	var _didIteratorError10 = false;
	var _iteratorError10 = undefined;

	try {
		for (var _iterator10 = wrapper.getAttributeKeys()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
			var _key6 = _step10.value;

			// Classes and styles should be checked separately.
			if (_key6 === 'class' || _key6 === 'style') {
				continue;
			}

			toUnwrap.removeAttribute(_key6);
		}

		// Remove all wrapper's classes from unwrapped element.
	} catch (err) {
		_didIteratorError10 = true;
		_iteratorError10 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion10 && _iterator10.return) {
				_iterator10.return();
			}
		} finally {
			if (_didIteratorError10) {
				throw _iteratorError10;
			}
		}
	}

	toUnwrap.removeClass.apply(toUnwrap, toConsumableArray(wrapper.getClassNames()));

	// Remove all wrapper's styles from unwrapped element.
	toUnwrap.removeStyle.apply(toUnwrap, toConsumableArray(wrapper.getStyleNames()));

	return true;
}

// Returns `true` if range is located in same {@link engine.view.AttributeElement AttributeElement}
// (`start` and `end` positions are located inside same {@link engine.view.AttributeElement AttributeElement}),
// starts on 0 offset and ends after last child node.
//
// @param {engine.view.Range} Range
// @returns {Boolean}
function rangeSpansOnAllChildren(range) {
	return range.start.parent == range.end.parent && range.start.parent instanceof AttributeElement && range.start.offset === 0 && range.end.offset === range.start.parent.childCount;
}

// Checks if provided nodes are valid to insert. Checks if each node is an instance of
// {@link engine.view.Text Text} or {@link engine.view.AttributeElement AttributeElement} or
// {@link engine.view.ContainerElement ContainerElement}.
//
// Throws {@link utils.CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert
// contains instances that are not {@link engine.view.Text Texts},
// {@link engine.view.AttributeElement AttributeElements} or
// {@link engine.view.ContainerElement ContainerElements}.
//
// @param Iterable.<engine.view.Text|engine.view.AttributeElement|engine.view.ContainerElement> nodes
function validateNodesToInsert(nodes) {
	var _iteratorNormalCompletion11 = true;
	var _didIteratorError11 = false;
	var _iteratorError11 = undefined;

	try {
		for (var _iterator11 = nodes[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
			var node = _step11.value;

			if (!(node instanceof Text$2 || node instanceof AttributeElement || node instanceof ContainerElement)) {
				/**
     * Inserted nodes should be instance of {@link engine.view.AttributeElement AttributeElement},
     * {@link engine.view.ContainerElement ContainerElement} or {@link engine.view.Text Text}.
     *
     * @error view-writer-insert-invalid-node
     */
				throw new CKEditorError('view-writer-insert-invalid-node');
			}

			if (!(node instanceof Text$2)) {
				validateNodesToInsert(node.getChildren());
			}
		}
	} catch (err) {
		_didIteratorError11 = true;
		_iteratorError11 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion11 && _iterator11.return) {
				_iterator11.return();
			}
		} finally {
			if (_didIteratorError11) {
				throw _iteratorError11;
			}
		}
	}
}

// Checks if node is ContainerElement or DocumentFragment, because in most cases they should be treated the same way.
//
// @param {engine.view.Node} node
// @returns {Boolean} Returns `true` if node is instance of ContainerElement or DocumentFragment.
function isContainerOrFragment(node) {
	return node instanceof ContainerElement || node instanceof DocumentFragment$1;
}

// Checks if {@link engine.view.Range#start range start} and {@link engine.view.Range#end range end} are placed
// inside same {@link engine.view.ContainerElement container}.
// Throws {@link utils.CKEditorError CKEditorError} `view-writer-invalid-range-container` when validation fails.
//
// @param {engine.view.Range} range
function validateRangeContainer(range) {
	var startContainer = getParentContainer(range.start);
	var endContainer = getParentContainer(range.end);

	if (!startContainer || !endContainer || startContainer !== endContainer) {
		/**
   * Range container is invalid. This can happen if {@link engine.view.Range#start range start} and
   * {@link engine.view.Range#end range end} positions are not placed inside same container or
   * parent container for these positions cannot be found.
   *
   * @error view-writer-invalid-range-container
   */
		throw new CKEditorError('view-writer-invalid-range-container');
	}
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Contains {@link engine.model model} to {@link engine.view view} converters for
 * {@link engine.conversion.ModelConversionDispatcher}.
 *
 * @namespace engine.conversion.modelToView
 */

/**
 * Function factory, creates a converter that converts node insertion changes from the model to the view.
 * The view element that will be added to the view depends on passed parameter. If {@link engine.view.Element} was passed,
 * it will be cloned and the copy will be inserted. If `Function` is provided, it is passed all the parameters of the
 * dispatcher's {@link engine.conversion.ModelConversionDispatcher#event:insert insert event}. It's expected that the
 * function returns a {@link engine.view.Element}. The result of the function will be inserted to the view.
 *
 * The converter automatically consumes corresponding value from consumables list, stops the event (see
 * {@link engine.conversion.ModelConversionDispatcher}) and bind model and view elements.
 *
 *		modelDispatcher.on( 'insert:paragraph', insertElement( new ViewElement( 'p' ) ) );
 *
 *		modelDispatcher.on(
 *			'insert:myElem',
 *			insertElement( ( data, consumable, conversionApi ) => {
 *				let myElem = new ViewElement( 'myElem', { myAttr: true }, new ViewText( 'myText' ) );
 *
 *				// Do something fancy with myElem using data/consumable/conversionApi ...
 *
 *				return myElem;
 *			}
 *		) );
 *
 * @external engine.conversion.modelToView
 * @function engine.conversion.modelToView.insertElement
 * @param {engine.view.Element|Function} elementCreator View element, or function returning a view element, which
 * will be inserted.
 * @returns {Function} Insert element event converter.
 */
function insertElement(elementCreator) {
  return function (evt, data, consumable, conversionApi) {
    if (!consumable.consume(data.item, 'insert')) {
      return;
    }

    var viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
    var viewElement = elementCreator instanceof Element$1 ? elementCreator.clone(true) : elementCreator(data, consumable, conversionApi);

    conversionApi.mapper.bindElements(data.item, viewElement);
    viewWriter.insert(viewPosition, viewElement);
  };
}

/**
 * Function factory, creates a default model-to-view converter for text insertion changes.
 *
 * The converter automatically consumes corresponding value from consumables list and stops the event (see
 * {@link engine.conversion.ModelConversionDispatcher}).
 *
 *		modelDispatcher.on( 'insert:$text', insertText() );
 *
 * @external engine.conversion.modelToView
 * @function engine.conversion.modelToView.insertText
 * @returns {Function} Insert text event converter.
 */
function insertText() {
  return function (evt, data, consumable, conversionApi) {
    if (!consumable.consume(data.item, 'insert')) {
      return;
    }

    var viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
    var viewText = new Text$2(data.item.data);

    viewWriter.insert(viewPosition, viewText);
  };
}

/**
 * Function factory, creates a converter that converts set/change attribute changes from the model to the view. Attributes
 * from model are converted to the view element attributes in the view. You may provide a custom function to generate a
 * key-value attribute pair to add/change. If not provided, model attributes will be converted to view elements attributes
 * on 1-to-1 basis.
 *
 * **Note:** Provided attribute creator should always return the same `key` for given attribute from the model.
 *
 * The converter automatically consumes corresponding value from consumables list and stops the event (see
 * {@link engine.conversion.ModelConversionDispatcher}).
 *
 *		modelDispatcher.on( 'addAttribute:customAttr:myElem', setAttribute( ( data ) => {
 *			// Change attribute key from `customAttr` to `class` in view.
 *			const key = 'class';
 *			let value = data.attributeNewValue;
 *
 *			// Force attribute value to 'empty' if the model element is empty.
 *			if ( data.item.childCount === 0 ) {
 *				value = 'empty';
 *			}
 *
 *			// Return key-value pair.
 *			return { key, value };
 *		} ) );
 *
 * @external engine.conversion.modelToView
 * @function engine.conversion.modelToView.setAttribute
 * @param {Function} [attributeCreator] Function returning an object with two properties: `key` and `value`, which
 * represents attribute key and attribute value to be set on a {@link engine.view.Element view element}. The function
 * is passed all the parameters of the {@link engine.conversion.ModelConversionDispatcher.addAttribute}
 * or {@link engine.conversion.ModelConversionDispatcher.changeAttribute} event.
 * @returns {Function} Set/change attribute converter.
 */
function setAttribute(attributeCreator) {
  attributeCreator = attributeCreator || function (value, key) {
    return { value: value, key: key };
  };

  return function (evt, data, consumable, conversionApi) {
    if (!consumable.consume(data.item, eventNameToConsumableType(evt.name))) {
      return;
    }

    var _attributeCreator = attributeCreator(data.attributeNewValue, data.attributeKey, data, consumable, conversionApi);

    var key = _attributeCreator.key;
    var value = _attributeCreator.value;


    conversionApi.mapper.toViewElement(data.item).setAttribute(key, value);
  };
}

/**
 * Function factory, creates a converter that converts remove attribute changes from the model to the view. Removes attributes
 * that were converted to the view element attributes in the view. You may provide a custom function to generate a
 * key-value attribute pair to remove. If not provided, model attributes will be removed from view elements on 1-to-1 basis.
 *
 * **Note:** Provided attribute creator should always return the same `key` for given attribute from the model.
 *
 * **Note:** You can use the same attribute creator as in {@link engine.conversion.modelToView.setAttribute}.
 *
 * The converter automatically consumes corresponding value from consumables list and stops the event (see
 * {@link engine.conversion.ModelConversionDispatcher}).
 *
 *		modelDispatcher.on( 'removeAttribute:customAttr:myElem', removeAttribute( ( data ) => {
 *			// Change attribute key from `customAttr` to `class` in view.
 *			const key = 'class';
 *			let value = data.attributeNewValue;
 *
 *			// Force attribute value to 'empty' if the model element is empty.
 *			if ( data.item.childCount === 0 ) {
 *				value = 'empty';
 *			}
 *
 *			// Return key-value pair.
 *			return { key, value };
 *		} ) );
 *
 * @external engine.conversion.modelToView
 * @function engine.conversion.modelToView.removeAttribute
 * @param {Function} [attributeCreator] Function returning an object with two properties: `key` and `value`, which
 * represents attribute key and attribute value to be removed from {@link engine.view.Element view element}. The function
 * is passed all the parameters of the {@link engine.conversion.ModelConversionDispatcher#event:addAttribute addAttribute event}
 * or {@link engine.conversion.ModelConversionDispatcher#event:changeAttribute changeAttribute event}.
 * @returns {Function} Remove attribute converter.
 */
function removeAttribute(attributeCreator) {
  attributeCreator = attributeCreator || function (value, key) {
    return { key: key };
  };

  return function (evt, data, consumable, conversionApi) {
    if (!consumable.consume(data.item, eventNameToConsumableType(evt.name))) {
      return;
    }

    var _attributeCreator2 = attributeCreator(data.attributeOldValue, data.attributeKey, data, consumable, conversionApi);

    var key = _attributeCreator2.key;


    conversionApi.mapper.toViewElement(data.item).removeAttribute(key);
  };
}

/**
 * Function factory, creates a converter that converts set/change attribute changes from the model to the view. In this case,
 * model attributes are converted to a view element that will be wrapping view nodes which corresponding model nodes had
 * the attribute set. This is useful for attributes like `bold`, which may be set on text nodes in model but are
 * represented as an element in the view:
 *
 *		[paragraph]              MODEL ====> VIEW        <p>
 *			|- a {bold: true}                             |- <b>
 *			|- b {bold: true}                             |   |- ab
 *			|- c                                          |- c
 *
 * The wrapping node depends on passed parameter. If {@link engine.view.Element} was passed, it will be cloned and
 * the copy will become the wrapping element. If `Function` is provided, it is passed all the parameters of the
 * {@link engine.conversion.ModelConversionDispatcher#event:setAttribute setAttribute event}. It's expected that the
 * function returns a {@link engine.view.Element}. The result of the function will be the wrapping element.
 * When provided `Function` does not return element, then will be no conversion.
 *
 * The converter automatically consumes corresponding value from consumables list, stops the event (see
 * {@link engine.conversion.ModelConversionDispatcher}).
 *
 *		modelDispatcher.on( 'addAttribute:bold', wrap( new ViewElement( 'strong' ) ) );
 *
 * @external engine.conversion.modelToView
 * @function engine.conversion.modelToView.wrap
 * @param {engine.view.Element|Function} elementCreator View element, or function returning a view element, which will
 * be used for wrapping.
 * @returns {Function} Set/change attribute converter.
 */
function wrap(elementCreator) {
  return function (evt, data, consumable, conversionApi) {
    var viewRange = conversionApi.mapper.toViewRange(data.range);

    var viewElement = elementCreator instanceof Element$1 ? elementCreator.clone(true) : elementCreator(data.attributeNewValue, data, consumable, conversionApi);

    if (viewElement) {
      if (!consumable.consume(data.item, eventNameToConsumableType(evt.name))) {
        return;
      }

      // If this is a change event (because old value is not empty) and the creator is a function (so
      // it may create different view elements basing on attribute value) we have to create
      // view element basing on old value and unwrap it before wrapping with a newly created view element.
      if (data.attributeOldValue !== null && !(elementCreator instanceof Element$1)) {
        var oldViewElement = elementCreator(data.attributeOldValue, data, consumable, conversionApi);
        viewRange = viewWriter.unwrap(viewRange, oldViewElement, evt.priority);
      }

      viewWriter.wrap(viewRange, viewElement);
    }
  };
}

/**
 * Function factory, creates a converter that converts remove attribute changes from the model to the view. It assumes, that
 * attributes from model were converted to elements in the view. This converter will unwrap view nodes from corresponding
 * view element if given attribute was removed.
 *
 * The view element type that will be unwrapped depends on passed parameter.
 * If {@link engine.view.Element} was passed, it will be used to look for similar element in the view for unwrapping. If `Function`
 * is provided, it is passed all the parameters of the
 * {@link engine.conversion.ModelConversionDispatcher#event:setAttribute setAttribute event}. It's expected that the
 * function returns a {@link engine.view.Element}. The result of the function will be used to look for similar element
 * in the view for unwrapping.
 *
 * The converter automatically consumes corresponding value from consumables list, stops the event (see
 * {@link engine.conversion.ModelConversionDispatcher}) and bind model and view elements.
 *
 *		modelDispatcher.on( 'removeAttribute:bold', unwrap( new ViewElement( 'strong' ) ) );
 *
 * @see engine.conversion.modelToView.wrap
 * @external engine.conversion.modelToView
 * @function engine.conversion.modelToView.unwrap
 * @param {engine.view.Element|Function} elementCreator View element, or function returning a view element, which will
 * be used for unwrapping.
 * @returns {Function} Remove attribute converter.
 */
function unwrap(elementCreator) {
  return function (evt, data, consumable, conversionApi) {
    if (!consumable.consume(data.item, eventNameToConsumableType(evt.name))) {
      return;
    }

    var viewRange = conversionApi.mapper.toViewRange(data.range);
    var viewNode = elementCreator instanceof Element$1 ? elementCreator.clone(true) : elementCreator(data.attributeOldValue, data, consumable, conversionApi);

    viewWriter.unwrap(viewRange, viewNode);
  };
}

/**
 * Function factory, creates a default model-to-view converter for nodes move changes.
 *
 *		modelDispatcher.on( 'move', move() );
 *
 * @external engine.conversion.modelToView
 * @function engine.conversion.modelToView.move
 * @returns {Function} Move event converter.
 */
function move() {
  return function (evt, data, consumable, conversionApi) {
    if (!consumable.consume(data.item, 'move')) {
      return;
    }

    var sourceViewRange = void 0;

    if (data.item instanceof Element) {
      var viewElement = conversionApi.mapper.toViewElement(data.item);
      sourceViewRange = Range$2.createOn(viewElement);
    } else {
      var viewPosition = conversionApi.mapper.toViewPosition(data.sourcePosition);

      sourceViewRange = findViewTextRange(viewPosition, data.item.offsetSize);
    }

    var targetViewPosition = conversionApi.mapper.toViewPosition(data.targetPosition);

    viewWriter.move(sourceViewRange, targetViewPosition);
  };
}

/**
 * Function factory, creates a default model-to-view converter for node remove changes.
 *
 *		modelDispatcher.on( 'remove', remove() );
 *
 * @external engine.conversion.modelToView
 * @function engine.conversion.modelToView.remove
 * @returns {Function} Remove event converter.
 */
function remove() {
  return function (evt, data, consumable, conversionApi) {
    if (!consumable.consume(data.item, 'remove')) {
      return;
    }

    var viewRange = null;

    if (data.item instanceof Element) {
      var viewElement = conversionApi.mapper.toViewElement(data.item);
      viewRange = Range$2.createOn(viewElement);
    } else {
      var viewPosition = conversionApi.mapper.toViewPosition(data.sourcePosition);

      viewRange = findViewTextRange(viewPosition, data.item.offsetSize);
    }

    viewWriter.remove(viewRange);
    conversionApi.mapper.unbindModelElement(data.item);
  };
}

// Helper function for `remove` and `move` converters. It returns a ViewRange that starts at ViewPosition `start` and
// includes `size` characters.
// This method is used to find a ViewRange basing on ModelPosition and ModelTextProxy item size in `move` and `remove`
// converters where it is impossible to just map positions because those positions already are invalid in model
// (because they got moved or removed).
function findViewTextRange(start, size) {
  var walker = new TreeWalker$1({ startPosition: start, singleCharacters: true, ignoreElementEnd: true });
  var offset = 0;

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = walker[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var value = _step.value;

      if (value.item instanceof TextProxy$1) {
        offset++;

        if (offset == size) {
          return new Range$2(start, walker.position);
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

/**
 * Function factory, creates default model-to-view converter for elements which name has changed.
 *
 *		modelDispatcher.on( 'rename', rename() );
 *
 * This converter re-uses converters added for `insert`, `move` and `remove` change types.
 *
 * @external engine.conversion.modelToView
 * @function engine.conversion.modelToView.rename
 * @fires engine.conversion.ModelConversionDispatcher#event:insert
 * @fires engine.conversion.ModelConversionDispatcher#event:move
 * @fires engine.conversion.ModelConversionDispatcher#event:remove
 * @returns {Function}
 */
function rename() {
  return function (evt, data, consumable, conversionApi) {
    if (!consumable.consume(data.element, 'rename')) {
      return;
    }

    // Create fake model element that will represent "old version" of renamed element.
    var fakeElement = new Element(data.oldName, data.element.getAttributes());
    // Append the fake element to model document to enable making range on it.
    data.element.parent.insertChildren(data.element.index, fakeElement);

    // Check what was bound to renamed element.
    var oldViewElement = conversionApi.mapper.toViewElement(data.element);
    // Unbind renamed element.
    conversionApi.mapper.unbindModelElement(data.element);
    // Bind view element to the fake element.
    conversionApi.mapper.bindElements(fakeElement, oldViewElement);

    // The range that includes only the renamed element. Will be used to insert an empty element in the view.
    var insertRange = Range$1.createFromParentsAndOffsets(data.element.parent, data.element.startOffset, data.element, 0);

    // Move source position and range of moved nodes. Will be used to move nodes from original view element to renamed one.
    var moveSourcePosition = Position.createAt(fakeElement, 0);
    var moveRange = Range$1.createIn(data.element);

    // Remove range containing the fake element. Will be used to remove original view element from the view.
    var removeRange = Range$1.createOn(fakeElement);

    // Start the conversion. Use already defined converters by firing insertion, move and remove conversion
    // on correct ranges / positions.
    conversionApi.dispatcher.convertInsertion(insertRange);
    conversionApi.dispatcher.convertMove(moveSourcePosition, moveRange);
    conversionApi.dispatcher.convertRemove(removeRange.start, removeRange);

    // Cleanup.
    fakeElement.remove();
  };
}

/**
 * Returns the consumable type that is to be consumed in an event, basing on that event name.
 *
 * @param {String} evtName Event name.
 * @returns {String} Consumable type.
 */
function eventNameToConsumableType(evtName) {
  var parts = evtName.split(':');

  return parts[0] + ':' + parts[1];
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * This is a private helper-class for {@link engine.conversion.ViewConsumable}.
 * It represents and manipulates consumable parts of a single {@link engine.view.Element}.
 *
 * @private
 * @memberOf engine.conversion
 */

var ViewElementConsumables = function () {

	/**
  * Creates ViewElementConsumables instance.
  */
	function ViewElementConsumables() {
		classCallCheck(this, ViewElementConsumables);

		/**
   * Flag indicating if name of the element can be consumed.
   *
   * @private
   * @member {Boolean} engine.conversion.ViewElementConsumables#_canConsumeName
   */
		this._canConsumeName = null;

		/**
   * Contains maps of element's consumables: attributes, classes and styles.
   *
   * @private
   * @member {Object} engine.conversion.ViewElementConsumables#_consumables
   */
		this._consumables = {
			attribute: new Map(),
			style: new Map(),
			class: new Map()
		};
	}

	/**
  * Adds consumable parts of the {@link engine.view.Element view element}.
  * Element's name itself can be marked to be consumed (when element's name is consumed its attributes, classes and
  * styles still could be consumed):
  *
  *		consumables.add( { name: true } );
  *
  * Attributes classes and styles:
  *
  *		consumables.add( { attribute: 'title', class: 'foo', style: 'color' } );
  *		consumables.add( { attribute: [ 'title', 'name' ], class: [ 'foo', 'bar' ] );
  *
  * Throws {@link utils.CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
  * attribute is provided - it should be handled separately by providing `style` and `class` in consumables object.
  *
  * @param {Object} consumables Object describing which parts of the element can be consumed.
  * @param {Boolean} consumables.name If set to `true` element's name will be added as consumable.
  * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names to add as consumable.
  * @param {String|Array.<String>} consumables.class Class name or array of class names to add as consumable.
  * @param {String|Array.<String>} consumables.style Style name or array of style names to add as consumable.
  */


	createClass(ViewElementConsumables, [{
		key: 'add',
		value: function add(consumables) {
			if (consumables.name) {
				this._canConsumeName = true;
			}

			for (var type in this._consumables) {
				if (type in consumables) {
					this._add(type, consumables[type]);
				}
			}
		}

		/**
   * Tests if parts of the {@link engine.view.Element view element} can be consumed.
   *
   * Element's name can be tested:
   *
   *		consumables.test( { name: true } );
   *
   * Attributes classes and styles:
   *
   *		consumables.test( { attribute: 'title', class: 'foo', style: 'color' } );
   *		consumables.test( { attribute: [ 'title', 'name' ], class: [ 'foo', 'bar' ] );
   *
   * @param {Object} consumables Object describing which parts of the element should be tested.
   * @param {Boolean} consumables.name If set to `true` element's name will be tested.
   * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names to test.
   * @param {String|Array.<String>} consumables.class Class name or array of class names to test.
   * @param {String|Array.<String>} consumables.style Style name or array of style names to test.
   * @returns {Boolean|null} `true` when all tested items can be consumed, `null` when even one of the items
   * was never marked for consumption and `false` when even one of the items was already consumed.
   */

	}, {
		key: 'test',
		value: function test(consumables) {
			// Check if name can be consumed.
			if (consumables.name && !this._canConsumeName) {
				return this._canConsumeName;
			}

			for (var type in this._consumables) {
				if (type in consumables) {
					var value = this._test(type, consumables[type]);

					if (value !== true) {
						return value;
					}
				}
			}

			// Return true only if all can be consumed.
			return true;
		}

		/**
   * Consumes parts of {@link engine.view.Element view element}. This function does not check if consumable item
   * is already consumed - it consumes all consumable items provided.
   * Element's name can be consumed:
   *
   *		consumables.consume( { name: true } );
   *
   * Attributes classes and styles:
   *
   *		consumables.consume( { attribute: 'title', class: 'foo', style: 'color' } );
   *		consumables.consume( { attribute: [ 'title', 'name' ], class: [ 'foo', 'bar' ] );
   *
   * @param {Object} consumables Object describing which parts of the element should be consumed.
   * @param {Boolean} consumables.name If set to `true` element's name will be consumed.
   * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names to consume.
   * @param {String|Array.<String>} consumables.class Class name or array of class names to consume.
   * @param {String|Array.<String>} consumables.style Style name or array of style names to consume.
   */

	}, {
		key: 'consume',
		value: function consume(consumables) {
			if (consumables.name) {
				this._canConsumeName = false;
			}

			for (var type in this._consumables) {
				if (type in consumables) {
					this._consume(type, consumables[type]);
				}
			}
		}

		/**
   * Revert already consumed parts of {@link engine.view.Element view Element}, so they can be consumed once again.
   * Element's name can be reverted:
   *
   *		consumables.revert( { name: true } );
   *
   * Attributes classes and styles:
   *
   *		consumables.revert( { attribute: 'title', class: 'foo', style: 'color' } );
   *		consumables.revert( { attribute: [ 'title', 'name' ], class: [ 'foo', 'bar' ] );
   *
   * @param {Object} consumables Object describing which parts of the element should be reverted.
   * @param {Boolean} consumables.name If set to `true` element's name will be reverted.
   * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names to revert.
   * @param {String|Array.<String>} consumables.class Class name or array of class names to revert.
   * @param {String|Array.<String>} consumables.style Style name or array of style names to revert.
   */

	}, {
		key: 'revert',
		value: function revert(consumables) {
			if (consumables.name) {
				this._canConsumeName = true;
			}

			for (var type in this._consumables) {
				if (type in consumables) {
					this._revert(type, consumables[type]);
				}
			}
		}

		/**
   * Helper method that adds consumables of a given type: attribute, class or style.
   *
   * Throws {@link utils.CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
   * type is provided - it should be handled separately by providing actual style/class type.
   *
   * @private
   * @param {String} type Type of the consumable item: `attribute`, `class` or `style`.
   * @param {String|Array.<String>} item Consumable item or array of items.
   */

	}, {
		key: '_add',
		value: function _add(type, item) {
			var items = isArray(item) ? item : [item];
			var consumables = this._consumables[type];

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var name = _step.value;

					if (type === 'attribute' && (name === 'class' || name === 'style')) {
						/**
       * Class and style attributes should be handled separately.
       *
       * @error viewconsumable-invalid-attribute
       */
						throw new CKEditorError('viewconsumable-invalid-attribute: Classes and styles should be handled separately.');
					}

					consumables.set(name, true);
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		}

		/**
   * Helper method that tests consumables of a given type: attribute, class or style.
   *
   * @private
   * @param {String} type Type of the consumable item: `attribute`, `class` or `style`.
   * @param {String|Array.<String>} item Consumable item or array of items.
   * @returns {Boolean|null} Returns `true` if all items can be consumed, `null` when one of the items cannot be
   * consumed and `false` when one of the items is already consumed.
   */

	}, {
		key: '_test',
		value: function _test(type, item) {
			var items = isArray(item) ? item : [item];
			var consumables = this._consumables[type];

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = items[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var name = _step2.value;

					if (type === 'attribute' && (name === 'class' || name === 'style')) {
						// Check all classes/styles if class/style attribute is tested.
						var value = this._test(name, [].concat(toConsumableArray(this._consumables[name].keys())));

						if (value !== true) {
							return value;
						}
					} else {
						var _value = consumables.get(name);
						// Return null if attribute is not found.
						if (_value === undefined) {
							return null;
						}

						if (!_value) {
							return false;
						}
					}
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			return true;
		}

		/**
   * Helper method that consumes items of a given type: attribute, class or style.
   *
   * @private
   * @param {String} type Type of the consumable item: `attribute`, `class` or `style`.
   * @param {String|Array.<String>} item Consumable item or array of items.
   */

	}, {
		key: '_consume',
		value: function _consume(type, item) {
			var items = isArray(item) ? item : [item];
			var consumables = this._consumables[type];

			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = items[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var name = _step3.value;

					if (type === 'attribute' && (name === 'class' || name === 'style')) {
						// If class or style is provided for consumption - consume them all.
						this._consume(name, [].concat(toConsumableArray(this._consumables[name].keys())));
					} else {
						consumables.set(name, false);
					}
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}
		}

		/**
   * Helper method that reverts items of a given type: attribute, class or style.
   *
   * @private
   * @param {String} type Type of the consumable item: `attribute`, `class` or , `style`.
   * @param {String|Array.<String>} item Consumable item or array of items.
   */

	}, {
		key: '_revert',
		value: function _revert(type, item) {
			var items = isArray(item) ? item : [item];
			var consumables = this._consumables[type];

			var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
				for (var _iterator4 = items[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var name = _step4.value;

					if (type === 'attribute' && (name === 'class' || name === 'style')) {
						// If class or style is provided for reverting - revert them all.
						this._revert(name, [].concat(toConsumableArray(this._consumables[name].keys())));
					} else {
						var value = consumables.get(name);

						if (value === false) {
							consumables.set(name, true);
						}
					}
				}
			} catch (err) {
				_didIteratorError4 = true;
				_iteratorError4 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion4 && _iterator4.return) {
						_iterator4.return();
					}
				} finally {
					if (_didIteratorError4) {
						throw _iteratorError4;
					}
				}
			}
		}
	}]);
	return ViewElementConsumables;
}();

/**
 * Class used for handling consumption of view {@link engine.view.Element elements},
 * {@link engine.view.Text text nodes} and {@link engine.view.DocumentFragment document fragments}.
 * Element's name and its parts (attributes, classes and styles) can be consumed separately. Consuming an element's name
 * does not consume its attributes, classes and styles.
 * To add items for consumption use {@link engine.conversion.ViewConsumable#add add method}.
 * To test items use {@link engine.conversion.ViewConsumable#test test method}.
 * To consume items use {@link engine.conversion.ViewConsumable#consume consume method}.
 * To revert already consumed items use {@link engine.conversion.ViewConsumable#revert revert method}.
 *
 *		viewConsumable.add( element, { name: true } ); // Adds element's name as ready to be consumed.
 *		viewConsumable.add( textNode ); // Adds text node for consumption.
 *		viewConsumable.add( docFragment ); // Adds document fragment for consumption.
 *		viewConsumable.test( element, { name: true }  ); // Tests if element's name can be consumed.
 *		viewConsumable.test( textNode ); // Tests if text node can be consumed.
 *		viewConsumable.test( docFragment ); // Tests if document fragment can be consumed.
 *		viewConsumable.consume( element, { name: true }  ); // Consume element's name.
 *		viewConsumable.consume( textNode ); // Consume text node.
 *		viewConsumable.consume( docFragment ); // Consume document fragment.
 *		viewConsumable.revert( element, { name: true }  ); // Revert already consumed element's name.
 *		viewConsumable.revert( textNode ); // Revert already consumed text node.
 *		viewConsumable.revert( docFragment ); // Revert already consumed document fragment.
 *
 * @memberOf engine.conversion
 */


var ViewConsumable = function () {

	/**
  * Creates new ViewConsumable.
  */
	function ViewConsumable() {
		classCallCheck(this, ViewConsumable);

		/**
   * Map of consumable elements. If {@link engine.view.Element element} is used as a key,
   * {@link engine.conversion.ViewElementConsumables ViewElementConsumables} instance is stored as value.
   * For {@link engine.view.Text text nodes} and {@link engine.view.DocumentFragment document fragments}
   * boolean value is stored as value.
   *
   * @protected
   * @member {Map.<engine.conversion.ViewElementConsumables|Boolean>} engine.conversion.ViewConsumable#_consumables
  */
		this._consumables = new Map();
	}

	/**
  * Adds {@link engine.view.Element view element}, {@link engine.view.Text text node} or
  * {@link engine.view.DocumentFragment document fragment} as ready to be consumed.
  *
  *		viewConsumable.add( p, { name: true } ); // Adds element's name to consume.
  *		viewConsumable.add( p, { attribute: 'name' } ); // Adds element's attribute.
  *		viewConsumable.add( p, { class: 'foobar' } ); // Adds element's class.
  *		viewConsumable.add( p, { style: 'color' } ); // Adds element's style
  *		viewConsumable.add( p, { attribute: 'name', style: 'color' } ); // Adds attribute and style.
  *		viewConsumable.add( p, { class: [ 'baz', 'bar' ] } ); // Multiple consumables can be provided.
  *		viewConsumable.add( textNode ); // Adds text node to consume.
  *		viewConsumable.add( docFragment ); // Adds document fragment to consume.
  *
  * Throws {@link utils.CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
  * attribute is provided - it should be handled separately by providing actual style/class.
  *
  *		viewConsumable.add( p, { attribute: 'style' } ); // This call will throw an exception.
  *		viewConsumable.add( p, { style: 'color' } ); // This is properly handled style.
  *
  * @param {engine.view.Element|engine.view.Text|engine.view.DocumentFragment} element
  * @param {Object} [consumables] Used only if first parameter is {@link engine.view.Element view element} instance.
  * @param {Boolean} consumables.name If set to true element's name will be included.
  * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names.
  * @param {String|Array.<String>} consumables.class Class name or array of class names.
  * @param {String|Array.<String>} consumables.style Style name or array of style names.
  */


	createClass(ViewConsumable, [{
		key: 'add',
		value: function add(element, consumables) {
			var elementConsumables = void 0;

			// For text nodes and document fragments just mark them as consumable.
			if (element instanceof Text$2 || element instanceof DocumentFragment$1) {
				this._consumables.set(element, true);

				return;
			}

			// For elements create new ViewElementConsumables or update already existing one.
			if (!this._consumables.has(element)) {
				elementConsumables = new ViewElementConsumables();
				this._consumables.set(element, elementConsumables);
			} else {
				elementConsumables = this._consumables.get(element);
			}

			elementConsumables.add(consumables);
		}

		/**
   * Tests if {@link engine.view.Element view element}, {@link engine.view.Text text node} or
   * {@link engine.view.DocumentFragment document fragment} can be consumed.
   * It returns `true` when all items included in method's call can be consumed. Returns `false` when
   * first already consumed item is found and `null` when first non-consumable item is found.
   *
   *		viewConsumable.test( p, { name: true } ); // Tests element's name.
   *		viewConsumable.test( p, { attribute: 'name' } ); // Tests attribute.
   *		viewConsumable.test( p, { class: 'foobar' } ); // Tests class.
   *		viewConsumable.test( p, { style: 'color' } ); // Tests style.
   *		viewConsumable.test( p, { attribute: 'name', style: 'color' } ); // Tests attribute and style.
   *		viewConsumable.test( p, { class: [ 'baz', 'bar' ] } ); // Multiple consumables can be tested.
   *		viewConsumable.test( textNode ); // Tests text node.
   *		viewConsumable.test( docFragment ); // Tests document fragment.
   *
   * Testing classes and styles as attribute will test if all added classes/styles can be consumed.
   *
   *		viewConsumable.test( p, { attribute: 'class' } ); // Tests if all added classes can be consumed.
   *		viewConsumable.test( p, { attribute: 'style' } ); // Tests if all added styles can be consumed.
   *
   * @param {engine.view.Element|engine.view.Text|engine.view.DocumentFragment} element
   * @param {Object} [consumables] Used only if first parameter is {@link engine.view.Element view element} instance.
   * @param {Boolean} consumables.name If set to true element's name will be included.
   * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names.
   * @param {String|Array.<String>} consumables.class Class name or array of class names.
   * @param {String|Array.<String>} consumables.style Style name or array of style names.
   * @returns {Boolean|null} Returns `true` when all items included in method's call can be consumed. Returns `false`
   * when first already consumed item is found and `null` when first non-consumable item is found.
   */

	}, {
		key: 'test',
		value: function test(element, consumables) {
			var elementConsumables = this._consumables.get(element);

			if (elementConsumables === undefined) {
				return null;
			}

			// For text nodes and document fragments return stored boolean value.
			if (element instanceof Text$2 || element instanceof DocumentFragment$1) {
				return elementConsumables;
			}

			// For elements test consumables object.
			return elementConsumables.test(consumables);
		}

		/**
   * Consumes {@link engine.view.Element view element}, {@link engine.view.Text text node} or
   * {@link engine.view.DocumentFragment document fragment}.
   * It returns `true` when all items included in method's call can be consumed, otherwise returns `false`.
   *
   *		viewConsumable.consume( p, { name: true } ); // Consumes element's name.
   *		viewConsumable.consume( p, { attribute: 'name' } ); // Consumes element's attribute.
   *		viewConsumable.consume( p, { class: 'foobar' } ); // Consumes element's class.
   *		viewConsumable.consume( p, { style: 'color' } ); // Consumes element's style.
   *		viewConsumable.consume( p, { attribute: 'name', style: 'color' } ); // Consumes attribute and style.
   *		viewConsumable.consume( p, { class: [ 'baz', 'bar' ] } ); // Multiple consumables can be consumed.
   *		viewConsumable.consume( textNode ); // Consumes text node.
   *		viewConsumable.consume( docFragment ); // Consumes document fragment.
   *
   * Consuming classes and styles as attribute will test if all added classes/styles can be consumed.
   *
   *		viewConsumable.consume( p, { attribute: 'class' } ); // Consume only if all added classes can be consumed.
   *		viewConsumable.consume( p, { attribute: 'style' } ); // Consume only if all added styles can be consumed.
   *
   * @param {engine.view.Element|engine.view.Text|engine.view.DocumentFragment} element
   * @param {Object} [consumables] Used only if first parameter is {@link engine.view.Element view element} instance.
   * @param {Boolean} consumables.name If set to true element's name will be included.
   * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names.
   * @param {String|Array.<String>} consumables.class Class name or array of class names.
   * @param {String|Array.<String>} consumables.style Style name or array of style names.
   * @returns {Boolean} Returns `true` when all items included in method's call can be consumed,
   * otherwise returns `false`.
   */

	}, {
		key: 'consume',
		value: function consume(element, consumables) {
			if (this.test(element, consumables)) {
				if (element instanceof Text$2 || element instanceof DocumentFragment$1) {
					// For text nodes and document fragments set value to false.
					this._consumables.set(element, false);
				} else {
					// For elements - consume consumables object.
					this._consumables.get(element).consume(consumables);
				}

				return true;
			}

			return false;
		}

		/**
   * Reverts {@link engine.view.Element view element}, {@link engine.view.Text text node} or
   * {@link engine.view.DocumentFragment document fragment} so they can be consumed once again.
   * Method does not revert items that were never previously added for consumption, even if they are included in
   * method's call.
   *
   *		viewConsumable.revert( p, { name: true } ); // Reverts element's name.
   *		viewConsumable.revert( p, { attribute: 'name' } ); // Reverts element's attribute.
   *		viewConsumable.revert( p, { class: 'foobar' } ); // Reverts element's class.
   *		viewConsumable.revert( p, { style: 'color' } ); // Reverts element's style.
   *		viewConsumable.revert( p, { attribute: 'name', style: 'color' } ); // Reverts attribute and style.
   *		viewConsumable.revert( p, { class: [ 'baz', 'bar' ] } ); // Multiple names can be reverted.
   *		viewConsumable.revert( textNode ); // Reverts text node.
   *		viewConsumable.revert( docFragment ); // Reverts document fragment.
   *
   * Reverting classes and styles as attribute will revert all classes/styles that were previously added for
   * consumption.
   *
   *		viewConsumable.revert( p, { attribute: 'class' } ); // Reverts all classes added for consumption.
   *		viewConsumable.revert( p, { attribute: 'style' } ); // Reverts all styles added for consumption.
   *
   * @param {engine.view.Element|engine.view.Text|engine.view.DocumentFragment} element
   * @param {Object} [consumables] Used only if first parameter is {@link engine.view.Element view element} instance.
   * @param {Boolean} consumables.name If set to true element's name will be included.
   * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names.
   * @param {String|Array.<String>} consumables.class Class name or array of class names.
   * @param {String|Array.<String>} consumables.style Style name or array of style names.
   */

	}, {
		key: 'revert',
		value: function revert(element, consumables) {
			var elementConsumables = this._consumables.get(element);

			if (elementConsumables !== undefined) {
				if (element instanceof Text$2 || element instanceof DocumentFragment$1) {
					// For text nodes and document fragments - set consumable to true.
					this._consumables.set(element, true);
				} else {
					// For elements - revert items from consumables object.
					elementConsumables.revert(consumables);
				}
			}
		}

		/**
   * Creates consumable object from {@link engine.view.Element view element}. Consumable object will include
   * element's name and all its attributes, classes and styles.
   *
   * @static
   * @param {engine.view.Element} element
   * @returns {Object} consumables
   */

	}], [{
		key: 'consumablesFromElement',
		value: function consumablesFromElement(element) {
			var consumables = {
				name: true,
				attribute: [],
				class: [],
				style: []
			};

			var attributes = element.getAttributeKeys();

			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = attributes[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var attribute = _step5.value;

					// Skip classes and styles - will be added separately.
					if (attribute == 'style' || attribute == 'class') {
						continue;
					}

					consumables.attribute.push(attribute);
				}
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5.return) {
						_iterator5.return();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}

			var classes = element.getClassNames();

			var _iteratorNormalCompletion6 = true;
			var _didIteratorError6 = false;
			var _iteratorError6 = undefined;

			try {
				for (var _iterator6 = classes[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
					var className = _step6.value;

					consumables.class.push(className);
				}
			} catch (err) {
				_didIteratorError6 = true;
				_iteratorError6 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion6 && _iterator6.return) {
						_iterator6.return();
					}
				} finally {
					if (_didIteratorError6) {
						throw _iteratorError6;
					}
				}
			}

			var styles = element.getStyleNames();

			var _iteratorNormalCompletion7 = true;
			var _didIteratorError7 = false;
			var _iteratorError7 = undefined;

			try {
				for (var _iterator7 = styles[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
					var style = _step7.value;

					consumables.style.push(style);
				}
			} catch (err) {
				_didIteratorError7 = true;
				_iteratorError7 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion7 && _iterator7.return) {
						_iterator7.return();
					}
				} finally {
					if (_didIteratorError7) {
						throw _iteratorError7;
					}
				}
			}

			return consumables;
		}

		/**
   * Creates {@link engine.conversion.ViewConsumable ViewConsumable} instance from
   * {@link engine.view.Element element} or {@link engine.view.DocumentFragment document fragment}.
   * Instance will contain all elements, child nodes, attributes, styles and classes added for consumption.
   *
   * @static
   * @param {engine.view.Element|engine.view.DocumentFragment} from View element or document fragment
   * from which `ViewConsumable` will be created.
   * @param {engine.conversion.ViewConsumable} [instance] If provided, given `ViewConsumable` instance will be used
   * to add all consumables. It will be returned instead of a new instance.
   */

	}, {
		key: 'createFrom',
		value: function createFrom(from, instance) {
			if (!instance) {
				instance = new ViewConsumable();
			}

			if (from instanceof Text$2) {
				instance.add(from);

				return instance;
			}

			// Add `from` itself, if it is an element.
			if (from instanceof Element$1) {
				instance.add(from, ViewConsumable.consumablesFromElement(from));
			}

			if (from instanceof DocumentFragment$1) {
				instance.add(from);
			}

			var _iteratorNormalCompletion8 = true;
			var _didIteratorError8 = false;
			var _iteratorError8 = undefined;

			try {
				for (var _iterator8 = from.getChildren()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
					var child = _step8.value;

					instance = ViewConsumable.createFrom(child, instance);
				}
			} catch (err) {
				_didIteratorError8 = true;
				_iteratorError8 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion8 && _iterator8.return) {
						_iterator8.return();
					}
				} finally {
					if (_didIteratorError8) {
						throw _iteratorError8;
					}
				}
			}

			return instance;
		}
	}]);
	return ViewConsumable;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * `ViewConversionDispatcher` is a central point of {@link engine.view view} conversion, which is a process of
 * converting given {@link engine.view.DocumentFragment view document fragment} or {@link engine.view.Element}
 * into another structure. In default application, {@link engine.view view} is converted to {@link engine.model}.
 *
 * During conversion process, for all {@link engine.view.Node view nodes} from the converted view document fragment,
 * `ViewConversionDispatcher` fires corresponding events. Special callbacks called "converters" should listen to
 * `ViewConversionDispatcher` for those events.
 *
 * Each callback, as a first argument, is passed a special object `data` that has `input` and `output` properties.
 * `input` property contains {@link engine.view.Node view node} or {@link engine.view.DocumentFragment view document fragment}
 * that is converted at the moment and might be handled by the callback. `output` property should be used to save the result
 * of conversion. Keep in mind that the `data` parameter is customizable and may contain other values - see
 * {@link engine.conversion.ViewConversionDispatcher#convert}. It is also shared by reference by all callbacks
 * listening to given event. **Note**: in view to model conversion - `data` contains `context` property that is an array
 * of {@link engine.model.Element model elements}. These are model elements that will be the parent of currently
 * converted view item. `context` property is used in examples below.
 *
 * The second parameter passed to a callback is an instance of {@link engine.conversion.ViewConsumable}. It stores
 * information about what parts of processed view item are still waiting to be handled. After a piece of view item
 * was converted, appropriate consumable value should be {@link engine.conversion.ViewConsumable#consume consumed}.
 *
 * The third parameter passed to a callback is an instance of {@link engine.conversion.ViewConversionDispatcher}
 * which provides additional tools for converters.
 *
 * Examples of providing callbacks for `ViewConversionDispatcher`:
 *
 *		// Converter for paragraphs (<p>).
 *		viewDispatcher.on( 'element:p', ( data, consumable, conversionApi ) => {
 *			const paragraph = new ModelElement( 'paragraph' );
 *			const schemaQuery = {
 *				name: 'paragraph',
 *				inside: data.context
 *			};
 *
 *			if ( conversionApi.schema.check( schemaQuery ) ) {
 *				if ( !consumable.consume( data.input, { name: true } ) ) {
 *					// Before converting this paragraph's children we have to update their context by this paragraph.
 *					data.context.push( paragraph );
 *					const children = conversionApi.convertChildren( data.input, consumable, data );
 *					data.context.pop();
 *					paragraph.appendChildren( children );
 *					data.output = paragraph;
 *				}
 *			}
 *		} );
 *
 *		// Converter for links (<a>).
 *		viewDispatcher.on( 'element:a', ( data, consumable, conversionApi ) => {
 *			if ( consumable.consume( data.input, { name: true, attributes: [ 'href' ] } ) ) {
 *				// <a> element is inline and is represented by an attribute in the model.
 *				// This is why we are not updating `context` property.
 *				data.output = conversionApi.convertChildren( data.input, consumable, data );
 *
 *				for ( let item of Range.createFrom( data.output ) ) {
 *					const schemaQuery = {
 *						name: item.name || '$text',
 *						attribute: 'link',
 *						inside: data.context
 *					};
 *
 *					if ( conversionApi.schema.checkQuery( schemaQuery ) ) {
 *						item.setAttribute( 'link', data.input.getAttribute( 'href' ) );
 *					}
 *				}
 *			}
 *		} );
 *
 *		// Fire conversion.
 *		// Always take care where the converted model structure will be appended to. If this `viewDocumentFragment`
 *		// is going to be appended directly to a '$root' element, use that in `context`.
 *		viewDispatcher.convert( viewDocumentFragment, { context: [ '$root' ] } );
 *
 * Before each conversion process, `ViewConversionDispatcher` fires {@link engine.conversion.ViewConversionDispatcher#viewCleanup}
 * event which can be used to prepare tree view for conversion.
 *
 * @mixes utils.EmitterMixin
 * @fires engine.conversion.ViewConversionDispatcher#viewCleanup
 * @fires engine.conversion.ViewConversionDispatcher#element
 * @fires engine.conversion.ViewConversionDispatcher#text
 * @fires engine.conversion.ViewConversionDispatcher#documentFragment
 *
 * @memberOf engine.conversion
 */

var ViewConversionDispatcher = function () {
  /**
   * Creates a `ViewConversionDispatcher` that operates using passed API.
   *
   * @see engine.conversion.ViewConversionApi
   * @param {Object} [conversionApi] Additional properties for interface that will be passed to events fired
   * by `ViewConversionDispatcher`.
   */
  function ViewConversionDispatcher() {
    var conversionApi = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    classCallCheck(this, ViewConversionDispatcher);

    /**
     * Interface passed by dispatcher to the events callbacks.
     *
     * @member {engine.conversion.ViewConversionApi} engine.conversion.ViewConversionDispatcher#conversionApi
     */
    this.conversionApi = assignIn({}, conversionApi);

    // `convertItem` and `convertChildren` are bound to this `ViewConversionDispatcher` instance and
    // set on `conversionApi`. This way only a part of `ViewConversionDispatcher` API is exposed.
    this.conversionApi.convertItem = this._convertItem.bind(this);
    this.conversionApi.convertChildren = this._convertChildren.bind(this);
  }

  /**
   * Starts the conversion process. The entry point for the conversion.
   *
   * @fires engine.conversion.ViewConversionDispatcher#element
   * @fires engine.conversion.ViewConversionDispatcher#text
   * @fires engine.conversion.ViewConversionDispatcher#documentFragment
   * @param {engine.view.DocumentFragment|engine.view.Element} viewItem Part of the view to be converted.
   * @param {Object} [additionalData] Additional data to be passed in `data` argument when firing `ViewConversionDispatcher`
   * events. See also {@link engine.conversion.ViewConversionDispatcher#element element event}.
   * @returns {engine.model.DocumentFragment} Model document fragment that is a result of the conversion process.
   */


  createClass(ViewConversionDispatcher, [{
    key: 'convert',
    value: function convert(viewItem) {
      var additionalData = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      this.fire('viewCleanup', viewItem);

      var consumable = ViewConsumable.createFrom(viewItem);

      return this._convertItem(viewItem, consumable, additionalData);
    }

    /**
     * @private
     * @see engine.conversion.ViewConversionApi#convertItem
     */

  }, {
    key: '_convertItem',
    value: function _convertItem(input, consumable) {
      var additionalData = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

      var data = assignIn({}, additionalData, {
        input: input,
        output: null
      });

      if (input instanceof Element$1) {
        this.fire('element:' + input.name, data, consumable, this.conversionApi);
      } else if (input instanceof Text$2) {
        this.fire('text', data, consumable, this.conversionApi);
      } else {
        this.fire('documentFragment', data, consumable, this.conversionApi);
      }

      return data.output;
    }

    /**
     * @private
     * @see engine.conversion.ViewConversionApi#convertChildren
     */

  }, {
    key: '_convertChildren',
    value: function _convertChildren(input, consumable) {
      var _this = this;

      var additionalData = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

      var viewChildren = Array.from(input.getChildren());
      var convertedChildren = viewChildren.map(function (viewChild) {
        return _this._convertItem(viewChild, consumable, additionalData);
      });

      // Flatten and remove nulls.
      return convertedChildren.reduce(function (a, b) {
        return b ? a.concat(b) : a;
      }, []);
    }

    /**
     * Fired before the first conversion event, at the beginning of view to model conversion process.
     *
     * @event engine.conversion.ViewConversionDispatcher#viewCleanup
     * @param {engine.view.DocumentFragment|engine.view.Element} viewItem Part of the view to be converted.
     */

    /**
     * Fired when {@link engine.view.Element} is converted.
     *
     * `element` is a namespace event for a class of events. Names of actually called events follow this pattern:
     * `element:<elementName>` where `elementName` is the name of converted element. This way listeners may listen to
     * all elements conversion or to conversion of specific elements.
     *
     * @event engine.conversion.ViewConversionDispatcher#element
     * @param {Object} data Object containing conversion input and a placeholder for conversion output and possibly other
     * values (see {@link engine.conversion.ViewConversionDispatcher#convert}). Keep in mind that this object is shared
     * by reference between all callbacks that will be called. This means that callbacks can add their own values if needed,
     * and those values will be available in other callbacks.
     * @param {engine.view.Element} data.input Converted element.
     * @param {*} data.output The current state of conversion result. Every change to converted element should
     * be reflected by setting or modifying this property.
     * @param {engine.model.SchemaPath} data.context The conversion context.
     * @param {engine.conversion.ViewConsumable} consumable Values to consume.
     * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ViewConversionDispatcher` constructor.
     * Besides of properties passed in constructor, it also has `convertItem` and `convertChildren` methods which are references
     * to {@link engine.conversion.ViewConversionDispatcher#_convertItem} and
     * {@link engine.conversion.ViewConversionDispatcher#_convertChildren}. Those methods are needed to convert
     * the whole view-tree they were exposed in `conversionApi` for callbacks.
     */

    /**
     * Fired when {@link engine.view.Text} is converted.
     *
     * @event engine.conversion.ViewConversionDispatcher#text
     * @see engine.conversion.ViewConversionDispatcher#element
     */

    /**
     * Fired when {@link engine.view.DocumentFragment} is converted.
     *
     * @event engine.conversion.ViewConversionDispatcher#documentFragment
     * @see engine.conversion.ViewConversionDispatcher#element
     */

  }]);
  return ViewConversionDispatcher;
}();

mix(ViewConversionDispatcher, EmitterMixin);

/**
 * Conversion interface that is registered for given {@link engine.conversion.ViewConversionDispatcher} and is
 * passed as one of parameters when {@link engine.conversion.ViewConversionDispatcher dispatcher} fires it's events.
 *
 * `ViewConversionApi` object is built by {@link engine.conversion.ViewConversionDispatcher} constructor. The exact
 * list of properties of this object is determined by the object passed to the constructor.
 *
 * @interface engine.conversion.ViewConversionApi
 */

/**
 * Starts conversion of given item by firing an appropriate event.
 *
 * Every fired event is passed (as first parameter) an object with `output` property. Every event may set and/or
 * modify that property. When all callbacks are done, the final value of `output` property is returned by this method.
 *
 * @memberOf engine.conversion.ViewConversionApi
 * @function covertItem
 * @fires engine.conversion.ViewConversionDispatcher#element
 * @fires engine.conversion.ViewConversionDispatcher#text
 * @fires engine.conversion.ViewConversionDispatcher#documentFragment
 * @param {engine.view.DocumentFragment|engine.view.Element|engine.view.Text} input Item to convert.
 * @param {engine.conversion.ViewConsumable} consumable Values to consume.
 * @param {Object} [additionalData] Additional data to be passed in `data` argument when firing `ViewConversionDispatcher`
 * events. See also {@link engine.conversion.ViewConversionDispatcher#element element event}.
 * @returns {*} The result of item conversion, created and modified by callbacks attached to fired event.
 */

/**
 * Starts conversion of all children of given item by firing appropriate events for all those children.
 *
 * @memberOf engine.conversion.ViewConversionApi
 * @function convertChildren
 * @fires engine.conversion.ViewConversionDispatcher#element
 * @fires engine.conversion.ViewConversionDispatcher#text
 * @fires engine.conversion.ViewConversionDispatcher#documentFragment
 * @param {engine.view.DocumentFragment|engine.view.Element} input Item which children will be converted.
 * @param {engine.conversion.ViewConsumable} consumable Values to consume.
 * @param {Object} [additionalData] Additional data to be passed in `data` argument when firing `ViewConversionDispatcher`
 * events. See also {@link engine.conversion.ViewConversionDispatcher#element element event}.
 * @returns {Array.<*>} Array containing results of conversion of all children of given item.
 */

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Contains functions used for composing model tree, grouped together under "model writer" name. Those functions
 * are built on top of {@link engine.model.Node node}, and it's child classes', APIs.
 *
 * Model writer API has multiple advantages and it is highly recommended to use it when changing model tree and nodes:
 * * model writer API {@link engine.model.writer.normalizeNodes normalizes inserted nodes}, which means that you can insert
 * not only {@link engine.model.Node nodes}, but also `String`s, {@link engine.model.TextProxy text proxies} and
 * {@link engine.model.DocumentFragment document fragments},
 * * model writer API operates on {@link engine.model.Position positions}, which means that you have
 * better control over manipulating model tree as positions operate on offsets rather than indexes,
 * * model writer API automatically merges {@link engine.model.TextNode text nodes} with same attributes, which means
 * lower memory usage and better efficiency.
 *
 * @namespace engine.model.writer
 */

var modelWriter = {
	insert: insert$1,
	remove: remove$2,
	move: move$2,
	setAttribute: setAttribute$1,
	removeAttribute: removeAttribute$1,
	normalizeNodes: normalizeNodes
};

/**
 * Inserts given nodes at given position.
 *
 * @function engine.model.writer.insert
 * @param {engine.model.Position} position Position at which nodes should be inserted.
 * @param {engine.model.NodeSet} nodes Nodes to insert.
 * @returns {engine.model.Range} Range spanning over inserted elements.
 */
function insert$1(position, nodes) {
	nodes = normalizeNodes(nodes);

	// We have to count offset before inserting nodes because they can get merged and we would get wrong offsets.
	var offset = nodes.reduce(function (sum, node) {
		return sum + node.offsetSize;
	}, 0);
	var parent = position.parent;

	// Insertion might be in a text node, we should split it if that's the case.
	_splitNodeAtPosition(position);
	var index = position.index;

	// Insert nodes at given index. After splitting we have a proper index and insertion is between nodes,
	// using basic `Element` API.
	parent.insertChildren(index, nodes);

	// Merge text nodes, if possible. Merging is needed only at points where inserted nodes "touch" "old" nodes.
	_mergeNodesAtIndex(parent, index + nodes.length);
	_mergeNodesAtIndex(parent, index);

	return new Range$1(position, position.getShiftedBy(offset));
}

/**
 * Removed nodes in given range. Only {@link engine.model.Range#isFlat flat} ranges are accepted.
 *
 * @function engine.model.writer.remove
 * @param {engine.model.Range} range Range containing nodes to remove.
 * @returns {Array.<engine.model.Node>}
 */
function remove$2(range) {
	if (!range.isFlat) {
		/**
   * Trying to remove a range that starts and ends in different element.
   *
   * @error model-writer-remove-range-not-flat
   */
		throw new CKEditorError('model-writer-remove-range-not-flat: ' + 'Trying to remove a range that starts and ends in different element.');
	}

	var parent = range.start.parent;

	// Range may be inside text nodes, we have to split them if that's the case.
	_splitNodeAtPosition(range.start);
	_splitNodeAtPosition(range.end);

	// Remove the text nodes using basic `Element` API.
	var removed = parent.removeChildren(range.start.index, range.end.index - range.start.index);

	// Merge text nodes, if possible. After some nodes were removed, node before and after removed range will be
	// touching at the position equal to the removed range beginning. We check merging possibility there.
	_mergeNodesAtIndex(parent, range.start.index);

	return removed;
}

/**
 * Moves nodes in given range to given target position. Only {@link engine.model.Range#isFlat flat} ranges are accepted.
 *
 * @param {engine.model.Range} sourceRange Range containing nodes to move.
 * @param {engine.model.Position} targetPosition Position to which nodes should be moved.
 * @returns {engine.model.Range} Range containing moved nodes.
 */
function move$2(sourceRange, targetPosition) {
	/* jshint validthis:true */
	if (!sourceRange.isFlat) {
		/**
   * Trying to move a range that starts and ends in different element.
   *
   * @error model-writer-move-range-not-flat
   */
		throw new CKEditorError('model-writer-move-range-not-flat: ' + 'Trying to move a range that starts and ends in different element.');
	}

	var nodes = this.remove(sourceRange);

	// We have to fix `targetPosition` because model changed after nodes from `sourceRange` got removed and
	// that change might have an impact on `targetPosition`.
	targetPosition = targetPosition._getTransformedByDeletion(sourceRange.start, sourceRange.end.offset - sourceRange.start.offset);

	return this.insert(targetPosition, nodes);
}

/**
 * Sets given attribute on nodes in given range.
 *
 * @param {engine.model.Range} range Range containing nodes that should have the attribute set.
 * @param {String} key Key of attribute to set.
 * @param {*} value Attribute value.
 */
function setAttribute$1(range, key, value) {
	// Range might start or end in text nodes, so we have to split them.
	_splitNodeAtPosition(range.start);
	_splitNodeAtPosition(range.end);

	// Iterate over all items in the range.
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = range.getItems()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var item = _step.value;

			// Iterator will return `TextProxy` instances but we know that those text proxies will
			// always represent full text nodes (this is guaranteed thanks to splitting we did before).
			// So, we can operate on those text proxies' text nodes.
			var node = item instanceof TextProxy ? item.textNode : item;

			if (value !== null) {
				node.setAttribute(key, value);
			} else {
				node.removeAttribute(key);
			}

			// After attributes changing it may happen that some text nodes can be merged. Try to merge with previous node.
			_mergeNodesAtIndex(node.parent, node.index);
		}

		// Try to merge last changed node with it's previous sibling (not covered by the loop above).
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	_mergeNodesAtIndex(range.end.parent, range.end.index);
}

/**
 * Removes given attribute from nodes in given range.
 *
 * @param {engine.model.Range} range Range containing nodes that should have the attribute removed.
 * @param {String} key Key of attribute to remove.
 */
function removeAttribute$1(range, key) {
	/* jshint validthis:true */
	this.setAttribute(range, key, null);
}

/**
 * Normalizes given object or an array of objects to an array of {@link engine.model.Node nodes}. See
 * {@link engine.model.NodeSet NodeSet} for details on how normalization is performed.
 *
 * @param {engine.model.NodeSet} nodes Objects to normalize.
 * @returns {Array.<engine.model.Node>} Normalized nodes.
 */
function normalizeNodes(nodes) {
	var normalized = [];

	if (!(nodes instanceof Array)) {
		nodes = [nodes];
	}

	// Convert instances of classes other than Node.
	for (var i = 0; i < nodes.length; i++) {
		if (typeof nodes[i] == 'string') {
			normalized.push(new Text$1(nodes[i]));
		} else if (nodes[i] instanceof TextProxy) {
			normalized.push(new Text$1(nodes[i].data, nodes[i].getAttributes()));
		} else if (nodes[i] instanceof DocumentFragment || nodes[i] instanceof NodeList) {
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = nodes[i][Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var child = _step2.value;

					normalized.push(child);
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}
		} else if (nodes[i] instanceof Node$1) {
			normalized.push(nodes[i]);
		}
		// Skip unrecognized type.
	}

	// Merge text nodes.
	for (var _i = 1; _i < normalized.length; _i++) {
		var node = normalized[_i];
		var prev = normalized[_i - 1];

		if (node instanceof Text$1 && prev instanceof Text$1 && _haveSameAttributes(node, prev)) {
			// Doing this instead changing prev.data because .data is readonly.
			normalized.splice(_i - 1, 2, new Text$1(prev.data + node.data, prev.getAttributes()));
			_i--;
		}
	}

	return normalized;
}

/**
 * Checks if nodes before and after given index in given element are {@link engine.model.Text text nodes} and
 * merges them into one node if they have same attributes.
 *
 * Merging is done by removing two text nodes and inserting a new text node containing data from both merged text nodes.
 *
 * @ignore
 * @private
 * @param {engine.model.Element} element Parent element of nodes to merge.
 * @param {Number} index Index between nodes to merge.
 */
function _mergeNodesAtIndex(element, index) {
	var nodeBefore = element.getChild(index - 1);
	var nodeAfter = element.getChild(index);

	// Check if both of those nodes are text objects with same attributes.
	if (nodeBefore instanceof Text$1 && nodeAfter instanceof Text$1 && _haveSameAttributes(nodeBefore, nodeAfter)) {
		// Append text of text node after index to the before one.
		var mergedNode = new Text$1(nodeBefore.data + nodeAfter.data, nodeBefore.getAttributes());

		// Remove separate text nodes.
		element.removeChildren(index - 1, 2);

		// Insert merged text node.
		element.insertChildren(index - 1, mergedNode);
	}
}

/**
 * Checks if given position is in a text node, and if so, splits the text node in two text nodes, each of them
 * containing a part of original text node.
 *
 * @ignore
 * @private
 * @param {engine.model.Position} position Position at which node should be split.
 */
function _splitNodeAtPosition(position) {
	var textNode = position.textNode;
	var element = position.parent;

	if (textNode) {
		var offsetDiff = position.offset - textNode.startOffset;
		var index = textNode.index;

		element.removeChildren(index, 1);

		var firstPart = new Text$1(textNode.data.substr(0, offsetDiff), textNode.getAttributes());
		var secondPart = new Text$1(textNode.data.substr(offsetDiff), textNode.getAttributes());

		element.insertChildren(index, [firstPart, secondPart]);
	}
}

/**
 * Checks whether two given nodes have same attributes.
 *
 * @ignore
 * @private
 * @param {engine.model.Node} nodeA Node to check.
 * @param {engine.model.Node} nodeB Node to check.
 * @returns {Boolean} `true` if nodes have same attributes, `false` otherwise.
 */
function _haveSameAttributes(nodeA, nodeB) {
	var iteratorA = nodeA.getAttributes();
	var iteratorB = nodeB.getAttributes();

	var _iteratorNormalCompletion3 = true;
	var _didIteratorError3 = false;
	var _iteratorError3 = undefined;

	try {
		for (var _iterator3 = iteratorA[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
			var attr = _step3.value;

			if (attr[1] !== nodeB.getAttribute(attr[0])) {
				return false;
			}

			iteratorB.next();
		}
	} catch (err) {
		_didIteratorError3 = true;
		_iteratorError3 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion3 && _iterator3.return) {
				_iterator3.return();
			}
		} finally {
			if (_didIteratorError3) {
				throw _iteratorError3;
			}
		}
	}

	return iteratorB.next().done;
}

/**
 * Value that can be normalized to an array of {@link engine.model.Node nodes}.
 *
 * Non-arrays are normalized as follows:
 * * {@link engine.model.Node Node} is left as is,
 * * {@link engine.model.TextProxy TextProxy} and `String` are normalized to {@link engine.model.Text Text},
 * * {@link engine.model.NodeList NodeList} is normalized to an array containing all nodes that are in that node list,
 * * {@link engine.model.DocumentFragment DocumentFragment} is normalized to an array containing all of it's children.
 *
 * Arrays are processed item by item like non-array values and flattened to one array. Normalization always results in
 * a flat array of {@link engine.model.Node nodes}. Consecutive text nodes (or items normalized to text nodes) will be
 * merged if they have same attributes.
 *
 * @typedef {engine.model.Node|engine.model.TextProxy|String|engine.model.NodeList|engine.model.DocumentFragment|Iterable}
 * engine.model.NodeSet
 */

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Contains {@link engine.view view} to {@link engine.model model} converters for
 * {@link engine.conversion.ViewConversionDispatcher}.
 *
 * @namespace engine.conversion.viewToModel
 */

/**
 * Function factory, creates a converter that converts {@link engine.view.DocumentFragment view document fragment} or
 * all children of {@link engine.view.Element} into {@link engine.model.DocumentFragment model document fragment}.
 * This is the "entry-point" converter for view to model conversion. This converter starts the conversion of all children
 * of passed view document fragment. Those children {@link engine.view.Node view nodes} are then handled by other converters.
 *
 * This also a "default", last resort converter for all view elements that has not been converted by other converters.
 * When a view element is being converted to the model but it does not have converter specified, that view element
 * will be converted to {@link engine.model.DocumentFragment model document fragment} and returned.
 *
 * @external engine.conversion.viewToModel
 * @function engine.conversion.viewToModel.convertToModelFragment
 * @returns {Function} Universal converter for view {@link engine.view.DocumentFragment fragments} and
 * {@link engine.view.Element elements} that returns {@link engine.model.DocumentFragment model fragment} with
 * children of converted view item.
 */
function convertToModelFragment() {
  return function (evt, data, consumable, conversionApi) {
    // Second argument in `consumable.consume` is discarded for ViewDocumentFragment but is needed for ViewElement.
    if (!data.output && consumable.consume(data.input, { name: true })) {
      var convertedChildren = conversionApi.convertChildren(data.input, consumable, data);

      data.output = new DocumentFragment(normalizeNodes(convertedChildren));
    }
  };
}

/**
 * Function factory, creates a converter that converts {@link engine.view.Text} to {@link engine.model.Text}.
 *
 * @external engine.conversion.viewToModel
 * @function engine.conversion.viewToModel.convertText
 * @returns {Function} {@link engine.view.Text View text} converter.
 */
function convertText() {
  return function (evt, data, consumable, conversionApi) {
    var schemaQuery = {
      name: '$text',
      inside: data.context
    };

    if (conversionApi.schema.check(schemaQuery)) {
      if (consumable.consume(data.input)) {
        data.output = new Text$1(data.input.data);
      }
    }
  };
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Type of {@link engine.model.Element} that is a root of a model tree.
 *
 * @memberOf engine.model
 * @extends engine.model.Element
 */

var RootElement = function (_Element) {
	inherits(RootElement, _Element);

	/**
  * Creates root element.
  *
  * @param {engine.model.Document} doc Document that is an owner of this root.
  * @param {String} name Node name.
  * @param {String} [rootName='main'] Unique root name used to identify this root element by {@link engine.model.Document}.
  */
	function RootElement(doc, name) {
		var rootName = arguments.length <= 2 || arguments[2] === undefined ? 'main' : arguments[2];
		classCallCheck(this, RootElement);

		/**
   * Document that is an owner of this root.
   *
   * @private
   * @member {engine.model.Document} engine.model.RootElement#_doc
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(RootElement).call(this, name));

		_this._doc = doc;

		/**
   * Unique root name used to identify this root element by {@link engine.model.Document}.
   *
   * @readonly
   * @member {String} engine.model.RootElement#rootName
   */
		_this.rootName = rootName;
		return _this;
	}

	/**
  * {@link engine.model.Document Document} that owns this root element.
  *
  * In contrary, to {@link engine.model.Node node}, root element always have a `document`.
  *
  * @readonly
  * @type {engine.model.Document|null}
  */


	createClass(RootElement, [{
		key: 'toJSON',


		/**
   * Converts `RootElement` instance to `String` containing it's name.
   *
   * @returns {String} `RootElement` instance converted to `String`.
   */
		value: function toJSON() {
			return this.rootName;
		}
	}, {
		key: 'document',
		get: function get() {
			return this._doc;
		}
	}]);
	return RootElement;
}(Element);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * `LivePosition` is a type of {@link engine.model.Position Position} that updates itself as {@link engine.model.Document document}
 * is changed through operations. It may be used as a bookmark.
 *
 * **Note:** Contrary to {@link engine.model.Position}, `LivePosition` works only in roots that are
 * {@link engine.model.RootElement}. If {@link engine.model.DocumentFragment} is passed, error will be thrown.
 *
 * **Note:** Be very careful when dealing with `LivePosition`. Each `LivePosition` instance bind events that might
 * have to be unbound. Use {@link engine.model.LivePosition#detach} whenever you don't need `LivePosition` anymore.
 *
 * @memberOf engine.model
 * @extends engine.model.Position
 */

var LivePosition = function (_Position) {
	inherits(LivePosition, _Position);

	/**
  * Creates a live position.
  *
  * @see engine.model.Position
  * @param {engine.model.RootElement} root
  * @param {Array.<Number>} path
  * @param {engine.model.PositionStickiness} [stickiness] Defaults to `'sticksToNext'`.
  * See {@link engine.model.LivePosition#stickiness}.
  */
	function LivePosition(root, path, stickiness) {
		classCallCheck(this, LivePosition);

		if (!(root instanceof RootElement)) {
			/**
    * LivePosition root has to be an instance of RootElement.
    *
    * @error liveposition-root-not-rootelement
    */
			throw new CKEditorError('model-liveposition-root-not-rootelement: LivePosition root has to be an instance of RootElement.');
		}

		/**
   * Flag representing `LivePosition` stickiness. `LivePosition` might be sticking to previous node or next node.
   * Whenever some nodes are inserted at the same position as `LivePosition`, `stickiness` is checked to decide if
   * LivePosition should be moved. Similar applies when a range of nodes is moved and one of it's boundary
   * position is same as `LivePosition`.
   *
   * Examples:
   *
   *		Insert:
   *		Position is at | and we insert at the same position, marked as ^:
   *		- | sticks to previous node: `<p>f|^oo</p>` => `<p>f|baroo</p>`
   *		- | sticks to next node: `<p>f^|oo</p>` => `<p>fbar|oo</p>`
   *
   *		Move:
   *		Position is at | and range [ ] is moved to position ^:
   *		- | sticks to previous node: `<p>f|[oo]</p><p>b^ar</p>` => `<p>f|</p><p>booar</p>`
   *		- | sticks to next node: `<p>f|[oo]</p><p>b^ar</p>` => `<p>f</p><p>b|ooar</p>`
   *
   * @member {engine.model.PositionStickiness} engine.model.LivePosition#stickiness
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(LivePosition).call(this, root, path));

		_this.stickiness = stickiness || 'sticksToNext';

		bindWithDocument.call(_this);
		return _this;
	}

	/**
  * Unbinds all events previously bound by `LivePosition`. Use it whenever you don't need `LivePosition` instance
  * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was
  * referring to it).
  */


	createClass(LivePosition, [{
		key: 'detach',
		value: function detach() {
			this.stopListening();
		}

		/**
   * @static
   * @method engine.model.LivePosition.createAfter
   * @see engine.model.Position.createAfter
   * @param {engine.model.Node} node
   * @returns {engine.model.LivePosition}
   */

		/**
   * @static
   * @method engine.model.LivePosition.createBefore
   * @see engine.model.Position.createBefore
   * @param {engine.model.Node} node
   * @returns {engine.model.LivePosition}
   */

		/**
   * @static
   * @method engine.model.LivePosition.createFromParentAndOffset
   * @see engine.model.Position.createFromParentAndOffset
   * @param {engine.model.Element} parent
   * @param {Number} offset
   * @returns {engine.model.LivePosition}
   */

		/**
   * @static
   * @method engine.model.LivePosition.createFromPosition
   * @see engine.model.Position.createFromPosition
   * @param {engine.model.Position} position
   * @returns {engine.model.LivePosition}
   */

		/**
   * Fired when `LivePosition` instance is changed due to changes on {@link engine.model.Document}.
   *
   * @event engine.model.LivePosition#change
   * @param {engine.model.Position} oldPosition Position equal to this live position before it got changed.
   */

	}]);
	return LivePosition;
}(Position);

function bindWithDocument() {
	var _this2 = this;

	/*jshint validthis: true */
	// Operation types handled by LivePosition (these are operations that change model tree structure).
	var supportedTypes = new Set(['insert', 'move', 'remove', 'reinsert']);

	this.listenTo(this.root.document, 'change', function (event, type, changes) {
		if (supportedTypes.has(type)) {
			transform.call(_this2, type, changes.range, changes.sourcePosition);
		}
	}, { priority: 'high' });
}

/**
 * Updates this position accordingly to the updates applied to the model. Bases on change events.
 *
 * @ignore
 * @private
 * @method transform
 * @param {String} type Type of changes applied to the Tree Model.
 * @param {engine.model.Range} range Range containing the result of applied change.
 * @param {engine.model.Position} [position] Additional position parameter provided by some change events.
 */
function transform(type, range, position) {
	/*jshint validthis: true */

	var howMany = range.end.offset - range.start.offset;
	var transformed = void 0;

	switch (type) {
		case 'insert':
			var insertBefore = this.stickiness == 'sticksToNext';
			transformed = this._getTransformedByInsertion(range.start, howMany, insertBefore);
			break;

		case 'move':
		case 'remove':
		case 'reinsert':
			var originalRange = Range$1.createFromPositionAndShift(position, howMany);

			var gotMoved = originalRange.containsPosition(this) || originalRange.start.isEqual(this) && this.stickiness == 'sticksToNext' || originalRange.end.isEqual(this) && this.stickiness == 'sticksToPrevious';

			// We can't use ._getTransformedByMove() because we have a different if-condition.
			if (gotMoved) {
				transformed = this._getCombined(position, range.start);
			} else {
				var _insertBefore = this.stickiness == 'sticksToNext';
				transformed = this._getTransformedByMove(position, range.start, howMany, _insertBefore);
			}
			break;
	}

	if (!this.isEqual(transformed)) {
		var oldPosition = Position.createFromPosition(this);

		this.path = transformed.path;
		this.root = transformed.root;

		this.fire('change', oldPosition);
	}
}

mix(LivePosition, EmitterMixin);

/**
 * Enum representing how position is "sticking" with their neighbour nodes.
 * Possible values: `'sticksToNext'`, `'sticksToPrevious'`.
 *
 * @typedef {String} engine.model.PositionStickiness
 */

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

// import { stringify as stringifyModel } from '../dev-utils/model.js';

/**
 * Inserts content into the editor (specified selection) as one would expect the paste
 * functionality to work.
 *
 * **Note:** Use {@link engine.controller.DataController#insert} instead of this function.
 * This function is only exposed to be reusable in algorithms which change the {@link engine.controller.DataController#insert}
 * method's behavior.
 *
 * @method engine.controller.insert
 * @param {engine.controller.DataController} dataController The data controller in context of which the insertion
 * should be performed.
 * @param {engine.view.DocumentFragment} content The content to insert.
 * @param {engine.model.Selection} selection Selection into which the content should be inserted.
 * @param {engine.model.Batch} [batch] Batch to which deltas will be added. If not specified, then
 * changes will be added to a new batch.
 */
function insert$2(dataController, content, selection, batch) {
	if (!batch) {
		batch = dataController.model.batch();
	}

	if (!selection.isCollapsed) {
		dataController.model.composer.deleteContents(batch, selection, {
			merge: true
		});
	}

	// Convert the pasted content to a model document fragment.
	// Convertion is contextual, but in this case we need an "all allowed" context and for that
	// we use the $clipboardHolder item.
	var modelFragment = dataController.viewToModel.convert(content, {
		context: ['$clipboardHolder']
	});

	// We'll be debugging this dozens of times still.
	// console.log( stringifyModel( modelFragment ) );

	var insertion = new Insertion(dataController, batch, selection.anchor);

	insertion.handleNodes(modelFragment.getChildren(), {
		// The set of children being inserted is the only set in this context
		// so it's the first and last (it's a hack ;)).
		isFirst: true,
		isLast: true
	});

	selection.setRanges(insertion.getSelectionRanges());
}

/**
 * Utility class for performing content insertion.
 *
 * @private
 * @memberOf engine.dataController.insert
 */

var Insertion = function () {
	function Insertion(dataController, batch, position) {
		classCallCheck(this, Insertion);

		/**
   * The data controller in context of which the insertion should be performed.
   */
		this.dataController = dataController;

		/**
   * Batch to which deltas will be added.
   */
		this.batch = batch;

		/**
   * The position at which (or near which) the next node will be inserted.
   */
		this.position = position;

		/**
   * Elements with which the inserted elements can be merged.
   *
   *		<p>x^</p><p>y</p> + <p>z</p> (can merge to <p>x</p>)
   *		<p>x</p><p>^y</p> + <p>z</p> (can merge to <p>y</p>)
   *		<p>x^y</p> + <p>z</p> (can merge to <p>xy</p> which will be split during the action,
   *								so both its pieces will be added to this set)
   */
		this.canMergeWith = new Set([this.position.parent]);

		/**
   * Schema of the model.
   */
		this.schema = dataController.model.schema;
	}

	/**
  * Handles insertion of a set of nodes.
  *
  * @param {Iterable.<engine.model.Node>} nodes Nodes to insert.
  * @param {Object} parentContext Context in which parent of these nodes was supposed to be inserted.
  * If the parent context is passed it means that the parent element was stripped (was not allowed).
  */


	createClass(Insertion, [{
		key: 'handleNodes',
		value: function handleNodes(nodes, parentContext) {
			nodes = Array.from(nodes);

			for (var i = 0; i < nodes.length; i++) {
				var node = nodes[i].clone();

				this._handleNode(node, {
					isFirst: i === 0 && parentContext.isFirst,
					isLast: i === nodes.length - 1 && parentContext.isLast
				});
			}
		}

		/**
   * Returns a range to be selected after insertion.
   *
   * @returns {engine.model.Range}
   */

	}, {
		key: 'getSelectionRanges',
		value: function getSelectionRanges() {
			if (this.nodeToSelect) {
				return [Range$1.createOn(this.nodeToSelect)];
			} else {
				var searchRange = new Range$1(Position.createAt(this.position.root), this.position);

				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = searchRange.getPositions({ direction: 'backward' })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var position = _step.value;

						if (this.schema.check({ name: '$text', inside: position })) {
							return [new Range$1(position)];
						}
					}

					// As a last resort, simply return the current position.
					// See the "should not break when autoparagraphing of text is not possible" test for
					// a case which triggers this condition.
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}

				return [new Range$1(this.position)];
			}
		}

		/**
   * Handles insertion of a single node.
   *
   * @param {engine.model.Node} node
   * @param {Object} context
   * @param {Boolean} context.isFirst Whether the given node is the first one in the content to be inserted.
   * @param {Boolean} context.isLast Whether the given node is the last one in the content to be inserted.
   */

	}, {
		key: '_handleNode',
		value: function _handleNode(node) {
			var context = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

			// Let's handle object in a special way.
			// * They should never be merged with other elements.
			// * If they are not allowed in any of the selection ancestors, they could be either autoparagraphed or totally removed.
			if (this._checkIsObject(node)) {
				this._handleObject(node, context);

				return;
			}

			// Try to find a place for the given node.
			// Split the position.parent's branch up to a point where the node can be inserted.
			// If it isn't allowed in the whole branch, then of course don't split anything.
			var isAllowed = this._checkAndSplitToAllowedPosition(node, context);

			if (!isAllowed) {
				this._handleDisallowedNode(node, context);

				return;
			}

			this._insert(node);

			// After the node was inserted we may try to merge it with its siblings.
			// This should happen only if it was the first and/or last of the nodes (so only with boundary nodes)
			// and only if the selection was in those elements initially.
			//
			// E.g.:
			// <p>x^</p> + <p>y</p> => <p>x</p><p>y</p> => <p>xy[]</p>
			// and:
			// <p>x^y</p> + <p>z</p> => <p>x</p>^<p>y</p> + <p>z</p> => <p>x</p><p>y</p><p>z</p> => <p>xy[]z</p>
			// but:
			// <p>x</p><p>^</p><p>z</p> + <p>y</p> => <p>x</p><p>y</p><p>z</p> (no merging)
			// <p>x</p>[<img>]<p>z</p> + <p>y</p> => <p>x</p><p>y</p><p>z</p> (no merging, note: after running deletetContents
			//																	 it's exactly the same case as above)
			this._mergeSiblingsOf(node, context);
		}

		/**
   * @param {engine.model.Element} node The object element.
   * @param {Object} context
   */

	}, {
		key: '_handleObject',
		value: function _handleObject(node, context) {
			// Try finding it a place in the tree.
			if (this._checkAndSplitToAllowedPosition(node)) {
				this._insert(node);
			}
			// Try autoparagraphing.
			else {
					this._tryAutoparagraphing(node, context);
				}
		}

		/**
   * @param {engine.model.Node} node The disallowed node which needs to be handled.
   * @param {Object} context
   */

	}, {
		key: '_handleDisallowedNode',
		value: function _handleDisallowedNode(node, context) {
			// Try inserting its children (strip the parent).
			if (node instanceof Element) {
				this.handleNodes(node.getChildren(), context);
			}
			// Try autoparagraphing.
			else {
					this._tryAutoparagraphing(node, context);
				}
		}

		/**
   * @param {engine.model.Node} node The node to insert.
   */

	}, {
		key: '_insert',
		value: function _insert(node) {
			/* istanbul ignore if */
			if (!this._checkIsAllowed(node, [this.position.parent])) {
				// Algorithm's correctness check. We should never end up here but it's good to know that we did.
				// Note that it would often be a silent issue if we insert node in a place where it's not allowed.
				log.error('insertcontent-wrong-position: The node cannot be inserted on the given position.', { node: node, position: this.position });

				return;
			}

			var livePos = LivePosition.createFromPosition(this.position);

			this.batch.insert(this.position, node);

			this.position = Position.createFromPosition(livePos);
			livePos.detach();

			// The last inserted object should be selected because we can't put a collapsed selection after it.
			if (this._checkIsObject(node) && !this.schema.check({ name: '$text', inside: [this.position.parent] })) {
				this.nodeToSelect = node;
			} else {
				this.nodeToSelect = null;
			}
		}

		/**
   * @param {engine.model.Node} node The node which could potentially be merged.
   * @param {Object} context
   */

	}, {
		key: '_mergeSiblingsOf',
		value: function _mergeSiblingsOf(node, context) {
			if (!(node instanceof Element)) {
				return;
			}

			var mergeLeft = context.isFirst && node.previousSibling instanceof Element && this.canMergeWith.has(node.previousSibling);
			var mergeRight = context.isLast && node.nextSibling instanceof Element && this.canMergeWith.has(node.nextSibling);
			var mergePosLeft = LivePosition.createBefore(node);
			var mergePosRight = LivePosition.createAfter(node);

			if (mergeLeft) {
				var position = LivePosition.createFromPosition(this.position);

				this.batch.merge(mergePosLeft);

				this.position = Position.createFromPosition(position);
				position.detach();
			}

			if (mergeRight) {
				var _position = void 0;

				/* istanbul ignore if */
				if (!this.position.isEqual(mergePosRight)) {
					// Algorithm's correctness check. We should never end up here but it's good to know that we did.
					// At this point the insertion position should be after the node we'll merge. If it isn't,
					// it should need to be secured as in the left merge case.
					log.error('insertcontent-wrong-position-on-merge: The insertion position should equal the merge position');
				}

				// Move the position to the previous node, so it isn't moved to the graveyard on merge.
				// <p>x</p>[]<p>y</p> => <p>x[]</p><p>y</p>
				this.position = Position.createAt(mergePosRight.nodeBefore, 'end');

				// OK:  <p>xx[]</p> + <p>yy</p> => <p>xx[]yy</p> (when sticks to previous)
				// NOK: <p>xx[]</p> + <p>yy</p> => <p>xxyy[]</p> (when sticks to next)
				_position = new LivePosition(this.position.root, this.position.path, 'sticksToPrevious');

				this.batch.merge(mergePosRight);

				this.position = Position.createFromPosition(_position);
				_position.detach();
			}

			mergePosLeft.detach();
			mergePosRight.detach();
		}

		/**
   * Tries wrapping the node in a new paragraph and inserting it this way.
   *
   * @param {engine.model.Node} node The node which needs to be autoparagraphed.
   * @param {Object} context
   */

	}, {
		key: '_tryAutoparagraphing',
		value: function _tryAutoparagraphing(node, context) {
			var paragraph = new Element('paragraph');

			// Do not autoparagraph if the paragraph won't be allowed there,
			// cause that would lead to an infinite loop. The paragraph would be rejected in
			// the next _handleNode() call and we'd be here again.
			if (this._getAllowedIn(paragraph, this.position.parent) && this._checkIsAllowed(node, [paragraph])) {
				paragraph.appendChildren(node);

				this._handleNode(paragraph, context);
			}
		}

		/**
   * @param {engine.model.Node} node
   */

	}, {
		key: '_checkAndSplitToAllowedPosition',
		value: function _checkAndSplitToAllowedPosition(node) {
			var allowedIn = this._getAllowedIn(node, this.position.parent);

			if (!allowedIn) {
				return false;
			}

			while (allowedIn != this.position.parent) {
				if (this.position.isAtStart) {
					var parent = this.position.parent;
					this.position = Position.createBefore(parent);

					// Special case – parent is empty (<p>^</p>) so isAtStart == isAtEnd == true.
					// We can remove the element after moving selection out of it.
					if (parent.isEmpty) {
						this.batch.remove(parent);
					}
				} else if (this.position.isAtEnd) {
					this.position = Position.createAfter(this.position.parent);
				} else {
					var tempPos = Position.createAfter(this.position.parent);

					this.batch.split(this.position);

					this.position = tempPos;

					this.canMergeWith.add(this.position.nodeAfter);
				}
			}

			return true;
		}

		/**
   * Gets the element in which the given node is allowed. It checks the passed element and all its ancestors.
   *
   * @param {engine.model.Node} node The node to check.
   * @param {engine.model.Element} element The element in which the node's correctness should be checked.
   * @returns {engine.model.Element|null}
   */

	}, {
		key: '_getAllowedIn',
		value: function _getAllowedIn(node, element) {
			if (this._checkIsAllowed(node, [element])) {
				return element;
			}

			if (element.parent) {
				return this._getAllowedIn(node, element.parent);
			}

			return null;
		}

		/**
   * Check whether the given node is allowed in the specified schema path.
   *
   * @param {engine.model.Node} node
   * @param {engine.model.SchemaPath} path
   */

	}, {
		key: '_checkIsAllowed',
		value: function _checkIsAllowed(node, path) {
			return this.schema.check({
				name: this._getNodeSchemaName(node),
				attributes: Array.from(node.getAttributeKeys()),
				inside: path
			});
		}

		/**
   * Checks wether according to the schema this is an object type element.
   *
   * @param {engine.model.Node} node The node to check.
   */

	}, {
		key: '_checkIsObject',
		value: function _checkIsObject(node) {
			return this.schema.objects.has(this._getNodeSchemaName(node));
		}

		/**
   * Gets a name under which we should check this node in the schema.
   *
   * @param {engine.model.Node} node The node.
   */

	}, {
		key: '_getNodeSchemaName',
		value: function _getNodeSchemaName(node) {
			if (node instanceof Text$1) {
				return '$text';
			}

			return node.name;
		}
	}]);
	return Insertion;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Controller for the data pipeline. The data pipeline controls how data is retrieved from the document
 * and set inside it. Hence, the controller features two methods which allow to {@link engine.controller.DataController#get get}
 * and {@link engine.controller.DataController#set set} data of the {@link engine.controller.DataController#model model}
 * using given:
 *
 * * {@link engine.dataProcessor.DataProcessor data processor},
 * * {@link engine.conversion.ModelConversionDispatcher model to view} and
 * * {@link engine.conversion.ViewConversionDispatcher view to model} converters.
 *
 * @memberOf engine.controller
 * @mixes utils.EmitterMixin
 */

var DataController = function () {
	/**
  * Creates data controller instance.
  *
  * @param {engine.model.Document} model Document model.
  * @param {engine.dataProcessor.DataProcessor} [dataProcessor] Data processor which should used by the controller.
  */
	function DataController(model, dataProcessor) {
		var _this = this;

		classCallCheck(this, DataController);

		/**
   * Document model.
   *
   * @readonly
   * @member {engine.model.document} engine.controller.DataController#model
   */
		this.model = model;

		/**
   * Data processor used during the conversion.
   *
   * @readonly
   * @member {engine.dataProcessor.DataProcessor} engine.controller.DataController#processor
   */
		this.processor = dataProcessor;

		/**
   * Mapper used for the conversion. It has no permanent bindings, because they are created when getting data and
   * cleared directly after data are converted. However, the mapper is defined as class property, because
   * it needs to be passed to the `ModelConversionDispatcher` as a conversion API.
   *
   * @member {engine.conversion.Mapper} engine.controller.DataController#_mapper
   */
		this.mapper = new Mapper();

		/**
   * Model to view conversion dispatcher used by the {@link engine.controller.DataController#get get method}.
   * To attach model to view converter to the data pipeline you need to add lister to this property:
   *
   *		data.modelToView( 'insert:$element', customInsertConverter );
   *
   * Or use {@link engine.conversion.ModelConverterBuilder}:
   *
   *		buildModelConverter().for( data.modelToView ).fromAttribute( 'bold' ).toElement( 'b' );
   *
   * @readonly
   * @member {engine.conversion.ModelConversionDispatcher} engine.controller.DataController#modelToView
   */
		this.modelToView = new ModelConversionDispatcher({
			mapper: this.mapper
		});
		this.modelToView.on('insert:$text', insertText(), { priority: 'lowest' });

		/**
   * View to model conversion dispatcher used by the {@link engine.controller.DataController#set set method}.
   * To attach view to model converter to the data pipeline you need to add lister to this property:
   *
   *		data.viewToModel( 'element', customElementConverter );
   *
   * Or use {@link engine.conversion.ViewConverterBuilder}:
   *
   *		buildViewConverter().for( data.viewToModel ).fromElement( 'b' ).toAttribute( 'bold', 'true' );
   *
   * @readonly
   * @member {engine.conversion.ViewConversionDispatcher} engine.controller.DataController#viewToModel
   */
		this.viewToModel = new ViewConversionDispatcher({
			schema: model.schema
		});

		// Define default converters for text and elements.
		//
		// Note that if there is no default converter for the element it will be skipped, for instance `<b>foo</b>` will be
		// converted to nothing. We add `convertToModelFragment` as a last converter so it converts children of that
		// element to the document fragment so `<b>foo</b>` will be converted to `foo` if there is no converter for `<b>`.
		this.viewToModel.on('text', convertText(), { priority: 'lowest' });
		this.viewToModel.on('element', convertToModelFragment(), { priority: 'lowest' });
		this.viewToModel.on('documentFragment', convertToModelFragment(), { priority: 'lowest' });

		this.on('insert', function (evt, data) {
			return insert$2(_this, data.content, data.selection, data.batch);
		});
	}

	/**
  * Returns model's data converted by the {@link engine.controller.DataController#modelToView model to view converters} and
  * formatted by the {@link engine.controller.DataController#processor data processor}.
  *
  * @param {String} [rootName='main'] Root name.
  * @returns {String} Output data.
  */


	createClass(DataController, [{
		key: 'get',
		value: function get() {
			var rootName = arguments.length <= 0 || arguments[0] === undefined ? 'main' : arguments[0];

			// Get model range.
			return this.stringify(this.model.getRoot(rootName));
		}

		/**
   * Returns the content of the given {@link engine.model.Element model's element} converted by the
   * {@link engine.controller.DataController#modelToView model to view converters} and formatted by the
   * {@link engine.controller.DataController#processor data processor}.
   *
   * @param {engine.model.Element} modelElement Element which content will be stringified.
   * @returns {String} Output data.
   */

	}, {
		key: 'stringify',
		value: function stringify(modelElement) {
			// model -> view
			var viewDocumentFragment = this.toView(modelElement);

			// view -> data
			return this.processor.toData(viewDocumentFragment);
		}

		/**
   * Returns the content of the given {@link engine.model.Element model's element} converted by the
   * {@link engine.controller.DataController#modelToView model to view converters} to the
   * {@link engine.view.DocumentFragment view DocumentFragment}.
   *
   * @param {engine.model.Element} modelElement Element which content will be stringified.
   * @returns {engine.view.DocumentFragment} Output view DocumentFragment.
   */

	}, {
		key: 'toView',
		value: function toView(modelElement) {
			var modelRange = Range$1.createIn(modelElement);

			var viewDocumentFragment = new DocumentFragment$1();
			this.mapper.bindElements(modelElement, viewDocumentFragment);

			this.modelToView.convertInsertion(modelRange);

			this.mapper.clearBindings();

			return viewDocumentFragment;
		}

		/**
   * Sets input data parsed by the {@link engine.controller.DataController#processor data processor} and
   * converted by the {@link engine.controller.DataController#viewToModel view to model converters}.
   *
   * This method also creates a batch with all the changes applied. If all you need is to parse data use
   * the {@link engine.controller.DataController#parse} method.
   *
   * @param {String} data Input data.
   * @param {String} [rootName='main'] Root name.
   */

	}, {
		key: 'set',
		value: function set(data) {
			var _this2 = this;

			var rootName = arguments.length <= 1 || arguments[1] === undefined ? 'main' : arguments[1];

			// Save to model.
			var modelRoot = this.model.getRoot(rootName);

			this.model.enqueueChanges(function () {
				// Clearing selection is a workaround for ticket #569 (LiveRange loses position after removing data from document).
				// After fixing it this code should be removed.
				_this2.model.selection.removeAllRanges();
				_this2.model.selection.clearAttributes();

				// Initial batch should be ignored by features like undo, etc.
				_this2.model.batch('transparent').remove(Range$1.createIn(modelRoot)).insert(Position.createAt(modelRoot, 0), _this2.parse(data));
			});
		}

		/**
   * Returns data parsed by the {@link engine.controller.DataController#processor data processor} and then
   * converted by the {@link engine.controller.DataController#viewToModel view to model converters}.
   *
   * @see engine.controller.DataController#set
   * @param {String} data Data to parse.
   * @param {String} [context='$root'] Base context in which view will be converted to the model. See:
   * {@link engine.conversion.ViewConversionDispatcher#convert}.
   * @returns {engine.model.DocumentFragment} Parsed data.
   */

	}, {
		key: 'parse',
		value: function parse(data) {
			var context = arguments.length <= 1 || arguments[1] === undefined ? '$root' : arguments[1];

			// data -> view
			var viewDocumentFragment = this.processor.toView(data);

			// view -> model
			return this.viewToModel.convert(viewDocumentFragment, { context: [context] });
		}

		/**
   * Removes all event listeners set by the DataController.
   */

	}, {
		key: 'destroy',
		value: function destroy() {}

		/**
   * See {@link engine.controller.insert}.
   *
   * @fires engine.controller.DataController#insert
   * @param {engine.view.DocumentFragment} content The content to insert.
   * @param {engine.model.Selection} selection Selection into which the content should be inserted.
   * @param {engine.model.Batch} [batch] Batch to which deltas will be added. If not specified, then
   * changes will be added to a new batch.
   */

	}, {
		key: 'insert',
		value: function insert(content, selection, batch) {
			this.fire('insert', { content: content, selection: selection, batch: batch });
		}
	}]);
	return DataController;
}();

mix(DataController, EmitterMixin);

/**
 * Event fired when {@link engine.controller.DataController#insert} method is called.
 * The {@link engine.controller.dataController.insert default action of the composer} is implemented as a
 * listener to that event so it can be fully customized by the features.
 *
 * @event engine.controller.DataController#insert
 * @param {Object} data
 * @param {engine.view.DocumentFragment} data.content The content to insert.
 * @param {engine.model.Selection} data.selection Selection into which the content should be inserted.
 * @param {engine.model.Batch} [data.batch] Batch to which deltas will be added.
 */

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache();
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/** Used to resolve the decompiled source of functions. */
var funcToString$2 = Function.prototype.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {}
    try {
      return func + '';
    } catch (e) {}
  }
  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var objectProto$10 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$10.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$4).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (!isObject(value)) {
    return false;
  }
  var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object[key];
  return isNative(value) ? value : undefined;
}

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$11 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$11.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty$5.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */
var objectProto$12 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$12.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty$6.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/* Built-in method references that are verified to be native. */
var Map$1 = getNative(root, 'Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map$1 || ListCache)(),
    'string': new Hash()
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache && cache.__data__.length == LARGE_ARRAY_SIZE) {
    cache = this.__data__ = new MapCache(cache.__data__);
  }
  cache.set(key, value);
  return this;
}

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/** Used for built-in method references. */
var objectProto$13 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$13.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
  // that are composed entirely of index properties, return `false` for
  // `hasOwnProperty` checks of them.
  return hasOwnProperty$7.call(object, key) || (typeof object === 'undefined' ? 'undefined' : _typeof(object)) == 'object' && key in object && getPrototype(object) === null;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = Object.keys;

/**
 * The base implementation of `_.keys` which doesn't skip the constructor
 * property of prototypes or treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  return nativeKeys(Object(object));
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  var isProto = isPrototype(object);
  if (!(isProto || isArrayLike(object))) {
    return baseKeys(object);
  }
  var indexes = indexKeys(object),
      skipIndexes = !!indexes,
      result = indexes || [],
      length = result.length;

  for (var key in object) {
    if (baseHas(object, key) && !(skipIndexes && (key == 'length' || isIndex(key, length))) && !(isProto && key == 'constructor')) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var result = new buffer.constructor(buffer.length);
  buffer.copy(result);
  return result;
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/** Built-in value references. */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
function getSymbols(object) {
  // Coerce `object` to an object to avoid non-object errors in V8.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=3443 for more details.
  return getOwnPropertySymbols(Object(object));
}

// Fallback for IE < 11.
if (!getOwnPropertySymbols) {
  getSymbols = function getSymbols() {
    return [];
  };
}

var getSymbols$1 = getSymbols;

/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols$1(source), object);
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols$1);
}

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

/* Built-in method references that are verified to be native. */
var Promise$1 = getNative(root, 'Promise');

/* Built-in method references that are verified to be native. */
var Set$1 = getNative(root, 'Set');

/* Built-in method references that are verified to be native. */
var WeakMap$1 = getNative(root, 'WeakMap');

var mapTag$1 = '[object Map]';
var objectTag$2 = '[object Object]';
var promiseTag = '[object Promise]';
var setTag$1 = '[object Set]';
var weakMapTag$1 = '[object WeakMap]';
var dataViewTag$1 = '[object DataView]';

/** Used for built-in method references. */
var objectProto$14 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$5 = objectProto$14.toString;

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView);
var mapCtorString = toSource(Map$1);
var promiseCtorString = toSource(Promise$1);
var setCtorString = toSource(Set$1);
var weakMapCtorString = toSource(WeakMap$1);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function getTag(value) {
  return objectToString$5.call(value);
}

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge, and promises in Node.js.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$1 || Map$1 && getTag(new Map$1()) != mapTag$1 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$1 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
  getTag = function getTag(value) {
    var result = objectToString$5.call(value),
        Ctor = result == objectTag$2 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$1;
        case mapCtorString:
          return mapTag$1;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$1;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}

var getTag$1 = getTag;

/** Used for built-in method references. */
var objectProto$15 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$15.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty$8.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `Map#set` because it doesn't return the map instance in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor());
}

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  set.add(value);
  return set;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor());
}

/** Built-in value references. */
var _Symbol = root.Symbol;

var symbolProto = _Symbol ? _Symbol.prototype : undefined;
var symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

var boolTag$1 = '[object Boolean]';
var dateTag$1 = '[object Date]';
var mapTag$2 = '[object Map]';
var numberTag$1 = '[object Number]';
var regexpTag$1 = '[object RegExp]';
var setTag$2 = '[object Set]';
var stringTag$2 = '[object String]';
var symbolTag$2 = '[object Symbol]';
var arrayBufferTag$1 = '[object ArrayBuffer]';
var dataViewTag$2 = '[object DataView]';
var float32Tag$1 = '[object Float32Array]';
var float64Tag$1 = '[object Float64Array]';
var int8Tag$1 = '[object Int8Array]';
var int16Tag$1 = '[object Int16Array]';
var int32Tag$1 = '[object Int32Array]';
var uint8Tag$1 = '[object Uint8Array]';
var uint8ClampedTag$1 = '[object Uint8ClampedArray]';
var uint16Tag$1 = '[object Uint16Array]';
var uint32Tag$1 = '[object Uint32Array]';
/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object);

    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object);

    case dataViewTag$2:
      return cloneDataView(object, isDeep);

    case float32Tag$1:case float64Tag$1:
    case int8Tag$1:case int16Tag$1:case int32Tag$1:
    case uint8Tag$1:case uint8ClampedTag$1:case uint16Tag$1:case uint32Tag$1:
      return cloneTypedArray(object, isDeep);

    case mapTag$2:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag$1:
    case stringTag$2:
      return new Ctor(object);

    case regexpTag$1:
      return cloneRegExp(object);

    case setTag$2:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag$2:
      return cloneSymbol(object);
  }
}

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function baseCreate(proto) {
  return isObject(proto) ? objectCreate(proto) : {};
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var getter = _.constant(object);
 *
 * getter() === object;
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

/** Used to determine if values are of the language type `Object`. */
var objectTypes$1 = {
  'function': true,
  'object': true
};

/** Detect free variable `exports`. */
var freeExports$1 = objectTypes$1[typeof exports === 'undefined' ? 'undefined' : _typeof(exports)] && exports && !exports.nodeType ? exports : undefined;

/** Detect free variable `module`. */
var freeModule$1 = objectTypes$1[typeof module === 'undefined' ? 'undefined' : _typeof(module)] && module && !module.nodeType ? module : undefined;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule$1 && freeModule$1.exports === freeExports$1 ? freeExports$1 : undefined;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = !Buffer ? constant(false) : function (value) {
  return value instanceof Buffer;
};

var argsTag$1 = '[object Arguments]';
var arrayTag = '[object Array]';
var boolTag = '[object Boolean]';
var dateTag = '[object Date]';
var errorTag = '[object Error]';
var funcTag$1 = '[object Function]';
var genTag$1 = '[object GeneratorFunction]';
var mapTag = '[object Map]';
var numberTag = '[object Number]';
var objectTag$1 = '[object Object]';
var regexpTag = '[object RegExp]';
var setTag = '[object Set]';
var stringTag$1 = '[object String]';
var symbolTag$1 = '[object Symbol]';
var weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]';
var dataViewTag = '[object DataView]';
var float32Tag = '[object Float32Array]';
var float64Tag = '[object Float64Array]';
var int8Tag = '[object Int8Array]';
var int16Tag = '[object Int16Array]';
var int32Tag = '[object Int32Array]';
var uint8Tag = '[object Uint8Array]';
var uint8ClampedTag = '[object Uint8ClampedArray]';
var uint16Tag = '[object Uint16Array]';
var uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag$1] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag$1] = cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag$1(value),
        isFunc = tag == funcTag$1 || tag == genTag$1;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object) {
      if (isHostObject(value)) {
        return object ? value : {};
      }
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (!isArr) {
    var props = isFull ? getAllKeys(value) : keys(value);
  }
  // Recursively populate clone (susceptible to call stack limits).
  arrayEach(props || value, function (subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
  });
  return result;
}

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, false, true);
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Abstract base operation class.
 *
 * @abstract
 * @memberOf engine.model.operation
 */

var Operation = function () {
	/**
  * Base operation constructor.
  * @param {Number} baseVersion {@link engine.model.Document#version} on which the operation can be applied.
  */
	function Operation(baseVersion) {
		classCallCheck(this, Operation);

		/**
   * {@link engine.model.Document#version} on which operation can be applied. If you try to
   * {@link engine.model.Document#applyOperation apply} operation with different base version than the
   * {@link engine.model.Document#version document version} the {@link document-applyOperation-wrong-version}
   * error is thrown.
   *
   * @member {Number} engine.model.operation.Operation#baseVersion
   */
		this.baseVersion = baseVersion;

		/**
   * Operation type.
   *
   * @member {String} engine.model.operation.Operation#type
   */

		/**
   * {@link engine.model.Delta Delta} which the operation is a part of. This property is set by the
   * {@link engine.model.Delta delta} when the operations is added to it by the
   * {@link engine.model.Delta#addOperation} method.
   *
   * @member {engine.model.Delta} engine.model.operation.Operation#delta
   */

		/**
   * Creates and returns an operation that has the same parameters as this operation.
   *
   * @method engine.model.operation.Operation#clone
   * @returns {engine.model.operation.Operation} Clone of this operation.
   */

		/**
   * Creates and returns a reverse operation. Reverse operation when executed right after
   * the original operation will bring back tree model state to the point before the original
   * operation execution. In other words, it reverses changes done by the original operation.
   *
   * Keep in mind that tree model state may change since executing the original operation,
   * so reverse operation will be "outdated". In that case you will need to
   * {@link engine.model.operation.transform} it by all operations that were executed after the original operation.
   *
   * @method engine.model.operation.Operation#getReversed
   * @returns {engine.model.operation.Operation} Reversed operation.
   */

		/**
   * Executes the operation - modifications described by the operation attributes
   * will be applied to the tree model.
   *
   * @protected
   * @method engine.model.operation.Operation#_execute
   * @returns {Object} Object with additional information about the applied changes. It properties depends on the
   * operation type.
   */
	}

	/**
  * Custom toJSON method to solve child-parent circular dependencies.
  *
  * @method engine.model.operation.Operation#toJSON
  * @returns {Object} Clone of this object with the delta property replaced with string.
  */


	createClass(Operation, [{
		key: 'toJSON',
		value: function toJSON() {
			var json = clone(this, true);

			json.__className = this.constructor.className;

			// Remove parent delta to avoid circular dependencies.
			delete json.delta;

			return json;
		}

		/**
   * Name of the operation class used for serialization.
   *
   * @type {String}
   */

	}], [{
		key: 'fromJSON',


		/**
   * Creates Operation object from deserilized object, i.e. from parsed JSON string.
   *
   * @param {Object} json Deserialized JSON object.
   * @param {engine.model.Document} doc Document on which this operation will be applied.
   * @returns {engine.model.operation.Operation}
   */
		value: function fromJSON(json) {
			return new Operation(json.baseVersion);
		}
	}, {
		key: 'className',
		get: function get() {
			return 'engine.model.operation.Operation';
		}
	}]);
	return Operation;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Operation to change nodes' attribute.
 *
 * Using this class you can add, remove or change value of the attribute.
 *
 * @memberOf engine.model.operation
 * @extends engine.model.operation.Operation
 */

var AttributeOperation = function (_Operation) {
	inherits(AttributeOperation, _Operation);

	/**
  * Creates an operation that changes, removes or adds attributes.
  *
  * If only `newValue` is set, attribute will be added on a node. Note that all nodes in operation's range must not
  * have an attribute with the same key as the added attribute.
  *
  * If only `oldValue` is set, then attribute with given key will be removed. Note that all nodes in operation's range
  * must have an attribute with that key added.
  *
  * If both `newValue` and `oldValue` are set, then the operation will change the attribute value. Note that all nodes in
  * operation's ranges must already have an attribute with given key and `oldValue` as value
  *
  * @param {engine.model.Range} range Range on which the operation should be applied.
  * @param {String} key Key of an attribute to change or remove.
  * @param {*} oldValue Old value of the attribute with given key or `null`, if attribute was not set before.
  * @param {*} newValue New value of the attribute with given key or `null`, if operation should remove attribute.
  * @param {Number} baseVersion {@link engine.model.Document#version} on which the operation can be applied.
  */
	function AttributeOperation(range, key, oldValue, newValue, baseVersion) {
		classCallCheck(this, AttributeOperation);

		/**
   * Range on which operation should be applied.
   *
   * @readonly
   * @member {engine.model.Range} engine.model.operation.AttributeOperation#range
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(AttributeOperation).call(this, baseVersion));

		_this.range = Range$1.createFromRange(range);

		/**
   * Key of an attribute to change or remove.
   *
   * @readonly
   * @member {String} engine.model.operation.AttributeOperation#key
   */
		_this.key = key;

		/**
   * Old value of the attribute with given key or `null`, if attribute was not set before.
   *
   * @readonly
   * @member {*} engine.model.operation.AttributeOperation#oldValue
   */
		_this.oldValue = oldValue === undefined ? null : oldValue;

		/**
   * New value of the attribute with given key or `null`, if operation should remove attribute.
   *
   * @readonly
   * @member {*} engine.model.operation.AttributeOperation#newValue
   */
		_this.newValue = newValue === undefined ? null : newValue;
		return _this;
	}

	/**
  * @inheritDoc
  */


	createClass(AttributeOperation, [{
		key: 'clone',


		/**
   * @inheritDoc
   * @returns {engine.model.operation.AttributeOperation}
   */
		value: function clone() {
			return new AttributeOperation(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
		}

		/**
   * @inheritDoc
   * @returns {engine.model.operation.AttributeOperation}
   */

	}, {
		key: 'getReversed',
		value: function getReversed() {
			return new AttributeOperation(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: '_execute',
		value: function _execute() {
			// Validation.
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = this.range.getItems()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var item = _step.value;

					if (this.oldValue !== null && item.getAttribute(this.key) !== this.oldValue) {
						/**
       * Changed node has different attribute value than operation's old attribute value.
       *
       * @error operation-attribute-wrong-old-value
       * @param {engine.model.Item} item
       * @param {String} key
       */
						throw new CKEditorError('attribute-operation-wrong-old-value: Changed node has different attribute value than operation\'s old attribute value.', { item: item, key: this.key });
					}

					if (this.oldValue === null && this.newValue !== null && item.hasAttribute(this.key)) {
						/**
       * The attribute with given key already exists for the given node.
       *
       * @error attribute-operation-attribute-exists
       * @param {engine.model.Node} node
       * @param {String} key
       */
						throw new CKEditorError('attribute-operation-attribute-exists: The attribute with given key already exists.', { node: item, key: this.key });
					}
				}

				// Execution.
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			modelWriter.setAttribute(this.range, this.key, this.newValue);

			return { range: this.range, key: this.key, oldValue: this.oldValue, newValue: this.newValue };
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'type',
		get: function get() {
			if (this.oldValue === null) {
				return 'addAttribute';
			} else if (this.newValue === null) {
				return 'removeAttribute';
			} else {
				return 'changeAttribute';
			}
		}
	}], [{
		key: 'fromJSON',


		/**
   * Creates `AttributeOperation` object from deserilized object, i.e. from parsed JSON string.
   *
   * @param {Object} json Deserialized JSON object.
   * @param {engine.model.Document} document Document on which this operation will be applied.
   * @returns {engine.model.operation.AttributeOperation}
   */
		value: function fromJSON(json, document) {
			return new AttributeOperation(Range$1.fromJSON(json.range, document), json.key, json.oldValue, json.newValue, json.baseVersion);
		}
	}, {
		key: 'className',
		get: function get() {
			return 'engine.model.operation.AttributeOperation';
		}
	}]);
	return AttributeOperation;
}(Operation);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Operation to move a range of {@link engine.model.Item model items} to given {@link engine.model.Position target position}.
 *
 * @memberOf engine.model.operation
 */

var MoveOperation = function (_Operation) {
	inherits(MoveOperation, _Operation);

	/**
  * Creates a move operation.
  *
  * @param {engine.model.Position} sourcePosition Position before the first {@link engine.model.Item model item} to move.
  * @param {Number} howMany Offset size of moved range. Moved range will start from `sourcePosition` and end at
  * `sourcePosition` with offset shifted by `howMany`.
  * @param {engine.model.Position} targetPosition Position at which moved nodes will be inserted.
  * @param {Number} baseVersion {@link engine.model.Document#version} on which operation can be applied.
  */
	function MoveOperation(sourcePosition, howMany, targetPosition, baseVersion) {
		classCallCheck(this, MoveOperation);

		/**
   * Position before the first {@link engine.model.Item model item} to move.
   *
   * @member {engine.model.Position} engine.model.operation.MoveOperation#sourcePosition
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(MoveOperation).call(this, baseVersion));

		_this.sourcePosition = Position.createFromPosition(sourcePosition);

		/**
   * Offset size of moved range.
   *
   * @member {Number} engine.model.operation.MoveOperation#howMany
   */
		_this.howMany = howMany;

		/**
   * Position at which moved nodes will be inserted.
   *
   * @member {engine.model.Position} engine.model.operation.MoveOperation#targetPosition
   */
		_this.targetPosition = Position.createFromPosition(targetPosition);

		/**
   * Position of the start of the moved range after it got moved. This may be different than
   * {@link engine.model.operation.MoveOperation#targetPosition} in some cases, i.e. when a range is moved
   * inside the same parent but {@link engine.model.operation.MoveOperation#targetPosition targetPosition}
   * is after {@link engine.model.operation.MoveOperation#sourcePosition sourcePosition}.
   *
   *		 vv              vv
   *		abcdefg ===> adefbcg
   *		     ^          ^
   *		     targetPos	movedRangeStart
   *		     offset 6	offset 4
   *
   * @member {engine.model.Position} engine.model.operation.MoveOperation#movedRangeStart
   */
		_this.movedRangeStart = _this.targetPosition._getTransformedByDeletion(_this.sourcePosition, _this.howMany);

		/**
   * Defines whether `MoveOperation` is sticky. If `MoveOperation` is sticky, during
   * {@link engine.model.operation.transform operational transformation} if there will be an operation that
   * inserts some nodes at the position equal to the boundary of this `MoveOperation`, that operation will
   * get their insertion path updated to the position where this `MoveOperation` moves the range.
   *
   * @member {Boolean} engine.model.operation.MoveOperation#isSticky
   */
		_this.isSticky = false;
		return _this;
	}

	/**
  * @inheritDoc
  */


	createClass(MoveOperation, [{
		key: 'clone',


		/**
   * @inheritDoc
   * @returns {engine.model.operation.MoveOperation}
   */
		value: function clone() {
			var op = new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
			op.isSticky = this.isSticky;

			return op;
		}

		/**
   * @inheritDoc
   * @returns {engine.model.operation.MoveOperation}
   */

	}, {
		key: 'getReversed',
		value: function getReversed() {
			var newTargetPosition = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);

			var op = new this.constructor(this.movedRangeStart, this.howMany, newTargetPosition, this.baseVersion + 1);
			op.isSticky = this.isSticky;

			return op;
		}

		/**
   * @inheritDoc
   */

	}, {
		key: '_execute',
		value: function _execute() {
			var sourceElement = this.sourcePosition.parent;
			var targetElement = this.targetPosition.parent;
			var sourceOffset = this.sourcePosition.offset;
			var targetOffset = this.targetPosition.offset;

			// Validate whether move operation has correct parameters.
			// Validation is pretty complex but move operation is one of the core ways to manipulate the document state.
			// We expect that many errors might be connected with one of scenarios described below.
			if (!sourceElement || !targetElement) {
				/**
     * Source position or target position is invalid.
     *
     * @error move-operation-position-invalid
     */
				throw new CKEditorError('move-operation-position-invalid: Source position or target position is invalid.');
			} else if (sourceOffset + this.howMany > sourceElement.maxOffset) {
				/**
     * The nodes which should be moved do not exist.
     *
     * @error move-operation-nodes-do-not-exist
     */
				throw new CKEditorError('move-operation-nodes-do-not-exist: The nodes which should be moved do not exist.');
			} else if (sourceElement === targetElement && sourceOffset < targetOffset && targetOffset < sourceOffset + this.howMany) {
				/**
     * Trying to move a range of nodes into the middle of that range.
     *
     * @error move-operation-range-into-itself
     */
				throw new CKEditorError('move-operation-range-into-itself: Trying to move a range of nodes to the inside of that range.');
			} else if (this.sourcePosition.root == this.targetPosition.root) {
				if (compareArrays(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == 'prefix') {
					var i = this.sourcePosition.path.length - 1;

					if (this.targetPosition.path[i] >= sourceOffset && this.targetPosition.path[i] < sourceOffset + this.howMany) {
						/**
       * Trying to move a range of nodes into one of nodes from that range.
       *
       * @error move-operation-node-into-itself
       */
						throw new CKEditorError('move-operation-node-into-itself: Trying to move a range of nodes into one of nodes from that range.');
					}
				}
			}

			var range = modelWriter.move(Range$1.createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);

			return {
				sourcePosition: this.sourcePosition,
				range: range
			};
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'type',
		get: function get() {
			return 'move';
		}
	}], [{
		key: 'fromJSON',


		/**
   * Creates `MoveOperation` object from deserilized object, i.e. from parsed JSON string.
   *
   * @param {Object} json Deserialized JSON object.
   * @param {engine.model.Document} document Document on which this operation will be applied.
   * @returns {engine.model.operation.MoveOperation}
   */
		value: function fromJSON(json, document) {
			var sourcePosition = Position.fromJSON(json.sourcePosition, document);
			var targetPosition = Position.fromJSON(json.targetPosition, document);

			return new MoveOperation(sourcePosition, json.howMany, targetPosition, json.baseVersion);
		}
	}, {
		key: 'className',
		get: function get() {
			return 'engine.model.operation.MoveOperation';
		}
	}]);
	return MoveOperation;
}(Operation);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Operation to reinsert previously removed nodes back to the non-graveyard root. This operation acts like
 * {@link engine.model.operation.MoveOperation} but it returns {@link engine.model.operation.RemoveOperation} when reversed
 * and fires different change event.
 *
 * @memberOf engine.model.operation
 */

var ReinsertOperation = function (_MoveOperation) {
	inherits(ReinsertOperation, _MoveOperation);

	function ReinsertOperation() {
		classCallCheck(this, ReinsertOperation);
		return possibleConstructorReturn(this, Object.getPrototypeOf(ReinsertOperation).apply(this, arguments));
	}

	createClass(ReinsertOperation, [{
		key: 'getReversed',


		/**
   * @inheritDoc
   * @returns {engine.model.operation.RemoveOperation}
   */
		value: function getReversed() {
			return new RemoveOperation(this.targetPosition, this.howMany, this.baseVersion + 1);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'position',

		/**
   * Position where nodes will be re-inserted.
   *
   * @type {engine.model.Position}
   */
		get: function get() {
			return this.targetPosition;
		}

		/**
   * @param {engine.model.Position} pos
   */
		,
		set: function set(pos) {
			this.targetPosition = pos;
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'type',
		get: function get() {
			return 'reinsert';
		}
	}], [{
		key: 'className',
		get: function get() {
			return 'engine.model.operation.ReinsertOperation';
		}
	}]);
	return ReinsertOperation;
}(MoveOperation);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Operation to remove a range of nodes.
 *
 * @memberOf engine.model.operation
 */

var RemoveOperation = function (_MoveOperation) {
	inherits(RemoveOperation, _MoveOperation);

	/**
  * Creates a remove operation.
  *
  * @param {engine.model.Position} position Position before the first {@link engine.model.Item model item} to remove.
  * @param {Number} howMany Offset size of removed range. {@link engine.model.Item Model items} will be removed starting
  * from `sourcePosition`, up to a `sourcePosition` with offset shifted by `howMany`.
  * @param {Number} baseVersion {@link engine.model.Document#version} on which operation can be applied.
  */
	function RemoveOperation(position, howMany, baseVersion) {
		classCallCheck(this, RemoveOperation);

		var graveyard = position.root.document.graveyard;
		var graveyardPosition = new Position(graveyard, [graveyard.maxOffset, 0]);

		return possibleConstructorReturn(this, Object.getPrototypeOf(RemoveOperation).call(this, position, howMany, graveyardPosition, baseVersion));
	}

	/**
  * @inheritDoc
  */


	createClass(RemoveOperation, [{
		key: 'getReversed',


		/**
   * @inheritDoc
   * @returns {engine.model.operation.ReinsertOperation}
   */
		value: function getReversed() {
			return new ReinsertOperation(this.targetPosition, this.howMany, this.sourcePosition, this.baseVersion + 1);
		}

		/**
   * @inheritDoc
   * @returns {engine.model.operation.RemoveOperation}
   */

	}, {
		key: 'clone',
		value: function clone() {
			var removeOperation = new RemoveOperation(this.sourcePosition, this.howMany, this.baseVersion);
			removeOperation.targetPosition = Position.createFromPosition(this.targetPosition);
			removeOperation.movedRangeStart = Position.createFromPosition(this.movedRangeStart);

			return removeOperation;
		}

		/**
   * @inheritDoc
   */

	}, {
		key: '_execute',
		value: function _execute() {
			// Insert "holder" element in graveyard root, if the operation needs it.
			if (this._needsHolderElement) {
				var graveyard = this.targetPosition.root;
				var holderElement = new Element('$graveyardHolder');

				graveyard.insertChildren(this.targetPosition.path[0], holderElement);
			}

			// Then, execute as a move operation.
			return get(Object.getPrototypeOf(RemoveOperation.prototype), '_execute', this).call(this);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'type',
		get: function get() {
			return 'remove';
		}

		/**
   * Offset of the graveyard "holder" element, in which nodes removed by this operation are stored.
   *
   * @protected
   * @type {Number}
   */

	}, {
		key: '_holderElementOffset',
		get: function get() {
			return this.targetPosition.path[0];
		}

		/**
   * Sets {@link engine.model.operation.RemoveOperation#_holderElementOffset}.
   *
   * @protected
   * @param {Number} offset
   */
		,
		set: function set(offset) {
			this.targetPosition.path[0] = offset;
		}

		/**
   * Flag informing whether this operation should insert "holder" element (`true`) or should move removed nodes
   * into existing "holder" element (`false`).
   *
   * It is `true` for each `RemoveOperation` that is the first `RemoveOperation` in it's delta that points to given holder element.
   * This way only one `RemoveOperation` in given delta will insert "holder" element.
   *
   * @protected
   * @type {Boolean}
   */

	}, {
		key: '_needsHolderElement',
		get: function get() {
			if (this.delta) {
				// Let's look up all operations from this delta in the same order as they are in the delta.
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = this.delta.operations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var operation = _step.value;

						// We are interested only in `RemoveOperation`s.
						if (operation instanceof RemoveOperation) {
							// If the first `RemoveOperation` in the delta is this operation, this operation
							// needs to insert holder element in the graveyard.
							if (operation == this) {
								return true;
							} else if (operation._holderElementOffset == this._holderElementOffset) {
								// If there is a `RemoveOperation` in this delta that "points" to the same holder element offset,
								// that operation will already insert holder element at that offset. We should not create another holder.
								return false;
							}
						}
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
			}

			// By default `RemoveOperation` needs holder element, so set it so, if the operation does not have delta.
			return true;
		}
	}], [{
		key: 'className',
		get: function get() {
			return 'engine.model.operation.RemoveOperation';
		}
	}]);
	return RemoveOperation;
}(MoveOperation);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Operation to insert one or more nodes at given position in the model.
 *
 * @memberOf engine.model.operation
 * @extends engine.model.operation.Operation
 */

var InsertOperation = function (_Operation) {
	inherits(InsertOperation, _Operation);

	/**
  * Creates an insert operation.
  *
  * @param {engine.model.Position} position Position of insertion.
  * @param {engine.model.NodeSet} nodes The list of nodes to be inserted.
  * @param {Number} baseVersion {@link engine.model.Document#version} on which operation can be applied.
  */
	function InsertOperation(position, nodes, baseVersion) {
		classCallCheck(this, InsertOperation);

		/**
   * Position of insertion.
   *
   * @readonly
   * @member {engine.model.Position} engine.model.operation.InsertOperation#position
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(InsertOperation).call(this, baseVersion));

		_this.position = Position.createFromPosition(position);

		/**
   * List of nodes to insert.
   *
   * @readonly
   * @member {engine.model.NodeList} engine.model.operation.InsertOperation#nodeList
   */
		_this.nodes = new NodeList(normalizeNodes(nodes));
		return _this;
	}

	/**
  * @inheritDoc
  */


	createClass(InsertOperation, [{
		key: 'clone',


		/**
   * @inheritDoc
   * @returns {engine.model.operation.InsertOperation}
   */
		value: function clone() {
			return new InsertOperation(this.position, this.nodes, this.baseVersion);
		}

		/**
   * @inheritDoc
   * @returns {engine.model.operation.RemoveOperation}
   */

	}, {
		key: 'getReversed',
		value: function getReversed() {
			return new RemoveOperation(this.position, this.nodes.maxOffset, this.baseVersion + 1);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: '_execute',
		value: function _execute() {
			// What happens here is that we want original nodes be passed to writer because we want original nodes
			// to be inserted to the model. But in InsertOperation, we want to keep those nodes as they were added
			// to the operation, not modified. For example, text nodes can get merged or cropped while Elements can
			// get children. It is important that InsertOperation has the copy of original nodes in intact state.
			var originalNodes = this.nodes;
			this.nodes = new NodeList([].concat(toConsumableArray(originalNodes)).map(function (node) {
				return node.clone(true);
			}));

			var range = modelWriter.insert(this.position, originalNodes);

			return { range: range };
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'type',
		get: function get() {
			return 'insert';
		}
	}], [{
		key: 'fromJSON',


		/**
   * Creates `InsertOperation` object from deserilized object, i.e. from parsed JSON string.
   *
   * @param {Object} json Deserialized JSON object.
   * @param {engine.model.Document} document Document on which this operation will be applied.
   * @returns {engine.model.operation.InsertOperation}
   */
		value: function fromJSON(json, document) {
			var children = [];

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = json.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var child = _step.value;

					if (child.name) {
						// If child has name property, it is an Element.
						children.push(Element.fromJSON(child));
					} else {
						// Otherwise, it is a Text node.
						children.push(Text$1.fromJSON(child));
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			return new InsertOperation(Position.fromJSON(json.position, document), children, json.baseVersion);
		}
	}, {
		key: 'className',
		get: function get() {
			return 'engine.model.operation.InsertOperation';
		}
	}]);
	return InsertOperation;
}(Operation);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Operation which is doing nothing ("empty operation", "do-nothing operation", "noop"). This is an operation,
 * which when executed does not change the tree model. It still has some parameters defined for transformation purposes.
 *
 * In most cases this operation is a result of transforming operations. When transformation returns
 * {@link engine.model.operation.NoOperation} it means that changes done by the transformed operation
 * have already been applied.
 *
 * @memberOf engine.model.operation
 * @extends engine.model.operation.Operation
 */

var NoOperation = function (_Operation) {
	inherits(NoOperation, _Operation);

	function NoOperation() {
		classCallCheck(this, NoOperation);
		return possibleConstructorReturn(this, Object.getPrototypeOf(NoOperation).apply(this, arguments));
	}

	createClass(NoOperation, [{
		key: 'clone',

		/**
   * @inheritDoc
   * @returns {engine.model.operation.NoOperation}
   */
		value: function clone() {
			return new NoOperation(this.baseVersion);
		}

		/**
   * @inheritDoc
   * @returns {engine.model.operation.NoOperation}
   */

	}, {
		key: 'getReversed',
		value: function getReversed() {
			return new NoOperation(this.baseVersion + 1);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: '_execute',
		value: function _execute() {}
		// Do nothing.


		/**
   * @inheritDoc
   */

	}], [{
		key: 'className',
		get: function get() {
			return 'engine.model.operation.NoOperation';
		}
	}]);
	return NoOperation;
}(Operation);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Operation to change root element's attribute. Using this class you can add, remove or change value of the attribute.
 *
 * This operation is needed, because root elements can't be changed through {@link engine.model.operation.AttributeOperation}.
 * It is because {@link engine.model.operation.AttributeOperation} requires a range to change and root element can't
 * be a part of range because every {@link engine.model.Position} has to be inside a root. {@link engine.model.Position}
 * can't be created before a root element.
 *
 * @memberOf engine.model.operation
 * @extends engine.model.operation.Operation
 */

var RootAttributeOperation = function (_Operation) {
	inherits(RootAttributeOperation, _Operation);

	/**
  * Creates an operation that changes, removes or adds attributes on root element.
  *
  * @see engine.model.operation.AttributeOperation
  * @param {engine.model.RootElement} root Root element to change.
  * @param {String} key Key of an attribute to change or remove.
  * @param {*} oldValue Old value of the attribute with given key or `null` if adding a new attribute.
  * @param {*} newValue New value to set for the attribute. If `null`, then the operation just removes the attribute.
  * @param {Number} baseVersion {@link engine.model.Document#version} on which the operation can be applied.
  */
	function RootAttributeOperation(root, key, oldValue, newValue, baseVersion) {
		classCallCheck(this, RootAttributeOperation);

		/**
   * Root element to change.
   *
   * @readonly
   * @member {engine.model.RootElement} engine.model.operation.RootAttributeOperation#root
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(RootAttributeOperation).call(this, baseVersion));

		_this.root = root;

		/**
   * Key of an attribute to change or remove.
   *
   * @readonly
   * @member {String} engine.model.operation.RootAttributeOperation#key
   */
		_this.key = key;

		/**
   * Old value of the attribute with given key or `null` if adding a new attribute.
   *
   * @readonly
   * @member {*} engine.model.operation.RootAttributeOperation#oldValue
   */
		_this.oldValue = oldValue;

		/**
   * New value to set for the attribute. If `null`, then the operation just removes the attribute.
   *
   * @readonly
   * @member {*} engine.model.operation.RootAttributeOperation#newValue
   */
		_this.newValue = newValue;
		return _this;
	}

	createClass(RootAttributeOperation, [{
		key: 'clone',


		/**
   * @returns {engine.model.operation.RootAttributeOperation}
   */
		value: function clone() {
			return new RootAttributeOperation(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
		}

		/**
   * @returns {engine.model.operation.RootAttributeOperation}
   */

	}, {
		key: 'getReversed',
		value: function getReversed() {
			return new RootAttributeOperation(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
		}
	}, {
		key: '_execute',
		value: function _execute() {
			if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue) {
				/**
     * The attribute which should be removed does not exists for the given node.
     *
     * @error rootattribute-operation-wrong-old-value
     * @param {engine.model.RootElement} root
     * @param {String} key
     * @param {*} value
     */
				throw new CKEditorError('rootattribute-operation-wrong-old-value: Changed node has different attribute value than operation\'s old attribute value.', { root: this.root, key: this.key });
			}

			if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key)) {
				/**
     * The attribute with given key already exists for the given node.
     *
     * @error rootattribute-operation-attribute-exists
     * @param {engine.model.RootElement} root
     * @param {String} key
     */
				throw new CKEditorError('rootattribute-operation-attribute-exists: The attribute with given key already exists.', { root: this.root, key: this.key });
			}

			if (this.newValue !== null) {
				this.root.setAttribute(this.key, this.newValue);
			} else {
				this.root.removeAttribute(this.key);
			}

			return { root: this.root, key: this.key, oldValue: this.oldValue, newValue: this.newValue };
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'type',
		get: function get() {
			if (this.oldValue === null) {
				return 'addRootAttribute';
			} else if (this.newValue === null) {
				return 'removeRootAttribute';
			} else {
				return 'changeRootAttribute';
			}
		}
	}], [{
		key: 'fromJSON',


		/**
   * Creates RootAttributeOperation object from deserilized object, i.e. from parsed JSON string.
   *
   * @param {Object} json Deserialized JSON object.
   * @param {engine.model.Document} document Document on which this operation will be applied.
   * @returns {engine.model.operation.RootAttributeOperation}
   */
		value: function fromJSON(json, document) {
			if (!document.hasRoot(json.root)) {
				/**
     * Cannot create RootAttributeOperation for document. Root with specified name does not exist.
     *
     * @error rootattributeoperation-fromjson-no-root
     * @param {String} rootName
     */
				throw new CKEditorError('rootattribute-operation-fromjson-no-root: Cannot create RootAttributeOperation. Root with specified name does not exist.', { rootName: json });
			}

			return new RootAttributeOperation(document.getRoot(json.root), json.key, json.oldValue, json.newValue, json.baseVersion);
		}
	}, {
		key: 'className',
		get: function get() {
			return 'engine.model.operation.RootAttributeOperation';
		}
	}]);
	return RootAttributeOperation;
}(Operation);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

var operations = {};
operations[AttributeOperation.className] = AttributeOperation;
operations[InsertOperation.className] = InsertOperation;
operations[MoveOperation.className] = MoveOperation;
operations[NoOperation.className] = NoOperation;
operations[Operation.className] = Operation;
operations[ReinsertOperation.className] = ReinsertOperation;
operations[RemoveOperation.className] = RemoveOperation;
operations[RootAttributeOperation.className] = RootAttributeOperation;

/**
 * A factory class for creating operations.
 *
 * @abstract
 * @memberOf engine.model.operation
 */

var OperationFactory = function () {
	function OperationFactory() {
		classCallCheck(this, OperationFactory);
	}

	createClass(OperationFactory, null, [{
		key: 'fromJSON',

		/**
   * Creates concrete `Operation` object from deserilized object, i.e. from parsed JSON string.
   *
   * @param {Object} json Deserialized JSON object.
   * @param {engine.model.Document} document Document on which this operation will be applied.
   * @returns {engine.model.operation.Operation}
   */
		value: function fromJSON(json, document) {
			return operations[json.__className].fromJSON(json, document);
		}
	}]);
	return OperationFactory;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

var deserializers = new Map();

/**
 * A factory class for creating operations.
 *
 * Delta is a single, from the user action point of view, change in the editable document, like insert, split or
 * rename element. Delta is composed of operations, which are unit changes needed to be done to execute user action.
 *
 * Multiple deltas are grouped into a single {@link engine.model.Batch}.
 *
 * @memberOf engine.model.delta
 */

var DeltaFactory = function () {
	function DeltaFactory() {
		classCallCheck(this, DeltaFactory);
	}

	createClass(DeltaFactory, null, [{
		key: 'fromJSON',

		/**
   * Creates InsertDelta from deserialized object, i.e. from parsed JSON string.
   *
   * @param {Object} json
   * @param {engine.model.Document} doc Document on which this delta will be applied.
   * @returns {engine.model.delta.InsertDelta}
   */
		value: function fromJSON(json, doc) {
			if (!deserializers.has(json.__className)) {
				/**
     * This delta has no defined deserializer.
     *
     * @error delta-fromjson-no-deserializer
     * @param {String} name
     */
				throw new CKEditorError('delta-fromjson-no-deserializer: This delta has no defined deserializer', { name: json.__className });
			}

			var Delta = deserializers.get(json.__className);

			var delta = new Delta();

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = json.operations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var operation = _step.value;

					delta.addOperation(OperationFactory.fromJSON(operation, doc));
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			return delta;
		}

		/**
   * Registers a class for delta factory.
   *
   * @param {Function} Delta A delta class to register.
   */

	}, {
		key: 'register',
		value: function register(Delta) {
			deserializers.set(Delta.className, Delta);
		}
	}]);
	return DeltaFactory;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Base class for all deltas.
 *
 * Delta is a single, from the user action point of view, change in the editable document, like insert, split or
 * rename element. Delta is composed of operations, which are unit changes needed to be done to execute user action.
 *
 * Multiple deltas are grouped into a single {@link engine.model.Batch}.
 *
 * @memberOf engine.model.delta
 */

var Delta = function () {
	/**
  * Creates a delta instance.
  */
	function Delta() {
		classCallCheck(this, Delta);

		/**
   * {@link engine.model.Batch} which delta is a part of. This property is null by default and set by the
   * {@link engine.model.Batch#addDelta} method.
   *
   * @readonly
   * @member {engine.model.Batch} engine.model.delta.Delta#batch
   */
		this.batch = null;

		/**
   * Array of operations which compose delta.
   *
   * @readonly
   * @member {engine.model.operation.Operation[]} engine.model.delta.Delta#operations
   */
		this.operations = [];
	}

	/**
  * Returns delta base version which is equal to the base version of the first operation in delta. If there
  * are no operations in delta, returns `null`.
  *
  * @see engine.model.Document
  * @type {Number|null}
  */


	createClass(Delta, [{
		key: 'addOperation',


		/**
   * Add operation to the delta.
   *
   * @param {engine.model.operation.Operation} operation Operation instance.
   */
		value: function addOperation(operation) {
			operation.delta = this;
			this.operations.push(operation);

			return operation;
		}

		/**
   * Creates and returns a delta that has the same parameters as this delta.
   *
   * @returns {engine.model.delta.Delta} Clone of this delta.
   */

	}, {
		key: 'clone',
		value: function clone() {
			var delta = new this.constructor();

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = this.operations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var op = _step.value;

					delta.addOperation(op.clone());
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			return delta;
		}

		/**
   * Creates and returns a reverse delta. Reverse delta when executed right after the original delta will bring back
   * tree model state to the point before the original delta execution. In other words, it reverses changes done
   * by the original delta.
   *
   * Keep in mind that tree model state may change since executing the original delta, so reverse delta may be "outdated".
   * In that case you will need to {@link engine.model.delta.transform} it by all deltas that were executed after
   * the original delta.
   *
   * @returns {engine.model.delta.Delta} Reversed delta.
   */

	}, {
		key: 'getReversed',
		value: function getReversed() {
			var delta = new this._reverseDeltaClass();

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = this.operations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var op = _step2.value;

					delta.addOperation(op.getReversed());
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			delta.operations.reverse();

			for (var i = 0; i < delta.operations.length; i++) {
				delta.operations[i].baseVersion = this.operations[this.operations.length - 1].baseVersion + i + 1;
			}

			return delta;
		}

		/**
   * Custom toJSON method to make deltas serializable.
   *
   * @returns {Object} Clone of this delta with added class name.
   */

	}, {
		key: 'toJSON',
		value: function toJSON() {
			var json = clone(this);

			json.__className = this.constructor.className;

			// Remove parent batch to avoid circular dependencies.
			delete json.batch;

			return json;
		}

		/**
   * Delta class name. Used by {@link engine.model.delta.Delta#toJSON} method for serialization and
   * {@link engine.model.delta.DeltaFactory.fromJSON} during deserialization.
   *
   * @type {String}
   * @readonly
   */

	}, {
		key: 'baseVersion',
		get: function get() {
			if (this.operations.length > 0) {
				return this.operations[0].baseVersion;
			}

			return null;
		}

		/**
   * @param {Number} baseVersion
   */
		,
		set: function set(baseVersion) {
			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = this.operations[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var operation = _step3.value;

					operation.baseVersion = baseVersion++;
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}
		}

		/**
   * A class that will be used when creating reversed delta.
   *
   * @private
   * @type {Function}
   */

	}, {
		key: '_reverseDeltaClass',
		get: function get() {
			return Delta;
		}
	}], [{
		key: 'className',
		get: function get() {
			return 'engine.model.delta.Delta';
		}

		/**
   * Delta priority. Used in {@link engine.model.delta.transform delta transformations}. Delta with the higher
   * priority will be treated as more important when resolving transformation conflicts. If deltas have same
   * priority, other factors will be used to determine which delta is more important.
   *
   * @private
   * @type {Number}
   */

	}, {
		key: '_priority',
		get: function get() {
			return 0;
		}
	}]);
	return Delta;
}();

DeltaFactory.register(Delta);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * `Batch` instance groups document changes ({@link engine.model.Delta deltas}). All deltas grouped in a single `Batch` can be
 * reverted together, so you can think about `Batch` as of a single undo step. If you want to extend given undo step you
 * can call another method on the same `Batch` object. If you want to create a separate undo step you can create a new `Batch`.
 *
 * For example to create two separate undo steps you can call:
 *
 *		doc.batch().insert( firstPosition, 'foo' );
 *		doc.batch().insert( secondPosition, 'bar' );
 *
 * To create a single undo step:
 *
 *		const batch = doc.batch();
 *		batch.insert( firstPosition, 'foo' );
 *		batch.insert( secondPosition, 'bar' );
 *
 * Note that all document modification methods (insert, remove, split, etc.) are chainable so you can shorten code to:
 *
 *		doc.batch().insert( firstPosition, 'foo' ).insert( secondPosition, 'bar' );
 *
 * @memberOf engine.model
 */

var Batch = function () {
	/**
  * Creates `Batch` instance. Not recommended to use directly, use {@link engine.model.Document#batch} instead.
  *
  * @param {engine.model.Document} document Document which this Batch changes.
  * @param {'transparent'|'default'} [type='default'] Type of the batch.
  */
	function Batch(document) {
		var type = arguments.length <= 1 || arguments[1] === undefined ? 'default' : arguments[1];
		classCallCheck(this, Batch);

		/**
   * Document which this batch changes.
   *
   * @readonly
   * @member {engine.model.Document} engine.model.Batch#document
   */
		this.document = document;

		/**
   * Array of deltas which compose this batch.
   *
   * @readonly
   * @member {Array.<engine.model.delta.Delta>} engine.model.Batch#deltas
   */
		this.deltas = [];

		/**
   * Type of the batch.
   *
   * Can be one of the following values:
   * * `'default'` - all "normal" batches, most commonly used type.
   * * `'transparent'` - batch that should be ignored by other features, i.e. initial batch or collaborative editing changes.
   *
   * @readonly
   * @member {'transparent'|'default'} engine.model.Batch#type
   */
		this.type = type;
	}

	/**
  * Returns this batch base version, which is equal to the base version of first delta in the batch.
  * If there are no deltas in the batch, it returns `null`.
  *
  * @readonly
  * @type {Number|null}
  */


	createClass(Batch, [{
		key: 'addDelta',


		/**
   * Adds delta to the batch instance. All modification methods (insert, remove, split, etc.) use this method
   * to add created deltas.
   *
   * @param {engine.model.delta.Delta} delta Delta to add.
   * @return {engine.model.delta.Delta} Added delta.
   */
		value: function addDelta(delta) {
			delta.batch = this;
			this.deltas.push(delta);

			return delta;
		}

		/**
   * Gets an iterable collection of operations.
   *
   * @returns {Iterable.<engine.model.operation.Operation>}
   */

	}, {
		key: 'getOperations',
		value: regeneratorRuntime.mark(function getOperations() {
			var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, delta;

			return regeneratorRuntime.wrap(function getOperations$(_context) {
				while (1) {
					switch (_context.prev = _context.next) {
						case 0:
							_iteratorNormalCompletion = true;
							_didIteratorError = false;
							_iteratorError = undefined;
							_context.prev = 3;
							_iterator = this.deltas[Symbol.iterator]();

						case 5:
							if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
								_context.next = 11;
								break;
							}

							delta = _step.value;
							return _context.delegateYield(delta.operations, 't0', 8);

						case 8:
							_iteratorNormalCompletion = true;
							_context.next = 5;
							break;

						case 11:
							_context.next = 17;
							break;

						case 13:
							_context.prev = 13;
							_context.t1 = _context['catch'](3);
							_didIteratorError = true;
							_iteratorError = _context.t1;

						case 17:
							_context.prev = 17;
							_context.prev = 18;

							if (!_iteratorNormalCompletion && _iterator.return) {
								_iterator.return();
							}

						case 20:
							_context.prev = 20;

							if (!_didIteratorError) {
								_context.next = 23;
								break;
							}

							throw _iteratorError;

						case 23:
							return _context.finish(20);

						case 24:
							return _context.finish(17);

						case 25:
						case 'end':
							return _context.stop();
					}
				}
			}, getOperations, this, [[3, 13, 17, 25], [18,, 20, 24]]);
		})
	}, {
		key: 'baseVersion',
		get: function get() {
			return this.deltas.length > 0 ? this.deltas[0].baseVersion : null;
		}
	}]);
	return Batch;
}();

function register(name, creator) {
	if (Batch.prototype[name]) {
		/**
   * This batch method name is already taken.
   *
   * @error batch-register-taken
   * @param {String} name
   */
		throw new CKEditorError('model-batch-register-taken: This batch method name is already taken.', { name: name });
	}

	Batch.prototype[name] = creator;
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * To provide specific OT behavior and better collisions solving, methods to change attributes
 * ({@link engine.model.Batch#setAttribute} and {@link engine.model.Batch#removeAttribute}) use `AttributeDelta` class
 * which inherits from the `Delta` class and may overwrite some methods.
 *
 * @memberOf engine.model.delta
 * @extends engine.model.delta.Delta
 */

var AttributeDelta = function (_Delta) {
	inherits(AttributeDelta, _Delta);

	function AttributeDelta() {
		classCallCheck(this, AttributeDelta);
		return possibleConstructorReturn(this, Object.getPrototypeOf(AttributeDelta).apply(this, arguments));
	}

	createClass(AttributeDelta, [{
		key: 'key',

		/**
   * The attribute key that is changed by the delta or `null` if the delta has no operations.
   *
   * @readonly
   * @type {String|null}
   */
		get: function get() {
			return this.operations[0] ? this.operations[0].key : null;
		}

		/**
   * The attribute value that is set by the delta or `null` if the delta has no operations.
   *
   * @readonly
   * @type {*|null}
   */

	}, {
		key: 'value',
		get: function get() {
			return this.operations[0] ? this.operations[0].newValue : null;
		}

		/**
   * The range on which delta operates or `null` if the delta has no operations.
   *
   * @readonly
   * @type {engine.model.Range|null}
   */

	}, {
		key: 'range',
		get: function get() {
			// Check if it is cached.
			if (this._range) {
				return this._range;
			}

			// If it is not cached we will evaluate it and cache it.
			var firstOperation = this.operations[0];
			var lastOperation = this.operations[this.operations.length - 1];

			if (firstOperation) {
				this._range = new Range$1(firstOperation.range.start, lastOperation.range.end);

				return this._range;
			}

			return null;
		}
	}, {
		key: '_reverseDeltaClass',
		get: function get() {
			return AttributeDelta;
		}

		/**
   * @inheritDoc
   */

	}], [{
		key: 'className',
		get: function get() {
			return 'engine.model.delta.AttributeDelta';
		}

		/**
   * @inheritDoc
   */

	}, {
		key: '_priority',
		get: function get() {
			return 20;
		}
	}]);
	return AttributeDelta;
}(Delta);

var RootAttributeDelta = function (_Delta2) {
	inherits(RootAttributeDelta, _Delta2);

	function RootAttributeDelta() {
		classCallCheck(this, RootAttributeDelta);
		return possibleConstructorReturn(this, Object.getPrototypeOf(RootAttributeDelta).apply(this, arguments));
	}

	createClass(RootAttributeDelta, null, [{
		key: 'className',

		/**
   * @inheritDoc
   */
		get: function get() {
			return 'engine.model.delta.RootAttributeDelta';
		}
	}]);
	return RootAttributeDelta;
}(Delta);

/**
 * Sets value of the attribute with given key on a {@link engine.model.Item model item} or on a {@link engine.model.Range range}.
 *
 * @chainable
 * @method engine.model.Batch#setAttribute
 * @param {engine.model.Item|engine.model.Range} itemOrRange Model item or range on which the attribute will be set.
 * @param {String} key Attribute key.
 * @param {*} value Attribute new value.
 */
register('setAttribute', function (itemOrRange, key, value) {
	attribute(this, key, value, itemOrRange);

	return this;
});

/**
 * Removes an attribute with given key from a {@link engine model.Item model item} or from a {@link engine.model.Range range}.
 *
 * @chainable
 * @param {engine.model.Item|engine.model.Range} itemOrRange Model item or range from which the attribute will be removed.
 * @method engine.model.Batch#removeAttribute
 * @param {String} key Attribute key.
 */
register('removeAttribute', function (itemOrRange, key) {
	attribute(this, key, null, itemOrRange);

	return this;
});

function attribute(batch, key, value, itemOrRange) {
	if (itemOrRange instanceof Range$1) {
		changeRange(batch, batch.document, key, value, itemOrRange);
	} else {
		changeItem(batch, batch.document, key, value, itemOrRange);
	}
}

function changeItem(batch, doc, key, value, item) {
	var previousValue = item.getAttribute(key);
	var range = void 0,
	    operation = void 0;

	var delta = item instanceof RootElement ? new RootAttributeDelta() : new AttributeDelta();
	batch.addDelta(delta);

	if (previousValue != value) {
		if (item instanceof RootElement) {
			// If we change attributes of root element, we have to use `RootAttributeOperation`.
			operation = new RootAttributeOperation(item, key, previousValue, value, doc.version);
		} else {
			if (item instanceof Element) {
				// If we change the attribute of the element, we do not want to change attributes of its children, so
				// the end of the range cannot be after the closing tag, it should be inside that element, before any of
				// it's children, so the range will contain only the opening tag.
				range = new Range$1(Position.createBefore(item), Position.createFromParentAndOffset(item, 0));
			} else {
				// If `item` is text proxy, we create a range from the beginning to the end of that text proxy, to change
				// all characters represented by it.
				range = new Range$1(Position.createBefore(item), Position.createAfter(item));
			}

			operation = new AttributeOperation(range, key, previousValue, value, doc.version);
		}

		delta.addOperation(operation);
		doc.applyOperation(operation);
	}
}

// Because attribute operation needs to have the same attribute value on the whole range, this function splits the range
// into smaller parts.
function changeRange(batch, doc, attributeKey, attributeValue, range) {
	var delta = new AttributeDelta();
	batch.addDelta(delta);

	// Position of the last split, the beginning of the new range.
	var lastSplitPosition = range.start;

	// Currently position in the scanning range. Because we need value after the position, it is not a current
	// position of the iterator but the previous one (we need to iterate one more time to get the value after).
	var position = void 0;
	// Value before the currently position.
	var attributeValueBefore = void 0;
	// Value after the currently position.
	var attributeValueAfter = void 0;

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = range[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var value = _step.value;

			attributeValueAfter = value.item.getAttribute(attributeKey);

			// At the first run of the iterator the position in undefined. We also do not have a attributeValueBefore, but
			// because attributeValueAfter may be null, attributeValueBefore may be equal attributeValueAfter ( undefined == null ).
			if (position && attributeValueBefore != attributeValueAfter) {
				// if attributeValueBefore == attributeValue there is nothing to change, so we add operation only if these values are different.
				if (attributeValueBefore != attributeValue) {
					addOperation();
				}

				lastSplitPosition = position;
			}

			position = value.nextPosition;
			attributeValueBefore = attributeValueAfter;
		}

		// Because position in the loop is not the iterator position (see let position comment), the last position in
		// the while loop will be last but one position in the range. We need to check the last position manually.
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	if (position instanceof Position && position != lastSplitPosition && attributeValueBefore != attributeValue) {
		addOperation();
	}

	function addOperation() {
		var range = new Range$1(lastSplitPosition, position);
		var operation = new AttributeOperation(range, attributeKey, attributeValueBefore, attributeValue, doc.version);

		delta.addOperation(operation);
		doc.applyOperation(operation);
	}
}

DeltaFactory.register(AttributeDelta);
DeltaFactory.register(RootAttributeDelta);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @classdesc
 * To provide specific OT behavior and better collisions solving, {@link engine.model.Batch#move} method
 * uses the `MoveDelta` class which inherits from the `Delta` class and may overwrite some methods.
 *
 * @memberOf engine.model.delta
 */

var MoveDelta = function (_Delta) {
	inherits(MoveDelta, _Delta);

	function MoveDelta() {
		classCallCheck(this, MoveDelta);
		return possibleConstructorReturn(this, Object.getPrototypeOf(MoveDelta).apply(this, arguments));
	}

	createClass(MoveDelta, [{
		key: 'howMany',

		/**
   * Offset size of moved range or `null` if there are no operations in the delta.
   *
   * @type {Number|null}
   */
		get: function get() {
			return this._moveOperation ? this._moveOperation.howMany : null;
		}

		/**
   * {@link engine.model.delta.MoveDelta#_moveOperation Move operation}
   * {@link engine.model.operation.MoveOperation#sourcePosition source position} or `null` if there are
   * no operations in the delta.
   *
   * @type {engine.model.Position|null}
   */

	}, {
		key: 'sourcePosition',
		get: function get() {
			return this._moveOperation ? this._moveOperation.sourcePosition : null;
		}

		/**
   * {@link engine.model.delta.MoveDelta#_moveOperation Move operation}
   * {@link engine.model.operation.MoveOperation#targetPosition target position} or `null` if there are
   * no operations in the delta.
   *
   * @type {engine.model.Position|null}
   */

	}, {
		key: 'targetPosition',
		get: function get() {
			return this._moveOperation ? this._moveOperation.targetPosition : null;
		}

		/**
   * {@link engine.model.delta.MoveDelta#_moveOperation Move operation} that is saved in this delta or `null`
   * if there are no operations in the delta.
   *
   * @protected
   * @type {engine.model.operation.MoveOperation|null}
   */

	}, {
		key: '_moveOperation',
		get: function get() {
			return this.operations[0] || null;
		}

		/**
   * @inheritDoc
   */

	}, {
		key: '_reverseDeltaClass',
		get: function get() {
			return MoveDelta;
		}

		/**
   * @inheritDoc
   */

	}], [{
		key: 'className',
		get: function get() {
			return 'engine.model.delta.MoveDelta';
		}

		/**
   * @inheritDoc
   */

	}, {
		key: '_priority',
		get: function get() {
			return 20;
		}
	}]);
	return MoveDelta;
}(Delta);

function addMoveOperation(batch, delta, sourcePosition, howMany, targetPosition) {
	var operation = new MoveOperation(sourcePosition, howMany, targetPosition, batch.document.version);
	delta.addOperation(operation);
	batch.document.applyOperation(operation);
}

/**
 * Moves given {@link engine.model.Item model item} or given range to target position.
 *
 * @chainable
 * @method engine.model.Batch#move
 * @param {engine.model.Item|engine.model.Range} itemOrRange Model item or range of nodes to move.
 * @param {engine.model.Position} targetPosition Position where moved nodes will be inserted.
 */
register('move', function (itemOrRange, targetPosition) {
	var delta = new MoveDelta();
	this.addDelta(delta);

	if (itemOrRange instanceof Range$1) {
		if (!itemOrRange.isFlat) {
			/**
    * Range to move is not flat.
    *
    * @error batch-move-range-not-flat
    */
			throw new CKEditorError('batch-move-range-not-flat: Range to move is not flat.');
		}

		addMoveOperation(this, delta, itemOrRange.start, itemOrRange.end.offset - itemOrRange.start.offset, targetPosition);
	} else {
		addMoveOperation(this, delta, Position.createBefore(itemOrRange), 1, targetPosition);
	}

	return this;
});

DeltaFactory.register(MoveDelta);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @classdesc
 * To provide specific OT behavior and better collisions solving, {@link engine.model.Batch#remove} method
 * uses the `RemoveDelta` class which inherits from the `Delta` class and may overwrite some methods.
 *
 * @memberOf engine.model.delta
 */

var RemoveDelta = function (_MoveDelta) {
	inherits(RemoveDelta, _MoveDelta);

	function RemoveDelta() {
		classCallCheck(this, RemoveDelta);
		return possibleConstructorReturn(this, Object.getPrototypeOf(RemoveDelta).apply(this, arguments));
	}

	createClass(RemoveDelta, null, [{
		key: 'className',

		/**
   * @inheritDoc
   */
		get: function get() {
			return 'engine.model.delta.RemoveDelta';
		}
	}]);
	return RemoveDelta;
}(MoveDelta);

function addRemoveOperation(batch, delta, position, howMany) {
	var operation = new RemoveOperation(position, howMany, batch.document.version);
	delta.addOperation(operation);
	batch.document.applyOperation(operation);
}

/**
 * Removes given {@link engine.model.Item model item} or given range.
 *
 * @chainable
 * @method engine.model.Batch#remove
 * @param {engine.model.Item|engine.model.Range} itemOrRange Model item or range to remove.
 */
register('remove', function (itemOrRange) {
	var delta = new RemoveDelta();
	this.addDelta(delta);

	if (itemOrRange instanceof Range$1) {
		// The array is reversed, so the ranges are correct and do not have to be updated.
		var ranges = itemOrRange.getMinimalFlatRanges().reverse();

		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var flat = _step.value;

				addRemoveOperation(this, delta, flat.start, flat.end.offset - flat.start.offset);
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}
	} else {
		addRemoveOperation(this, delta, Position.createBefore(itemOrRange), 1);
	}

	return this;
});

DeltaFactory.register(RemoveDelta);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @classdesc
 * To provide specific OT behavior and better collisions solving, the {@link engine.model.Batch#insert Batch#insert} method
 * uses the `InsertDelta` class which inherits from the `Delta` class and may overwrite some methods.
 *
 * @memberOf engine.model.delta
 */

var InsertDelta = function (_Delta) {
	inherits(InsertDelta, _Delta);

	function InsertDelta() {
		classCallCheck(this, InsertDelta);
		return possibleConstructorReturn(this, Object.getPrototypeOf(InsertDelta).apply(this, arguments));
	}

	createClass(InsertDelta, [{
		key: 'position',

		/**
   * Position where the delta inserts nodes or `null` if there are no operations in the delta.
   *
   * @readonly
   * @type {engine.model.Position|null}
   */
		get: function get() {
			return this._insertOperation ? this._insertOperation.position : null;
		}

		/**
   * Node list containing all the nodes inserted by the delta or `null` if there are no operations in the delta.
   *
   * @readonly
   * @type {engine.model.NodeList|null}
   */

	}, {
		key: 'nodes',
		get: function get() {
			return this._insertOperation ? this._insertOperation.nodes : null;
		}

		/**
   * Insert operation that is saved in this delta or `null` if there are no operations in the delta.
   *
   * @readonly
   * @protected
   * @type {engine.model.operation.InsertOperation|null}
   */

	}, {
		key: '_insertOperation',
		get: function get() {
			return this.operations[0] || null;
		}

		/**
   * @inheritDoc
   */

	}, {
		key: '_reverseDeltaClass',
		get: function get() {
			return RemoveDelta;
		}

		/**
   * @inheritDoc
   */

	}], [{
		key: 'className',
		get: function get() {
			return 'engine.model.delta.InsertDelta';
		}

		/**
   * @inheritDoc
   */

	}, {
		key: '_priority',
		get: function get() {
			return 20;
		}
	}]);
	return InsertDelta;
}(Delta);

register('insert', function (position, nodes) {
	var delta = new InsertDelta();
	var insert = new InsertOperation(position, nodes, this.document.version);

	this.addDelta(delta);
	delta.addOperation(insert);
	this.document.applyOperation(insert);

	return this;
});

DeltaFactory.register(InsertDelta);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @classdesc
 * To provide specific OT behavior and better collisions solving, the {@link engine.model.Batch#split} method
 * uses `SplitDelta` class which inherits from the `Delta` class and may overwrite some methods.
 *
 * @memberOf engine.model.delta
 */

var SplitDelta = function (_Delta) {
	inherits(SplitDelta, _Delta);

	function SplitDelta() {
		classCallCheck(this, SplitDelta);
		return possibleConstructorReturn(this, Object.getPrototypeOf(SplitDelta).apply(this, arguments));
	}

	createClass(SplitDelta, [{
		key: 'getReversed',


		/**
   * @inheritDoc
   */
		value: function getReversed() {
			var delta = get(Object.getPrototypeOf(SplitDelta.prototype), 'getReversed', this).call(this);

			if (delta.operations.length > 0) {
				delta.operations[0].isSticky = true;
			}

			return delta;
		}

		/**
   * Operation in the delta that adds to model an element into which split nodes will be moved, or `null` if
   * there are no operations in the delta.
   *
   * Most commonly this will be {@link engine.model.operation.InsertOperation an insert operation}, as `SplitDelta`
   * has to create a new node. If `SplitDelta` was created through {@link engine.model.delta.Delta#getReversed reversing}
   * a {@link engine.model.delta.MergeDelta merge delta}, this will be a {@link engine.model.operation.ReinsertOperation reinsert operation},
   * as we will want to re-insert the exact element that was removed by that merge delta.
   *
   * @protected
   * @type {engine.model.operation.InsertOpertaion|engine.model.operation.ReinsertOperation|null}
   */

	}, {
		key: 'position',

		/**
   * Position of split or `null` if there are no operations in the delta.
   *
   * @type {engine.model.Position|null}
   */
		get: function get() {
			return this._moveOperation ? this._moveOperation.sourcePosition : null;
		}
	}, {
		key: '_cloneOperation',
		get: function get() {
			return this.operations[0] || null;
		}

		/**
   * Operation in the delta that moves model items, that are after split position, to their new parent or `null`
   * if there are no operations in the delta.
   *
   * @protected
   * @type {engine.model.operation.MoveOperation|null}
   */

	}, {
		key: '_moveOperation',
		get: function get() {
			return this.operations[1] || null;
		}

		/**
   * @inheritDoc
   */

	}, {
		key: '_reverseDeltaClass',
		get: function get() {
			return MergeDelta;
		}

		/**
   * @inheritDoc
   */

	}], [{
		key: 'className',
		get: function get() {
			return 'engine.model.delta.SplitDelta';
		}

		/**
   * @inheritDoc
   */

	}, {
		key: '_priority',
		get: function get() {
			return 5;
		}
	}]);
	return SplitDelta;
}(Delta);

register('split', function (position) {
	var delta = new SplitDelta();
	this.addDelta(delta);

	var splitElement = position.parent;

	if (!splitElement.parent) {
		/**
   * Root element can not be split.
   *
   * @error batch-split-root
   */
		throw new CKEditorError('batch-split-root: Root element can not be split.');
	}

	var copy = new Element(splitElement.name, splitElement.getAttributes());

	var insert = new InsertOperation(Position.createAfter(splitElement), copy, this.document.version);

	delta.addOperation(insert);
	this.document.applyOperation(insert);

	var move = new MoveOperation(position, splitElement.maxOffset - position.offset, Position.createFromParentAndOffset(copy, 0), this.document.version);
	move.isSticky = true;

	delta.addOperation(move);
	this.document.applyOperation(move);

	return this;
});

DeltaFactory.register(SplitDelta);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @classdesc
 * To provide specific OT behavior and better collisions solving, {@link engine.model.Batch#merge} method
 * uses the `MergeDelta` class which inherits from the `Delta` class and may overwrite some methods.
 *
 * @memberOf engine.model.delta
 */

var MergeDelta = function (_Delta) {
	inherits(MergeDelta, _Delta);

	function MergeDelta() {
		classCallCheck(this, MergeDelta);
		return possibleConstructorReturn(this, Object.getPrototypeOf(MergeDelta).apply(this, arguments));
	}

	createClass(MergeDelta, [{
		key: 'getReversed',


		/**
   * @inheritDoc
   */
		value: function getReversed() {
			var delta = get(Object.getPrototypeOf(MergeDelta.prototype), 'getReversed', this).call(this);

			if (delta.operations.length > 0) {
				delta.operations[1].isSticky = false;
			}

			return delta;
		}

		/**
   * Operation in this delta that removes the node after merge position (which will be empty at that point) or
   * `null` if the delta has no operations. Note, that after {@link engine.model.delta.transform transformation}
   * this might be an instance of {@link engine.model.operation.MoveOperation} instead of
   * {@link engine.model.operation.RemoveOperation}.
   *
   * @readonly
   * @protected
   * @type {engine.model.operation.MoveOperation|null}
   */

	}, {
		key: 'position',

		/**
   * Position between to merged nodes or `null` if the delta has no operations.
   *
   * @readonly
   * @type {engine.model.Position|null}
   */
		get: function get() {
			return this._removeOperation ? this._removeOperation.sourcePosition : null;
		}
	}, {
		key: '_removeOperation',
		get: function get() {
			return this.operations[1] || null;
		}

		/**
   * @inheritDoc
   */

	}, {
		key: '_reverseDeltaClass',
		get: function get() {
			return SplitDelta;
		}

		/**
   * @inheritDoc
   */

	}], [{
		key: 'className',
		get: function get() {
			return 'engine.model.delta.MergeDelta';
		}
	}]);
	return MergeDelta;
}(Delta);

register('merge', function (position) {
	var delta = new MergeDelta();
	this.addDelta(delta);

	var nodeBefore = position.nodeBefore;
	var nodeAfter = position.nodeAfter;

	if (!(nodeBefore instanceof Element)) {
		/**
   * Node before merge position must be an element.
   *
   * @error batch-merge-no-element-before
   */
		throw new CKEditorError('batch-merge-no-element-before: Node before merge position must be an element.');
	}

	if (!(nodeAfter instanceof Element)) {
		/**
   * Node after merge position must be an element.
   *
   * @error batch-merge-no-element-after
   */
		throw new CKEditorError('batch-merge-no-element-after: Node after merge position must be an element.');
	}

	var positionAfter = Position.createFromParentAndOffset(nodeAfter, 0);
	var positionBefore = Position.createFromParentAndOffset(nodeBefore, nodeBefore.maxOffset);

	var move = new MoveOperation(positionAfter, nodeAfter.maxOffset, positionBefore, this.document.version);
	move.isSticky = true;
	delta.addOperation(move);
	this.document.applyOperation(move);

	var remove = new RemoveOperation(position, 1, this.document.version);
	delta.addOperation(remove);
	this.document.applyOperation(remove);

	return this;
});

DeltaFactory.register(MergeDelta);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Operation to change element's name.
 *
 * Using this class you can change element's name.
 *
 * @memberOf engine.model.operation
 * @extends engine.model.operation.Operation
 */

var RenameOperation = function (_Operation) {
	inherits(RenameOperation, _Operation);

	/**
  * Creates an operation that changes element's name.
  *
  * @param {engine.model.Position} position Position before an element to change.
  * @param {String} oldName Current name of the element.
  * @param {String} newName New name for the element.
  * @param {Number} baseVersion {@link engine.model.Document#version} on which the operation can be applied.
  */
	function RenameOperation(position, oldName, newName, baseVersion) {
		classCallCheck(this, RenameOperation);

		/**
   * Position before an element to change.
   *
   * @member {engine.model.Position} engine.model.operation.RenameOperation#position
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(RenameOperation).call(this, baseVersion));

		_this.position = position;

		/**
   * Current name of the element.
   *
   * @member {String} engine.model.operation.RenameOperation#oldName
   */
		_this.oldName = oldName;

		/**
   * New name for the element.
   *
   * @member {String} engine.model.operation.RenameOperation#newName
   */
		_this.newName = newName;
		return _this;
	}

	/**
  * @inheritDoc
  */


	createClass(RenameOperation, [{
		key: 'clone',


		/**
   * @inheritDoc
   * @returns {engine.model.operation.RenameOperation}
   */
		value: function clone() {
			return new RenameOperation(Position.createFromPosition(this.position), this.oldName, this.newName, this.baseVersion);
		}

		/**
   * @inheritDoc
   * @returns {engine.model.operation.RenameOperation}
   */

	}, {
		key: 'getReversed',
		value: function getReversed() {
			return new RenameOperation(Position.createFromPosition(this.position), this.newName, this.oldName, this.baseVersion + 1);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: '_execute',
		value: function _execute() {
			// Validation.
			var element = this.position.nodeAfter;

			if (!(element instanceof Element)) {
				/**
     * Given position is invalid or node after it is not instance of Element.
     *
     * @error rename-operation-wrong-position
     */
				throw new CKEditorError('rename-operation-wrong-position: Given position is invalid or node after it is not an instance of Element.');
			} else if (element.name !== this.oldName) {
				/**
     * Element to change has different name than operation's old name.
     *
     * @error rename-operation-wrong-name
     */
				throw new CKEditorError('rename-operation-wrong-name: Element to change has different name than operation\'s old name.');
			}

			element.name = this.newName;

			return { element: element, oldName: this.oldName };
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'type',
		get: function get() {
			return 'rename';
		}
	}], [{
		key: 'fromJSON',


		/**
   * Creates `RenameOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param {Object} json Deserialized JSON object.
   * @param {engine.model.Document} document Document on which this operation will be applied.
   * @returns {engine.model.operation.AttributeOperation}
   */
		value: function fromJSON(json, document) {
			return new RenameOperation(Position.fromJSON(json.position, document), json.oldName, json.newName, json.baseVersion);
		}
	}, {
		key: 'className',
		get: function get() {
			return 'engine.model.operation.RenameOperation';
		}
	}]);
	return RenameOperation;
}(Operation);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * To provide specific OT behavior and better collisions solving, the {@link engine.model.Batch#rename Batch#rename} method
 * uses the `RenameDelta` class which inherits from the `Delta` class and may overwrite some methods.
 *
 * @memberOf engine.model.delta
 */

var RenameDelta = function (_Delta) {
	inherits(RenameDelta, _Delta);

	function RenameDelta() {
		classCallCheck(this, RenameDelta);
		return possibleConstructorReturn(this, Object.getPrototypeOf(RenameDelta).apply(this, arguments));
	}

	createClass(RenameDelta, [{
		key: '_reverseDeltaClass',

		/**
   * @inheritDoc
   */
		get: function get() {
			return RenameDelta;
		}

		/**
   * @inheritDoc
   */

	}], [{
		key: 'className',
		get: function get() {
			return 'engine.model.delta.RenameDelta';
		}
	}]);
	return RenameDelta;
}(Delta);

function apply$1(batch, delta, operation) {
	delta.addOperation(operation);
	batch.document.applyOperation(operation);
}

/**
 * Renames given element.
 *
 * @chainable
 * @method engine.model.Batch#rename
 * @param {engine.model.Element} element The element to rename.
 * @param {String} newName New element name.
 */
register('rename', function (element, newName) {
	if (!(element instanceof Element)) {
		/**
   * Trying to rename an object which is not an instance of Element.
   *
   * @error batch-rename-not-element-instance
   */
		throw new CKEditorError('batch-rename-not-element-instance: Trying to rename an object which is not an instance of Element.');
	}

	var delta = new RenameDelta();
	this.addDelta(delta);

	apply$1(this, delta, new RenameOperation(Position.createBefore(element), element.name, newName, this.document.version));

	return this;
});

DeltaFactory.register(RenameDelta);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @classdesc
 * To provide specific OT behavior and better collisions solving, {@link engine.model.Batch#merge} method
 * uses the `WrapDelta` class which inherits from the `Delta` class and may overwrite some methods.
 *
 * @memberOf engine.model.delta
 */

var WrapDelta = function (_Delta) {
	inherits(WrapDelta, _Delta);

	function WrapDelta() {
		classCallCheck(this, WrapDelta);
		return possibleConstructorReturn(this, Object.getPrototypeOf(WrapDelta).apply(this, arguments));
	}

	createClass(WrapDelta, [{
		key: 'range',

		/**
   * Range to wrap or `null` if there are no operations in the delta.
   *
   * @type {engine.model.Range|null}
   */
		get: function get() {
			var moveOp = this._moveOperation;

			return moveOp ? Range$1.createFromPositionAndShift(moveOp.sourcePosition, moveOp.howMany) : null;
		}

		/**
   * Offset size of range to wrap by the delta or `null` if there are no operations in delta.
   *
   * @type {Number}
   */

	}, {
		key: 'howMany',
		get: function get() {
			var range = this.range;

			return range ? range.end.offset - range.start.offset : 0;
		}

		/**
   * Operation that inserts wrapping element or `null` if there are no operations in the delta.
   *
   * @protected
   * @type {engine.model.operation.InsertOperation|engine.model.operation.ReinsertOperation}
   */

	}, {
		key: '_insertOperation',
		get: function get() {
			return this.operations[0] || null;
		}

		/**
   * Operation that moves wrapped nodes to their new parent or `null` if there are no operations in the delta.
   *
   * @protected
   * @type {engine.model.operation.MoveOperation|null}
   */

	}, {
		key: '_moveOperation',
		get: function get() {
			return this.operations[1] || null;
		}

		/**
   * @inheritDoc
   */

	}, {
		key: '_reverseDeltaClass',
		get: function get() {
			return UnwrapDelta;
		}

		/**
   * @inheritDoc
   */

	}], [{
		key: 'className',
		get: function get() {
			return 'engine.model.delta.WrapDelta';
		}

		/**
   * @inheritDoc
   */

	}, {
		key: '_priority',
		get: function get() {
			return 10;
		}
	}]);
	return WrapDelta;
}(Delta);

register('wrap', function (range, elementOrString) {
	if (!range.isFlat) {
		/**
   * Range to wrap is not flat.
   *
   * @error batch-wrap-range-not-flat
   */
		throw new CKEditorError('batch-wrap-range-not-flat: Range to wrap is not flat.');
	}

	var element = elementOrString instanceof Element ? elementOrString : new Element(elementOrString);

	if (element.childCount > 0) {
		/**
   * Element to wrap with is not empty.
   *
   * @error batch-wrap-element-not-empty
   */
		throw new CKEditorError('batch-wrap-element-not-empty: Element to wrap with is not empty.');
	}

	if (element.parent !== null) {
		/**
   * Element to wrap with is already attached to a tree model.
   *
   * @error batch-wrap-element-attached
   */
		throw new CKEditorError('batch-wrap-element-attached: Element to wrap with is already attached to tree model.');
	}

	var delta = new WrapDelta();
	this.addDelta(delta);

	var insert = new InsertOperation(range.end, element, this.document.version);
	delta.addOperation(insert);
	this.document.applyOperation(insert);

	var targetPosition = Position.createFromParentAndOffset(element, 0);
	var move = new MoveOperation(range.start, range.end.offset - range.start.offset, targetPosition, this.document.version);
	delta.addOperation(move);
	this.document.applyOperation(move);

	return this;
});

DeltaFactory.register(WrapDelta);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @classdesc
 * To provide specific OT behavior and better collisions solving, {@link engine.model.Batch#merge} method
 * uses the `UnwrapDelta` class which inherits from the `Delta` class and may overwrite some methods.
 *
 * @memberOf engine.model.delta
 */

var UnwrapDelta = function (_Delta) {
	inherits(UnwrapDelta, _Delta);

	function UnwrapDelta() {
		classCallCheck(this, UnwrapDelta);
		return possibleConstructorReturn(this, Object.getPrototypeOf(UnwrapDelta).apply(this, arguments));
	}

	createClass(UnwrapDelta, [{
		key: 'position',

		/**
   * Position before unwrapped element or `null` if there are no operations in the delta.
   *
   * @type {engine.model.Position|null}
   */
		get: function get() {
			return this._moveOperation ? this._moveOperation.targetPosition : null;
		}

		/**
   * Operation in the delta that moves unwrapped nodes to their new parent or `null` if there are no operations in the delta.
   *
   * @protected
   * @type {engine.model.operation.MoveOperation|null}
   */

	}, {
		key: '_moveOperation',
		get: function get() {
			return this.operations[0] || null;
		}

		/**
   * @inheritDoc
   */

	}, {
		key: '_reverseDeltaClass',
		get: function get() {
			return WrapDelta;
		}

		/**
   * @inheritDoc
   */

	}], [{
		key: 'className',
		get: function get() {
			return 'engine.model.delta.UnwrapDelta';
		}

		/**
   * @inheritDoc
   */

	}, {
		key: '_priority',
		get: function get() {
			return 10;
		}
	}]);
	return UnwrapDelta;
}(Delta);

register('unwrap', function (element) {
	if (element.parent === null) {
		/**
   * Trying to unwrap an element that has no parent.
   *
   * @error batch-unwrap-element-no-parent
   */
		throw new CKEditorError('batch-unwrap-element-no-parent: Trying to unwrap an element that has no parent.');
	}

	var delta = new UnwrapDelta();
	this.addDelta(delta);

	var sourcePosition = Position.createFromParentAndOffset(element, 0);

	var move = new MoveOperation(sourcePosition, element.maxOffset, Position.createBefore(element), this.document.version);
	move.isSticky = true;
	delta.addOperation(move);
	this.document.applyOperation(move);

	// Computing new position because we moved some nodes before `element`.
	// If we would cache `Position.createBefore( element )` we remove wrong node.
	var remove = new RemoveOperation(Position.createBefore(element), 1, this.document.version);
	delta.addOperation(remove);
	this.document.applyOperation(remove);

	return this;
});

DeltaFactory.register(UnwrapDelta);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @classdesc
 * To provide specific OT behavior and better collisions solving, the {@link engine.model.Batch#insert} method
 * uses the `WeakInsertDelta` class which inherits from the `Delta` class and may overwrite some methods.
 *
 * @memberOf engine.model.delta
 */

var WeakInsertDelta = function (_InsertDelta) {
  inherits(WeakInsertDelta, _InsertDelta);

  function WeakInsertDelta() {
    classCallCheck(this, WeakInsertDelta);
    return possibleConstructorReturn(this, Object.getPrototypeOf(WeakInsertDelta).apply(this, arguments));
  }

  createClass(WeakInsertDelta, null, [{
    key: 'className',

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'engine.model.delta.WeakInsertDelta';
    }
  }]);
  return WeakInsertDelta;
}(InsertDelta);

register('weakInsert', function (position, nodes) {
  var delta = new WeakInsertDelta();
  this.addDelta(delta);

  nodes = normalizeNodes(nodes);

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var node = _step.value;

      node.setAttributesTo(this.document.selection.getAttributes());
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var operation = new InsertOperation(position, nodes, this.document.version);
  delta.addOperation(operation);
  this.document.applyOperation(operation);

  return this;
});

DeltaFactory.register(WeakInsertDelta);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

// Deltas require `register` method that require `Batch` class and is defined in batch-base.js.
// We would like to group all deltas files in one place, so we would only have to include batch.js
// which would already have all default deltas registered.

// Import default suite of deltas so a feature have to include only Batch class file.

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED$2);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache();
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

var UNORDERED_COMPARE_FLAG = 1;
var PARTIAL_COMPARE_FLAG$1 = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG$1,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;

  stack.set(array, other);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!seen.has(othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          return seen.add(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  return result;
}

var UNORDERED_COMPARE_FLAG$1 = 1;
var PARTIAL_COMPARE_FLAG$2 = 2;
var boolTag$2 = '[object Boolean]';
var dateTag$2 = '[object Date]';
var errorTag$1 = '[object Error]';
var mapTag$3 = '[object Map]';
var numberTag$2 = '[object Number]';
var regexpTag$2 = '[object RegExp]';
var setTag$3 = '[object Set]';
var stringTag$3 = '[object String]';
var symbolTag$3 = '[object Symbol]';
var arrayBufferTag$2 = '[object ArrayBuffer]';
var dataViewTag$3 = '[object DataView]';
var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined;
var symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
  switch (tag) {
    case dataViewTag$3:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag$2:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag$2:
    case dateTag$2:
      // Coerce dates and booleans to numbers, dates to milliseconds and
      // booleans to `1` or `0` treating invalid dates coerced to `NaN` as
      // not equal.
      return +object == +other;

    case errorTag$1:
      return object.name == other.name && object.message == other.message;

    case numberTag$2:
      // Treat `NaN` vs. `NaN` as equal.
      return object != +object ? other != +other : object == +other;

    case regexpTag$2:
    case stringTag$3:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/6.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag$3:
      var convert = mapToArray;

    case setTag$3:
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG$2;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= UNORDERED_COMPARE_FLAG$1;
      stack.set(object, other);

      // Recursively compare objects (susceptible to call stack limits).
      return equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);

    case symbolTag$3:
      if (symbolValueOf$1) {
        return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
      }
  }
  return false;
}

/** Used to compose bitmasks for comparison styles. */
var PARTIAL_COMPARE_FLAG$3 = 2;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG$3,
      objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : baseHas(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  return result;
}

var argsTag$3 = '[object Arguments]';
var arrayTag$2 = '[object Array]';
var boolTag$3 = '[object Boolean]';
var dateTag$3 = '[object Date]';
var errorTag$2 = '[object Error]';
var funcTag$2 = '[object Function]';
var mapTag$4 = '[object Map]';
var numberTag$3 = '[object Number]';
var objectTag$4 = '[object Object]';
var regexpTag$3 = '[object RegExp]';
var setTag$4 = '[object Set]';
var stringTag$4 = '[object String]';
var weakMapTag$2 = '[object WeakMap]';
var arrayBufferTag$3 = '[object ArrayBuffer]';
var dataViewTag$4 = '[object DataView]';
var float32Tag$2 = '[object Float32Array]';
var float64Tag$2 = '[object Float64Array]';
var int8Tag$2 = '[object Int8Array]';
var int16Tag$2 = '[object Int16Array]';
var int32Tag$2 = '[object Int32Array]';
var uint8Tag$2 = '[object Uint8Array]';
var uint8ClampedTag$2 = '[object Uint8ClampedArray]';
var uint16Tag$2 = '[object Uint16Array]';
var uint32Tag$2 = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$3] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$2] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$4] = typedArrayTags[weakMapTag$2] = false;

/** Used for built-in method references. */
var objectProto$17 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$6 = objectProto$17.toString;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
function isTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString$6.call(value)];
}

/** Used to compose bitmasks for comparison styles. */
var PARTIAL_COMPARE_FLAG = 2;

/** `Object#toString` result references. */
var argsTag$2 = '[object Arguments]';
var arrayTag$1 = '[object Array]';
var objectTag$3 = '[object Object]';
/** Used for built-in method references. */
var objectProto$16 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$16.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag$1,
      othTag = arrayTag$1;

  if (!objIsArr) {
    objTag = getTag$1(object);
    objTag = objTag == argsTag$2 ? objectTag$3 : objTag;
  }
  if (!othIsArr) {
    othTag = getTag$1(other);
    othTag = othTag == argsTag$2 ? objectTag$3 : othTag;
  }
  var objIsObj = objTag == objectTag$3 && !isHostObject(object),
      othIsObj = othTag == objectTag$3 && !isHostObject(other),
      isSameTag = objTag == othTag;

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
  }
  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty$9.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$9.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, bitmask, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are **not** supported.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent,
 *  else `false`.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var other = { 'user': 'fred' };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

var ot = {
	InsertOperation: {
		// Transforms InsertOperation `a` by InsertOperation `b`. Accepts a flag stating whether `a` is more important
		// than `b` when it comes to resolving conflicts. Returns results as an array of operations.
		InsertOperation: function InsertOperation(a, b, isStrong) {
			// Transformed operations are always new instances, not references to the original operations.
			var transformed = a.clone();

			// Transform insert position by the other operation position.
			transformed.position = transformed.position._getTransformedByInsertion(b.position, b.nodes.maxOffset, !isStrong);

			return [transformed];
		},


		AttributeOperation: doNotUpdate,

		RootAttributeOperation: doNotUpdate,

		RenameOperation: doNotUpdate,

		// Transforms InsertOperation `a` by MoveOperation `b`. Accepts a flag stating whether `a` is more important
		// than `b` when it comes to resolving conflicts. Returns results as an array of operations.
		MoveOperation: function MoveOperation(a, b, isStrong) {
			var transformed = a.clone();

			// Transform insert position by the other operation parameters.
			transformed.position = a.position._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany, !isStrong, b.isSticky);

			return [transformed];
		}
	},

	AttributeOperation: {
		// Transforms AttributeOperation `a` by InsertOperation `b`. Returns results as an array of operations.
		InsertOperation: function InsertOperation(a, b) {
			// Transform this operation's range.
			var ranges = a.range._getTransformedByInsertion(b.position, b.nodes.maxOffset, true, false);

			// Map transformed range(s) to operations and return them.
			return ranges.reverse().map(function (range) {
				return new AttributeOperation(range, a.key, a.oldValue, a.newValue, a.baseVersion);
			});
		},


		// Transforms AttributeOperation `a` by AttributeOperation `b`. Accepts a flag stating whether `a` is more important
		// than `b` when it comes to resolving conflicts. Returns results as an array of operations.
		AttributeOperation: function AttributeOperation$$(a, b, isStrong) {
			if (a.key === b.key) {
				// If operations attributes are in conflict, check if their ranges intersect and manage them properly.

				// First, we want to apply change to the part of a range that has not been changed by the other operation.
				var operations = a.range.getDifference(b.range).map(function (range) {
					return new AttributeOperation(range, a.key, a.oldValue, a.newValue, a.baseVersion);
				});

				// Then we take care of the common part of ranges, but only if operations has different `newValue`.
				if (isStrong && !isEqual(a.newValue, b.newValue)) {
					// If this operation is more important, we also want to apply change to the part of the
					// original range that has already been changed by the other operation. Since that range
					// got changed we also have to update `oldValue`.
					var common = a.range.getIntersection(b.range);

					if (common !== null) {
						operations.push(new AttributeOperation(common, b.key, b.oldValue, a.newValue, a.baseVersion));
					}
				}

				// If no operations has been added nothing should get updated, but since we need to return
				// an instance of Operation we add NoOperation to the array.
				if (operations.length === 0) {
					operations.push(new NoOperation(a.baseVersion));
				}

				return operations;
			} else {
				// If operations don't conflict, simply return an array containing just a clone of this operation.
				return [a.clone()];
			}
		},


		RootAttributeOperation: doNotUpdate,

		RenameOperation: doNotUpdate,

		// Transforms AttributeOperation `a` by MoveOperation `b`. Returns results as an array of operations.
		MoveOperation: function MoveOperation(a, b) {
			// Convert MoveOperation properties into a range.
			var rangeB = Range$1.createFromPositionAndShift(b.sourcePosition, b.howMany);

			// This will aggregate transformed ranges.
			var ranges = [];

			// Special case when MoveOperation is in fact a RemoveOperation. RemoveOperation not only moves nodes but also
			// creates a "holder" element for them in graveyard. If there was a RemoveOperation pointing to an offset
			// before this AttributeOperation, we have to increment AttributeOperation's offset.
			if (b instanceof RemoveOperation && b._needsHolderElement && a.range.root == b.targetPosition.root && a.range.start.path[0] >= b._holderElementOffset) {
				// Do not change original operation!
				a = a.clone();
				a.range.start.path[0]++;
				a.range.end.path[0]++;
			}

			// Difference is a part of changed range that is modified by AttributeOperation but is not affected
			// by MoveOperation. This can be zero, one or two ranges (if moved range is inside changed range).
			// Right now we will make a simplification and join difference ranges and transform them as one. We will cover rangeB later.
			var difference = joinRanges(a.range.getDifference(rangeB));

			// Common is a range of nodes that is affected by MoveOperation. So it got moved to other place.
			var common = a.range.getIntersection(rangeB);

			if (difference !== null) {
				// MoveOperation removes nodes from their original position. We acknowledge this by proper transformation.
				// Take the start and the end of the range and transform them by deletion of moved nodes.
				// Note that if rangeB was inside AttributeOperation range, only difference.end will be transformed.
				// This nicely covers the joining simplification we did in the previous step.
				difference.start = difference.start._getTransformedByDeletion(b.sourcePosition, b.howMany);
				difference.end = difference.end._getTransformedByDeletion(b.sourcePosition, b.howMany);

				// MoveOperation pastes nodes into target position. We acknowledge this by proper transformation.
				// Note that since we operate on transformed difference range, we should transform by
				// previously transformed target position.
				// Note that we do not use Position._getTransformedByMove on range boundaries because we need to
				// transform by insertion a range as a whole, since newTargetPosition might be inside that range.
				ranges = difference._getTransformedByInsertion(b.movedRangeStart, b.howMany, true, false).reverse();
			}

			if (common !== null) {
				// Here we do not need to worry that newTargetPosition is inside moved range, because that
				// would mean that the MoveOperation targets into itself, and that is incorrect operation.
				// Instead, we calculate the new position of that part of original range.
				common.start = common.start._getCombined(b.sourcePosition, b.movedRangeStart);
				common.end = common.end._getCombined(b.sourcePosition, b.movedRangeStart);

				ranges.push(common);
			}

			// Map transformed range(s) to operations and return them.
			return ranges.map(function (range) {
				return new AttributeOperation(range, a.key, a.oldValue, a.newValue, a.baseVersion);
			});
		}
	},

	RootAttributeOperation: {
		InsertOperation: doNotUpdate,

		AttributeOperation: doNotUpdate,

		// Transforms RootAttributeOperation `a` by RootAttributeOperation `b`. Accepts a flag stating whether `a` is more important
		// than `b` when it comes to resolving conflicts. Returns results as an array of operations.
		RootAttributeOperation: function RootAttributeOperation(a, b, isStrong) {
			if (a.root === b.root && a.key === b.key) {
				if (a.newValue !== b.newValue && !isStrong || a.newValue === b.newValue) {
					return [new NoOperation(a.baseVersion)];
				}
			}

			return [a.clone()];
		},


		RenameOperation: doNotUpdate,

		MoveOperation: doNotUpdate
	},

	RenameOperation: {
		// Transforms RenameOperation `a` by InsertOperation `b`. Returns results as an array of operations.
		InsertOperation: function InsertOperation(a, b) {
			// Clone the operation, we don't want to alter the original operation.
			var clone = a.clone();

			// Transform this operation's position.
			clone.position = clone.position._getTransformedByInsertion(b.position, b.nodes.maxOffset, true);

			return [clone];
		},


		AttributeOperation: doNotUpdate,

		RootAttributeOperation: doNotUpdate,

		// Transforms RenameOperation `a` by RenameOperation `b`. Accepts a flag stating whether `a` is more important
		// than `b` when it comes to resolving conflicts. Returns results as an array of operations.
		RenameOperation: function RenameOperation(a, b, isStrong) {
			// Clone the operation, we don't want to alter the original operation.
			var clone = a.clone();

			if (a.position.isEqual(b.position) && !isStrong) {
				return [new NoOperation(a.baseVersion)];
			}

			return [clone];
		},


		// Transforms RenameOperation `a` by MoveOperation `b`. Returns results as an array of operations.
		MoveOperation: function MoveOperation(a, b) {
			var clone = a.clone();
			var isSticky = clone.position.isEqual(b.sourcePosition);

			clone.position = clone.position._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany, true, isSticky);

			return [clone];
		}
	},

	MoveOperation: {
		// Transforms MoveOperation `a` by InsertOperation `b`. Accepts a flag stating whether `a` is more important
		// than `b` when it comes to resolving conflicts. Returns results as an array of operations.
		InsertOperation: function InsertOperation(a, b, isStrong) {
			// Create range from MoveOperation properties and transform it by insertion.
			var range = Range$1.createFromPositionAndShift(a.sourcePosition, a.howMany);
			range = range._getTransformedByInsertion(b.position, b.nodes.maxOffset, false, a.isSticky)[0];

			var result = new a.constructor(range.start, range.end.offset - range.start.offset, a instanceof RemoveOperation ? a.baseVersion : a.targetPosition._getTransformedByInsertion(b.position, b.nodes.maxOffset, !isStrong), a instanceof RemoveOperation ? undefined : a.baseVersion);

			result.isSticky = a.isSticky;

			return [result];
		},


		AttributeOperation: doNotUpdate,

		RootAttributeOperation: doNotUpdate,

		RenameOperation: doNotUpdate,

		// Transforms MoveOperation `a` by MoveOperation `b`. Accepts a flag stating whether `a` is more important
		// than `b` when it comes to resolving conflicts. Returns results as an array of operations.
		MoveOperation: function MoveOperation(a, b, isStrong) {
			// Special case when both move operations' target positions are inside nodes that are
			// being moved by the other move operation. So in other words, we move ranges into inside of each other.
			// This case can't be solved reasonably (on the other hand, it should not happen often).
			if (moveTargetIntoMovedRange(a, b) && moveTargetIntoMovedRange(b, a)) {
				// Instead of transforming operation, we return a reverse of the operation that we transform by.
				// So when the results of this "transformation" will be applied, `b` MoveOperation will get reversed.
				return [b.getReversed()];
			}

			// Special case when both operations are RemoveOperations. RemoveOperation not only moves nodes but also
			// (usually) creates a "holder" element for them in graveyard. Each RemoveOperation should move nodes to different
			// "holder" element. If `a` operation points after `b` operation, we move `a` offset to acknowledge
			// "holder" element insertion.
			if (a instanceof RemoveOperation && b instanceof RemoveOperation && b._needsHolderElement) {
				var aTarget = a.targetPosition.path[0];
				var bTarget = b.targetPosition.path[0];

				if (aTarget > bTarget || aTarget == bTarget && isStrong) {
					// Do not change original operation!
					a = a.clone();
					a.targetPosition.path[0]++;
				}
			}

			// If only one of operations is a remove operation, we force remove operation to be the "stronger" one
			// to provide more expected results.
			if (a instanceof RemoveOperation && !(b instanceof RemoveOperation)) {
				isStrong = true;
			} else if (!(a instanceof RemoveOperation) && b instanceof RemoveOperation) {
				isStrong = false;
			}

			// Create ranges from MoveOperations properties.
			var rangeA = Range$1.createFromPositionAndShift(a.sourcePosition, a.howMany);
			var rangeB = Range$1.createFromPositionAndShift(b.sourcePosition, b.howMany);

			// This will aggregate transformed ranges.
			var ranges = [];

			// All the other non-special cases are treated by generic algorithm below.
			var difference = joinRanges(rangeA.getDifference(rangeB));

			if (difference) {
				difference.start = difference.start._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany, !a.isSticky, false);
				difference.end = difference.end._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany, a.isSticky, false);

				ranges.push(difference);
			}

			// Then, we have to manage the common part of both move ranges.
			var common = rangeA.getIntersection(rangeB);

			// If MoveOperations has common range it can be one of two:
			// * on the same tree level - it means that we move the same nodes into different places
			// * on deeper tree level - it means that we move nodes that are inside moved nodes
			// The operations are conflicting only if they try to move exactly same nodes, so only in the first case.
			// That means that we transform common part in two cases:
			// * `rangeA` is "deeper" than `rangeB` so it does not collide
			// * `rangeA` is at the same level but is stronger than `rangeB`.
			var aCompB = compareArrays(a.sourcePosition.getParentPath(), b.sourcePosition.getParentPath());

			// If the `b` MoveOperation points inside the `a` MoveOperation range, the common part will be included in
			// range(s) that (is) are results of processing `difference`. If that's the case, we cannot include it again.
			var bTargetsToA = rangeA.containsPosition(b.targetPosition) || rangeA.start.isEqual(b.targetPosition) && a.isSticky || rangeA.end.isEqual(b.targetPosition) && a.isSticky;

			// If the `b` MoveOperation range contains both whole `a` range and target position we do an exception and
			// transform `a` operation. Normally, when same nodes are moved, we stick with stronger operation's target.
			// Here it is a move inside larger range so there is no conflict because after all, all nodes from
			// smaller range will be moved to larger range target. The effect of this transformation feels natural.
			// Also if we wouldn't do that, we would get different results on both sides of transformation (i.e. in
			// collaborative editing).
			var aIsInside = rangeB.containsRange(rangeA) && (rangeB.containsPosition(a.targetPosition) || rangeB.start.isEqual(a.targetPosition) || rangeB.end.isEqual(a.targetPosition));

			if (common !== null && (aCompB === 'extension' || aCompB === 'same' && isStrong || aIsInside) && !bTargetsToA) {
				// Here we do not need to worry that newTargetPosition is inside moved range, because that
				// would mean that the MoveOperation targets into itself, and that is incorrect operation.
				// Instead, we calculate the new position of that part of original range.
				common.start = common.start._getCombined(b.sourcePosition, b.movedRangeStart);
				common.end = common.end._getCombined(b.sourcePosition, b.movedRangeStart);

				// We have to take care of proper range order.
				if (difference && difference.start.isBefore(common.start)) {
					ranges.push(common);
				} else {
					ranges.unshift(common);
				}
			}

			// At this point we transformed this operation's source ranges it means that nothing should be changed.
			// But since we need to return an instance of Operation we return an array with NoOperation.
			if (ranges.length === 0) {
				return [new NoOperation(a.baseVersion)];
			}

			// Target position also could be affected by the other MoveOperation. We will transform it.
			var newTargetPosition = a.targetPosition._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany, !isStrong, b.isSticky || aIsInside);

			// Map transformed range(s) to operations and return them.
			return ranges.reverse().map(function (range) {
				// We want to keep correct operation class.
				var result = new a.constructor(range.start, range.end.offset - range.start.offset, a instanceof RemoveOperation ? a.baseVersion : newTargetPosition, a instanceof RemoveOperation ? undefined : a.baseVersion);

				result.isSticky = a.isSticky;
				result._holderElementOffset = a._holderElementOffset;

				return result;
			});
		}
	}
};

function transform$2(a, b, isStrong) {
	var group = void 0;
	var algorithm = void 0;

	if (a instanceof InsertOperation) {
		group = ot.InsertOperation;
	} else if (a instanceof AttributeOperation) {
		group = ot.AttributeOperation;
	} else if (a instanceof RootAttributeOperation) {
		group = ot.RootAttributeOperation;
	} else if (a instanceof RenameOperation) {
		group = ot.RenameOperation;
	} else if (a instanceof MoveOperation) {
		group = ot.MoveOperation;
	} else {
		algorithm = doNotUpdate;
	}

	if (group) {
		if (b instanceof InsertOperation) {
			algorithm = group.InsertOperation;
		} else if (b instanceof AttributeOperation) {
			algorithm = group.AttributeOperation;
		} else if (b instanceof RootAttributeOperation) {
			algorithm = group.RootAttributeOperation;
		} else if (b instanceof RenameOperation) {
			algorithm = group.RenameOperation;
		} else if (b instanceof MoveOperation) {
			algorithm = group.MoveOperation;
		} else {
			algorithm = doNotUpdate;
		}
	}

	var transformed = algorithm(a, b, isStrong);

	return updateBaseVersions(a.baseVersion, transformed);
}

// When we don't want to update an operation, we create and return a clone of it.
// Returns the operation in "unified format" - wrapped in an Array.
function doNotUpdate(operation) {
	return [operation.clone()];
}

// Takes an Array of operations and sets consecutive base versions for them, starting from given base version.
// Returns the passed array.
function updateBaseVersions(baseVersion, operations) {
	for (var i = 0; i < operations.length; i++) {
		operations[i].baseVersion = baseVersion + i + 1;
	}

	return operations;
}

// Checks whether MoveOperation targetPosition is inside a node from the moved range of the other MoveOperation.
function moveTargetIntoMovedRange(a, b) {
	return a.targetPosition._getTransformedByDeletion(b.sourcePosition, b.howMany) === null;
}

// Gets an array of Ranges and produces one Range out of it. The root of a new range will be same as
// the root of the first range in the array. If any of given ranges has different root than the first range,
// it will be discarded.
function joinRanges(ranges) {
	if (ranges.length === 0) {
		return null;
	} else if (ranges.length == 1) {
		return ranges[0];
	} else {
		ranges[0].end = ranges[ranges.length - 1].end;

		return ranges[0];
	}
}

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

var nativeCeil = Math.ceil;
var nativeMax$1 = Math.max;
/**
 * Creates an array of elements split into groups the length of `size`.
 * If `array` can't be split evenly, the final chunk will be the remaining
 * elements.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to process.
 * @param {number} [size=1] The length of each chunk
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the new array of chunks.
 * @example
 *
 * _.chunk(['a', 'b', 'c', 'd'], 2);
 * // => [['a', 'b'], ['c', 'd']]
 *
 * _.chunk(['a', 'b', 'c', 'd'], 3);
 * // => [['a', 'b', 'c'], ['d']]
 */
function chunk(array, size, guard) {
  if (guard ? isIterateeCall(array, size, guard) : size === undefined) {
    size = 1;
  } else {
    size = nativeMax$1(toInteger(size), 0);
  }
  var length = array ? array.length : 0;
  if (!length || size < 1) {
    return [];
  }
  var index = 0,
      resIndex = 0,
      result = Array(nativeCeil(length / size));

  while (index < length) {
    result[resIndex++] = baseSlice(array, index, index += size);
  }
  return result;
}

/**
 * Creates an array with all falsey values removed. The values `false`, `null`,
 * `0`, `""`, `undefined`, and `NaN` are falsey.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to compact.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.compact([0, 1, false, 2, '', 3]);
 * // => [1, 2, 3]
 */
function compact(array) {
  var index = -1,
      length = array ? array.length : 0,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value);
}

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * Creates a new array concatenating `array` with any additional arrays
 * and/or values.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to concatenate.
 * @param {...*} [values] The values to concatenate.
 * @returns {Array} Returns the new concatenated array.
 * @example
 *
 * var array = [1];
 * var other = _.concat(array, 2, [3], [[4]]);
 *
 * console.log(other);
 * // => [1, 2, 3, [4]]
 *
 * console.log(array);
 * // => [1]
 */
function concat() {
  var length = arguments.length,
      args = Array(length ? length - 1 : 0),
      array = arguments[0],
      index = length;

  while (index--) {
    args[index - 1] = arguments[index];
  }
  return length ? arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1)) : [];
}

/**
 * Gets the index at which the first occurrence of `NaN` is found in `array`.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched `NaN`, else `-1`.
 */
function indexOfNaN(array, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 0 : -1);

  while (fromRight ? index-- : ++index < length) {
    var other = array[index];
    if (other !== other) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return indexOfNaN(array, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  return !!array.length && baseIndexOf(array, value, 0) > -1;
}

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing wrapper metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE$1 = 200;

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  } else if (values.length >= LARGE_ARRAY_SIZE$1) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer: while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = comparator || value !== 0 ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    } else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

/**
 * Creates an array of unique `array` values not included in the other given
 * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons. The order of result values is determined by the
 * order they occur in the first array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.without, _.xor
 * @example
 *
 * _.difference([3, 2, 1], [4, 2]);
 * // => [3, 1]
 */
var difference = rest(function (array, values) {
  return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
});

var UNORDERED_COMPARE_FLAG$2 = 1;
var PARTIAL_COMPARE_FLAG$4 = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG$2 | PARTIAL_COMPARE_FLAG$4, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

/**
 * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
 * of key-value pairs for `object` corresponding to the property names of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the key-value pairs.
 */
function baseToPairs(object, props) {
  return arrayMap(props, function (key) {
    return [key, object[key]];
  });
}

/**
 * Converts `set` to its value-value pairs.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the value-value pairs.
 */
function setToPairs(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function (value) {
    result[++index] = [value, value];
  });
  return result;
}

var mapTag$5 = '[object Map]';
var setTag$5 = '[object Set]';
/**
 * Creates a `_.toPairs` or `_.toPairsIn` function.
 *
 * @private
 * @param {Function} keysFunc The function to get the keys of a given object.
 * @returns {Function} Returns the new pairs function.
 */
function createToPairs(keysFunc) {
  return function (object) {
    var tag = getTag$1(object);
    if (tag == mapTag$5) {
      return mapToArray(object);
    }
    if (tag == setTag$5) {
      return setToPairs(object);
    }
    return baseToPairs(object, keysFunc(object));
  };
}

/**
 * Creates an array of own enumerable string keyed-value pairs for `object`
 * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
 * entries are returned.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias entries
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the key-value pairs.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.toPairs(new Foo);
 * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
 */
var toPairs = createToPairs(keys);

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = toPairs(object),
      length = result.length;

  while (length--) {
    result[length][2] = isStrictComparable(result[length][1]);
  }
  return result;
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT$1 = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || resolver && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function memoized() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/** Used as references for various `Number` constants. */
var INFINITY$1 = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto$2 = _Symbol ? _Symbol.prototype : undefined;
var symbolToString = symbolProto$2 ? symbolProto$2.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = value + '';
  return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function (string) {
  var result = [];
  toString(string).replace(rePropName, function (match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

/** Used as references for various `Number` constants. */
var INFINITY$2 = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = value + '';
  return result == '0' && 1 / value == -INFINITY$2 ? '-0' : result;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return index && index == length ? object : undefined;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is used in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get$1(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return key in Object(object);
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = isKey(path, object) ? [path] : castPath(path);

  var result,
      index = -1,
      length = path.length;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result) {
    return result;
  }
  var length = object ? object.length : 0;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isString(object) || isArguments(object));
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

var UNORDERED_COMPARE_FLAG$3 = 1;
var PARTIAL_COMPARE_FLAG$5 = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function (object) {
    var objValue = get$1(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG$3 | PARTIAL_COMPARE_FLAG$5);
  };
}

/**
 * This method returns the first argument given to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function (object) {
    return baseGet(object, path);
  };
}

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}

/**
 * This method is like `_.difference` except that it accepts `iteratee` which
 * is invoked for each element of `array` and `values` to generate the criterion
 * by which they're compared. Result values are chosen from the first array.
 * The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.differenceBy([3.1, 2.2, 1.3], [4.4, 2.5], Math.floor);
 * // => [3.1, 1.3]
 *
 * // The `_.property` iteratee shorthand.
 * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
 * // => [{ 'x': 2 }]
 */
var differenceBy = rest(function (array, values) {
  var iteratee = last(values);
  if (isArrayLikeObject(iteratee)) {
    iteratee = undefined;
  }
  return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), baseIteratee(iteratee)) : [];
});

/**
 * This method is like `_.difference` except that it accepts `comparator`
 * which is invoked to compare elements of `array` to `values`. Result values
 * are chosen from the first array. The comparator is invoked with two arguments:
 * (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 *
 * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
 * // => [{ 'x': 2, 'y': 1 }]
 */
var differenceWith = rest(function (array, values) {
  var comparator = last(values);
  if (isArrayLikeObject(comparator)) {
    comparator = undefined;
  }
  return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : [];
});

/**
 * Creates a slice of `array` with `n` elements dropped from the beginning.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to drop.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.drop([1, 2, 3]);
 * // => [2, 3]
 *
 * _.drop([1, 2, 3], 2);
 * // => [3]
 *
 * _.drop([1, 2, 3], 5);
 * // => []
 *
 * _.drop([1, 2, 3], 0);
 * // => [1, 2, 3]
 */
function drop(array, n, guard) {
  var length = array ? array.length : 0;
  if (!length) {
    return [];
  }
  n = guard || n === undefined ? 1 : toInteger(n);
  return baseSlice(array, n < 0 ? 0 : n, length);
}

/**
 * Creates a slice of `array` with `n` elements dropped from the end.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to drop.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.dropRight([1, 2, 3]);
 * // => [1, 2]
 *
 * _.dropRight([1, 2, 3], 2);
 * // => [1]
 *
 * _.dropRight([1, 2, 3], 5);
 * // => []
 *
 * _.dropRight([1, 2, 3], 0);
 * // => [1, 2, 3]
 */
function dropRight(array, n, guard) {
  var length = array ? array.length : 0;
  if (!length) {
    return [];
  }
  n = guard || n === undefined ? 1 : toInteger(n);
  n = length - n;
  return baseSlice(array, 0, n < 0 ? 0 : n);
}

/**
 * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
 * without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to query.
 * @param {Function} predicate The function invoked per iteration.
 * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the slice of `array`.
 */
function baseWhile(array, predicate, isDrop, fromRight) {
  var length = array.length,
      index = fromRight ? length : -1;

  while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}

  return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
}

/**
 * Creates a slice of `array` excluding elements dropped from the end.
 * Elements are dropped until `predicate` returns falsey. The predicate is
 * invoked with three arguments: (value, index, array).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': true },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': false }
 * ];
 *
 * _.dropRightWhile(users, function(o) { return !o.active; });
 * // => objects for ['barney']
 *
 * // The `_.matches` iteratee shorthand.
 * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
 * // => objects for ['barney', 'fred']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.dropRightWhile(users, ['active', false]);
 * // => objects for ['barney']
 *
 * // The `_.property` iteratee shorthand.
 * _.dropRightWhile(users, 'active');
 * // => objects for ['barney', 'fred', 'pebbles']
 */
function dropRightWhile(array, predicate) {
  return array && array.length ? baseWhile(array, baseIteratee(predicate, 3), true, true) : [];
}

/**
 * Creates a slice of `array` excluding elements dropped from the beginning.
 * Elements are dropped until `predicate` returns falsey. The predicate is
 * invoked with three arguments: (value, index, array).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.dropWhile(users, function(o) { return !o.active; });
 * // => objects for ['pebbles']
 *
 * // The `_.matches` iteratee shorthand.
 * _.dropWhile(users, { 'user': 'barney', 'active': false });
 * // => objects for ['fred', 'pebbles']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.dropWhile(users, ['active', false]);
 * // => objects for ['pebbles']
 *
 * // The `_.property` iteratee shorthand.
 * _.dropWhile(users, 'active');
 * // => objects for ['barney', 'fred', 'pebbles']
 */
function dropWhile(array, predicate) {
  return array && array.length ? baseWhile(array, baseIteratee(predicate, 3), true) : [];
}

/**
 * The base implementation of `_.clamp` which doesn't coerce arguments to numbers.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }
    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH = 4294967295;

/**
 * Converts `value` to an integer suitable for use as the length of an
 * array-like object.
 *
 * **Note:** This method is based on
 * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toLength(3.2);
 * // => 3
 *
 * _.toLength(Number.MIN_VALUE);
 * // => 0
 *
 * _.toLength(Infinity);
 * // => 4294967295
 *
 * _.toLength('3.2');
 * // => 3
 */
function toLength(value) {
  return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
}

/**
 * The base implementation of `_.fill` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to fill.
 * @param {*} value The value to fill `array` with.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns `array`.
 */
function baseFill(array, value, start, end) {
  var length = array.length;

  start = toInteger(start);
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end === undefined || end > length ? length : toInteger(end);
  if (end < 0) {
    end += length;
  }
  end = start > end ? 0 : toLength(end);
  while (start < end) {
    array[start++] = value;
  }
  return array;
}

/**
 * Fills elements of `array` with `value` from `start` up to, but not
 * including, `end`.
 *
 * **Note:** This method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 3.2.0
 * @category Array
 * @param {Array} array The array to fill.
 * @param {*} value The value to fill `array` with.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = [1, 2, 3];
 *
 * _.fill(array, 'a');
 * console.log(array);
 * // => ['a', 'a', 'a']
 *
 * _.fill(Array(3), 2);
 * // => [2, 2, 2]
 *
 * _.fill([4, 6, 8, 10], '*', 1, 3);
 * // => [4, '*', '*', 10]
 */
function fill(array, value, start, end) {
  var length = array ? array.length : 0;
  if (!length) {
    return [];
  }
  if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
    start = 0;
    end = length;
  }
  return baseFill(array, value, start, end);
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {Function} predicate The function invoked per iteration.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromRight) {
  var length = array.length,
      index = fromRight ? length : -1;

  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to search.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate) {
  return array && array.length ? baseFindIndex(array, baseIteratee(predicate, 3)) : -1;
}

/**
 * This method is like `_.findIndex` except that it iterates over elements
 * of `collection` from right to left.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to search.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': true },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': false }
 * ];
 *
 * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
 * // => 2
 *
 * // The `_.matches` iteratee shorthand.
 * _.findLastIndex(users, { 'user': 'barney', 'active': true });
 * // => 0
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findLastIndex(users, ['active', false]);
 * // => 2
 *
 * // The `_.property` iteratee shorthand.
 * _.findLastIndex(users, 'active');
 * // => 0
 */
function findLastIndex(array, predicate) {
  return array && array.length ? baseFindIndex(array, baseIteratee(predicate, 3), true) : -1;
}

/**
 * Gets the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias first
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the first element of `array`.
 * @example
 *
 * _.head([1, 2, 3]);
 * // => 1
 *
 * _.head([]);
 * // => undefined
 */
function head(array) {
  return array && array.length ? array[0] : undefined;
}

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array ? array.length : 0;
  return length ? baseFlatten(array, 1) : [];
}

/** Used as references for various `Number` constants. */
var INFINITY$3 = 1 / 0;

/**
 * Recursively flattens `array`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flattenDeep([1, [2, [3, [4]], 5]]);
 * // => [1, 2, 3, 4, 5]
 */
function flattenDeep(array) {
  var length = array ? array.length : 0;
  return length ? baseFlatten(array, INFINITY$3) : [];
}

/**
 * Recursively flatten `array` up to `depth` times.
 *
 * @static
 * @memberOf _
 * @since 4.4.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @param {number} [depth=1] The maximum recursion depth.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * var array = [1, [2, [3, [4]], 5]];
 *
 * _.flattenDepth(array, 1);
 * // => [1, 2, [3, [4]], 5]
 *
 * _.flattenDepth(array, 2);
 * // => [1, 2, 3, [4], 5]
 */
function flattenDepth(array, depth) {
  var length = array ? array.length : 0;
  if (!length) {
    return [];
  }
  depth = depth === undefined ? 1 : toInteger(depth);
  return baseFlatten(array, depth);
}

/**
 * The inverse of `_.toPairs`; this method returns an object composed
 * from key-value `pairs`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} pairs The key-value pairs.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.fromPairs([['fred', 30], ['barney', 40]]);
 * // => { 'fred': 30, 'barney': 40 }
 */
function fromPairs(pairs) {
  var index = -1,
      length = pairs ? pairs.length : 0,
      result = {};

  while (++index < length) {
    var pair = pairs[index];
    result[pair[0]] = pair[1];
  }
  return result;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$2 = Math.max;

/**
 * Gets the index at which the first occurrence of `value` is found in `array`
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons. If `fromIndex` is negative, it's used as the
 * offset from the end of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.indexOf([1, 2, 1, 2], 2);
 * // => 1
 *
 * // Search from the `fromIndex`.
 * _.indexOf([1, 2, 1, 2], 2, 2);
 * // => 3
 */
function indexOf(array, value, fromIndex) {
  var length = array ? array.length : 0;
  if (!length) {
    return -1;
  }
  fromIndex = toInteger(fromIndex);
  if (fromIndex < 0) {
    fromIndex = nativeMax$2(length + fromIndex, 0);
  }
  return baseIndexOf(array, value, fromIndex);
}

/**
 * Gets all but the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.initial([1, 2, 3]);
 * // => [1, 2]
 */
function initial(array) {
  return dropRight(array, 1);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * The base implementation of methods like `_.intersection`, without support
 * for iteratee shorthands, that accepts an array of arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of shared values.
 */
function baseIntersection(arrays, iteratee, comparator) {
  var includes = comparator ? arrayIncludesWith : arrayIncludes,
      length = arrays[0].length,
      othLength = arrays.length,
      othIndex = othLength,
      caches = Array(othLength),
      maxLength = Infinity,
      result = [];

  while (othIndex--) {
    var array = arrays[othIndex];
    if (othIndex && iteratee) {
      array = arrayMap(array, baseUnary(iteratee));
    }
    maxLength = nativeMin(array.length, maxLength);
    caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
  }
  array = arrays[0];

  var index = -1,
      seen = caches[0];

  outer: while (++index < length && result.length < maxLength) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = comparator || value !== 0 ? value : 0;
    if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
      othIndex = othLength;
      while (--othIndex) {
        var cache = caches[othIndex];
        if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
          continue outer;
        }
      }
      if (seen) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/**
 * Casts `value` to an empty array if it's not an array like object.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array|Object} Returns the cast array-like object.
 */
function castArrayLikeObject(value) {
  return isArrayLikeObject(value) ? value : [];
}

/**
 * Creates an array of unique values that are included in all given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons. The order of result values is determined by the
 * order they occur in the first array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * _.intersection([2, 1], [4, 2], [1, 2]);
 * // => [2]
 */
var intersection = rest(function (arrays) {
  var mapped = arrayMap(arrays, castArrayLikeObject);
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
});

/**
 * This method is like `_.intersection` except that it accepts `iteratee`
 * which is invoked for each element of each `arrays` to generate the criterion
 * by which they're compared. Result values are chosen from the first array.
 * The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * _.intersectionBy([2.1, 1.2], [4.3, 2.4], Math.floor);
 * // => [2.1]
 *
 * // The `_.property` iteratee shorthand.
 * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }]
 */
var intersectionBy = rest(function (arrays) {
  var iteratee = last(arrays),
      mapped = arrayMap(arrays, castArrayLikeObject);

  if (iteratee === last(mapped)) {
    iteratee = undefined;
  } else {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, baseIteratee(iteratee)) : [];
});

/**
 * This method is like `_.intersection` except that it accepts `comparator`
 * which is invoked to compare elements of `arrays`. Result values are chosen
 * from the first array. The comparator is invoked with two arguments:
 * (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.intersectionWith(objects, others, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }]
 */
var intersectionWith = rest(function (arrays) {
  var comparator = last(arrays),
      mapped = arrayMap(arrays, castArrayLikeObject);

  if (comparator === last(mapped)) {
    comparator = undefined;
  } else {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : [];
});

/** Used for built-in method references. */
var arrayProto$1 = Array.prototype;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeJoin = arrayProto$1.join;

/**
 * Converts all elements in `array` into a string separated by `separator`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to convert.
 * @param {string} [separator=','] The element separator.
 * @returns {string} Returns the joined string.
 * @example
 *
 * _.join(['a', 'b', 'c'], '~');
 * // => 'a~b~c'
 */
function join(array, separator) {
  return array ? nativeJoin.call(array, separator) : '';
}

var nativeMax$3 = Math.max;
var nativeMin$1 = Math.min;
/**
 * This method is like `_.indexOf` except that it iterates over elements of
 * `array` from right to left.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=array.length-1] The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.lastIndexOf([1, 2, 1, 2], 2);
 * // => 3
 *
 * // Search from the `fromIndex`.
 * _.lastIndexOf([1, 2, 1, 2], 2, 2);
 * // => 1
 */
function lastIndexOf(array, value, fromIndex) {
  var length = array ? array.length : 0;
  if (!length) {
    return -1;
  }
  var index = length;
  if (fromIndex !== undefined) {
    index = toInteger(fromIndex);
    index = (index < 0 ? nativeMax$3(length + index, 0) : nativeMin$1(index, length - 1)) + 1;
  }
  if (value !== value) {
    return indexOfNaN(array, index, true);
  }
  while (index--) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.nth` which doesn't coerce `n` to an integer.
 *
 * @private
 * @param {Array} array The array to query.
 * @param {number} n The index of the element to return.
 * @returns {*} Returns the nth element of `array`.
 */
function baseNth(array, n) {
  var length = array.length;
  if (!length) {
    return;
  }
  n += n < 0 ? length : 0;
  return isIndex(n, length) ? array[n] : undefined;
}

/**
 * Gets the element at `n` index of `array`. If `n` is negative, the nth
 * element from the end is returned.
 *
 * @static
 * @memberOf _
 * @since 4.11.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=0] The index of the element to return.
 * @returns {*} Returns the nth element of `array`.
 * @example
 *
 * var array = ['a', 'b', 'c', 'd'];
 *
 * _.nth(array, 1);
 * // => 'b'
 *
 * _.nth(array, -2);
 * // => 'c';
 */
function nth(array, n) {
  return array && array.length ? baseNth(array, toInteger(n)) : undefined;
}

/**
 * This function is like `baseIndexOf` except that it accepts a comparator.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOfWith(array, value, fromIndex, comparator) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (comparator(array[index], value)) {
      return index;
    }
  }
  return -1;
}

/** Used for built-in method references. */
var arrayProto$2 = Array.prototype;

/** Built-in value references. */
var splice$1 = arrayProto$2.splice;

/**
 * The base implementation of `_.pullAllBy` without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns `array`.
 */
function basePullAll(array, values, iteratee, comparator) {
  var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
      index = -1,
      length = values.length,
      seen = array;

  if (iteratee) {
    seen = arrayMap(array, baseUnary(iteratee));
  }
  while (++index < length) {
    var fromIndex = 0,
        value = values[index],
        computed = iteratee ? iteratee(value) : value;

    while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
      if (seen !== array) {
        splice$1.call(seen, fromIndex, 1);
      }
      splice$1.call(array, fromIndex, 1);
    }
  }
  return array;
}

/**
 * This method is like `_.pull` except that it accepts an array of values to remove.
 *
 * **Note:** Unlike `_.difference`, this method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = [1, 2, 3, 1, 2, 3];
 *
 * _.pullAll(array, [2, 3]);
 * console.log(array);
 * // => [1, 1]
 */
function pullAll(array, values) {
  return array && array.length && values && values.length ? basePullAll(array, values) : array;
}

/**
 * Removes all given values from `array` using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
 * to remove elements from an array by predicate.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {...*} [values] The values to remove.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = [1, 2, 3, 1, 2, 3];
 *
 * _.pull(array, 2, 3);
 * console.log(array);
 * // => [1, 1]
 */
var pull = rest(pullAll);

/**
 * This method is like `_.pullAll` except that it accepts `iteratee` which is
 * invoked for each element of `array` and `values` to generate the criterion
 * by which they're compared. The iteratee is invoked with one argument: (value).
 *
 * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
 *
 * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
 * console.log(array);
 * // => [{ 'x': 2 }]
 */
function pullAllBy(array, values, iteratee) {
  return array && array.length && values && values.length ? basePullAll(array, values, baseIteratee(iteratee)) : array;
}

/**
 * This method is like `_.pullAll` except that it accepts `comparator` which
 * is invoked to compare elements of `array` to `values`. The comparator is
 * invoked with two arguments: (arrVal, othVal).
 *
 * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 4.6.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Array} values The values to remove.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
 *
 * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
 * console.log(array);
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
 */
function pullAllWith(array, values, comparator) {
  return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array;
}

/**
 * The base implementation of `_.at` without support for individual paths.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {string[]} paths The property paths of elements to pick.
 * @returns {Array} Returns the picked elements.
 */
function baseAt(object, paths) {
  var index = -1,
      isNil = object == null,
      length = paths.length,
      result = Array(length);

  while (++index < length) {
    result[index] = isNil ? undefined : get$1(object, paths[index]);
  }
  return result;
}

/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object, path) {
  return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
}

/** Used for built-in method references. */
var arrayProto$3 = Array.prototype;

/** Built-in value references. */
var splice$2 = arrayProto$3.splice;

/**
 * The base implementation of `_.pullAt` without support for individual
 * indexes or capturing the removed elements.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {number[]} indexes The indexes of elements to remove.
 * @returns {Array} Returns `array`.
 */
function basePullAt(array, indexes) {
  var length = array ? indexes.length : 0,
      lastIndex = length - 1;

  while (length--) {
    var index = indexes[length];
    if (length == lastIndex || index !== previous) {
      var previous = index;
      if (isIndex(index)) {
        splice$2.call(array, index, 1);
      } else if (!isKey(index, array)) {
        var path = castPath(index),
            object = parent(array, path);

        if (object != null) {
          delete object[toKey(last(path))];
        }
      } else {
        delete array[toKey(index)];
      }
    }
  }
  return array;
}

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

/**
 * Removes elements from `array` corresponding to `indexes` and returns an
 * array of removed elements.
 *
 * **Note:** Unlike `_.at`, this method mutates `array`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {...(number|number[])} [indexes] The indexes of elements to remove.
 * @returns {Array} Returns the new array of removed elements.
 * @example
 *
 * var array = [5, 10, 15, 20];
 * var evens = _.pullAt(array, 1, 3);
 *
 * console.log(array);
 * // => [5, 15]
 *
 * console.log(evens);
 * // => [10, 20]
 */
var pullAt = rest(function (array, indexes) {
  indexes = baseFlatten(indexes, 1);

  var length = array ? array.length : 0,
      result = baseAt(array, indexes);

  basePullAt(array, arrayMap(indexes, function (index) {
    return isIndex(index, length) ? +index : index;
  }).sort(compareAscending));

  return result;
});

/**
 * Removes all elements from `array` that `predicate` returns truthy for
 * and returns an array of the removed elements. The predicate is invoked
 * with three arguments: (value, index, array).
 *
 * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
 * to pull elements from an array by value.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {Array} Returns the new array of removed elements.
 * @example
 *
 * var array = [1, 2, 3, 4];
 * var evens = _.remove(array, function(n) {
 *   return n % 2 == 0;
 * });
 *
 * console.log(array);
 * // => [1, 3]
 *
 * console.log(evens);
 * // => [2, 4]
 */
function remove$3(array, predicate) {
  var result = [];
  if (!(array && array.length)) {
    return result;
  }
  var index = -1,
      indexes = [],
      length = array.length;

  predicate = baseIteratee(predicate, 3);
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result.push(value);
      indexes.push(index);
    }
  }
  basePullAt(array, indexes);
  return result;
}

/** Used for built-in method references. */
var arrayProto$4 = Array.prototype;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeReverse = arrayProto$4.reverse;

/**
 * Reverses `array` so that the first element becomes the last, the second
 * element becomes the second to last, and so on.
 *
 * **Note:** This method mutates `array` and is based on
 * [`Array#reverse`](https://mdn.io/Array/reverse).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @returns {Array} Returns `array`.
 * @example
 *
 * var array = [1, 2, 3];
 *
 * _.reverse(array);
 * // => [3, 2, 1]
 *
 * console.log(array);
 * // => [3, 2, 1]
 */
function reverse(array) {
  return array ? nativeReverse.call(array) : array;
}

/**
 * Creates a slice of `array` from `start` up to, but not including, `end`.
 *
 * **Note:** This method is used instead of
 * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
 * returned.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function slice(array, start, end) {
  var length = array ? array.length : 0;
  if (!length) {
    return [];
  }
  if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
    start = 0;
    end = length;
  } else {
    start = start == null ? 0 : toInteger(start);
    end = end === undefined ? length : toInteger(end);
  }
  return baseSlice(array, start, end);
}

var MAX_ARRAY_LENGTH$2 = 4294967295;
var MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH$2 - 1;
var nativeFloor = Math.floor;
var nativeMin$2 = Math.min;
/**
 * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
 * which invokes `iteratee` for `value` and each element of `array` to compute
 * their sort ranking. The iteratee is invoked with one argument; (value).
 *
 * @private
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Function} iteratee The iteratee invoked per element.
 * @param {boolean} [retHighest] Specify returning the highest qualified index.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 */
function baseSortedIndexBy(array, value, iteratee, retHighest) {
  value = iteratee(value);

  var low = 0,
      high = array ? array.length : 0,
      valIsNaN = value !== value,
      valIsNull = value === null,
      valIsSymbol = isSymbol(value),
      valIsUndefined = value === undefined;

  while (low < high) {
    var mid = nativeFloor((low + high) / 2),
        computed = iteratee(array[mid]),
        othIsDefined = computed !== undefined,
        othIsNull = computed === null,
        othIsReflexive = computed === computed,
        othIsSymbol = isSymbol(computed);

    if (valIsNaN) {
      var setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? computed <= value : computed < value;
    }
    if (setLow) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return nativeMin$2(high, MAX_ARRAY_INDEX);
}

var MAX_ARRAY_LENGTH$1 = 4294967295;
var HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH$1 >>> 1;
/**
 * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
 * performs a binary search of `array` to determine the index at which `value`
 * should be inserted into `array` in order to maintain its sort order.
 *
 * @private
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {boolean} [retHighest] Specify returning the highest qualified index.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 */
function baseSortedIndex(array, value, retHighest) {
  var low = 0,
      high = array ? array.length : low;

  if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
    while (low < high) {
      var mid = low + high >>> 1,
          computed = array[mid];

      if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return high;
  }
  return baseSortedIndexBy(array, value, identity, retHighest);
}

/**
 * Uses a binary search to determine the lowest index at which `value`
 * should be inserted into `array` in order to maintain its sort order.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * _.sortedIndex([30, 50], 40);
 * // => 1
 *
 * _.sortedIndex([4, 5], 4);
 * // => 0
 */
function sortedIndex(array, value) {
  return baseSortedIndex(array, value);
}

/**
 * This method is like `_.sortedIndex` except that it accepts `iteratee`
 * which is invoked for `value` and each element of `array` to compute their
 * sort ranking. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * var dict = { 'thirty': 30, 'forty': 40, 'fifty': 50 };
 *
 * _.sortedIndexBy(['thirty', 'fifty'], 'forty', _.propertyOf(dict));
 * // => 1
 *
 * // The `_.property` iteratee shorthand.
 * _.sortedIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
 * // => 0
 */
function sortedIndexBy(array, value, iteratee) {
  return baseSortedIndexBy(array, value, baseIteratee(iteratee));
}

/**
 * This method is like `_.indexOf` except that it performs a binary
 * search on a sorted `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.sortedIndexOf([1, 1, 2, 2], 2);
 * // => 2
 */
function sortedIndexOf(array, value) {
  var length = array ? array.length : 0;
  if (length) {
    var index = baseSortedIndex(array, value);
    if (index < length && eq(array[index], value)) {
      return index;
    }
  }
  return -1;
}

/**
 * This method is like `_.sortedIndex` except that it returns the highest
 * index at which `value` should be inserted into `array` in order to
 * maintain its sort order.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * _.sortedLastIndex([4, 5], 4);
 * // => 1
 */
function sortedLastIndex(array, value) {
  return baseSortedIndex(array, value, true);
}

/**
 * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
 * which is invoked for `value` and each element of `array` to compute their
 * sort ranking. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * // The `_.property` iteratee shorthand.
 * _.sortedLastIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
 * // => 1
 */
function sortedLastIndexBy(array, value, iteratee) {
  return baseSortedIndexBy(array, value, baseIteratee(iteratee), true);
}

/**
 * This method is like `_.lastIndexOf` except that it performs a binary
 * search on a sorted `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to search.
 * @param {*} value The value to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.sortedLastIndexOf([1, 1, 2, 2], 2);
 * // => 3
 */
function sortedLastIndexOf(array, value) {
  var length = array ? array.length : 0;
  if (length) {
    var index = baseSortedIndex(array, value, true) - 1;
    if (eq(array[index], value)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseSortedUniq(array, iteratee) {
  var index = -1,
      length = array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    if (!index || !eq(computed, seen)) {
      var seen = computed;
      result[resIndex++] = value === 0 ? 0 : value;
    }
  }
  return result;
}

/**
 * This method is like `_.uniq` except that it's designed and optimized
 * for sorted arrays.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.sortedUniq([1, 1, 2]);
 * // => [1, 2]
 */
function sortedUniq(array) {
  return array && array.length ? baseSortedUniq(array) : [];
}

/**
 * This method is like `_.uniqBy` except that it's designed and optimized
 * for sorted arrays.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
 * // => [1.1, 2.3]
 */
function sortedUniqBy(array, iteratee) {
  return array && array.length ? baseSortedUniq(array, baseIteratee(iteratee)) : [];
}

/**
 * Gets all but the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.tail([1, 2, 3]);
 * // => [2, 3]
 */
function tail(array) {
  return drop(array, 1);
}

/**
 * Creates a slice of `array` with `n` elements taken from the beginning.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to take.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.take([1, 2, 3]);
 * // => [1]
 *
 * _.take([1, 2, 3], 2);
 * // => [1, 2]
 *
 * _.take([1, 2, 3], 5);
 * // => [1, 2, 3]
 *
 * _.take([1, 2, 3], 0);
 * // => []
 */
function take(array, n, guard) {
  if (!(array && array.length)) {
    return [];
  }
  n = guard || n === undefined ? 1 : toInteger(n);
  return baseSlice(array, 0, n < 0 ? 0 : n);
}

/**
 * Creates a slice of `array` with `n` elements taken from the end.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to take.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.takeRight([1, 2, 3]);
 * // => [3]
 *
 * _.takeRight([1, 2, 3], 2);
 * // => [2, 3]
 *
 * _.takeRight([1, 2, 3], 5);
 * // => [1, 2, 3]
 *
 * _.takeRight([1, 2, 3], 0);
 * // => []
 */
function takeRight(array, n, guard) {
  var length = array ? array.length : 0;
  if (!length) {
    return [];
  }
  n = guard || n === undefined ? 1 : toInteger(n);
  n = length - n;
  return baseSlice(array, n < 0 ? 0 : n, length);
}

/**
 * Creates a slice of `array` with elements taken from the end. Elements are
 * taken until `predicate` returns falsey. The predicate is invoked with
 * three arguments: (value, index, array).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': true },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': false }
 * ];
 *
 * _.takeRightWhile(users, function(o) { return !o.active; });
 * // => objects for ['fred', 'pebbles']
 *
 * // The `_.matches` iteratee shorthand.
 * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
 * // => objects for ['pebbles']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.takeRightWhile(users, ['active', false]);
 * // => objects for ['fred', 'pebbles']
 *
 * // The `_.property` iteratee shorthand.
 * _.takeRightWhile(users, 'active');
 * // => []
 */
function takeRightWhile(array, predicate) {
  return array && array.length ? baseWhile(array, baseIteratee(predicate, 3), false, true) : [];
}

/**
 * Creates a slice of `array` with elements taken from the beginning. Elements
 * are taken until `predicate` returns falsey. The predicate is invoked with
 * three arguments: (value, index, array).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false},
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.takeWhile(users, function(o) { return !o.active; });
 * // => objects for ['barney', 'fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.takeWhile(users, { 'user': 'barney', 'active': false });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.takeWhile(users, ['active', false]);
 * // => objects for ['barney', 'fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.takeWhile(users, 'active');
 * // => []
 */
function takeWhile(array, predicate) {
  return array && array.length ? baseWhile(array, baseIteratee(predicate, 3)) : [];
}

/**
 * A no-operation function that returns `undefined` regardless of the
 * arguments it receives.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.noop(object) === undefined;
 * // => true
 */
function noop() {
  // No operation performed.
}

/** Used as references for various `Number` constants. */
var INFINITY$4 = 1 / 0;

/**
 * Creates a set of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY$4) ? noop : function (values) {
  return new Set$1(values);
};

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE$2 = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE$2) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee ? [] : result;
  }
  outer: while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = comparator || value !== 0 ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    } else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2, 1], [4, 2], [1, 2]);
 * // => [2, 1, 4]
 */
var union = rest(function (arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});

/**
 * This method is like `_.union` except that it accepts `iteratee` which is
 * invoked for each element of each `arrays` to generate the criterion by
 * which uniqueness is computed. The iteratee is invoked with one argument:
 * (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.unionBy([2.1, 1.2], [4.3, 2.4], Math.floor);
 * // => [2.1, 1.2, 4.3]
 *
 * // The `_.property` iteratee shorthand.
 * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }, { 'x': 2 }]
 */
var unionBy = rest(function (arrays) {
  var iteratee = last(arrays);
  if (isArrayLikeObject(iteratee)) {
    iteratee = undefined;
  }
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), baseIteratee(iteratee));
});

/**
 * This method is like `_.union` except that it accepts `comparator` which
 * is invoked to compare elements of `arrays`. The comparator is invoked
 * with two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.unionWith(objects, others, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
 */
var unionWith = rest(function (arrays) {
  var comparator = last(arrays);
  if (isArrayLikeObject(comparator)) {
    comparator = undefined;
  }
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
});

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each
 * element is kept.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return array && array.length ? baseUniq(array) : [];
}

/**
 * This method is like `_.uniq` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * uniqueness is computed. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
 * // => [2.1, 1.2]
 *
 * // The `_.property` iteratee shorthand.
 * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }, { 'x': 2 }]
 */
function uniqBy(array, iteratee) {
  return array && array.length ? baseUniq(array, baseIteratee(iteratee)) : [];
}

/**
 * This method is like `_.uniq` except that it accepts `comparator` which
 * is invoked to compare elements of `array`. The comparator is invoked with
 * two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 },  { 'x': 1, 'y': 2 }];
 *
 * _.uniqWith(objects, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
 */
function uniqWith(array, comparator) {
  return array && array.length ? baseUniq(array, undefined, comparator) : [];
}

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$4 = Math.max;

/**
 * This method is like `_.zip` except that it accepts an array of grouped
 * elements and creates an array regrouping the elements to their pre-zip
 * configuration.
 *
 * @static
 * @memberOf _
 * @since 1.2.0
 * @category Array
 * @param {Array} array The array of grouped elements to process.
 * @returns {Array} Returns the new array of regrouped elements.
 * @example
 *
 * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
 * // => [['fred', 30, true], ['barney', 40, false]]
 *
 * _.unzip(zipped);
 * // => [['fred', 'barney'], [30, 40], [true, false]]
 */
function unzip(array) {
  if (!(array && array.length)) {
    return [];
  }
  var length = 0;
  array = arrayFilter(array, function (group) {
    if (isArrayLikeObject(group)) {
      length = nativeMax$4(group.length, length);
      return true;
    }
  });
  return baseTimes(length, function (index) {
    return arrayMap(array, baseProperty(index));
  });
}

/**
 * This method is like `_.unzip` except that it accepts `iteratee` to specify
 * how regrouped values should be combined. The iteratee is invoked with the
 * elements of each group: (...group).
 *
 * @static
 * @memberOf _
 * @since 3.8.0
 * @category Array
 * @param {Array} array The array of grouped elements to process.
 * @param {Function} [iteratee=_.identity] The function to combine
 *  regrouped values.
 * @returns {Array} Returns the new array of regrouped elements.
 * @example
 *
 * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
 * // => [[1, 10, 100], [2, 20, 200]]
 *
 * _.unzipWith(zipped, _.add);
 * // => [3, 30, 300]
 */
function unzipWith(array, iteratee) {
  if (!(array && array.length)) {
    return [];
  }
  var result = unzip(array);
  if (iteratee == null) {
    return result;
  }
  return arrayMap(result, function (group) {
    return apply(iteratee, undefined, group);
  });
}

/**
 * Creates an array excluding all given values using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...*} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.difference, _.xor
 * @example
 *
 * _.without([1, 2, 1, 3], 1, 2);
 * // => [3]
 */
var without = rest(function (array, values) {
  return isArrayLikeObject(array) ? baseDifference(array, values) : [];
});

/**
 * The base implementation of methods like `_.xor`, without support for
 * iteratee shorthands, that accepts an array of arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of values.
 */
function baseXor(arrays, iteratee, comparator) {
  var index = -1,
      length = arrays.length;

  while (++index < length) {
    var result = result ? arrayPush(baseDifference(result, arrays[index], iteratee, comparator), baseDifference(arrays[index], result, iteratee, comparator)) : arrays[index];
  }
  return result && result.length ? baseUniq(result, iteratee, comparator) : [];
}

/**
 * Creates an array of unique values that is the
 * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
 * of the given arrays. The order of result values is determined by the order
 * they occur in the arrays.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.difference, _.without
 * @example
 *
 * _.xor([2, 1], [4, 2]);
 * // => [1, 4]
 */
var xor = rest(function (arrays) {
  return baseXor(arrayFilter(arrays, isArrayLikeObject));
});

/**
 * This method is like `_.xor` except that it accepts `iteratee` which is
 * invoked for each element of each `arrays` to generate the criterion by
 * which by which they're compared. The iteratee is invoked with one argument:
 * (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Array|Function|Object|string} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.xorBy([2.1, 1.2], [4.3, 2.4], Math.floor);
 * // => [1.2, 4.3]
 *
 * // The `_.property` iteratee shorthand.
 * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 2 }]
 */
var xorBy = rest(function (arrays) {
  var iteratee = last(arrays);
  if (isArrayLikeObject(iteratee)) {
    iteratee = undefined;
  }
  return baseXor(arrayFilter(arrays, isArrayLikeObject), baseIteratee(iteratee));
});

/**
 * This method is like `_.xor` except that it accepts `comparator` which is
 * invoked to compare elements of `arrays`. The comparator is invoked with
 * two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.xorWith(objects, others, _.isEqual);
 * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
 */
var xorWith = rest(function (arrays) {
  var comparator = last(arrays);
  if (isArrayLikeObject(comparator)) {
    comparator = undefined;
  }
  return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
});

/**
 * Creates an array of grouped elements, the first of which contains the
 * first elements of the given arrays, the second of which contains the
 * second elements of the given arrays, and so on.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to process.
 * @returns {Array} Returns the new array of grouped elements.
 * @example
 *
 * _.zip(['fred', 'barney'], [30, 40], [true, false]);
 * // => [['fred', 30, true], ['barney', 40, false]]
 */
var zip = rest(unzip);

/**
 * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
 *
 * @private
 * @param {Array} props The property identifiers.
 * @param {Array} values The property values.
 * @param {Function} assignFunc The function to assign values.
 * @returns {Object} Returns the new object.
 */
function baseZipObject(props, values, assignFunc) {
  var index = -1,
      length = props.length,
      valsLength = values.length,
      result = {};

  while (++index < length) {
    var value = index < valsLength ? values[index] : undefined;
    assignFunc(result, props[index], value);
  }
  return result;
}

/**
 * This method is like `_.fromPairs` except that it accepts two arrays,
 * one of property identifiers and one of corresponding values.
 *
 * @static
 * @memberOf _
 * @since 0.4.0
 * @category Array
 * @param {Array} [props=[]] The property identifiers.
 * @param {Array} [values=[]] The property values.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.zipObject(['a', 'b'], [1, 2]);
 * // => { 'a': 1, 'b': 2 }
 */
function zipObject(props, values) {
  return baseZipObject(props || [], values || [], assignValue);
}

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]);
    if (isObject(nested)) {
      var newValue = value;
      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : undefined;
        if (newValue === undefined) {
          newValue = objValue == null ? isIndex(path[index + 1]) ? [] : {} : objValue;
        }
      }
      assignValue(nested, key, newValue);
    }
    nested = nested[key];
  }
  return object;
}

/**
 * This method is like `_.zipObject` except that it supports property paths.
 *
 * @static
 * @memberOf _
 * @since 4.1.0
 * @category Array
 * @param {Array} [props=[]] The property identifiers.
 * @param {Array} [values=[]] The property values.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
 * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
 */
function zipObjectDeep(props, values) {
  return baseZipObject(props || [], values || [], baseSet);
}

/**
 * This method is like `_.zip` except that it accepts `iteratee` to specify
 * how grouped values should be combined. The iteratee is invoked with the
 * elements of each group: (...group).
 *
 * @static
 * @memberOf _
 * @since 3.8.0
 * @category Array
 * @param {...Array} [arrays] The arrays to process.
 * @param {Function} [iteratee=_.identity] The function to combine grouped values.
 * @returns {Array} Returns the new array of grouped elements.
 * @example
 *
 * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
 *   return a + b + c;
 * });
 * // => [111, 222]
 */
var zipWith = rest(function (arrays) {
  var length = arrays.length,
      iteratee = length > 1 ? arrays[length - 1] : undefined;

  iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
  return unzipWith(arrays, iteratee);
});

var arrayUtils = {
  chunk: chunk, compact: compact, concat: concat, difference: difference, differenceBy: differenceBy,
  differenceWith: differenceWith, drop: drop, dropRight: dropRight, dropRightWhile: dropRightWhile, dropWhile: dropWhile,
  fill: fill, findIndex: findIndex, findLastIndex: findLastIndex, first: head, flatten: flatten,
  flattenDeep: flattenDeep, flattenDepth: flattenDepth, fromPairs: fromPairs, head: head, indexOf: indexOf,
  initial: initial, intersection: intersection, intersectionBy: intersectionBy, intersectionWith: intersectionWith, join: join,
  last: last, lastIndexOf: lastIndexOf, nth: nth, pull: pull, pullAll: pullAll,
  pullAllBy: pullAllBy, pullAllWith: pullAllWith, pullAt: pullAt, remove: remove$3, reverse: reverse,
  slice: slice, sortedIndex: sortedIndex, sortedIndexBy: sortedIndexBy, sortedIndexOf: sortedIndexOf, sortedLastIndex: sortedLastIndex,
  sortedLastIndexBy: sortedLastIndexBy, sortedLastIndexOf: sortedLastIndexOf, sortedUniq: sortedUniq, sortedUniqBy: sortedUniqBy, tail: tail,
  take: take, takeRight: takeRight, takeRightWhile: takeRightWhile, takeWhile: takeWhile, union: union,
  unionBy: unionBy, unionWith: unionWith, uniq: uniq, uniqBy: uniqBy, uniqWith: uniqWith,
  unzip: unzip, unzipWith: unzipWith, without: without, xor: xor, xorBy: xorBy,
  xorWith: xorWith, zip: zip, zipObject: zipObject, zipObjectDeep: zipObjectDeep, zipWith: zipWith
};

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

var specialCases = new Map();

/**
 * Transforms given {@link engine.model.delta.Delta delta} by another {@link engine.model.delta.Delta delta} and
 * returns the result of that transformation as an array containing one or more {@link engine.model.delta.Delta delta}
 * instances.
 *
 * Delta transformations heavily base on {@link engine.model.operation.transform operational transformations}. Since
 * delta is a list of operations most situations can be handled thanks to operational transformation. Unfortunately,
 * deltas are more complicated than operations and have they semantic meaning, as they represent user's editing intentions.
 *
 * Sometimes, simple operational transformation on deltas' operations might result in some unexpected results. Those
 * results would be fine from OT point of view, but would not reflect user's intentions. Because of such conflicts
 * we need to handle transformations in special cases in a custom way.
 *
 * The function itself looks whether two given delta types have a special case function registered. If so, the deltas are
 * transformed using that function. If not, {@link engine.model.delta.defaultTransform default transformation algorithm}
 * is used.
 *
 * @see engine.model.operation.transform
 *
 * @external engine.model.delta.transform
 * @function engine.model.delta.transform.transform
 * @param {engine.model.delta.Delta} a Delta that will be transformed.
 * @param {engine.model.delta.Delta} b Delta to transform by.
 * @param {Boolean} isAMoreImportantThanB Flag indicating whether the delta which will be transformed (`a`) should be treated
 * as more important when resolving conflicts. Note that this flag is used only if provided deltas have same
 * {@link engine.model.delta.priorities priority}. If deltas have different priorities, their importance is resolved
 * automatically and overwrites this flag.
 * @returns {Array.<engine.model.delta.Delta>} Result of the transformation.
 */
function transform$1(a, b, isAMoreImportantThanB) {
	var transformAlgorithm = getTransformationCase(a, b) || defaultTransform;

	var transformed = transformAlgorithm(a, b, isAMoreImportantThanB);
	var baseVersion = arrayUtils.last(b.operations).baseVersion;

	return updateBaseVersion(baseVersion, transformed);
}

// Updates base versions of operations inside deltas (which are the results of delta transformation).
function updateBaseVersion(baseVersion, deltas) {
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = deltas[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var delta = _step.value;
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = delta.operations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var op = _step2.value;

					op.baseVersion = ++baseVersion;
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return deltas;
}

/**
 * The default delta transformation function. It is used for those deltas that are not in special case conflict.
 *
 * This algorithm is similar to a popular `dOPT` algorithm used in operational transformation, as we are in fact
 * transforming two sets of operations by each other.
 *
 * @external engine.model.delta.transform
 * @function engine.model.delta.transform.defaultTransform
 * @param {engine.model.delta.Delta} a Delta that will be transformed.
 * @param {engine.model.delta.Delta} b Delta to transform by.
 * @param {Boolean} isAMoreImportantThanB Flag indicating whether the delta which will be transformed (`a`) should be treated
 * as more important when resolving conflicts. Note that this flag is used only if provided deltas have same
 * {@link engine.model.delta.priorities priority}. If deltas have different priorities, their importance is resolved
 * automatically and overwrites this flag.
 * @returns {Array.<engine.model.delta.Delta>} Result of the transformation, that is an array with single delta instance.
 */
function defaultTransform(a, b, isAMoreImportantThanB) {
	// First, resolve the flag real value.
	isAMoreImportantThanB = getPriority(a.constructor, b.constructor, isAMoreImportantThanB);

	// Create a new delta instance. Make sure that the new delta is of same type as transformed delta.
	// We will transform operations in that delta but it doesn't mean the delta's "meaning" which is connected to
	// the delta's type. Since the delta's type is heavily used in transformations and probably other parts
	// of system it is important to keep proper delta type through all transformation process.
	var transformed = new a.constructor();

	// Array containing operations that we will transform by. At the beginning these are just operations from
	var byOps = b.operations;

	// This array is storing operations from `byOps` which got transformed by operation from delta `a`.
	var newByOps = [];

	// We take each operation from original set of operations to transform.
	var _iteratorNormalCompletion3 = true;
	var _didIteratorError3 = false;
	var _iteratorError3 = undefined;

	try {
		for (var _iterator3 = a.operations[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
			var opA = _step3.value;

			// We wrap the operation in the array. This is important, because operation transformation algorithm returns
			// an array of operations so we need to make sure that our algorithm is ready to handle arrays.
			var ops = [opA];

			// Now the real algorithm takes place.
			var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
				for (var _iterator4 = byOps[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var opB = _step4.value;

					// For each operation that we need transform by...
					for (var i = 0; i < ops.length; i++) {
						// We take each operation to transform...
						var op = ops[i];

						// And transform both of them by themselves.

						// The result of transforming operation from delta B by operation from delta A is saved in
						// `newByOps` array. We will use that array for transformations in next loops. We need delta B
						// operations after transformed by delta A operations to get correct results of transformations
						// of next operations from delta A.
						//
						// It's like this because 2nd operation from delta A assumes that 1st operation from delta A
						// is "already applied". When we transform 2nd operation from delta A by operations from delta B
						// we have to be sure that operations from delta B are in a state that acknowledges 1st operation
						// from delta A.
						//
						// This can be easier understood when operations sets to transform are represented by diamond diagrams:
						// http://www.codecommit.com/blog/java/understanding-and-applying-operational-transformation

						// Using push.apply because operationTransform function is returning an array with one or multiple results.
						Array.prototype.push.apply(newByOps, transform$2(opB, op, !isAMoreImportantThanB));

						// Then, we transform operation from delta A by operation from delta B.
						var results = transform$2(op, opB, isAMoreImportantThanB);

						// We replace currently processed operation from `ops` array by the results of transformation.
						// Note, that we process single operation but the operationTransform result might be an array, so we
						// might splice-in more operations. We will process them further in next iterations. Right now we
						// just save them in `ops` array and move `i` pointer by proper offset.
						Array.prototype.splice.apply(ops, [i, 1].concat(results));

						i += results.length - 1;
					}

					// At this point a single operation from delta A got transformed by a single operation from delta B.
					// The transformation result is in `ops` array and it may be one or more operations. This was just the first step.
					// Operation from delta A has to be further transformed by the other operations from delta B.
					// So in next iterator loop we will take another operation from delta B and use transformed delta A (`ops`)
					// to transform it further.
				}

				// We got through all delta B operations and have a final transformed state of an operation from delta A.

				// As previously mentioned, we substitute operations from delta B by their transformed equivalents.
			} catch (err) {
				_didIteratorError4 = true;
				_iteratorError4 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion4 && _iterator4.return) {
						_iterator4.return();
					}
				} finally {
					if (_didIteratorError4) {
						throw _iteratorError4;
					}
				}
			}

			byOps = newByOps;
			newByOps = [];

			// We add transformed operation from delta A to newly created delta.
			// Remember that transformed operation from delta A may consist of multiple operations.
			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = ops[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var _op = _step5.value;

					transformed.addOperation(_op);
				}

				// In next loop, we will take another operation from delta A and transform it through (transformed) operations
				// from delta B...
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5.return) {
						_iterator5.return();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}
		}
	} catch (err) {
		_didIteratorError3 = true;
		_iteratorError3 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion3 && _iterator3.return) {
				_iterator3.return();
			}
		} finally {
			if (_didIteratorError3) {
				throw _iteratorError3;
			}
		}
	}

	return [transformed];
}

/**
 * Adds a special case callback for given delta classes.
 *
 * @external engine.model.delta.transform
 * @function engine.model.delta.transform.addTransformationCase
 * @param {Function} A Delta constructor which instance will get transformed.
 * @param {Function} B Delta constructor which instance will be transformed by.
 * @param {Function} resolver A callback that will handle custom special case transformation for instances of given delta classes.
 */
function addTransformationCase(A, B, resolver) {
	var casesA = specialCases.get(A);

	if (!casesA) {
		casesA = new Map();
		specialCases.set(A, casesA);
	}

	casesA.set(B, resolver);
}

/**
 * Gets a special case callback which was previously {@link engine.model.delta.transform.addTransformationCase added}.
 *
 * @external engine.model.delta.transform
 * @function engine.model.delta.transform.getTransformationCase
 * @param {engine.model.delta.Delta} a Delta to transform.
 * @param {engine.model.delta.Delta} b Delta to be transformed by.
 */
function getTransformationCase(a, b) {
	var casesA = specialCases.get(a.constructor);

	// If there are no special cases registered for class which `a` is instance of, we will
	// check if there are special cases registered for any parent class.
	if (!casesA || !casesA.get(b.constructor)) {
		var cases = specialCases.keys();

		var _iteratorNormalCompletion6 = true;
		var _didIteratorError6 = false;
		var _iteratorError6 = undefined;

		try {
			for (var _iterator6 = cases[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
				var caseClass = _step6.value;

				if (a instanceof caseClass) {
					casesA = specialCases.get(caseClass);
				}
			}
		} catch (err) {
			_didIteratorError6 = true;
			_iteratorError6 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion6 && _iterator6.return) {
					_iterator6.return();
				}
			} finally {
				if (_didIteratorError6) {
					throw _iteratorError6;
				}
			}
		}
	}

	if (casesA) {
		return casesA.get(b.constructor);
	}

	return undefined;
}

// Checks priorities of passed constructors and decides which one is more important.
// If both priorities are same, value passed in `isAMoreImportantThanB` parameter is used.
function getPriority(A, B, isAMoreImportantThanB) {
	if (A._priority > B._priority) {
		return true;
	} else if (A._priority < B._priority) {
		return false;
	} else {
		return isAMoreImportantThanB;
	}
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

// Provide transformations for default deltas.

// Add special case for AttributeDelta x WeakInsertDelta transformation.
addTransformationCase(AttributeDelta, WeakInsertDelta, function (a, b, isStrong) {
	// If nodes are weak-inserted into attribute delta range, we need to apply changes from attribute delta on them.
	// So first we do the normal transformation and if this special cases happens, we will add an extra delta.
	var deltas = defaultTransform(a, b, isStrong);

	if (a.range.containsPosition(b.position)) {
		deltas.push(_getComplementaryAttrDelta(b, a));
	}

	return deltas;
});

// Add special case for InsertDelta x MergeDelta transformation.
addTransformationCase(InsertDelta, MergeDelta, function (a, b, isStrong) {
	// If insert is applied at the same position where merge happened, we reverse the merge (we treat it like it
	// didn't happen) and then apply the original insert operation. This is "mirrored" in MergeDelta x InsertDelta
	// transformation below, where we simply do not apply MergeDelta.
	if (a.position.isEqual(b.position)) {
		return [b.getReversed(), a.clone()];
	}

	return defaultTransform(a, b, isStrong);
});

// Add special case for MoveDelta x MergeDelta transformation.
addTransformationCase(MoveDelta, MergeDelta, function (a, b, isStrong) {
	// If move delta is supposed to move a node that has been merged, we reverse the merge (we treat it like it
	// didn't happen) and then apply the original move operation. This is "mirrored" in MergeDelta x MoveDelta
	// transformation below, where we simply do not apply MergeDelta.

	var operateInSameParent = a.sourcePosition.root == b.position.root && compareArrays(a.sourcePosition.getParentPath(), b.position.getParentPath()) === 'same';

	var mergeInsideMoveRange = a.sourcePosition.offset <= b.position.offset && a.sourcePosition.offset + a.howMany > b.position.offset;

	if (operateInSameParent && mergeInsideMoveRange) {
		return [b.getReversed(), a.clone()];
	}

	return defaultTransform(a, b, isStrong);
});

// Add special case for MergeDelta x InsertDelta transformation.
addTransformationCase(MergeDelta, InsertDelta, function (a, b, isStrong) {
	// If merge is applied at the same position where we inserted a range of nodes we cancel the merge as it's results
	// may be unexpected and very weird. Even if we do some "magic" we don't know what really are users' expectations.
	if (a.position.isEqual(b.position)) {
		return [noDelta()];
	}

	return defaultTransform(a, b, isStrong);
});

// Add special case for MergeDelta x MoveDelta transformation.
addTransformationCase(MergeDelta, MoveDelta, function (a, b, isStrong) {
	// If merge is applied at the position between moved nodes we cancel the merge as it's results may be unexpected and
	// very weird. Even if we do some "magic" we don't know what really are users' expectations.

	var operateInSameParent = a.position.root == b.sourcePosition.root && compareArrays(a.position.getParentPath(), b.sourcePosition.getParentPath()) === 'same';

	var mergeInsideMoveRange = b.sourcePosition.offset <= a.position.offset && b.sourcePosition.offset + b.howMany > a.position.offset;

	if (operateInSameParent && mergeInsideMoveRange) {
		return [noDelta()];
	}

	return defaultTransform(a, b, isStrong);
});

// Add special case for SplitDelta x SplitDelta transformation.
addTransformationCase(SplitDelta, SplitDelta, function (a, b, isStrong) {
	var pathA = a.position.getParentPath();
	var pathB = b.position.getParentPath();

	// The special case is for splits inside the same parent.
	if (compareArrays(pathA, pathB) == 'same') {
		if (a.position.offset == b.position.offset) {
			// We are applying split at the position where split already happened. Additional split is not needed.
			return [noDelta()];
		} else if (a.position.offset < b.position.offset) {
			// Incoming split delta splits at closer offset. So we simply have to once again split the same node,
			// but since it was already split (at further offset) there are less child nodes in the split node.
			// This means that we have to update `howMany` parameter of `MoveOperation` for that delta.

			var delta = a.clone();
			delta._moveOperation.howMany = b.position.offset - a.position.offset;

			// If both SplitDeltas are taking their nodes from graveyard, we have to transform their ReinsertOperations.
			if (a._cloneOperation instanceof ReinsertOperation && b._cloneOperation instanceof ReinsertOperation && a._cloneOperation.sourcePosition.offset > b._cloneOperation.sourcePosition.offset) {
				delta._cloneOperation.sourcePosition.offset--;
			}

			return [delta];
		} else {
			// Incoming split delta splits at further offset. We have to simulate that we are not splitting the
			// original split node but the node after it, which got created by the other split delta.
			// To do so, we increment offsets so it looks like the split delta was created in the next node.

			var _delta = a.clone();

			_delta._cloneOperation.position.offset++;
			_delta._moveOperation.sourcePosition.path[_delta._moveOperation.sourcePosition.path.length - 2]++;
			_delta._moveOperation.targetPosition.path[_delta._moveOperation.targetPosition.path.length - 2]++;
			_delta._moveOperation.sourcePosition.offset = a.position.offset - b.position.offset;

			// If both SplitDeltas are taking their nodes from graveyard, we have to transform their ReinsertOperations.
			if (a._cloneOperation instanceof ReinsertOperation && b._cloneOperation instanceof ReinsertOperation && a._cloneOperation.sourcePosition.offset > b._cloneOperation.sourcePosition.offset) {
				_delta._cloneOperation.sourcePosition.offset--;
			}

			return [_delta];
		}
	}

	return defaultTransform(a, b, isStrong);
});

// Add special case for SplitDelta x UnwrapDelta transformation.
addTransformationCase(SplitDelta, UnwrapDelta, function (a, b, isStrong) {
	// If incoming split delta tries to split a node that just got unwrapped, there is actually nothing to split,
	// so we discard that delta.
	if (compareArrays(b.position.path, a.position.getParentPath()) === 'same') {
		return [noDelta()];
	}

	return defaultTransform(a, b, isStrong);
});

// Add special case for SplitDelta x WrapDelta transformation.
addTransformationCase(SplitDelta, WrapDelta, function (a, b, isStrong) {
	// If split is applied at the position between wrapped nodes, we cancel the split as it's results may be unexpected and
	// very weird. Even if we do some "magic" we don't know what really are users' expectations.

	var operateInSameParent = compareArrays(a.position.getParentPath(), b.range.start.getParentPath()) === 'same';
	var splitInsideWrapRange = b.range.start.offset < a.position.offset && b.range.end.offset >= a.position.offset;

	if (operateInSameParent && splitInsideWrapRange) {
		return [noDelta()];
	} else if (compareArrays(a.position.getParentPath(), b.range.end.getShiftedBy(-1).path) === 'same') {
		// Split position is directly inside the last node from wrap range.
		// If that's the case, we manually change split delta so it will "target" inside the wrapping element.
		// By doing so we will be inserting split node right to the original node which feels natural and is a good UX.
		var delta = a.clone();

		// 1. Fix insert operation position.
		// Node to split is the last children of the wrapping element.
		// Wrapping element is the element inserted by WrapDelta (re)insert operation.
		// It is inserted after the wrapped range, but the wrapped range will be moved inside it.
		// Having this in mind, it is correct to use wrapped range start position as the position before wrapping element.
		var splitNodePos = Position.createFromPosition(b.range.start);
		// Now, `splitNodePos` points before wrapping element.
		// To get a position before last children of that element, we expand position's `path` member by proper offset.
		splitNodePos.path.push(b.howMany - 1);

		// SplitDelta insert operation position should be right after the node we split.
		var insertPos = splitNodePos.getShiftedBy(1);
		delta._cloneOperation.position = insertPos;

		// 2. Fix move operation source position.
		// Nodes moved by SplitDelta will be moved from new position, modified by WrapDelta.
		// To obtain that new position, `splitNodePos` will be used, as this is the node we are extracting children from.
		var sourcePos = Position.createFromPosition(splitNodePos);
		// Nothing changed inside split node so it is correct to use the original split position offset.
		sourcePos.path.push(a.position.offset);
		delta._moveOperation.sourcePosition = sourcePos;

		// 3. Fix move operation target position.
		// SplitDelta move operation target position should be inside the node inserted by operation above.
		// Since the node is empty, we will insert at offset 0.
		var targetPos = Position.createFromPosition(insertPos);
		targetPos.path.push(0);
		delta._moveOperation.targetPosition = targetPos;

		return [delta];
	}

	return defaultTransform(a, b, isStrong);
});

// Add special case for UnwrapDelta x SplitDelta transformation.
addTransformationCase(UnwrapDelta, SplitDelta, function (a, b, isStrong) {
	// If incoming unwrap delta tries to unwrap node that got split we should unwrap the original node and the split copy.
	// This can be achieved either by reverting split and applying unwrap to singular node, or creating additional unwrap delta.
	if (compareArrays(a.position.path, b.position.getParentPath()) === 'same') {
		var transformed = [b.getReversed(), a.clone()];

		// It's a kind of magic-magic-magic-maaaaagiiic!
		transformed[1].operations[1].targetPosition.path[0]++;
		// But seriously, we have to fix RemoveOperation in the second delta because reversed UnwrapDelta creates
		// MergeDelta which also has RemoveOperation. Those two operations cannot point to the same "holder" element
		// in the graveyard, so we fix it by hand. This is the only case where it happens in "special" transformation
		// cases, and it won't happen for "default" transformation apart of RemoveDelta, where it is okay.

		return transformed;
	}

	return defaultTransform(a, b, isStrong);
});

// Add special case for WeakInsertDelta x AttributeDelta transformation.
addTransformationCase(WeakInsertDelta, AttributeDelta, function (a, b, isStrong) {
	// If nodes are weak-inserted into attribute delta range, we need to apply changes from attribute delta on them.
	// So first we do the normal transformation and if this special cases happens, we will add an extra delta.
	var deltas = defaultTransform(a, b, isStrong);

	if (b.range.containsPosition(a.position)) {
		deltas.push(_getComplementaryAttrDelta(a, b));
	}

	return deltas;
});

// Add special case for WrapDelta x SplitDelta transformation.
addTransformationCase(WrapDelta, SplitDelta, function (a, b, isStrong) {
	// If incoming wrap delta tries to wrap range that contains split position, we have to cancel the split and apply
	// the wrap. Since split was already applied, we have to revert it.

	var operateInSameParent = compareArrays(a.range.start.getParentPath(), b.position.getParentPath()) === 'same';
	var splitInsideWrapRange = a.range.start.offset < b.position.offset && a.range.end.offset >= b.position.offset;

	if (operateInSameParent && splitInsideWrapRange) {
		return [b.getReversed(), a.clone()];
	} else if (compareArrays(b.position.getParentPath(), a.range.end.getShiftedBy(-1).path) === 'same') {
		var delta = a.clone();

		// Move wrapping element insert position one node further so it is after the split node insertion.
		delta._insertOperation.position.offset++;

		// Include the split node copy.
		delta._moveOperation.howMany++;

		// Change the path to wrapping element in move operation.
		delta._moveOperation.targetPosition.path[delta._moveOperation.targetPosition.path.length - 2]++;

		return [delta];
	}

	return defaultTransform(a, b, isStrong);
});

// Helper function for `AttributeDelta` class transformations.
// Creates an attribute delta that sets attribute from given `attributeDelta` on nodes from given `weakInsertDelta`.
function _getComplementaryAttrDelta(weakInsertDelta, attributeDelta) {
	var complementaryAttrDelta = new AttributeDelta();
	var nodes = weakInsertDelta.nodes;

	// At the beginning we store the attribute value from the first node on `weakInsertDelta` node list.
	var val = nodes.getNode(0).getAttribute(attributeDelta.key);

	// This stores the last index of `weakInsertDelta` node list where the attribute value was different
	// than in the previous node. We need it to create separate `AttributeOperation`s for nodes with different attributes.
	var lastOffset = 0;
	// Sum of offsets of already processed nodes.
	var offsetSum = nodes.getNode(0).offsetSize;

	for (var i = 1; i < nodes.length; i++) {
		var node = nodes.getNode(i);
		var nodeAttrVal = node.getAttribute(attributeDelta.key);

		// If previous node has different attribute value, we will create an operation to the point before current node.
		// So all nodes with the same attributes up to this point will be included in one `AttributeOperation`.
		if (nodeAttrVal != val) {
			// New operation is created only when it is needed. If given node already has proper value for this
			// attribute we simply skip it without adding a new operation.
			if (val != attributeDelta.value) {
				addOperation();
			}

			val = nodeAttrVal;
			lastOffset = offsetSum;
		}

		offsetSum = offsetSum + node.offsetSize;
	}

	// At the end we have to add additional `AttributeOperation` for the last part of node list. If all nodes on the
	// node list had same attributes, this will be the only operation added to the delta.
	addOperation();

	return complementaryAttrDelta;

	function addOperation() {
		var range = new Range$1(weakInsertDelta.position.getShiftedBy(lastOffset), weakInsertDelta.position.getShiftedBy(offsetSum));

		var attrOperation = new AttributeOperation(range, attributeDelta.key, val, attributeDelta.value, 0);
		complementaryAttrDelta.addOperation(attrOperation);
	}
}

// This is "no-op" delta, it has no type and only no-operation, it basically does nothing.
// It is used when we don't want to apply changes but still we need to return a delta.
function noDelta() {
	var noDelta = new Delta();

	// BaseVersion will be fixed later anyway.
	noDelta.addOperation(new NoOperation(0));

	return noDelta;
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * `History` keeps the track of all the deltas applied to the {@link engine.model.Document document}. Deltas stored in
 * `History` might get updated, split into more deltas or even removed. This is used mostly to compress history, instead
 * of keeping all deltas in a state in which they were applied.
 *
 * **Note:** deltas kept in `History` should be used only to transform deltas. It's not advised to use `History` to get
 * original delta basing on it's {@link engine.model.delta.Delta#baseVersion baseVersion}. Also, after transforming a
 * delta by deltas from `History`, fix it's base version accordingly (set it to {@link engine.model.Document#version document version}).
 *
 * @memberOf engine.model
 */

var History = function () {
	/**
  * Creates an empty History instance.
  */
	function History() {
		classCallCheck(this, History);

		/**
   * Deltas added to the history.
   *
   * @protected
   * @member {Array.<engine.model.delta.Delta>} engine.model.History#_deltas
   */
		this._deltas = [];

		/**
   * Helper structure that maps added delta's base version to the index in {@link engine.model.History#_deltas}
   * at which the delta was added.
   *
   * @protected
   * @member {Map} engine.model.History#_historyPoints
   */
		this._historyPoints = new Map();
	}

	/**
  * Adds delta to the history.
  *
  * @param {engine.model.delta.Delta} delta Delta to add.
  */


	createClass(History, [{
		key: 'addDelta',
		value: function addDelta(delta) {
			if (delta.operations.length > 0 && !this._historyPoints.has(delta.baseVersion)) {
				var index = this._deltas.length;

				this._deltas[index] = delta;
				this._historyPoints.set(delta.baseVersion, index);
			}
		}

		/**
   * Returns deltas added to the history.
   *
   * @param {Number} [from=0] Base version from which deltas should be returned (inclusive). Defaults to `0`, which means
   * that deltas from the first one will be returned.
   * @param {Number} [to=Number.POSITIVE_INFINITY] Base version up to which deltas should be returned (exclusive).
   * Defaults to `Number.POSITIVE_INFINITY` which means that deltas up to the last one will be returned.
   * @returns {Iterator.<engine.model.delta.Delta>} Deltas added to the history.
   */

	}, {
		key: 'getDeltas',
		value: regeneratorRuntime.mark(function getDeltas() {
			var from = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
			var to = arguments.length <= 1 || arguments[1] === undefined ? Number.POSITIVE_INFINITY : arguments[1];
			var fromIndex, delta;
			return regeneratorRuntime.wrap(function getDeltas$(_context) {
				while (1) {
					switch (_context.prev = _context.next) {
						case 0:
							if (!(this._deltas.length === 0)) {
								_context.next = 2;
								break;
							}

							return _context.abrupt('return');

						case 2:

							// Will throw if base version is incorrect.
							fromIndex = this._getIndex(from);

							// Base version is too low or too high and is not found in history.

							if (!(fromIndex == -1)) {
								_context.next = 5;
								break;
							}

							return _context.abrupt('return');

						case 5:
							if (!(fromIndex < this._deltas.length)) {
								_context.next = 13;
								break;
							}

							delta = this._deltas[fromIndex++];

							if (!(delta.baseVersion >= to)) {
								_context.next = 9;
								break;
							}

							return _context.abrupt('break', 13);

						case 9:
							_context.next = 11;
							return delta;

						case 11:
							_context.next = 5;
							break;

						case 13:
						case 'end':
							return _context.stop();
					}
				}
			}, getDeltas, this);
		})

		/**
   * Returns one or more deltas from history that bases on given `baseVersion`. Most often it will be just
   * one delta, but if that delta got updated by multiple deltas, all of those updated deltas will be returned.
   *
   * @see engine.model.History#updateDelta
   * @param {Number} baseVersion Base version of the delta to retrieve.
   * @returns {Array.<engine.model.delta.Delta>|null} Delta with given base version or null if no such delta is in history.
   */

	}, {
		key: 'getDelta',
		value: function getDelta(baseVersion) {
			var index = this._historyPoints.get(baseVersion);

			if (index === undefined) {
				return null;
			}

			var deltas = [];

			for (index; index < this._deltas.length; index++) {
				var delta = this._deltas[index];

				if (delta.baseVersion != baseVersion) {
					break;
				}

				deltas.push(delta);
			}

			return deltas.length === 0 ? null : deltas;
		}

		/**
   * Removes delta from the history. This happens i.e., when a delta is undone by another delta. Both undone delta and
   * undoing delta should be removed so they won't have an impact on transforming other deltas.
   *
   * **Note:** using this method does not change the state of {@link engine.model.Document model}. It just affects
   * the state of `History`.
   *
   * **Note:** when some deltas are removed, deltas between them should probably get updated. See
   * {@link engine.model.History#updateDelta}.
   *
   * **Note:** if delta with `baseVersion` got {@link engine.model.History#updateDelta updated} by multiple
   * deltas, all updated deltas will be removed.
   *
   * @param {Number} baseVersion Base version of a delta to be removed.
   */

	}, {
		key: 'removeDelta',
		value: function removeDelta(baseVersion) {
			this.updateDelta(baseVersion, []);
		}

		/**
   * Substitutes delta in history by one or more given deltas.
   *
   * **Note:** if delta with `baseVersion` was already updated by multiple deltas, all updated deltas will be removed
   * and new deltas will be inserted at their position.
   *
   * **Note:** removed delta won't get updated.
   *
   * @param {Number} baseVersion Base version of a delta to update.
   * @param {Iterable.<engine.model.delta.Delta>} updatedDeltas Deltas to be inserted in place of updated delta.
   */

	}, {
		key: 'updateDelta',
		value: function updateDelta(baseVersion, updatedDeltas) {
			var _deltas;

			var deltas = this.getDelta(baseVersion);

			// If there are no deltas, stop executing function as there is nothing to update.
			if (deltas === null) {
				return;
			}

			// Make sure that every updated delta has correct `baseVersion`.
			// This is crucial for algorithms in `History` and algorithms using `History`.
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = updatedDeltas[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var delta = _step.value;

					delta.baseVersion = baseVersion;
				}

				// Put updated deltas in place of old deltas.
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			(_deltas = this._deltas).splice.apply(_deltas, [this._getIndex(baseVersion), deltas.length].concat(toConsumableArray(updatedDeltas)));

			// Update history points.
			var changeBy = updatedDeltas.length - deltas.length;

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = this._historyPoints.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var key = _step2.value;

					if (key > baseVersion) {
						this._historyPoints.set(key, this._historyPoints.get(key) + changeBy);
					}
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}
		}

		/**
   * Gets an index in {@link engine.model.History#_deltas} where delta with given `baseVersion` is added.
   *
   * @private
   * @param {Number} baseVersion Base version of delta.
   */

	}, {
		key: '_getIndex',
		value: function _getIndex(baseVersion) {
			var index = this._historyPoints.get(baseVersion);

			// Base version not found - it is either too high or too low, or is in the middle of delta.
			if (index === undefined) {
				var lastDelta = this._deltas[this._deltas.length - 1];
				var nextBaseVersion = lastDelta.baseVersion + lastDelta.operations.length;

				if (baseVersion < 0 || baseVersion >= nextBaseVersion) {
					// Base version is too high or too low - it's acceptable situation.
					// Return -1 because `baseVersion` was correct.
					return -1;
				}

				/**
     * Given base version points to the middle of a delta.
     *
     * @error history-wrong-version
     */
				throw new CKEditorError('model-history-wrong-version: Given base version points to the middle of a delta.');
			}

			return index;
		}
	}]);
	return History;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * `LiveRange` is a type of {@link engine.model.Range Range} that updates itself as {@link engine.model.Document document}
 * is changed through operations. It may be used as a bookmark.
 *
 * **Note:** Be very careful when dealing with `LiveRange`. Each `LiveRange` instance bind events that might
 * have to be unbound. Use {@link engine.model.LiveRange#detach detach} whenever you don't need `LiveRange` anymore.
 *
 * @memberOf engine.model
 */

var LiveRange = function (_Range) {
	inherits(LiveRange, _Range);

	/**
  * Creates a live range.
  *
  * @see engine.model.Range
  */
	function LiveRange(start, end) {
		classCallCheck(this, LiveRange);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(LiveRange).call(this, start, end));

		bindWithDocument$1.call(_this);
		return _this;
	}

	/**
  * Unbinds all events previously bound by `LiveRange`. Use it whenever you don't need `LiveRange` instance
  * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was
  * referring to it).
  */


	createClass(LiveRange, [{
		key: 'detach',
		value: function detach() {
			this.stopListening();
		}

		/**
   * @see engine.model.Range.createIn
   * @static
   * @method engine.model.LiveRange.createIn
   * @param {engine.model.Element} element
   * @returns {engine.model.LiveRange}
   */

		/**
   * @see engine.model.Range.createFromPositionAndShift
   * @static
   * @method engine.model.LiveRange.createFromPositionAndShift
   * @param {engine.model.Position} position
   * @param {Number} shift
   * @returns {engine.model.LiveRange}
   */

		/**
   * @see engine.model.Range.createFromParentsAndOffsets
   * @static
   * @method engine.model.LiveRange.createFromParentsAndOffsets
   * @param {engine.model.Element} startElement
   * @param {Number} startOffset
   * @param {engine.model.Element} endElement
   * @param {Number} endOffset
   * @returns {engine.model.LiveRange}
   */

		/**
   * @see engine.model.Range.createFromRange
   * @static
   * @method engine.model.LiveRange.createFromRange
   * @param {engine.model.Range} range
   * @returns {engine.model.LiveRange}
   */

		/**
   * Fired when `LiveRange` instance is changed due to changes on {@link engine.model.Document}.
   *
   * @event engine.model.LiveRange#change
   * @param {engine.model.Range} oldRange Range with start and end position equal to start and end position of this live range
   * before it got changed.
   */

	}]);
	return LiveRange;
}(Range$1);

function bindWithDocument$1() {
	var _this2 = this;

	/*jshint validthis: true */
	// Operation types handled by LiveRange (these are operations that change model tree structure).
	var supportedTypes = new Set(['insert', 'move', 'remove', 'reinsert']);

	this.listenTo(this.root.document, 'change', function (event, type, changes) {
		if (supportedTypes.has(type)) {
			transform$3.call(_this2, type, changes.range, changes.sourcePosition);
		}
	}, { priority: 'high' });
}

/**
 * Updates this range accordingly to the updates applied to the model. Bases on change events.
 *
 * @ignore
 * @private
 * @method transform
 * @param {String} type Type of changes applied to the Tree Model.
 * @param {engine.model.Range} range Range containing the result of applied change.
 * @param {engine.model.Position} [position] Additional position parameter provided by some change events.
 */
function transform$3(type, range, position) {
	/* jshint validthis: true */
	var updated = void 0;
	var howMany = range.end.offset - range.start.offset;

	switch (type) {
		case 'insert':
			updated = this._getTransformedByInsertion(range.start, howMany, false, true)[0];
			break;

		case 'move':
		case 'remove':
		case 'reinsert':
			var sourcePosition = position;

			// Range._getTransformedByMove is expecting `targetPosition` to be "before" move
			// (before transformation). `range.start` is already after the move happened.
			// We have to revert `range.start` to the state before the move.
			var targetPosition = range.start._getTransformedByInsertion(sourcePosition, howMany);

			var result = this._getTransformedByMove(sourcePosition, targetPosition, howMany, false, true);

			// First item in the array is the "difference" part, so a part of the range
			// that did not get moved. We use it as reference range and expand if possible.
			updated = result[0];

			// We will check if there is other range and if it is touching the reference range.
			// If it does, we will expand the reference range (at the beginning or at the end).
			// Keep in mind that without settings `spread` flag, `_getTransformedByMove` may
			// return maximum two ranges.
			if (result.length > 1) {
				var otherRange = result[1];

				if (updated.start.isTouching(otherRange.end)) {
					updated.start = otherRange.start;
				} else if (updated.end.isTouching(otherRange.start)) {
					updated.end = otherRange.end;
				}
			}

			break;
	}

	// If anything changed, update the range and fire an event.
	if (!updated.start.isEqual(this.start) || !updated.end.isEqual(this.end)) {
		var oldRange = Range$1.createFromRange(this);

		this.start = updated.start;
		this.end = updated.end;

		this.fire('change', oldRange);
	}
}

mix(LiveRange, EmitterMixin);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Checks whether given {Map}s are equal, that is has same size and same key-value pairs.
 *
 * @memberOf utils
 * @returns {Boolean} `true` if given maps are equal, `false` otherwise.
 */
function mapsEqual(mapA, mapB) {
	if (mapA.size != mapB.size) {
		return false;
	}

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = mapA.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var attr = _step.value;

			var valA = JSON.stringify(attr[1]);
			var valB = JSON.stringify(mapB.get(attr[0]));

			if (valA !== valB) {
				return false;
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return true;
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * `Selection` is a group of {@link engine.model.Range ranges} which has a direction specified by
 * {@link engine.model.Selection#anchor anchor} and {@link engine.model.Selection#focus focus}. Additionally,
 * `Selection` may have it's own attributes.
 *
 * @memberOf engine.model
 */

var Selection = function () {
	/**
  * Creates an empty selection.
  */
	function Selection() {
		classCallCheck(this, Selection);

		/**
   * Specifies whether the last added range was added as a backward or forward range.
   *
   * @private
   * @member {Boolean} engine.model.Selection#_lastRangeBackward
   */
		this._lastRangeBackward = false;

		/**
   * Stores selection ranges.
   *
   * @protected
   * @member {Array.<engine.model.Range>} engine.model.Selection#_ranges
   */
		this._ranges = [];

		/**
   * List of attributes set on current selection.
   *
   * @protected
   * @member {Map} engine.model.LiveSelection#_attrs
   */
		this._attrs = new Map();
	}

	/**
  * Selection anchor. Anchor may be described as a position where the most recent part of the selection starts.
  * Together with {@link engine.model.Selection#focus} they define the direction of selection, which is important
  * when expanding/shrinking selection. Anchor is always {@link engine.model.Range#start start} or
  * {@link engine.model.Range#end end} position of the most recently added range.
  *
  * Is set to `null` if there are no ranges in selection.
  *
  * @see engine.model.Selection#focus
  * @readonly
  * @type {engine.model.Position|null}
  */


	createClass(Selection, [{
		key: 'isEqual',


		/**
   * Checks whether, this selection is equal to given selection. Selections equal if they have the same ranges and directions.
   *
   * @param {engine.model.Selection} otherSelection Selection to compare with.
   * @returns {Boolean} `true` if selections are equal, `false` otherwise.
   */
		value: function isEqual(otherSelection) {
			var rangeCount = this.rangeCount;

			if (rangeCount != otherSelection.rangeCount) {
				return false;
			}

			for (var i = 0; i < this.rangeCount; i++) {
				if (!this._ranges[i].isEqual(otherSelection._ranges[i])) {
					return false;
				}
			}

			return this.isBackward === otherSelection.isBackward;
		}

		/**
   * Returns an iterator that iterates over copies of selection ranges.
   *
   * @returns {Iterator.<engine.model.Range>}
   */

	}, {
		key: 'getRanges',
		value: regeneratorRuntime.mark(function getRanges() {
			var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, range;

			return regeneratorRuntime.wrap(function getRanges$(_context) {
				while (1) {
					switch (_context.prev = _context.next) {
						case 0:
							_iteratorNormalCompletion = true;
							_didIteratorError = false;
							_iteratorError = undefined;
							_context.prev = 3;
							_iterator = this._ranges[Symbol.iterator]();

						case 5:
							if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
								_context.next = 12;
								break;
							}

							range = _step.value;
							_context.next = 9;
							return Range$1.createFromRange(range);

						case 9:
							_iteratorNormalCompletion = true;
							_context.next = 5;
							break;

						case 12:
							_context.next = 18;
							break;

						case 14:
							_context.prev = 14;
							_context.t0 = _context['catch'](3);
							_didIteratorError = true;
							_iteratorError = _context.t0;

						case 18:
							_context.prev = 18;
							_context.prev = 19;

							if (!_iteratorNormalCompletion && _iterator.return) {
								_iterator.return();
							}

						case 21:
							_context.prev = 21;

							if (!_didIteratorError) {
								_context.next = 24;
								break;
							}

							throw _iteratorError;

						case 24:
							return _context.finish(21);

						case 25:
							return _context.finish(18);

						case 26:
						case 'end':
							return _context.stop();
					}
				}
			}, getRanges, this, [[3, 14, 18, 26], [19,, 21, 25]]);
		})

		/**
   * Returns a copy of the first range in the selection. First range is the one which {@link engine.model.Range#start start} position
   * {@link engine.model.Position#isBefore is before} start position of all other ranges (not to confuse with the first range
   * added to the selection).
   *
   * Returns `null` if there are no ranges in selection.
   *
   * @returns {engine.model.Range|null}
   */

	}, {
		key: 'getFirstRange',
		value: function getFirstRange() {
			var first = null;

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = this._ranges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var range = _step2.value;

					if (!first || range.start.isBefore(first.start)) {
						first = range;
					}
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			return first ? Range$1.createFromRange(first) : null;
		}

		/**
   * Returns a copy of the last range in the selection. Last range is the one which {@link engine.model.Range#end end} position
   * {@link engine.model.Position#isAfter is after} end position of all other ranges (not to confuse with the range most
   * recently added to the selection).
   *
   * Returns `null` if there are no ranges in selection.
   *
   * @returns {engine.model.Range|null}
   */

	}, {
		key: 'getLastRange',
		value: function getLastRange() {
			var last = null;

			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = this._ranges[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var range = _step3.value;

					if (!last || range.end.isAfter(last.end)) {
						last = range;
					}
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}

			return last ? Range$1.createFromRange(last) : null;
		}

		/**
   * Returns the first position in the selection. First position is the position that {@link engine.model.Position#isBefore is before}
   * any other position in the selection.
   *
   * Returns `null` if there are no ranges in selection.
   *
   * @returns {engine.model.Position|null}
   */

	}, {
		key: 'getFirstPosition',
		value: function getFirstPosition() {
			var first = this.getFirstRange();

			return first ? Position.createFromPosition(first.start) : null;
		}

		/**
   * Returns the last position in the selection. Last position is the position that {@link engine.model.Position#isAfter is after}
   * any other position in the selection.
   *
   * Returns `null` if there are no ranges in selection.
   *
   * @returns {engine.model.Position|null}
   */

	}, {
		key: 'getLastPosition',
		value: function getLastPosition() {
			var lastRange = this.getLastRange();

			return lastRange ? Position.createFromPosition(lastRange.end) : null;
		}

		/**
   * Adds a range to this selection. Added range is copied. This means that passed range is not saved in `Selection`
   * instance and operating on it will not change `Selection` state.
   *
   * Accepts a flag describing in which way the selection is made - passed range might be selected from
   * {@link engine.model.Range#start start} to {@link engine.model.Range#end end} or from {@link engine.model.Range#end end}
   * to {@link engine.model.Range#start start}. The flag is used to set {@link engine.model.Selection#anchor} and
   * {@link engine.model.Selection#focus} properties.
   *
   * @fires engine.model.Selection#change:range
   * @param {engine.model.Range} range Range to add.
   * @param {Boolean} [isBackward=false] Flag describing if added range was selected forward - from start to end (`false`)
   * or backward - from end to start (`true`).
   */

	}, {
		key: 'addRange',
		value: function addRange(range) {
			var isBackward = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

			this._pushRange(range);
			this._lastRangeBackward = !!isBackward;

			this.fire('change:range', { directChange: true });
		}

		/**
   * Removes all ranges that were added to the selection.
   *
   * @fires engine.model.Selection#change:range
   */

	}, {
		key: 'removeAllRanges',
		value: function removeAllRanges() {
			if (this._ranges.length > 0) {
				this._removeAllRanges();
				this.fire('change:range', { directChange: true });
			}
		}

		/**
   * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
   * is treated like the last added range and is used to set {@link engine.model.Selection#anchor} and
   * {@link engine.model.Selection#focus}. Accepts a flag describing in which direction the selection is made
   * (see {@link engine.model.Selection#addRange}).
   *
   * @fires engine.model.Selection#change:range
   * @param {Iterable.<engine.model.Range>} newRanges Ranges to set.
   * @param {Boolean} [isLastBackward=false] Flag describing if last added range was selected forward - from start to end (`false`)
   * or backward - from end to start (`true`).
   */

	}, {
		key: 'setRanges',
		value: function setRanges(newRanges) {
			var _this = this;

			var isLastBackward = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

			newRanges = Array.from(newRanges);

			// Check whether there is any range in new ranges set that is different than all already added ranges.
			var anyNewRange = newRanges.some(function (newRange) {
				if (!(newRange instanceof Range$1)) {
					throw new CKEditorError('model-selection-added-not-range: Trying to add an object that is not an instance of Range.');
				}

				return _this._ranges.every(function (oldRange) {
					return !oldRange.isEqual(newRange);
				});
			});

			// Don't do anything if nothing changed.
			if (newRanges.length === this._ranges.length && !anyNewRange) {
				return;
			}

			this._removeAllRanges();

			var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
				for (var _iterator4 = newRanges[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var range = _step4.value;

					this._pushRange(range);
				}
			} catch (err) {
				_didIteratorError4 = true;
				_iteratorError4 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion4 && _iterator4.return) {
						_iterator4.return();
					}
				} finally {
					if (_didIteratorError4) {
						throw _iteratorError4;
					}
				}
			}

			this._lastRangeBackward = !!isLastBackward;

			this.fire('change:range', { directChange: true });
		}

		/**
   * Sets this selection's ranges and direction to the ranges and direction of the given selection.
   *
   * @param {engine.model.Selection} otherSelection
   */

	}, {
		key: 'setTo',
		value: function setTo(otherSelection) {
			this.setRanges(otherSelection.getRanges(), otherSelection.isBackward);
		}

		/**
   * Sets collapsed selection in the specified location.
   *
   * The location can be specified in the same form as {@link engine.model.Position.createAt} parameters.
   *
   * @fires engine.model.Selection#change:range
   * @param {engine.model.Item|engine.model.Position} itemOrPosition
   * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when
   * first parameter is a {@link engine.model.Item model item}.
   */

	}, {
		key: 'collapse',
		value: function collapse(itemOrPosition, offset) {
			var pos = Position.createAt(itemOrPosition, offset);
			var range = new Range$1(pos, pos);

			this.setRanges([range]);
		}

		/**
   * Collapses selection to the selection's {@link engine.model.Selection#getFirstPosition first position}.
   * All ranges, besides the collapsed one, will be removed. Nothing will change if there are no ranges stored
   * inside selection.
   *
   * @fires engine.view.Selection#change
   */

	}, {
		key: 'collapseToStart',
		value: function collapseToStart() {
			var startPosition = this.getFirstPosition();

			if (startPosition !== null) {
				this.setRanges([new Range$1(startPosition, startPosition)]);
			}
		}

		/**
   * Collapses selection to the selection's {@link engine.model.Selection#getLastPosition last position}.
   * All ranges, besides the collapsed one, will be removed. Nothing will change if there are no ranges stored
   * inside selection.
   *
   * @fires engine.view.Selection#change
   */

	}, {
		key: 'collapseToEnd',
		value: function collapseToEnd() {
			var endPosition = this.getLastPosition();

			if (endPosition !== null) {
				this.setRanges([new Range$1(endPosition, endPosition)]);
			}
		}

		/**
   * Sets {@link engine.model.Selection#focus} to the specified location.
   *
   * The location can be specified in the same form as {@link engine.model.Position.createAt} parameters.
   *
   * @fires engine.model.Selection#change:range
   * @param {engine.model.Item|engine.model.Position} itemOrPosition
   * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when
   * first parameter is a {@link engine.model.Item model item}.
   */

	}, {
		key: 'setFocus',
		value: function setFocus(itemOrPosition, offset) {
			if (this.anchor === null) {
				/**
     * Cannot set selection focus if there are no ranges in selection.
     *
     * @error model-selection-setFocus-no-ranges
     */
				throw new CKEditorError('model-selection-setFocus-no-ranges: Cannot set selection focus if there are no ranges in selection.');
			}

			var newFocus = Position.createAt(itemOrPosition, offset);

			if (newFocus.compareWith(this.focus) == 'same') {
				return;
			}

			var anchor = this.anchor;

			if (this._ranges.length) {
				this._popRange();
			}

			if (newFocus.compareWith(anchor) == 'before') {
				this.addRange(new Range$1(newFocus, anchor), true);
			} else {
				this.addRange(new Range$1(anchor, newFocus));
			}
		}

		/**
   * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.
   *
   * @param {String} key Key of attribute to look for.
   * @returns {*} Attribute value or `undefined`.
   */

	}, {
		key: 'getAttribute',
		value: function getAttribute(key) {
			return this._attrs.get(key);
		}

		/**
   * Returns iterator that iterates over this selection's attributes.
   *
   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
   *
   * @returns {Iterable.<*>}
   */

	}, {
		key: 'getAttributes',
		value: function getAttributes() {
			return this._attrs.entries();
		}

		/**
   * Returns iterator that iterates over this selection's attribute keys.
   *
   * @returns {Iterator.<String>}
   */

	}, {
		key: 'getAttributeKeys',
		value: function getAttributeKeys() {
			return this._attrs.keys();
		}

		/**
   * Checks if the selection has an attribute for given key.
   *
   * @param {String} key Key of attribute to check.
   * @returns {Boolean} `true` if attribute with given key is set on selection, `false` otherwise.
   */

	}, {
		key: 'hasAttribute',
		value: function hasAttribute(key) {
			return this._attrs.has(key);
		}

		/**
   * Removes all attributes from the selection.
   *
   * If there were any attributes in selection, fires the {@link engine.model.Selection#change} event with
   * removed attributes' keys.
   *
   * @fires engine.model.Selection#change:attribute
   */

	}, {
		key: 'clearAttributes',
		value: function clearAttributes() {
			if (this._attrs.size > 0) {
				var attributeKeys = Array.from(this._attrs.keys());
				this._attrs.clear();

				this.fire('change:attribute', { attributeKeys: attributeKeys, directChange: true });
			}
		}

		/**
   * Removes an attribute with given key from the selection.
   *
   * If given attribute was set on the selection, fires the {@link engine.model.Selection#change} event with
   * removed attribute key.
   *
   * @fires engine.model.Selection#change:attribute
   * @param {String} key Key of attribute to remove.
   */

	}, {
		key: 'removeAttribute',
		value: function removeAttribute(key) {
			if (this.hasAttribute(key)) {
				this._attrs.delete(key);

				this.fire('change:attribute', { attributeKeys: [key], directChange: true });
			}
		}

		/**
   * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.
   *
   * If the attribute value has changed, fires the {@link engine.model.Selection#change} event with
   * the attribute key.
   *
   * @fires engine.model.Selection#change:attribute
   * @param {String} key Key of attribute to set.
   * @param {*} value Attribute value.
   */

	}, {
		key: 'setAttribute',
		value: function setAttribute(key, value) {
			if (this.getAttribute(key) !== value) {
				this._attrs.set(key, value);

				this.fire('change:attribute', { attributeKeys: [key], directChange: true });
			}
		}

		/**
   * Removes all attributes from the selection and sets given attributes.
   *
   * If given set of attributes is different than set of attributes already added to selection, fires
   * {@link engine.model.Selection#change change event} with keys of attributes that changed.
   *
   * @fires engine.model.Selection#change:attribute
   * @param {Iterable|Object} attrs Iterable object containing attributes to be set.
   */

	}, {
		key: 'setAttributesTo',
		value: function setAttributesTo(attrs) {
			attrs = toMap(attrs);

			if (!mapsEqual(attrs, this._attrs)) {
				// Create a set from keys of old and new attributes.
				var changed = new Set(Array.from(attrs.keys()).concat(Array.from(this._attrs.keys())));

				var _iteratorNormalCompletion5 = true;
				var _didIteratorError5 = false;
				var _iteratorError5 = undefined;

				try {
					for (var _iterator5 = attrs[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
						var _step5$value = slicedToArray(_step5.value, 2);

						var key = _step5$value[0];
						var value = _step5$value[1];

						// If the attribute remains unchanged, remove it from changed set.
						if (this._attrs.get(key) === value) {
							changed.delete(key);
						}
					}
				} catch (err) {
					_didIteratorError5 = true;
					_iteratorError5 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion5 && _iterator5.return) {
							_iterator5.return();
						}
					} finally {
						if (_didIteratorError5) {
							throw _iteratorError5;
						}
					}
				}

				this._attrs = attrs;

				this.fire('change:attribute', { attributeKeys: Array.from(changed), directChange: true });
			}
		}

		/**
   * Creates and returns an instance of `Selection` that is a clone of given selection, meaning that it has same
   * ranges and same direction as this selection.
   *
   * @params {engine.model.Selection} otherSelection Selection to be cloned.
   * @returns {engine.model.Selection} `Selection` instance that is a clone of given selection.
   */

	}, {
		key: '_pushRange',


		/**
   * Adds given range to internal {@link engine.model.Selection#_ranges ranges array}. Throws an error
   * if given range is intersecting with any range that is already stored in this selection.
   *
   * @protected
   * @param {engine.model.Range} range Range to add.
   */
		value: function _pushRange(range) {
			if (!(range instanceof Range$1)) {
				throw new CKEditorError('model-selection-added-not-range: Trying to add an object that is not an instance of Range.');
			}

			this._checkRange(range);
			this._ranges.push(Range$1.createFromRange(range));
		}

		/**
   * Checks if given range intersects with ranges that are already in the selection. Throws an error if it does.
   *
   * @protected
   * @param {engine.model.Range} range Range to check.
   */

	}, {
		key: '_checkRange',
		value: function _checkRange(range) {
			for (var i = 0; i < this._ranges.length; i++) {
				if (range.isIntersecting(this._ranges[i])) {
					/**
      * Trying to add a range that intersects with another range from selection.
      *
      * @error selection-range-intersects
      * @param {engine.model.Range} addedRange Range that was added to the selection.
      * @param {engine.model.Range} intersectingRange Range from selection that intersects with `addedRange`.
      */
					throw new CKEditorError('model-selection-range-intersects: Trying to add a range that intersects with another range from selection.', { addedRange: range, intersectingRange: this._ranges[i] });
				}
			}
		}

		/**
   * Removes most recently added range from the selection.
   *
   * @protected
   */

	}, {
		key: '_popRange',
		value: function _popRange() {
			this._ranges.pop();
		}

		/**
   * Deletes ranges from internal range array. Uses {@link engine.model.Selection#_popRange _popRange} to
   * ensure proper ranges removal.
   *
   * @private
   */

	}, {
		key: '_removeAllRanges',
		value: function _removeAllRanges() {
			while (this._ranges.length > 0) {
				this._popRange();
			}
		}

		/**
   * Fired whenever selection ranges are changed.
   *
   * @event engine.model.Selection#change:range
   * @param {Boolean} directChange Specifies whether the range change was caused by direct usage of `Selection` API (`true`)
   * or by changes done to {@link engine.model.Document model document} using {@link engine.model.Batch Batch} API (`false`).
   */

		/**
   * Fired whenever selection attributes are changed.
   *
   * @event engine.model.Selection#change:attribute
   * @param {Boolean} directChange Specifies whether the attributes changed by direct usage of the Selection API (`true`)
   * or by changes done to the {@link engine.model.Document model document} using the {@link engine.model.Batch Batch} API (`false`).
   * @param {Array.<String>} attributeKeys Array containing keys of attributes that changed.
   */

	}, {
		key: 'anchor',
		get: function get() {
			if (this._ranges.length > 0) {
				var range = this._ranges[this._ranges.length - 1];

				return this._lastRangeBackward ? range.end : range.start;
			}

			return null;
		}

		/**
   * Selection focus. Focus is a position where the selection ends.
   *
   * Is set to `null` if there are no ranges in selection.
   *
   * @see engine.model.Selection#anchor
   * @readonly
   * @type {engine.model.Position|null}
   */

	}, {
		key: 'focus',
		get: function get() {
			if (this._ranges.length > 0) {
				var range = this._ranges[this._ranges.length - 1];

				return this._lastRangeBackward ? range.start : range.end;
			}

			return null;
		}

		/**
   * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
   * collapsed.
   *
   * @readonly
   * @type {Boolean}
   */

	}, {
		key: 'isCollapsed',
		get: function get() {
			var length = this._ranges.length;

			if (length === 1) {
				return this._ranges[0].isCollapsed;
			} else {
				return false;
			}
		}

		/**
   * Returns number of ranges in selection.
   *
   * @type {Number}
   */

	}, {
		key: 'rangeCount',
		get: function get() {
			return this._ranges.length;
		}

		/**
   * Specifies whether the {@link engine.model.Selection#focus} precedes {@link engine.model.Selection#anchor}.
   *
   * @type {Boolean}
   */

	}, {
		key: 'isBackward',
		get: function get() {
			return !this.isCollapsed && this._lastRangeBackward;
		}
	}], [{
		key: 'createFromSelection',
		value: function createFromSelection(otherSelection) {
			var selection = new this();
			selection.setTo(otherSelection);

			return selection;
		}
	}]);
	return Selection;
}();

mix(Selection, EmitterMixin);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

var storePrefix = 'selection:';

var attrOpTypes = new Set(['addAttribute', 'removeAttribute', 'changeAttribute', 'addRootAttribute', 'removeRootAttribute', 'changeRootAttribute']);

/**
 * `LiveSelection` is a type of {@link engine.model.Selection selection} that listens to changes on a
 * {@link engine.model.Document document} and has it ranges updated accordingly. Internal implementation of this
 * mechanism bases on {@link engine.model.LiveRange live ranges}.
 *
 * Differences between {@link engine.model.Selection} and `LiveSelection` are two:
 * * there is always a range in `LiveSelection` - even if no ranges were added there is a
 * {@link engine.model.LiveSelection#_getDefaultRange "default range"} present in the selection,
 * * ranges added to this selection updates automatically when the document changes.
 *
 * Since `LiveSelection` uses {@link engine.model.LiveRange live ranges} and is updated when {@link engine.model.Document document}
 * changes, it cannot be set on {@link engine.model.Node nodes} that are inside {@link engine.model.DocumentFragment document fragment}.
 * If you need to represent a selection in document fragment, use {@link engine.model.Selection "normal" selection} instead.
 *
 * @memberOf engine.model
 */

var LiveSelection = function (_Selection) {
	inherits(LiveSelection, _Selection);

	/**
  * Creates an empty live selection for given {@link engine.model.Document}.
  *
  * @param {engine.model.Document} document Document which owns this selection.
  */
	function LiveSelection(document) {
		classCallCheck(this, LiveSelection);

		/**
   * Document which owns this selection.
   *
   * @protected
   * @member {engine.model.Document} engine.model.LiveSelection#_document
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(LiveSelection).call(this));

		_this._document = document;

		/**
   * Keeps mapping of attribute name to priority with which the attribute got modified (added/changed/removed)
   * last time. Possible values of priority are: `'low'` and `'normal'`.
   *
   * Priorities are used by internal `LiveSelection` mechanisms. All attributes set using `LiveSelection`
   * attributes API are set with `'normal'` priority.
   *
   * @private
   * @member {Map} engine.model.LiveSelection#_attributePriority
   */
		_this._attributePriority = new Map();

		// Whenever attribute operation is performed on document, update attributes. This is not the most efficient
		// way to update selection attributes, but should be okay for now. `_updateAttributes` will be fired too often,
		// but it won't change attributes or fire `change:attribute` event if not needed.
		_this.listenTo(_this._document, 'change', function (evt, type) {
			if (attrOpTypes.has(type)) {
				_this._updateAttributes(false);
			}
		});
		return _this;
	}

	/**
  * @inheritDoc
  */


	createClass(LiveSelection, [{
		key: 'destroy',


		/**
   * Unbinds all events previously bound by document selection.
   */
		value: function destroy() {
			for (var i = 0; i < this._ranges.length; i++) {
				this._ranges[i].detach();
			}

			this.stopListening();
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'getRanges',
		value: regeneratorRuntime.mark(function getRanges() {
			return regeneratorRuntime.wrap(function getRanges$(_context) {
				while (1) {
					switch (_context.prev = _context.next) {
						case 0:
							if (!this._ranges.length) {
								_context.next = 4;
								break;
							}

							return _context.delegateYield(get(Object.getPrototypeOf(LiveSelection.prototype), 'getRanges', this).call(this), 't0', 2);

						case 2:
							_context.next = 6;
							break;

						case 4:
							_context.next = 6;
							return this._document._getDefaultRange();

						case 6:
						case 'end':
							return _context.stop();
					}
				}
			}, getRanges, this);
		})

		/**
   * @inheritDoc
   */

	}, {
		key: 'getFirstRange',
		value: function getFirstRange() {
			return get(Object.getPrototypeOf(LiveSelection.prototype), 'getFirstRange', this).call(this) || this._document._getDefaultRange();
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'getLastRange',
		value: function getLastRange() {
			return get(Object.getPrototypeOf(LiveSelection.prototype), 'getLastRange', this).call(this) || this._document._getDefaultRange();
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'addRange',
		value: function addRange(range) {
			var isBackward = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

			get(Object.getPrototypeOf(LiveSelection.prototype), 'addRange', this).call(this, range, isBackward);
			this.refreshAttributes();
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'removeAllRanges',
		value: function removeAllRanges() {
			get(Object.getPrototypeOf(LiveSelection.prototype), 'removeAllRanges', this).call(this);
			this.refreshAttributes();
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'setRanges',
		value: function setRanges(newRanges) {
			var isLastBackward = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

			get(Object.getPrototypeOf(LiveSelection.prototype), 'setRanges', this).call(this, newRanges, isLastBackward);
			this.refreshAttributes();
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'setAttribute',
		value: function setAttribute(key, value) {
			// Store attribute in parent element if the selection is collapsed in an empty node.
			if (this.isCollapsed && this.anchor.parent.childCount === 0) {
				this._storeAttribute(key, value);
			}

			if (this._setAttribute(key, value)) {
				// Fire event with exact data.
				var attributeKeys = [key];
				this.fire('change:attribute', { attributeKeys: attributeKeys, directChange: true });
			}
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'removeAttribute',
		value: function removeAttribute(key) {
			// Remove stored attribute from parent element if the selection is collapsed in an empty node.
			if (this.isCollapsed && this.anchor.parent.childCount === 0) {
				this._removeStoredAttribute(key);
			}

			if (this._removeAttribute(key)) {
				// Fire event with exact data.
				var attributeKeys = [key];
				this.fire('change:attribute', { attributeKeys: attributeKeys, directChange: true });
			}
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'setAttributesTo',
		value: function setAttributesTo(attrs) {
			attrs = toMap(attrs);

			if (this.isCollapsed && this.anchor.parent.childCount === 0) {
				this._setStoredAttributesTo(attrs);
			}

			var changed = this._setAttributesTo(attrs);

			if (changed.size > 0) {
				// Fire event with exact data (fire only if anything changed).
				var attributeKeys = Array.from(changed);
				this.fire('change:attribute', { attributeKeys: attributeKeys, directChange: true });
			}
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'clearAttributes',
		value: function clearAttributes() {
			this.setAttributesTo([]);
		}

		/**
   * Removes all attributes from the selection and sets attributes according to the surrounding nodes.
   */

	}, {
		key: 'refreshAttributes',
		value: function refreshAttributes() {
			this._updateAttributes(true);
		}

		/**
   * Creates and returns an instance of `LiveSelection` that is a clone of given selection, meaning that it has same
   * ranges and same direction as this selection.
   *
   * @params {engine.model.Selection} otherSelection Selection to be cloned.
   * @returns {engine.model.LiveSelection} `Selection` instance that is a clone of given selection.
   */

	}, {
		key: '_popRange',


		/**
   * @inheritDoc
   */
		value: function _popRange() {
			this._ranges.pop().detach();
		}

		/**
   * @inheritDoc
   */

	}, {
		key: '_pushRange',
		value: function _pushRange(range) {
			var liveRange = this._prepareRange(range);

			// `undefined` is returned when given `range` is in graveyard root.
			if (liveRange) {
				this._ranges.push(liveRange);
			}
		}

		/**
   * Prepares given range to be added to selection. Checks if it is correct, converts it to {@link engine.model.LiveRange LiveRange}
   * and sets listeners listening to the range's change event.
   *
   * @private
   * @param {engine.model.Range} range
   */

	}, {
		key: '_prepareRange',
		value: function _prepareRange(range) {
			var _this2 = this;

			if (!(range instanceof Range$1)) {
				/**
     * Trying to add an object that is not an instance of Range.
     *
     * @error model-selection-added-not-range
     */
				throw new CKEditorError('model-selection-added-not-range: Trying to add an object that is not an instance of Range.');
			}

			if (range.root == this._document.graveyard) {
				/**
     * Trying to add a Range that is in the graveyard root. Range rejected.
     *
     * @warning model-selection-range-in-graveyard
     */
				log.warn('model-selection-range-in-graveyard: Trying to add a Range that is in the graveyard root. Range rejected.');

				return;
			}

			this._checkRange(range);

			var liveRange = LiveRange.createFromRange(range);
			this.listenTo(liveRange, 'change', function (evt, oldRange) {
				if (liveRange.root == _this2._document.graveyard) {
					_this2._fixGraveyardSelection(liveRange, oldRange);
				}

				_this2.fire('change:range', { directChange: false });
			});

			return liveRange;
		}

		/**
   * Updates this selection attributes according to its ranges and the {@link engine.model.Document model document}.
   *
   * @protected
   * @param {Boolean} clearAll
   * @fires engine.model.LiveSelection#change:attribute
   */

	}, {
		key: '_updateAttributes',
		value: function _updateAttributes(clearAll) {
			var newAttributes = toMap(this._getSurroundingAttributes());
			var oldAttributes = toMap(this.getAttributes());

			if (clearAll) {
				// If `clearAll` remove all attributes and reset priorities.
				this._attributePriority = new Map();
				this._attrs = new Map();
			} else {
				// If not, remove only attributes added with `low` priority.
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = this._attributePriority[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var _step$value = slicedToArray(_step.value, 2);

						var key = _step$value[0];
						var priority = _step$value[1];

						if (priority == 'low') {
							this._attrs.delete(key);
							this._attributePriority.delete(key);
						}
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
			}

			this._setAttributesTo(newAttributes, false);

			// Let's evaluate which attributes really changed.
			var changed = [];

			// First, loop through all attributes that are set on selection right now.
			// Check which of them are different than old attributes.
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = this.getAttributes()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var _step2$value = slicedToArray(_step2.value, 2);

					var newKey = _step2$value[0];
					var newValue = _step2$value[1];

					if (!oldAttributes.has(newKey) || oldAttributes.get(newKey) !== newValue) {
						changed.push(newKey);
					}
				}

				// Then, check which of old attributes got removed.
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = oldAttributes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var _step3$value = slicedToArray(_step3.value, 1);

					var oldKey = _step3$value[0];

					if (!this.hasAttribute(oldKey)) {
						changed.push(oldKey);
					}
				}

				// Fire event with exact data (fire only if anything changed).
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}

			if (changed.length > 0) {
				this.fire('change:attribute', { attributeKeys: changed, directChange: false });
			}
		}

		/**
   * Generates and returns an attribute key for selection attributes store, basing on original attribute key.
   *
   * @protected
   * @param {String} key Attribute key to convert.
   * @returns {String} Converted attribute key, applicable for selection store.
   */

	}, {
		key: '_setAttribute',


		/**
   * Internal method for setting `LiveSelection` attribute. Supports attribute priorities (through `directChange`
   * parameter).
   *
   * @private
   * @param {String} key Attribute key.
   * @param {*} value Attribute value.
   * @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change
   * is caused by `Batch` API.
   * @returns {Boolean} Whether value has changed.
   */
		value: function _setAttribute(key, value) {
			var directChange = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

			var priority = directChange ? 'normal' : 'low';

			if (priority == 'low' && this._attributePriority.get(key) == 'normal') {
				// Priority too low.
				return false;
			}

			var oldValue = get(Object.getPrototypeOf(LiveSelection.prototype), 'getAttribute', this).call(this, key);

			// Don't do anything if value has not changed.
			if (oldValue === value) {
				return false;
			}

			this._attrs.set(key, value);

			// Update priorities map.
			this._attributePriority.set(key, priority);

			return true;
		}

		/**
   * Internal method for removing `LiveSelection` attribute. Supports attribute priorities (through `directChange`
   * parameter).
   *
   * @private
   * @param {String} key Attribute key.
   * @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change
   * is caused by `Batch` API.
   * @returns {Boolean} Whether attribute was removed. May not be true if such attributes didn't exist or the
   * existing attribute had higher priority.
   */

	}, {
		key: '_removeAttribute',
		value: function _removeAttribute(key) {
			var directChange = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

			var priority = directChange ? 'normal' : 'low';

			if (priority == 'low' && this._attributePriority.get(key) == 'normal') {
				// Priority too low.
				return false;
			}

			// Don't do anything if value has not changed.
			if (!get(Object.getPrototypeOf(LiveSelection.prototype), 'hasAttribute', this).call(this, key)) {
				return false;
			}

			this._attrs.delete(key);

			// Update priorities map.
			this._attributePriority.set(key, priority);

			return true;
		}

		/**
   * Internal method for setting multiple `LiveSelection` attributes. Supports attribute priorities (through
   * `directChange` parameter).
   *
   * @private
   * @param {Iterable|Object} attrs Iterable object containing attributes to be set.
   * @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change
   * is caused by `Batch` API.
   * @returns {Set.<String>} Changed attribute keys.
   */

	}, {
		key: '_setAttributesTo',
		value: function _setAttributesTo(attrs) {
			var directChange = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

			var changed = new Set();

			var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
				for (var _iterator4 = this.getAttributes()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var _step4$value = slicedToArray(_step4.value, 2);

					var oldKey = _step4$value[0];
					var oldValue = _step4$value[1];

					// Do not remove attribute if attribute with same key and value is about to be set.
					if (attrs.get(oldKey) === oldValue) {
						continue;
					}

					// Attribute still might not get removed because of priorities.
					if (this._removeAttribute(oldKey, directChange)) {
						changed.add(oldKey);
					}
				}
			} catch (err) {
				_didIteratorError4 = true;
				_iteratorError4 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion4 && _iterator4.return) {
						_iterator4.return();
					}
				} finally {
					if (_didIteratorError4) {
						throw _iteratorError4;
					}
				}
			}

			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = attrs[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var _step5$value = slicedToArray(_step5.value, 2);

					var key = _step5$value[0];
					var value = _step5$value[1];

					// Attribute may not be set because of attributes or because same key/value is already added.
					var gotAdded = this._setAttribute(key, value, directChange);

					if (gotAdded) {
						changed.add(key);
					}
				}
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5.return) {
						_iterator5.return();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}

			return changed;
		}

		/**
   * Returns an iterator that iterates through all selection attributes stored in current selection's parent.
   *
   * @private
   * @returns {Iterable.<*>}
   */

	}, {
		key: '_getStoredAttributes',
		value: regeneratorRuntime.mark(function _getStoredAttributes() {
			var selectionParent, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, key, realKey;

			return regeneratorRuntime.wrap(function _getStoredAttributes$(_context2) {
				while (1) {
					switch (_context2.prev = _context2.next) {
						case 0:
							selectionParent = this.getFirstPosition().parent;

							if (!(this.isCollapsed && selectionParent.childCount === 0)) {
								_context2.next = 30;
								break;
							}

							_iteratorNormalCompletion6 = true;
							_didIteratorError6 = false;
							_iteratorError6 = undefined;
							_context2.prev = 5;
							_iterator6 = selectionParent.getAttributeKeys()[Symbol.iterator]();

						case 7:
							if (_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done) {
								_context2.next = 16;
								break;
							}

							key = _step6.value;

							if (!(key.indexOf(storePrefix) === 0)) {
								_context2.next = 13;
								break;
							}

							realKey = key.substr(storePrefix.length);
							_context2.next = 13;
							return [realKey, selectionParent.getAttribute(key)];

						case 13:
							_iteratorNormalCompletion6 = true;
							_context2.next = 7;
							break;

						case 16:
							_context2.next = 22;
							break;

						case 18:
							_context2.prev = 18;
							_context2.t0 = _context2['catch'](5);
							_didIteratorError6 = true;
							_iteratorError6 = _context2.t0;

						case 22:
							_context2.prev = 22;
							_context2.prev = 23;

							if (!_iteratorNormalCompletion6 && _iterator6.return) {
								_iterator6.return();
							}

						case 25:
							_context2.prev = 25;

							if (!_didIteratorError6) {
								_context2.next = 28;
								break;
							}

							throw _iteratorError6;

						case 28:
							return _context2.finish(25);

						case 29:
							return _context2.finish(22);

						case 30:
						case 'end':
							return _context2.stop();
					}
				}
			}, _getStoredAttributes, this, [[5, 18, 22, 30], [23,, 25, 29]]);
		})

		/**
   * Removes attribute with given key from attributes stored in current selection's parent node.
   *
   * @private
   * @param {String} key Key of attribute to remove.
   */

	}, {
		key: '_removeStoredAttribute',
		value: function _removeStoredAttribute(key) {
			var storeKey = LiveSelection._getStoreAttributeKey(key);

			this._document.batch().removeAttribute(this.anchor.parent, storeKey);
		}

		/**
   * Stores given attribute key and value in current selection's parent node.
   *
   * @private
   * @param {String} key Key of attribute to set.
   * @param {*} value Attribute value.
   */

	}, {
		key: '_storeAttribute',
		value: function _storeAttribute(key, value) {
			var storeKey = LiveSelection._getStoreAttributeKey(key);

			this._document.batch().setAttribute(this.anchor.parent, storeKey, value);
		}

		/**
   * Sets selection attributes stored in current selection's parent node to given set of attributes.
   *
   * @private
   * @param {Iterable|Object} attrs Iterable object containing attributes to be set.
   */

	}, {
		key: '_setStoredAttributesTo',
		value: function _setStoredAttributesTo(attrs) {
			var selectionParent = this.anchor.parent;
			var batch = this._document.batch();

			var _iteratorNormalCompletion7 = true;
			var _didIteratorError7 = false;
			var _iteratorError7 = undefined;

			try {
				for (var _iterator7 = this._getStoredAttributes()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
					var _step7$value = slicedToArray(_step7.value, 1);

					var oldKey = _step7$value[0];

					var storeKey = LiveSelection._getStoreAttributeKey(oldKey);

					batch.removeAttribute(selectionParent, storeKey);
				}
			} catch (err) {
				_didIteratorError7 = true;
				_iteratorError7 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion7 && _iterator7.return) {
						_iterator7.return();
					}
				} finally {
					if (_didIteratorError7) {
						throw _iteratorError7;
					}
				}
			}

			var _iteratorNormalCompletion8 = true;
			var _didIteratorError8 = false;
			var _iteratorError8 = undefined;

			try {
				for (var _iterator8 = attrs[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
					var _step8$value = slicedToArray(_step8.value, 2);

					var key = _step8$value[0];
					var value = _step8$value[1];

					var _storeKey = LiveSelection._getStoreAttributeKey(key);

					batch.setAttribute(selectionParent, _storeKey, value);
				}
			} catch (err) {
				_didIteratorError8 = true;
				_iteratorError8 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion8 && _iterator8.return) {
						_iterator8.return();
					}
				} finally {
					if (_didIteratorError8) {
						throw _iteratorError8;
					}
				}
			}
		}

		/**
   * Checks model text nodes that are closest to the selection's first position and returns attributes of first
   * found element. If there are no text nodes in selection's first position parent, it returns selection
   * attributes stored in that parent.
   *
   * @private
   * @returns {Iterable.<*>} Collection of attributes.
   */

	}, {
		key: '_getSurroundingAttributes',
		value: function _getSurroundingAttributes() {
			var position = this.getFirstPosition();

			var attrs = null;

			if (!this.isCollapsed) {
				// 1. If selection is a range...
				var range = this.getFirstRange();

				// ...look for a first character node in that range and take attributes from it.
				var _iteratorNormalCompletion9 = true;
				var _didIteratorError9 = false;
				var _iteratorError9 = undefined;

				try {
					for (var _iterator9 = range[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
						var item = _step9.value;

						// This is not an optimal solution because of https://github.com/ckeditor/ckeditor5-engine/issues/454.
						// It can be done better by using `break;` instead of checking `attrs === null`.
						if (item.type == 'text' && attrs === null) {
							attrs = item.item.getAttributes();
						}
					}
				} catch (err) {
					_didIteratorError9 = true;
					_iteratorError9 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion9 && _iterator9.return) {
							_iterator9.return();
						}
					} finally {
						if (_didIteratorError9) {
							throw _iteratorError9;
						}
					}
				}
			} else {
				// 2. If the selection is a caret or the range does not contain a character node...

				var nodeBefore = position.textNode ? position.textNode : position.nodeBefore;
				var nodeAfter = position.textNode ? position.textNode : position.nodeAfter;

				// ...look at the node before caret and take attributes from it if it is a character node.
				attrs = getAttrsIfCharacter(nodeBefore);

				// 3. If not, look at the node after caret...
				if (!attrs) {
					attrs = getAttrsIfCharacter(nodeAfter);
				}

				// 4. If not, try to find the first character on the left, that is in the same node.
				if (!attrs) {
					var node = nodeBefore;

					while (node && !attrs) {
						node = node.previousSibling;
						attrs = getAttrsIfCharacter(node);
					}
				}

				// 5. If not found, try to find the first character on the right, that is in the same node.
				if (!attrs) {
					var _node = nodeAfter;

					while (_node && !attrs) {
						_node = _node.nextSibling;
						attrs = getAttrsIfCharacter(_node);
					}
				}

				// 6. If not found, selection should retrieve attributes from parent.
				if (!attrs) {
					attrs = this._getStoredAttributes();
				}
			}

			return attrs;
		}

		/**
   * Fixes a selection range after it ends up in graveyard root.
   *
   * @private
   * @param {engine.model.LiveRange} gyRange The range added in selection, that ended up in graveyard root.
   * @param {engine.model.Range} oldRange The state of that range before it was added to graveyard root.
   */

	}, {
		key: '_fixGraveyardSelection',
		value: function _fixGraveyardSelection(gyRange, oldRange) {
			var gyPath = gyRange.start.path;

			var newPathLength = oldRange.start.path.length - (gyPath.length - 2);
			var newPath = oldRange.start.path.slice(0, newPathLength);
			newPath[newPath.length - 1] -= gyPath[1];

			var newPosition = new Position(oldRange.root, newPath);
			var newRange = this._prepareRange(new Range$1(newPosition, newPosition));

			var index = this._ranges.indexOf(gyRange);
			this._ranges.splice(index, 1, newRange);

			gyRange.detach();
		}
	}, {
		key: 'isCollapsed',
		get: function get$$() {
			var length = this._ranges.length;

			return length === 0 ? true : get(Object.getPrototypeOf(LiveSelection.prototype), 'isCollapsed', this);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'anchor',
		get: function get$$() {
			return get(Object.getPrototypeOf(LiveSelection.prototype), 'anchor', this) || this._document._getDefaultRange().start;
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'focus',
		get: function get$$() {
			return get(Object.getPrototypeOf(LiveSelection.prototype), 'focus', this) || this._document._getDefaultRange().start;
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'rangeCount',
		get: function get$$() {
			return this._ranges.length ? this._ranges.length : 1;
		}
	}], [{
		key: 'createFromSelection',
		value: function createFromSelection(otherSelection) {
			var selection = new this(otherSelection._document);
			selection.setTo(otherSelection);

			return selection;
		}
	}, {
		key: '_getStoreAttributeKey',
		value: function _getStoreAttributeKey(key) {
			return storePrefix + key;
		}
	}]);
	return LiveSelection;
}(Selection);

function getAttrsIfCharacter(node) {
	if (node instanceof TextProxy || node instanceof Text$1) {
		return node.getAttributes();
	}

	return null;
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * SchemaItem is a singular registry item in {@link engine.model.Schema} that groups and holds allow/disallow rules for
 * one entity. This class is used internally in {@link engine.model.Schema} and should not be used outside it.
 *
 * @see engine.model.Schema
 * @protected
 * @memberOf engine.model
 */
var SchemaItem = function () {
	/**
  * Creates SchemaItem instance.
  *
  * @param {engine.model.Schema} schema Schema instance that owns this item.
  */
	function SchemaItem(schema) {
		classCallCheck(this, SchemaItem);

		/**
   * Schema instance that owns this item.
   *
   * @private
   * @member {engine.model.Schema} engine.model.SchemaItem#_schema
   */
		this._schema = schema;

		/**
   * Paths in which the entity, represented by this item, is allowed.
   *
   * @private
   * @member {Array} engine.model.SchemaItem#_allowed
   */
		this._allowed = [];

		/**
   * Paths in which the entity, represented by this item, is disallowed.
   *
   * @private
   * @member {Array} engine.model.SchemaItem#_disallowed
   */
		this._disallowed = [];

		/**
   * Attributes that are required by the entity represented by this item.
   *
   * @protected
   * @member {Array} engine.model.SchemaItem#_requiredAttributes
   */
		this._requiredAttributes = [];
	}

	/**
  * Allows entity, represented by this item, to be in given path.
  *
  * @param {Array.<String>} path Path in which entity is allowed.
  * @param {Array.<String>|String} [attributes] If set, this path will be used only for entities that have attribute(s) with this key.
  */


	createClass(SchemaItem, [{
		key: 'allow',
		value: function allow(path, attributes) {
			this._addPath('_allowed', path, attributes);
		}

		/**
   * Disallows entity, represented by this item, to be in given path.
   *
   * @param {Array.<String>} path Path in which entity is disallowed.
   * @param {Array.<String>|String} [attributes] If set, this path will be used only for entities that have an attribute(s) with this key.
   */

	}, {
		key: 'disallow',
		value: function disallow(path, attributes) {
			this._addPath('_disallowed', path, attributes);
		}

		/**
   * Specifies that the entity, to be valid, requires given attributes set. It is possible to register multiple
   * different attributes set. If there are more than one attributes set required, the entity will be valid if
   * at least one of them is fulfilled.
   *
   * @param {Array.<String>} attributes Attributes that has to be set on the entity to make it valid.
   */

	}, {
		key: 'requireAttributes',
		value: function requireAttributes(attributes) {
			this._requiredAttributes.push(attributes);
		}

		/**
   * Adds path to the SchemaItem instance.
   *
   * @private
   * @param {String} member Name of the array member into which the path will be added. Possible values are `_allowed` or `_disallowed`.
   * @param {Array.<String>} path Path to add.
   * @param {Array.<String>|String} [attributes] If set, this path will be used only for entities that have attribute(s) with this key.
   */

	}, {
		key: '_addPath',
		value: function _addPath(member, path, attributes) {
			path = path.slice();

			if (!isArray(attributes)) {
				attributes = [attributes];
			}

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = attributes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var attribute = _step.value;

					this[member].push({ path: path, attribute: attribute });
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		}

		/**
   * Returns all paths of given type that were previously registered in the item.
   *
   * @private
   * @param {String} type Paths' type. Possible values are `allow` or `disallow`.
   * @param {String} [attribute] If set, only paths registered for given attribute will be returned.
   * @returns {Array} Paths registered in the item.
   */

	}, {
		key: '_getPaths',
		value: function _getPaths(type, attribute) {
			var source = type === 'allow' ? this._allowed : this._disallowed;
			var paths = [];

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = source[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var item = _step2.value;

					if (item.attribute === attribute) {
						paths.push(item.path);
					}
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			return paths;
		}

		/**
   * Checks whether given set of attributes fulfills required attributes of this item.
   *
   * @protected
   * @see engine.model.SchemaItem#requireAttributes
   * @param {Array.<String>} attributesToCheck Attributes to check.
   * @returns {Boolean} `true` if given set or attributes fulfills required attributes, `false` otherwise.
   */

	}, {
		key: '_checkRequiredAttributes',
		value: function _checkRequiredAttributes(attributesToCheck) {
			var found = true;

			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = this._requiredAttributes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var attributeSet = _step3.value;

					found = true;

					var _iteratorNormalCompletion4 = true;
					var _didIteratorError4 = false;
					var _iteratorError4 = undefined;

					try {
						for (var _iterator4 = attributeSet[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
							var attribute = _step4.value;

							if (attributesToCheck.indexOf(attribute) == -1) {
								found = false;
								break;
							}
						}
					} catch (err) {
						_didIteratorError4 = true;
						_iteratorError4 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion4 && _iterator4.return) {
								_iterator4.return();
							}
						} finally {
							if (_didIteratorError4) {
								throw _iteratorError4;
							}
						}
					}

					if (found) {
						break;
					}
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}

			return found;
		}

		/**
   * Checks whether this item has any registered path of given type that matches provided path.
   *
   * @protected
   * @param {String} type Paths' type. Possible values are `allow` or `disallow`.
   * @param {Array.<String>} checkPath Path to check.
   * @param {String} [attribute] If set, only paths registered for given attribute will be checked.
   * @returns {Boolean} `true` if item has any registered matching path, `false` otherwise.
   */

	}, {
		key: '_hasMatchingPath',
		value: function _hasMatchingPath(type, checkPath, attribute) {
			var itemPaths = this._getPaths(type, attribute);

			// We check every path registered (possibly with given attribute) in the item.
			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = itemPaths[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var itemPath = _step5.value;

					// Pointer to last found item from `itemPath`.
					var i = 0;

					// Now we have to check every item name from the path to check.
					var _iteratorNormalCompletion6 = true;
					var _didIteratorError6 = false;
					var _iteratorError6 = undefined;

					try {
						for (var _iterator6 = checkPath[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
							var checkName = _step6.value;

							// Don't check items that are not registered in schema.
							if (!this._schema.hasItem(checkName)) {
								continue;
							}

							// Every item name is expanded to all names of items that item is extending.
							// So, if on item path, there is an item that is extended by item from checked path, it will
							// also be treated as matching.
							var chain = this._schema._extensionChains.get(checkName);

							// Since our paths have to match in given order, we always check against first item from item path.
							// So, if item path is: B D E
							// And checked path is: A B C D E
							// It will be matching (A won't match, B will match, C won't match, D and E will match)
							if (chain.indexOf(itemPath[i]) > -1) {
								// Move pointer as we found element under index `i`.
								i++;
							}
						}

						// If `itemPath` has no items it means that we removed all of them, so we matched all of them.
						// This means that we found a matching path.
					} catch (err) {
						_didIteratorError6 = true;
						_iteratorError6 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion6 && _iterator6.return) {
								_iterator6.return();
							}
						} finally {
							if (_didIteratorError6) {
								throw _iteratorError6;
							}
						}
					}

					if (i === itemPath.length) {
						return true;
					}
				}
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5.return) {
						_iterator5.return();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}

			return false;
		}

		/**
   * Custom toJSON method to solve child-parent circular dependencies.
   *
   * @returns {Object} Clone of this object with the parent property replaced with its name.
   */

	}, {
		key: 'toJSON',
		value: function toJSON() {
			var json = clone(this);

			// Due to circular references we need to remove parent reference.
			json._schema = '[model.Schema]';

			return json;
		}
	}]);
	return SchemaItem;
}();

/**
 * Schema is a definition of the structure of the document. It allows to define which tree model items (element, text, etc.)
 * can be nested within which ones and which attributes can be applied to them. It's created during the run-time of the application,
 * typically by features. Also, the features can query the schema to learn what structure is allowed and act accordingly.
 *
 * For instance, if a feature wants to define that an attribute bold is allowed on the text it needs to register this rule like this:
 *
 *		editor.document.schema.allow( '$text', 'bold' );
 *
 * Note: items prefixed with `$` are special group of items. By default, `Schema` defines three special items:
 *
 * * `$inline` represents all inline elements,
 * * `$text` is a sub-group of `$inline` and represents text nodes,
 * * `$block` represents block elements,
 * * `$root` represents default editing roots (those that allow only `$block`s inside them).
 *
 * When registering an item it's possible to tell that this item should inherit from some other existing item.
 * E.g. `p` can inherit from `$block`, so whenever given attribute is allowed on the `$block` it will automatically be
 * also allowed on the `p` element. By default, `$text` item already inherits from `$inline`.
 *
 * @memberOf engine.model
 */

var Schema = function () {
	/**
  * Creates Schema instance.
  */
	function Schema() {
		classCallCheck(this, Schema);

		/**
   * Names of elements which have "object" nature. This means that these
   * elements should be treated as whole, never merged, can be selected from outside, etc.
   * Just like images, placeholder widgets, etc.
   *
   * @member {Set.<String>} engine.model.Schema#objects
   */
		this.objects = new Set();

		/**
   * Schema items registered in the schema.
   *
   * @private
   * @member {Map} engine.model.Schema#_items
   */
		this._items = new Map();

		/**
   * Description of what entities are a base for given entity.
   *
   * @private
   * @member {Map} engine.model.Schema#_extensionChains
   */
		this._extensionChains = new Map();

		// Register some default abstract entities.
		this.registerItem('$root');
		this.registerItem('$block');
		this.registerItem('$inline');
		this.registerItem('$text', '$inline');

		this.allow({ name: '$block', inside: '$root' });
		this.allow({ name: '$inline', inside: '$block' });

		// TMP!
		// Create an "all allowed" context in the schema for processing the pasted content.
		// Read: https://github.com/ckeditor/ckeditor5-engine/issues/638#issuecomment-255086588

		this.registerItem('$clipboardHolder', '$root');
		this.allow({ name: '$inline', inside: '$clipboardHolder' });
	}

	/**
  * Allows given query in the schema.
  *
  *		// Allow text with bold attribute in all P elements.
  *		schema.registerItem( 'p', '$block' );
  *		schema.allow( { name: '$text', attributes: 'bold', inside: 'p' } );
  *
  *		// Allow header in Ps that are in DIVs
  *		schema.registerItem( 'header', '$block' );
  *		schema.registerItem( 'div', '$block' );
  *		schema.allow( { name: 'header', inside: 'div p' } ); // inside: [ 'div', 'p' ] would also work.
  *
  * @param {engine.model.SchemaQuery} query Allowed query.
  */


	createClass(Schema, [{
		key: 'allow',
		value: function allow(query) {
			this._getItem(query.name).allow(Schema._normalizeQueryPath(query.inside), query.attributes);
		}

		/**
   * Disallows given query in the schema.
   *
   * @see {@link engine.model.Schema#allow}
   * @param {engine.model.SchemaQuery} query Disallowed query.
   */

	}, {
		key: 'disallow',
		value: function disallow(query) {
			this._getItem(query.name).disallow(Schema._normalizeQueryPath(query.inside), query.attributes);
		}

		/**
   * Makes a requirement in schema that entity represented by given item has to have given set of attributes. Some
   * elements in the model might require some attributes to be set. If multiple sets of attributes are required it
   * is enough that the entity fulfills only one set.
   *
   *		// "a" element must either have "href" attribute or "name" attribute
   *		schema.requireAttributes( 'a', [ 'href' ] );
   *		schema.requireAttributes( 'a', [ 'name' ] );
   *		// "img" element must have both "src" and "alt" attributes
   *		schema.requireAttributes( 'img', [ 'src', 'alt' ] );
   *
   * @param {String} name Entity name.
   * @param {Array.<String>} attributes Attributes that has to be set on the entity to make it valid.
   */

	}, {
		key: 'requireAttributes',
		value: function requireAttributes(name, attributes) {
			this._getItem(name).requireAttributes(attributes);
		}

		/**
   * Checks whether given query is allowed in schema.
   *
   *		// Check whether bold text is allowed in header element.
   *		let query = {
   *			name: '$text',
   *			attributes: 'bold',
   *			inside: 'header'
   *		};
   *		if ( schema.check( query ) ) { ... }
   *
   *		// Check whether bold and italic text can be placed at caret position.
   *		let caretPos = editor.document.selection.getFirstPosition();
   *		let query = {
   *			name: '$text',
   *			attributes: [ 'bold', 'italic' ],
   *			inside: caretPos
   *		};
   *		if ( schema.check( query ) ) { ... }
   *
   *		// Check whether image with alt, src and title is allowed in given elements path.
   *		let quoteElement = new Element( 'quote' );
   *		let query = {
   *			name: 'img',
   *			attributes: [ 'alt', 'src', 'title' ],
   *			// It is possible to mix strings with elements.
   *			// Query will check whether "img" can be inside "quoteElement" that is inside a block element.
   *			inside: [ '$block', quoteElement ]
   *		};
   *		if ( schema.check( query ) ) { ... }
   *
   * @param {engine.model.SchemaQuery} query Query to check.
   * @returns {Boolean} `true` if given query is allowed in schema, `false` otherwise.
   */

	}, {
		key: 'check',
		value: function check(query) {
			var _this = this;

			if (!this.hasItem(query.name)) {
				return false;
			}

			// If attributes property is a string or undefined, wrap it in an array for easier processing.
			if (!isArray(query.attributes)) {
				query.attributes = [query.attributes];
			} else if (query.attributes.length === 0) {
				// To simplify algorithms, when a SchemaItem path is added "without" attribute, it is added with
				// attribute equal to undefined. This means that algorithms can work the same way for specified attributes
				// and no-atrtibutes, but we have to fill empty array with "fake" undefined value for algorithms reasons.
				query.attributes.push(undefined);
			}

			// Normalize the path to an array of strings.
			var path = Schema._normalizeQueryPath(query.inside);

			// Get extension chain of given item and retrieve all schema items that are extended by given item.
			var schemaItems = this._extensionChains.get(query.name).map(function (name) {
				return _this._getItem(name);
			});

			// First check if the query meets at required attributes for this item.
			if (!this._getItem(query.name)._checkRequiredAttributes(query.attributes)) {
				return false;
			}

			// If there is matching disallow path, this query is not valid with schema.
			var _iteratorNormalCompletion7 = true;
			var _didIteratorError7 = false;
			var _iteratorError7 = undefined;

			try {
				for (var _iterator7 = query.attributes[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
					var attribute = _step7.value;
					var _iteratorNormalCompletion9 = true;
					var _didIteratorError9 = false;
					var _iteratorError9 = undefined;

					try {
						for (var _iterator9 = schemaItems[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
							var schemaItem = _step9.value;

							if (schemaItem._hasMatchingPath('disallow', path, attribute)) {
								return false;
							}
						}
					} catch (err) {
						_didIteratorError9 = true;
						_iteratorError9 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion9 && _iterator9.return) {
								_iterator9.return();
							}
						} finally {
							if (_didIteratorError9) {
								throw _iteratorError9;
							}
						}
					}
				}

				// At this point, the query is not disallowed.
				// If there are correct allow paths that match the query, this query is valid with schema.
				// Since we are supporting multiple attributes, we have to make sure that if attributes are set,
				// we have allowed paths for all of them.
				// Keep in mind that if the query has no attributes, query.attribute was converted to an array
				// with a single `undefined` value. This fits the algorithm well.
			} catch (err) {
				_didIteratorError7 = true;
				_iteratorError7 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion7 && _iterator7.return) {
						_iterator7.return();
					}
				} finally {
					if (_didIteratorError7) {
						throw _iteratorError7;
					}
				}
			}

			var _iteratorNormalCompletion8 = true;
			var _didIteratorError8 = false;
			var _iteratorError8 = undefined;

			try {
				for (var _iterator8 = query.attributes[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
					var _attribute = _step8.value;

					var matched = false;

					var _iteratorNormalCompletion10 = true;
					var _didIteratorError10 = false;
					var _iteratorError10 = undefined;

					try {
						for (var _iterator10 = schemaItems[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
							var _schemaItem = _step10.value;

							if (_schemaItem._hasMatchingPath('allow', path, _attribute)) {
								matched = true;
								break;
							}
						}

						// The attribute has not been matched, so it is not allowed by any schema item.
						// The query is disallowed.
					} catch (err) {
						_didIteratorError10 = true;
						_iteratorError10 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion10 && _iterator10.return) {
								_iterator10.return();
							}
						} finally {
							if (_didIteratorError10) {
								throw _iteratorError10;
							}
						}
					}

					if (!matched) {
						return false;
					}
				}
			} catch (err) {
				_didIteratorError8 = true;
				_iteratorError8 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion8 && _iterator8.return) {
						_iterator8.return();
					}
				} finally {
					if (_didIteratorError8) {
						throw _iteratorError8;
					}
				}
			}

			return true;
		}

		/**
   * Checks whether there is an item registered under given name in schema.
   *
   * @param itemName
   * @returns {boolean}
   */

	}, {
		key: 'hasItem',
		value: function hasItem(itemName) {
			return this._items.has(itemName);
		}

		/**
   * Registers given item name in schema.
   *
   *		// Register P element that should be treated like all block elements.
   *		schema.registerItem( 'p', '$block' );
   *
   * @param {String} itemName Name to register.
   * @param [isExtending] If set, new item will extend item with given name.
   */

	}, {
		key: 'registerItem',
		value: function registerItem(itemName, isExtending) {
			if (this.hasItem(itemName)) {
				/**
     * Item with specified name already exists in schema.
     *
     * @error model-schema-item-exists
     */
				throw new CKEditorError('model-schema-item-exists: Item with specified name already exists in schema.');
			}

			if (!!isExtending && !this.hasItem(isExtending)) {
				/**
     * Item with specified name does not exist in schema.
     *
     * @error model-schema-no-item
     */
				throw new CKEditorError('model-schema-no-item: Item with specified name does not exist in schema.');
			}

			// Create new SchemaItem and add it to the items store.
			this._items.set(itemName, new SchemaItem(this));

			// Create an extension chain.
			// Extension chain has all item names that should be checked when that item is on path to check.
			// This simply means, that if item is not extending anything, it should have only itself in it's extension chain.
			// Since extending is not dynamic, we can simply get extension chain of extended item and expand it with registered name,
			// if the registered item is extending something.
			var chain = this.hasItem(isExtending) ? this._extensionChains.get(isExtending).concat(itemName) : [itemName];
			this._extensionChains.set(itemName, chain);
		}

		/**
   * Checks whether item of given name is extending item of another given name.
   *
   * @param {String} childItemName Name of the child item.
   * @param {String} parentItemName Name of the parent item.
   * @returns {Boolean} `true` if child item extends parent item, `false` otherwise.
   */

	}, {
		key: 'itemExtends',
		value: function itemExtends(childItemName, parentItemName) {
			if (!this.hasItem(childItemName) || !this.hasItem(parentItemName)) {
				/**
     * Item with specified name does not exist in schema.
     *
     * @error model-schema-no-item
     */
				throw new CKEditorError('model-schema-no-item: Item with specified name does not exist in schema.');
			}

			var chain = this._extensionChains.get(childItemName);

			return chain.some(function (itemName) {
				return itemName == parentItemName;
			});
		}

		/**
   * Returns {@link engine.model.SchemaItem schema item} that was registered in the schema under given name.
   * If item has not been found, throws error.
   *
   * @private
   * @param {String} itemName Name to look for in schema.
   * @returns {engine.model.SchemaItem} Schema item registered under given name.
   */

	}, {
		key: '_getItem',
		value: function _getItem(itemName) {
			if (!this.hasItem(itemName)) {
				/**
     * Item with specified name does not exist in schema.
     *
     * @error model-schema-no-item
     */
				throw new CKEditorError('model-schema-no-item: Item with specified name does not exist in schema.');
			}

			return this._items.get(itemName);
		}

		/**
   * Normalizes a path to an entity by converting it from {@link engine.model.SchemaPath} to an array of strings.
   *
   * @protected
   * @param {engine.model.SchemaPath} path Path to normalize.
   * @returns {Array.<String>} Normalized path.
   */

	}], [{
		key: '_normalizeQueryPath',
		value: function _normalizeQueryPath(path) {
			var normalized = [];

			if (isArray(path)) {
				var _iteratorNormalCompletion11 = true;
				var _didIteratorError11 = false;
				var _iteratorError11 = undefined;

				try {
					for (var _iterator11 = path[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
						var pathItem = _step11.value;

						if (pathItem instanceof Element) {
							normalized.push(pathItem.name);
						} else if (isString(pathItem)) {
							normalized.push(pathItem);
						}
					}
				} catch (err) {
					_didIteratorError11 = true;
					_iteratorError11 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion11 && _iterator11.return) {
							_iterator11.return();
						}
					} finally {
						if (_didIteratorError11) {
							throw _iteratorError11;
						}
					}
				}
			} else if (path instanceof Position) {
				var parent = path.parent;

				while (parent !== null) {
					normalized.push(parent.name);
					parent = parent.parent;
				}

				normalized.reverse();
			} else if (isString(path)) {
				normalized = path.split(' ');
			}

			return normalized;
		}
	}]);
	return Schema;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Delete contents of the selection and merge siblings. The resulting selection is always collapsed.
 *
 * @method engine.model.composer.deleteContents
 * @param {engine.model.Batch} batch Batch to which the deltas will be added.
 * @param {engine.model.Selection} selection Selection of which the content should be deleted.
 * @param {Object} [options]
 * @param {Boolean} [options.merge=false] Merge elements after removing the contents of the selection.
 * For example, `<h>x[x</h><p>y]y</p>` will become: `<h>x^y</h>` with the option enabled
 * and: `<h>x^</h><p>y</p>` without it.
 */
function deleteContents(batch, selection) {
	var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

	if (selection.isCollapsed) {
		return;
	}

	var selRange = selection.getFirstRange();

	var startPos = selRange.start;
	var endPos = LivePosition.createFromPosition(selRange.end);

	// 1. Remove the contents if there are any.
	if (!selRange.isEmpty) {
		batch.remove(selRange);
	}

	// 2. Merge elements in the right branch to the elements in the left branch.
	// The only reasonable (in terms of data and selection correctness) case in which we need to do that is:
	//
	// <heading type=1>Fo[</heading><paragraph>]ar</paragraph> => <heading type=1>Fo^ar</heading>
	//
	// However, the algorithm supports also merging deeper structures (up to the depth of the shallower branch),
	// as it's hard to imagine what should actually be the default behavior. Usually, specific features will
	// want to override that behavior anyway.
	if (options.merge) {
		var endPath = endPos.path;
		var mergeEnd = Math.min(startPos.path.length - 1, endPath.length - 1);
		var mergeDepth = compareArrays(startPos.path, endPath);

		if (typeof mergeDepth == 'number') {
			for (; mergeDepth < mergeEnd; mergeDepth++) {
				var mergePath = startPos.path.slice(0, mergeDepth);
				mergePath.push(startPos.path[mergeDepth] + 1);

				batch.merge(new Position(endPos.root, mergePath));
			}
		}
	}

	selection.collapse(startPos);

	// 3. Autoparagraphing.
	// Check if a text is allowed in the new container. If not, try to create a new paragraph (if it's allowed here).
	if (shouldAutoparagraph(batch.document, startPos)) {
		var paragraph = new Element('paragraph');
		batch.insert(startPos, paragraph);

		selection.collapse(paragraph);
	}

	endPos.detach();
}

function shouldAutoparagraph(doc, position) {
	var isTextAllowed = doc.schema.check({ name: '$text', inside: position });
	var isParagraphAllowed = doc.schema.check({ name: 'paragraph', inside: position });

	return !isTextAllowed && isParagraphAllowed;
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Set of utils to handle unicode characters.
 *
 * @namespace utils.unicode
 */

/**
 * Checks whether given `character` is a combining mark.
 *
 * @param {String} character Character to check.
 * @returns {Boolean}
 */
function isCombiningMark(character) {
  return !!character && character.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(character);
}

/**
 * Checks whether given `character` is a high half of surrogate pair.
 *
 * Using UTF-16 terminology, a surrogate pair denotes UTF-16 character using two UTF-8 characters. The surrogate pair
 * consist of high surrogate pair character followed by low surrogate pair character.
 *
 * @param {String} character Character to check.
 * @returns {Boolean}
 */
function isHighSurrogateHalf(character) {
  return !!character && character.length == 1 && /[\ud800-\udbff]/.test(character);
}

/**
 * Checks whether given `character` is a low half of surrogate pair.
 *
 * Using UTF-16 terminology, a surrogate pair denotes UTF-16 character using two UTF-8 characters. The surrogate pair
 * consist of high surrogate pair character followed by low surrogate pair character.
 *
 * @param {String} character Character to check.
 * @returns {Boolean}
 */
function isLowSurrogateHalf(character) {
  return !!character && character.length == 1 && /[\udc00-\udfff]/.test(character);
}

/**
 * Checks whether given offset in a string is inside a surrogate pair (between two surrogate halves).
 *
 * @param {String} string String to check.
 * @param {Number} offset Offset to check.
 * @returns {Boolean}
 */
function isInsideSurrogatePair(string, offset) {
  return isHighSurrogateHalf(string.charAt(offset - 1)) && isLowSurrogateHalf(string.charAt(offset));
}

/**
 * Checks whether given offset in a string is between base character and combining mark or between two combining marks.
 *
 * @param {String} string String to check.
 * @param {Number} offset Offset to check.
 * @returns {Boolean}
 */
function isInsideCombinedSymbol(string, offset) {
  return isCombiningMark(string.charAt(offset));
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Modifies the selection. Currently the supported modifications are:
 *
 * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.
 * Possible values for `unit` are:
 *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one
 *  character in `String` sense. However, unicode also defines "combing marks". These are special symbols, that combines
 *  with a symbol before it ("base character") to create one user-perceived character. For example, `q̣̇` is a normal
 *  letter `q` with two "combining marks": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending
 *  selection by one position, it is correct to include both "base character" and all of it's "combining marks". That is
 *  why `'character'` value is most natural and common method of modifying selection.
 *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert
 *  selection between "base character" and "combining mark", because "combining marks" have their own unicode code points.
 *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by
 *  two characters, called "surrogate pairs". Halves of "surrogate pairs" have a meaning only when placed next to each other.
 *  For example `𨭎` is represented in `String` by `\uD862\uDF4E`. Both `\uD862` and `\uDF4E` do not have any meaning
 *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection
 *  extension will include whole "surrogate pair".
 *
 * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.
 *
 * @method engine.model.composer.modifySelection
 * @param {engine.model.Selection} selection The selection to modify.
 * @param {Object} [options]
 * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.
 * @param {'character'|'codePoint'} [options.unit='character'] The unit by which selection should be modified.
 */
function modifySelection(selection) {
	var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	var isForward = options.direction != 'backward';
	options.unit = options.unit ? options.unit : 'character';

	var focus = selection.focus;
	var walker = new TreeWalker({
		boundaries: getSearchRange(focus, isForward),
		singleCharacters: true,
		direction: isForward ? 'forward' : 'backward'
	});

	var next = walker.next();

	// 1. Nothing to do here.
	if (next.done) {
		return;
	}

	var value = next.value;

	// 2. Focus is before/after text. Extending by text data.
	if (value.type == 'text') {
		selection.setFocus(getCorrectPosition(walker, options.unit));

		return;
	}

	// 3. Focus is before/after element. Extend by whole element.
	if (value.type == (isForward ? 'elementStart' : 'elementEnd')) {
		selection.setFocus(value.item, isForward ? 'after' : 'before');

		return;
	}

	// 4. If previous scenarios are false, it means that focus is at the beginning/at the end of element and by
	// extending we are "leaving" the element. Let's see what is further.
	next = walker.next();

	// 4.1. Nothing left, so let's stay where we were.
	if (next.done) {
		return;
	}

	value = next.value;

	// 4.2. Text data found after leaving an element end. Put selection before it. This way extension will include
	// "opening" element tag.
	if (value.type == 'text') {
		selection.setFocus(value.previousPosition);
	}
	// 4.3. An element found after leaving previous element. Put focus inside that element, at it's beginning or end.
	else {
			selection.setFocus(value.item, isForward ? 0 : 'end');
		}
}

// Finds a correct position by walking in a text node and checking whether selection can be extended to given position
// or should be extended further.
function getCorrectPosition(walker, unit) {
	var textNode = walker.position.textNode;

	if (textNode) {
		var data = textNode.data;
		var offset = walker.position.offset - textNode.startOffset;

		while (isInsideSurrogatePair(data, offset) || unit == 'character' && isInsideCombinedSymbol(data, offset)) {
			walker.next();

			offset = walker.position.offset - textNode.startOffset;
		}
	}

	return walker.position;
}

function getSearchRange(start, isForward) {
	var root = start.root;
	var searchEnd = Position.createAt(root, isForward ? 'end' : 0);

	if (isForward) {
		return new Range$1(start, searchEnd);
	} else {
		return new Range$1(searchEnd, start);
	}
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Set of frequently used tools to work with a document.
 * The instance of composer is available in {@link engine.model.Document#composer}.
 *
 * By default this class implements only a very basic version of those algorithms. However, all its methods can be extended
 * by features by listening to related events. The default action of those events are implemented
 * by functions available in the {@link engine.model.composer} namespace, so they can be reused
 * in the algorithms implemented by features.
 *
 * @member engine.model.composer
 * @mixes utils.EmitterMixin
 */

var Composer = function () {
	/**
  * Creates an instance of the composer.
  */
	function Composer() {
		classCallCheck(this, Composer);

		this.on('deleteContents', function (evt, data) {
			return deleteContents(data.batch, data.selection, data.options);
		});
		this.on('modifySelection', function (evt, data) {
			return modifySelection(data.selection, data.options);
		});
	}

	/**
  * See {@link engine.model.composer.deleteContents}.
  *
  * Note: For the sake of predictability, the resulting selection should always be collapsed.
  * In cases where a feature wants to modify deleting behavior so selection isn't collapsed
  * (e.g. a table feature may want to keep row selection after pressing <kbd>Backspace</kbd>),
  * then that behavior should be implemented in the view's listener. At the same time, the table feature
  * will need to modify this method's behavior too, e.g. to "delete contents and then collapse
  * the selection inside the last selected cell" or "delete the row and collapse selection somewhere near".
  * That needs to be done in order to ensure that other features which use `deleteContents()` will work well with tables.
  *
  * @fires engine.model.composer.Composer#deleteContents
  * @param {engine.model.Batch} batch Batch to which deltas will be added.
  * @param {engine.model.Selection} selection Selection of which the content should be deleted.
  * @param {Object} options See {@link engine.model.composer.deleteContents}'s options.
  */


	createClass(Composer, [{
		key: 'deleteContents',
		value: function deleteContents(batch, selection, options) {
			this.fire('deleteContents', { batch: batch, selection: selection, options: options });
		}

		/**
   * See {@link engine.model.composer.modifySelection}.
   *
   * @fires engine.model.composer.Composer#modifySelection
   * @param {engine.model.Selection} The selection to modify.
   * @param {Object} options See {@link engine.model.composer.modifySelection}'s options.
   */

	}, {
		key: 'modifySelection',
		value: function modifySelection(selection, options) {
			this.fire('modifySelection', { selection: selection, options: options });
		}
	}]);
	return Composer;
}();

mix(Composer, EmitterMixin);

/**
 * Event fired when {@link engine.model.composer.Composer#deleteContents} method is called.
 * The {@link engine.model.composer.deleteContents default action of the composer} is implemented as a
 * listener to that event so it can be fully customized by the features.
 *
 * @event engine.model.composer.Composer#deleteContents
 * @param {Object} data
 * @param {engine.model.Batch} data.batch
 * @param {engine.model.Selection} data.selection
 * @param {Object} data.options See {@link engine.model.composer.deleteContents}'s options.
 */

/**
 * Event fired when {@link engine.model.composer.Composer#modifySelection} method is called.
 * The {@link engine.model.composer.modifySelection default action of the composer} is implemented as a
 * listener to that event so it can be fully customized by the features.
 *
 * @event engine.model.composer.Composer#modifySelection
 * @param {Object} data
 * @param {engine.model.Selection} data.selection
 * @param {Object} data.options See {@link engine.model.composer.modifySelection}'s options.
 */

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

// Load all basic deltas and transformations, they register themselves, but they need to be imported somewhere.
// jshint ignore:line
// jshint ignore:line

var graveyardName = '$graveyard';

/**
 * Document tree model describes all editable data in the editor. It may contain multiple
 * {@link engine.model.Document#roots root elements}, for example if the editor have multiple editable areas, each area will be
 * represented by the separate root.
 *
 * All changes in the document are done by {@link engine.model.operation.Operation operations}. To create operations in
 * a simple way, use the {@link engine.model.Batch} API, for example:
 *
 *		doc.batch().insert( position, nodes ).split( otherPosition );
 *
 * @see engine.model.Document#batch
 *
 * @memberOf engine.model
 */

var Document = function () {
	/**
  * Creates an empty document instance with no {@link engine.model.Document#roots} (other than
  * a {@link engine.model.Document#graveyard graveyard root}).
  */
	function Document() {
		var _this = this;

		classCallCheck(this, Document);

		/**
   * Document version. It starts from `0` and every operation increases the version number. It is used to ensure that
   * operations are applied on the proper document version. If the {@link engine.model.operation.Operation#baseVersion} will
   * not match document version the {@link document-applyOperation-wrong-version} error is thrown.
   *
   * @readonly
   * @member {Number} engine.model.Document#version
   */
		this.version = 0;

		/**
   * Selection done on this document.
   *
   * @readonly
   * @member {engine.model.LiveSelection} engine.model.Document#selection
   */
		this.selection = new LiveSelection(this);

		/**
   * Schema for this document.
   *
   * @member {engine.model.Schema} engine.model.Document#schema
   */
		this.schema = new Schema();

		/**
   * Document's history.
   *
   * **Note:** Be aware that deltas applied to the stored deltas might be removed or changed.
   *
   * @readonly
   * @member {engine.model.History} engine.model.Document#history
   */
		this.history = new History(this);

		/**
   * Composer for this document. Set of tools to work with the document.
   *
   * The features can tune up these tools to better work on their specific cases.
   *
   * @member {engine.model.composer.Composer} engine.model.Document#composer
   */
		this.composer = new Composer();

		/**
   * Array of pending changes. See: {@link engine.model.Document#enqueueChanges}.
   *
   * @private
   * @member {Array.<Function>} engine.model.Document#_pendingChanges
   */
		this._pendingChanges = [];

		/**
   * List of roots that are owned and managed by this document. Use {@link engine.model.document#createRoot} and
   * {@link engine.model.document#getRoot} to manipulate it.
   *
   * @readonly
   * @protected
   * @member {Map} engine.model.Document#roots
   */
		this._roots = new Map();

		// Add events that will ensure selection correctness.
		this.selection.on('change:range', function () {
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = _this.selection.getRanges()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var range = _step.value;

					if (!_this._validateSelectionRange(range)) {
						/**
       * Range from document selection starts or ends at incorrect position.
       *
       * @error document-selection-wrong-position
       * @param {engine.model.Range} range
       */
						throw new CKEditorError('document-selection-wrong-position: ' + 'Range from document selection starts or ends at incorrect position.', { range: range });
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		});

		// Graveyard tree root. Document always have a graveyard root, which stores removed nodes.
		this.createRoot('$root', graveyardName);
	}

	/**
  * Graveyard tree root. Document always have a graveyard root, which stores removed nodes.
  *
  * @readonly
  * @type {engine.model.RootElement}
  */


	createClass(Document, [{
		key: 'applyOperation',


		/**
   * This is the entry point for all document changes. All changes on the document are done using
   * {@link engine.model.operation.Operation operations}. To create operations in the simple way use the
   * {@link engine.model.Batch} API available via {@link engine.model.Document#batch} method.
   *
   * @fires @link engine.model.Document#change
   * @param {engine.model.operation.Operation} operation Operation to be applied.
   */
		value: function applyOperation(operation) {
			if (operation.baseVersion !== this.version) {
				/**
     * Only operations with matching versions can be applied.
     *
     * @error document-applyOperation-wrong-version
     * @param {engine.model.operation.Operation} operation
     */
				throw new CKEditorError('model-document-applyOperation-wrong-version: Only operations with matching versions can be applied.', { operation: operation });
			}

			var changes = operation._execute();

			this.version++;

			this.history.addDelta(operation.delta);

			var batch = operation.delta && operation.delta.batch;

			if (changes) {
				// `NoOperation` returns no changes, do not fire event for it.
				this.fire('change', operation.type, changes, batch);
			}
		}

		/**
   * Creates a {@link engine.model.Batch} instance which allows to change the document.
   *
   * @param {String} [type] Batch type. See {@link engine.model.Batch#type}.
   * @returns {engine.model.Batch} Batch instance.
   */

	}, {
		key: 'batch',
		value: function batch(type) {
			return new Batch(this, type);
		}

		/**
   * Creates a new top-level root.
   *
   * @param {String} [elementName='$root'] Element name. Defaults to `'$root'` which also have
   * some basic schema defined (`$block`s are allowed inside the `$root`). Make sure to define a proper
   * schema if you use a different name.
   * @param {String} [rootName='main'] Unique root name.
   * @returns {engine.model.RootElement} Created root.
   */

	}, {
		key: 'createRoot',
		value: function createRoot() {
			var elementName = arguments.length <= 0 || arguments[0] === undefined ? '$root' : arguments[0];
			var rootName = arguments.length <= 1 || arguments[1] === undefined ? 'main' : arguments[1];

			if (this._roots.has(rootName)) {
				/**
     * Root with specified name already exists.
     *
     * @error document-createRoot-name-exists
     * @param {engine.model.Document} doc
     * @param {String} name
     */
				throw new CKEditorError('model-document-createRoot-name-exists: Root with specified name already exists.', { name: rootName });
			}

			var root = new RootElement(this, elementName, rootName);
			this._roots.set(rootName, root);

			return root;
		}

		/**
   * Removes all events listeners set by document instance.
   */

	}, {
		key: 'destroy',
		value: function destroy() {
			this.selection.destroy();
			this.stopListening();
		}

		/**
   * Enqueues document changes. Any changes to be done on document (mostly using {@link engine.model.Document#batch}
   * should be placed in the queued callback. If no other plugin is changing document at the moment, the callback will be
   * called immediately. Otherwise it will wait for all previously queued changes to finish happening. This way
   * queued callback will not interrupt other callbacks.
   *
   * When all queued changes are done {@link engine.model.Document#changesDone} event is fired.
   *
   * @fires @link engine.model.Document#changesDone
   * @param {Function} callback Callback to enqueue.
   */

	}, {
		key: 'enqueueChanges',
		value: function enqueueChanges(callback) {
			this._pendingChanges.push(callback);

			if (this._pendingChanges.length == 1) {
				while (this._pendingChanges.length) {
					this._pendingChanges[0]();
					this._pendingChanges.shift();
				}

				this.fire('changesDone');
			}
		}

		/**
   * Returns top-level root by its name.
   *
   * @param {String} [name='main'] Unique root name.
   * @returns {engine.model.RootElement} Root registered under given name.
   */

	}, {
		key: 'getRoot',
		value: function getRoot() {
			var name = arguments.length <= 0 || arguments[0] === undefined ? 'main' : arguments[0];

			if (!this._roots.has(name)) {
				/**
     * Root with specified name does not exist.
     *
     * @error document-getRoot-root-not-exist
     * @param {String} name
     */
				throw new CKEditorError('model-document-getRoot-root-not-exist: Root with specified name does not exist.', { name: name });
			}

			return this._roots.get(name);
		}

		/**
   * Checks if root with given name is defined.
   *
   * @param {String} name Name of root to check.
   * @returns {Boolean}
   */

	}, {
		key: 'hasRoot',
		value: function hasRoot(name) {
			return this._roots.has(name);
		}

		/**
   * Returns array with names of all roots (without the {@link engine.model.Document#graveyard}) added to the document.
   *
   * @returns {Array.<String>} Roots names.
   */

	}, {
		key: 'getRootNames',
		value: function getRootNames() {
			return Array.from(this._roots.keys()).filter(function (name) {
				return name != graveyardName;
			});
		}

		/**
   * Custom toJSON method to solve child-parent circular dependencies.
   *
   * @returns {Object} Clone of this object with the document property changed to string.
   */

	}, {
		key: 'toJSON',
		value: function toJSON() {
			var json = clone(this);

			// Due to circular references we need to remove parent reference.
			json.selection = '[engine.model.LiveSelection]';

			return json;
		}

		/**
   * Returns default root for this document which is either the first root that was added to the the document using
   * {@link engine.model.Document#createRoot} or the {@link engine.model.Document#graveyard graveyard root} if
   * no other roots were created.
   *
   * @protected
   * @returns {engine.model.RootElement} The default root for this document.
   */

	}, {
		key: '_getDefaultRoot',
		value: function _getDefaultRoot() {
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = this._roots.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var root = _step2.value;

					if (root !== this.graveyard) {
						return root;
					}
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			return this.graveyard;
		}

		/**
   * Returns a default range for this selection. The default range is a collapsed range that starts and ends
   * at the beginning of this selection's document's {@link engine.model.Document#_getDefaultRoot default root}.
   *
   * @protected
   * @returns {engine.model.Range}
   */

	}, {
		key: '_getDefaultRange',
		value: function _getDefaultRange() {
			var defaultRoot = this._getDefaultRoot();

			// Find the first position where the selection can be put.
			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = Range$1.createIn(defaultRoot).getPositions()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var _position = _step3.value;

					if (this.schema.check({ name: '$text', inside: _position })) {
						return new Range$1(_position, _position);
					}
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}

			var position = new Position(defaultRoot, [0]);

			return new Range$1(position, position);
		}

		/**
   * Checks whether given {@link engine.model.Range range} is a valid range for
   * {@link engine.model.Document#selection document's selection}.
   *
   * @private
   * @param {engine.model.Range} range Range to check.
   * @returns {Boolean} `true` if `range` is valid, `false` otherwise.
   */

	}, {
		key: '_validateSelectionRange',
		value: function _validateSelectionRange(range) {
			return validateTextNodePosition(range.start) && validateTextNodePosition(range.end);
		}

		/**
   * Fired when document changes by applying an operation.
   *
   * There are 5 types of change:
   *
   * * 'insert' when nodes are inserted,
   * * 'remove' when nodes are removed,
   * * 'reinsert' when remove is undone,
   * * 'move' when nodes are moved,
   * * 'addAttribute' when attributes are added,
   * * 'removeAttribute' when attributes are removed,
   * * 'changeAttribute' when attributes change,
   * * 'addRootAttribute' when attribute for root is added,
   * * 'removeRootAttribute' when attribute for root is removed,
   * * 'changeRootAttribute' when attribute for root changes.
   *
   * @event engine.model.Document#change
   * @param {String} type Change type, possible option: 'insert', 'remove', 'reinsert', 'move', 'attribute'.
   * @param {Object} data Additional information about the change.
   * @param {engine.model.Range} data.range Range in model containing changed nodes. Note that the range state is
   * after changes has been done, i.e. for 'remove' the range will be in the {@link engine.model.Document#graveyard graveyard root}.
   * This is `undefined` for "...root..." types.
   * @param {engine.model.Position} [data.sourcePosition] Change source position. Exists for 'remove', 'reinsert' and 'move'.
   * Note that this position state is before changes has been done, i.e. for 'reinsert' the source position will be in the
   * {@link engine.model.Document#graveyard graveyard root}.
   * @param {String} [data.key] Only for attribute types. Key of changed / inserted / removed attribute.
   * @param {*} [data.oldValue] Only for 'removeAttribute', 'removeRootAttribute', 'changeAttribute' or
   * 'changeRootAttribute' type.
   * @param {*} [data.newValue] Only for 'addAttribute', 'addRootAttribute', 'changeAttribute' or
   * 'changeRootAttribute' type.
   * @param {engine.model.RootElement} [changeInfo.root] Root element which attributes got changed. This is defined
   * only for root types.
   * @param {engine.model.Batch} batch A {@link engine.model.Batch batch} of changes which this change is a part of.
   */

		/**
   * Fired when all queued document changes are done. See {@link engine.model.Document#enqueueChanges}.
   *
   * @event engine.model.Document#changesDone
   */

	}, {
		key: 'graveyard',
		get: function get() {
			return this.getRoot(graveyardName);
		}
	}]);
	return Document;
}();

mix(Document, EmitterMixin);

// Checks whether given range boundary position is valid for document selection, meaning that is not between
// unicode surrogate pairs or base character and combining marks.
function validateTextNodePosition(rangeBoundary) {
	var textNode = rangeBoundary.textNode;

	if (textNode) {
		var data = textNode.data;
		var offset = rangeBoundary.offset - textNode.startOffset;

		return !isInsideSurrogatePair(data, offset) && !isInsideCombinedSymbol(data, offset);
	}

	return true;
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Mixin that injects the DOM events API into its host. It provides the API
 * compatible with {@link utils.EmitterMixin}.
 *
 * DOM emitter mixin is by default available in the {@link ui.View} class,
 * but it can also be mixed into any other class:
 *
 *		import mix from '../utils/mix.js';
 *		import DOMEmitterMixin from '../ui/domemittermixin.js';
 *
 *		class SomeView {}
 *		mix( SomeView, DOMEmitterMixin );
 *
 *		const view = new SomeView();
 *		view.listenTo( domElement, ( evt, domEvt ) => {
 *			console.log( evt, domEvt );
 *		} );
 *
 * @mixin ui.DOMEmitterMixin
 * @mixes utils.EmitterMixin
 * @implements ui.DOMEmitter
 */
var DOMEmitterMixin = assignIn({}, EmitterMixin, {
	/**
  * Registers a callback function to be executed when an event is fired in a specific Emitter or DOM Node.
  * It is backwards compatible with {@link utils.EmitterMixin#listenTo}.
  *
  * @param {utils.Emitter|Node} emitter The object that fires the event.
  * @param {String} event The name of the event.
  * @param {Function} callback The function to be called on event.
  * @param {Object} [options={}] Additional options.
  * @param {utils.PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher
  * the priority value the sooner the callback will be fired. Events having the same priority are called in the
  * order they were added.
  * @param {Object} [options.context] The object that represents `this` in the callback. Defaults to the object firing the event.
  * @param {Boolean} [options.useCapture=false] Indicates that events of this type will be dispatched to the registered
  * listener before being dispatched to any EventTarget beneath it in the DOM tree.
  *
  * @method ui.DOMEmitterMixin#listenTo
  */
	listenTo: function listenTo() {
		var args = Array.prototype.slice.call(arguments);
		var emitter = args[0];

		// Check if emitter is an instance of DOM Node. If so, replace the argument with
		// corresponding ProxyEmitter (or create one if not existing).
		if (isDomNode(emitter)) {
			args[0] = this._getProxyEmitter(emitter) || new ProxyEmitter(emitter);
		}

		// Execute parent class method with Emitter (or ProxyEmitter) instance.
		EmitterMixin.listenTo.apply(this, args);
	},


	/**
  * Stops listening for events. It can be used at different levels:
  * It is backwards compatible with {@link utils.EmitterMixin#listenTo}.
  *
  * * To stop listening to a specific callback.
  * * To stop listening to a specific event.
  * * To stop listening to all events fired by a specific object.
  * * To stop listening to all events fired by all object.
  *
  * @param {utils.Emitter|Node} [emitter] The object to stop listening to. If omitted, stops it for all objects.
  * @param {String} [event] (Requires the `emitter`) The name of the event to stop listening to. If omitted, stops it
  * for all events from `emitter`.
  * @param {Function} [callback] (Requires the `event`) The function to be removed from the call list for the given
  * `event`.
  *
  * @method ui.DOMEmitterMixin#stopListening
  */
	stopListening: function stopListening() {
		var args = Array.prototype.slice.call(arguments);
		var emitter = args[0];

		// Check if emitter is an instance of DOM Node. If so, replace the argument with corresponding ProxyEmitter.
		if (isDomNode(emitter)) {
			var proxy = this._getProxyEmitter(emitter);

			// Element has no listeners.
			if (!proxy) {
				return;
			}

			args[0] = proxy;
		}

		// Execute parent class method with Emitter (or ProxyEmitter) instance.
		EmitterMixin.stopListening.apply(this, args);
	},


	/**
  * Retrieves ProxyEmitter instance for given DOM Node residing in this Host.
  *
  * @param {Node} node DOM Node of the ProxyEmitter.
  * @method ui.DOMEmitterMixin#_getProxyEmitter
  * @return {ProxyEmitter} ProxyEmitter instance or null.
  */
	_getProxyEmitter: function _getProxyEmitter(node) {
		var proxy = void 0,
		    emitters = void 0,
		    emitterInfo = void 0;

		// Get node UID. It allows finding Proxy Emitter for this DOM Node.
		var uid = getNodeUID(node);

		// Find existing Proxy Emitter for this DOM Node among emitters.
		if (emitters = this._listeningTo) {
			if (emitterInfo = emitters[uid]) {
				proxy = emitterInfo.emitter;
			}
		}

		return proxy || null;
	}
});

/**
 * Creates a ProxyEmitter instance. Such an instance is a bridge between a DOM Node firing events
 * and any Host listening to them. It is backwards compatible with {@link utils.EmitterMixin#on}.
 *
 *                                  listenTo( click, ... )
 *                    +-----------------------------------------+
 *                    |              stopListening( ... )       |
 *     +----------------------------+                           |             addEventListener( click, ... )
 *     | Host                       |                           |   +---------------------------------------------+
 *     +----------------------------+                           |   |       removeEventListener( click, ... )     |
 *     | _listeningTo: {            |                +----------v-------------+                                   |
 *     |   UID: {                   |                | ProxyEmitter           |                                   |
 *     |     emitter: ProxyEmitter, |                +------------------------+                      +------------v----------+
 *     |     callbacks: {           |                | events: {              |                      | Node (HTMLElement)    |
 *     |       click: [ callbacks ] |                |   click: [ callbacks ] |                      +-----------------------+
 *     |     }                      |                | },                     |                      | data-cke-expando: UID |
 *     |   }                        |                | _domNode: Node,        |                      +-----------------------+
 *     | }                          |                | _domListeners: {},     |                                   |
 *     | +------------------------+ |                | _emitterId: UID        |                                   |
 *     | | DOMEmitterMixin        | |                +--------------^---------+                                   |
 *     | +------------------------+ |                           |   |                                             |
 *     +--------------^-------------+                           |   +---------------------------------------------+
 *                    |                                         |                  click (DOM Event)
 *                    +-----------------------------------------+
 *                                fire( click, DOM Event )
 *
 * @memberOf ui
 * @mixes utils.EmitterMixin
 * @implements ui.DOMEmitter
 */

var ProxyEmitter =
/**
 * @param {Node} node DOM Node that fires events.
 * @returns {Object} ProxyEmitter instance bound to the DOM Node.
 */
function ProxyEmitter(node) {
	classCallCheck(this, ProxyEmitter);

	// Set emitter ID to match DOM Node "expando" property.
	this._emitterId = getNodeUID(node);

	// Remember the DOM Node this ProxyEmitter is bound to.
	this._domNode = node;
};

assignIn(ProxyEmitter.prototype, EmitterMixin, {
	/**
  * Collection of native DOM listeners.
  *
  * @private
  * @member {Object} ui.ProxyEmitter#_domListeners
  */

	/**
  * Registers a callback function to be executed when an event is fired.
  *
  * It attaches a native DOM listener to the DOM Node. When fired,
  * a corresponding Emitter event will also fire with DOM Event object as an argument.
  *
  * @param {String} event The name of the event.
  * @param {Function} callback The function to be called on event.
  * @param {Object} [options={}] Additional options.
  * @param {utils.PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher
  * the priority value the sooner the callback will be fired. Events having the same priority are called in the
  * order they were added.
  * @param {Object} [options.context] The object that represents `this` in the callback. Defaults to the object firing the event.
  * @param {Boolean} [options.useCapture=false] Indicates that events of this type will be dispatched to the registered
  * listener before being dispatched to any EventTarget beneath it in the DOM tree.
  *
  * @method ui.ProxyEmitter#on
  */
	on: function on(event, callback) {
		var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

		// Execute parent class method first.
		EmitterMixin.on.apply(this, arguments);

		// If the DOM Listener for given event already exist it is pointless
		// to attach another one.
		if (this._domListeners && this._domListeners[event]) {
			return;
		}

		var domListener = this._createDomListener(event);

		// Attach the native DOM listener to DOM Node.
		this._domNode.addEventListener(event, domListener, !!options.useCapture);

		if (!this._domListeners) {
			this._domListeners = {};
		}

		// Store the native DOM listener in this ProxyEmitter. It will be helpful
		// when stopping listening to the event.
		this._domListeners[event] = domListener;
	},


	/**
  * Stops executing the callback on the given event.
  *
  * @param {String} event The name of the event.
  * @param {Function} callback The function to stop being called.
  * @param {Object} [context] The context object to be removed, pared with the given callback. To handle cases where
  * the same callback is used several times with different contexts.
  *
  * @method ui.ProxyEmitter#off
  */
	off: function off(event) {
		// Execute parent class method first.
		EmitterMixin.off.apply(this, arguments);

		var events = void 0;

		// Remove native DOM listeners which are orphans. If no callbacks
		// are awaiting given event, detach native DOM listener from DOM Node.
		// See: {@link on}.

		if (this._domListeners[event] && (!(events = this._events[event]) || !events.callbacks.length)) {
			this._domListeners[event].removeListener();
		}
	},


	/**
  * Create a native DOM listener callback. When the native DOM event
  * is fired it will fire corresponding event on this ProxyEmitter.
  * Note: A native DOM Event is passed as an argument.
  *
  * @param {String} event
  *
  * @method ui.ProxyEmitter#_createDomListener
  * @returns {Function} The DOM listener callback.
  */
	_createDomListener: function _createDomListener(event) {
		var _this = this;

		var domListener = function domListener(domEvt) {
			_this.fire(event, domEvt);
		};

		// Supply the DOM listener callback with a function that will help
		// detach it from the DOM Node, when it is no longer necessary.
		// See: {@link off}.
		domListener.removeListener = function () {
			_this._domNode.removeEventListener(event, domListener);
			delete _this._domListeners[event];
		};

		return domListener;
	}
});

// Gets an unique DOM Node identifier. The identifier will be set if not defined.
//
// @private
// @param {Node} node
// @return {Number} UID for given DOM Node.
function getNodeUID(node) {
	return node['data-ck-expando'] || (node['data-ck-expando'] = uid());
}

// Checks (naively) if given node is native DOM Node.
//
// @private
// @param {Node} node
// @return {Boolean} True when native DOM Node.
function isDomNode(node) {
	return node && isNative(node.addEventListener);
}

/**
 * Interface representing classes which mix in {@link ui.DOMEmitter}.
 *
 * @interface ui.DOMEmitter
 */

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* global setTimeout, clearTimeout */

/**
 * Allows observing a group of `HTMLElement`s whether at least one of them is focused.
 *
 * Used by the {@link core.Editor} in order to track whether the focus is still within the application,
 * or were used outside of its UI.
 *
 * **Note** `focus` and `blur` listeners use event capturing, so it is only needed to register wrapper `HTMLElement`
 * which contain other `focusable` elements. But note that this wrapper element has to be focusable too
 * (have e.g. `tabindex="-1"`).
 *
 * @memberOf utils
 * @mixes utils.DOMEmitterMixin
 * @mixes utils.ObservableMixin
 */

var FocusTracker = function () {
	function FocusTracker() {
		classCallCheck(this, FocusTracker);

		/**
   * True when one of the registered elements is focused.
   *
   * @readonly
   * @observable
   * @member {Boolean} utils.FocusTracker#isFocused
   */
		this.set('isFocused', false);

		/**
   * List of registered elements.
   *
   * @private
   * @member {Set<HTMLElement>} utils.FocusTracker#_elements
   */
		this._elements = new Set();

		/**
   * Event loop timeout.
   *
   * @private
   * @member {Number} utils.FocusTracker#_nextEventLoopTimeout
   */
		this._nextEventLoopTimeout = null;

		/**
   * Currently focused element.
   *
   * @private
   * @member {HTMLElement} utils.FocusTracker#_focusedElement
   */
		this._focusedElement = null;
	}

	/**
  * Starts tracking the specified element.
  *
  * @param {HTMLElement} element
  */


	createClass(FocusTracker, [{
		key: 'add',
		value: function add(element) {
			var _this = this;

			if (this._elements.has(element)) {
				throw new CKEditorError('focusTracker-add-element-already-exist');
			}

			this.listenTo(element, 'focus', function () {
				return _this._focus(element);
			}, { useCapture: true });
			this.listenTo(element, 'blur', function () {
				return _this._blur();
			}, { useCapture: true });
			this._elements.add(element);
		}

		/**
   * Stops tracking the specified element and stops listening on this element.
   *
   * @param {HTMLElement} element
   */

	}, {
		key: 'remove',
		value: function remove(element) {
			if (element === this._focusedElement) {
				this._blur(element);
			}

			if (this._elements.has(element)) {
				this.stopListening(element);
				this._elements.delete(element);
			}
		}

		/**
   * Stores currently focused element and set {utils.FocusTracker#isFocused} as `true`.
   *
   * @private
   * @param {HTMLElement} element Element which has been focused.
   */

	}, {
		key: '_focus',
		value: function _focus(element) {
			clearTimeout(this._nextEventLoopTimeout);

			this._focusedElement = element;
			this.isFocused = true;
		}

		/**
   * Clears currently focused element and set {utils.FocusTracker#isFocused} as `false`.
   * This method uses `setTimeout` to change order of fires `blur` and `focus` events.
   *
   * @private
   * @fires utils.FocusTracker#blur
   */

	}, {
		key: '_blur',
		value: function _blur() {
			var _this2 = this;

			this._nextEventLoopTimeout = setTimeout(function () {
				_this2._focusedElement = null;
				_this2.isFocused = false;
			}, 0);
		}
	}]);
	return FocusTracker;
}();

mix(FocusTracker, DOMEmitterMixin);
mix(FocusTracker, ObservableMixin);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Class representing a basic editor. It contains a base architecture, without much additional logic.
 *
 * See also {@link core.editor.StandardEditor}.
 *
 * @memberOf core.editor
 * @mixes utils.EmitterMixin
 */

var Editor = function () {
	/**
  * Creates a new instance of the Editor class.
  *
  * @param {Object} config The editor config.
  */
	function Editor(config) {
		classCallCheck(this, Editor);

		/**
   * Holds all configurations specific to this editor instance.
   *
   * @readonly
   * @member {utils.Config} core.editor.Editor#config
   */
		this.config = new Config(config);

		/**
   * The plugins loaded and in use by this editor instance.
   *
   * @readonly
   * @member {core.PluginCollection} core.editor.Editor#plugins
   */
		this.plugins = new PluginCollection(this);

		/**
   * Commands registered to the editor.
   *
   * @readonly
   * @member {Map.<core.command.Command>} core.editor.Editor#commands
   */
		this.commands = new Map();

		/**
   * @readonly
   * @member {utils.Locale} core.editor.Editor#locale
   */
		this.locale = new Locale(this.config.get('lang'));

		/**
   * Shorthand for {@link utils.Locale#t}.
   *
   * @see utils.Locale#t
   * @method core.editor.Editor#t
   */
		this.t = this.locale.t;

		/**
   * Tree Model document managed by this editor.
   *
   * @readonly
   * @member {engine.model.Document} core.editor.Editor#document
   */
		this.document = new Document();

		/**
   * Instance of the {@link engine.controller.DataController data controller}.
   *
   * @readonly
   * @member {engine.controller.DataController} core.editor.Editor#data
   */
		this.data = new DataController(this.document);

		/**
   * Keeps information about editor focus.
   *
   * @member {utils.FocusTracker} core.editor.Editor#focusTracker
   */
		this.focusTracker = new FocusTracker();

		/**
   * Instance of the {@link engine.controller.EditingController editing controller}.
   *
   * This property is set by more specialized editor classes (such as {@link core.editor.StandardEditor}),
   * however, it's required for features to work as their engine-related parts will try to connect converters.
   *
   * When defining a virtual editor class, like one working in Node.js, it's possible to plug a virtual
   * editing controller which only instantiates necessary properties, but without any observers and listeners.
   *
   * @readonly
   * @member {engine.controller.EditingController} core.editor.Editor#editing
   */
	}

	/**
  * Loads and initializes plugins specified in config features.
  *
  * @returns {Promise} A promise which resolves once the initialization is completed.
  */


	createClass(Editor, [{
		key: 'initPlugins',
		value: function initPlugins() {
			var that = this;
			var config = this.config;

			return loadPlugins().then(initPlugins);

			function loadPlugins() {
				var plugins = config.get('features') || [];

				return that.plugins.load(plugins);
			}

			function initPlugins(loadedPlugins) {
				return loadedPlugins.reduce(function (promise, plugin) {
					return promise.then(plugin.init.bind(plugin));
				}, Promise.resolve());
			}
		}

		/**
   * Destroys the editor instance, releasing all resources used by it.
   *
   * @fires core.editor.Editor#destroy
   * @returns {Promise} A promise that resolves once the editor instance is fully destroyed.
   */

	}, {
		key: 'destroy',
		value: function destroy() {
			var _this = this;

			this.fire('destroy');
			this.stopListening();

			return Promise.resolve().then(function () {
				_this.document.destroy();
				_this.data.destroy();
			});
		}

		/**
   * Executes specified command with given parameter.
   *
   * @param {String} commandName Name of command to execute.
   * @param {*} [commandParam] If set, command will be executed with this parameter.
   */

	}, {
		key: 'execute',
		value: function execute(commandName, commandParam) {
			var command = this.commands.get(commandName);

			if (!command) {
				/**
     * Specified command has not been added to the editor.
     *
     * @error editor-command-not-found
     */
				throw new CKEditorError('editor-command-not-found: Specified command has not been added to the editor.');
			}

			command._execute(commandParam);
		}

		/**
   * Creates a basic editor instance.
   *
   * @param {Object} config See {@link core.editor.StandardEditor}'s param.
   * @returns {Promise} Promise resolved once editor is ready.
   * @returns {core.editor.StandardEditor} return.editor The editor instance.
   */

	}], [{
		key: 'create',
		value: function create(config) {
			var _this2 = this;

			return new Promise(function (resolve) {
				var editor = new _this2(config);

				resolve(editor.initPlugins().then(function () {
					return editor;
				}));
			});
		}
	}]);
	return Editor;
}();

mix(Editor, EmitterMixin);

/**
 * Fired when this editor instance is destroyed. The editor at this point is not usable and this event should be used to
 * perform the clean-up in any plugin.
 *
 * @event core.editor.Editor#destroy
 */

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* globals navigator:false */

var userAgent = navigator.userAgent.toLowerCase();

/**
 * A namespace containing environment and browser information.
 *
 * @namespace utils.env
 */
var env = {
  /**
   * Indicates that application is running on Macintosh.
   *
   * @member {Boolean} utils.env.mac
   */
  mac: isMac(userAgent)
};

/**
 * Checks if User Agent represented by the string is running on Macintosh.
 *
 * @function utils.env.isMac
 * @param {String} userAgent **Lowercase** `navigator.userAgent` string.
 * @returns {Boolean} Whether User Agent is running on Macintosh or not.
 */
function isMac(userAgent) {
  return userAgent.indexOf('macintosh') > -1;
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Set of utils related to keyboard support.
 *
 * @namespace utils.keyboard
 */

/**
 * Object with `keyName => keyCode` pairs for a set of known keys.
 *
 * Contains:
 *
 * * `a-z`,
 * * `0-9`,
 * * `arrow(left|up|right|bottom)`,
 * * `backspace`, `delete`, `enter`, `esc`, `tab`,
 * * `ctrl`, `cmd`, `shift`, `alt`.
 *
 * @member {Object} utils.keyboard.keyCodes
 */
var keyCodes = generateKnownKeyCodes();

/**
 * Converts a key name or a {@link utils.keyboard.KeystrokeInfo keystroke info} into a key code.
 *
 * Note: Key names are matched with {@link utils.keyboard.keyCodes} in a case-insensitive way.
 *
 * @method utils.keyboard.getCode
 * @param {String|utils.keyboard.KeystrokeInfo} Key name (see {@link utils.keyboard.keyCodes})
 * or a keystroke data object.
 * @returns {Number} Key or keystroke code.
 */
function getCode(key) {
  var keyCode = void 0;

  if (typeof key == 'string') {
    keyCode = keyCodes[key.toLowerCase()];

    if (!keyCode) {
      /**
       * Unknown key name. Only key names contained by the {@link utils.keyboard.keyCodes} can be used.
       *
       * @errror keyboard-unknown-key
       * @param {String} key
       */
      throw new CKEditorError('keyboard-unknown-key: Unknown key name.', { key: key });
    }
  } else {
    keyCode = key.keyCode + (key.altKey ? keyCodes.alt : 0) + (key.ctrlKey ? keyCodes.ctrl : 0) + (key.shiftKey ? keyCodes.shift : 0);
  }

  return keyCode;
}

/**
 * Parses keystroke and returns a keystroke code that will match the code returned by
 * link {@link utils.keyboard.getCode} for a corresponding {@link utils.keyboard.KeystrokeInfo keystroke info}.
 *
 * The keystroke can be passed in two formats:
 *
 * * as a single string – e.g. `ctrl + A`,
 * * as an array of {@link utils.keyboard.keyCodes known key names} and key codes – e.g.:
 *   * `[ 'ctrl', 32 ]` (ctrl + space),
 *   * `[ 'ctrl', 'a' ]` (ctrl + A).
 *
 * Note: Key names are matched with {@link utils.keyboard.keyCodes} in a case-insensitive way.
 *
 * Note: Only keystrokes with a single non-modifier key are supported (e.g. `ctrl+A` is OK, but `ctrl+A+B` is not).
 *
 * @method utils.keyboard.parseKeystroke
 * @param {String|Array.<Number|String>} keystroke Keystroke definition.
 * @returns {Number} Keystroke code.
 */
function parseKeystroke(keystroke) {
  if (typeof keystroke == 'string') {
    keystroke = splitKeystrokeText(keystroke);
  }

  return keystroke.map(function (key) {
    return typeof key == 'string' ? getCode(key) : key;
  }).reduce(function (key, sum) {
    return sum + key;
  }, 0);
}

/**
 * It translates any keystroke string text like `"CTRL+A"` to an
 * environment–specific keystroke, i.e. `"⌘A"` on Mac OSX.
 *
 * @method utils.keyboard.getEnvKeystrokeText
 * @param {String} keystroke Keystroke text.
 * @returns {String} Keystroke text specific for the environment.
 */
function getEnvKeystrokeText(keystroke) {
  var split = splitKeystrokeText(keystroke);

  if (env.mac) {
    if (split[0].toLowerCase() == 'ctrl') {
      return '⌘' + (split[1] || '');
    }
  }

  return keystroke;
}

function generateKnownKeyCodes() {
  var keyCodes = {
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    backspace: 8,
    delete: 46,
    enter: 13,
    esc: 27,
    tab: 9,

    // The idea about these numbers is that they do not collide with any real key codes, so we can use them
    // like bit masks.
    ctrl: 0x110000,
    // Has the same code as ctrl, because their behaviour should be unified across the editor.
    // See http://ckeditor.github.io/editor-recommendations/general-policies#ctrl-vs-cmd
    cmd: 0x110000,
    shift: 0x220000,
    alt: 0x440000
  };

  // a-z
  for (var code = 65; code <= 90; code++) {
    var letter = String.fromCharCode(code);

    keyCodes[letter.toLowerCase()] = code;
  }

  // 0-9
  for (var _code = 48; _code <= 57; _code++) {
    keyCodes[_code - 48] = _code;
  }

  return keyCodes;
}

function splitKeystrokeText(keystroke) {
  return keystroke.split(/\s*\+\s*/);
}

/**
 * Information about a keystroke.
 *
 * @interface utils.keyboard.KeystrokeInfo
 */

/**
 * The [key code](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode).
 *
 * @member {Number} utils.keyboard.KeystrokeInfo#keyCode
 */

/**
 * Whether the <kbd>Alt</kbd> modifier was pressed.
 *
 * @member {Bolean} utils.keyboard.KeystrokeInfo#altKey
 */

/**
 * Whether the <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> modifier was pressed.
 *
 * @member {Bolean} utils.keyboard.KeystrokeInfo#ctrlKey
 */

/**
 * Whether the <kbd>Shift</kbd> modifier was pressed.
 *
 * @member {Bolean} utils.keyboard.KeystrokeInfo#shiftKey
 */

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Keystroke handler. Its instance is available in {@link core.editor.Editor#keystrokes} so features
 * can register their keystrokes.
 *
 * E.g. an undo feature would do this:
 *
 *		editor.keystrokes.set( 'ctrl + Z', 'undo' );
 *		editor.keystrokes.set( 'ctrl + shift + Z', 'redo' );
 *		editor.keystrokes.set( 'ctrl + Y', 'redo' );
 *
 * @memberOf core
 */

var KeystrokeHandler = function () {
	/**
  * Creates an instance of the keystroke handler.
  *
  * @param {engine.treeView.TreeView} editingView
  */
	function KeystrokeHandler(editor) {
		var _this = this;

		classCallCheck(this, KeystrokeHandler);

		/**
   * The editor instance.
   *
   * @readonly
   * @member {core.editor.Editor} core.KeystrokeHandler#editor
   */
		this.editor = editor;

		/**
   * Listener used to listen to events for easier keystroke handler destruction.
   *
   * @private
   * @member {utils.Emitter} core.KeystrokeHandler#_listener
   */
		this._listener = Object.create(EmitterMixin);

		/**
   * Map of the defined keystrokes. Keystroke codes are the keys.
   *
   * @private
   * @member {Map} core.KeystrokeHandler#_keystrokes
   */
		this._keystrokes = new Map();

		this._listener.listenTo(editor.editing.view, 'keydown', function (evt, data) {
			var handled = _this.press(data);

			if (handled) {
				data.preventDefault();
			}
		});
	}

	/**
  * Registers a handler for the specified keystroke.
  *
  * The handler can be specified as a command name or a callback.
  *
  * @param {String|Array.<String|Number>} keystroke Keystroke defined in a format accepted by
  * the {@link utils.keyboard.parseKeystroke} function.
  * @param {String|Function} callback If a string is passed, then the keystroke will
  * {@link core.editor.Editor#execute execute a command}.
  * If a function, then it will be called with the
  * {@link engine.view.observer.keyObserver.KeyEventData key event data} object.
  */


	createClass(KeystrokeHandler, [{
		key: 'set',
		value: function set(keystroke, callback) {
			this._keystrokes.set(parseKeystroke(keystroke), callback);
		}

		/**
   * Triggers a keystroke handler for a specified key combination, if such a keystroke was {@link #set defined}.
   *
   * @param {engine.view.observer.keyObserver.KeyEventData} keyEventData Key event data.
   * @returns {Boolean} Whether the keystroke was handled.
   */

	}, {
		key: 'press',
		value: function press(keyEventData) {
			var keyCode = getCode(keyEventData);
			var callback = this._keystrokes.get(keyCode);

			if (!callback) {
				return false;
			}

			if (typeof callback == 'string') {
				this.editor.execute(callback);
			} else {
				callback(keyEventData);
			}

			return true;
		}

		/**
   * Destroys the keystroke handler.
   */

	}, {
		key: 'destroy',
		value: function destroy() {
			this._keystrokes = new Map();
			this._listener.stopListening();
		}
	}]);
	return KeystrokeHandler;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Class representing selection in tree view.
 *
 * Selection can consist of {@link engine.view.Range ranges} that can be added using
 * {@link engine.view.Selection#addRange addRange} and {@link engine.view.Selection#setRanges setRanges} methods.
 * Both methods create copies of provided ranges and store those copies internally. Further modifications to passed
 * ranges will not change selection's state.
 * Selection's ranges can be obtained via {@link engine.view.Selection#getRanges getRanges},
 * {@link engine.view.Selection#getFirstRange getFirstRange} and {@link engine.view.Selection#getLastRange getLastRange}
 * methods, which return copies of ranges stored inside selection. Modifications made on these copies will not change
 * selection's state. Similar situation occurs when getting {@link engine.view.Selection#anchor anchor},
 * {@link engine.view.Selection#focus focus}, {@link engine.view.Selection#getFirstPosition first} and
 * {@link engine.view.Selection#getLastPosition last} positions - all will return copies of requested positions.
 *
 * @memberOf engine.view
 */

var Selection$1 = function () {
	/**
  * Creates new selection instance.
  */
	function Selection() {
		classCallCheck(this, Selection);

		/**
   * Stores all ranges that are selected.
   *
   * @protected
   * @member {Array.<engine.view.Range>} engine.view.Selection#_ranges
   */
		this._ranges = [];

		/**
   * Specifies whether the last added range was added as a backward or forward range.
   *
   * @protected
   * @member {Boolean} engine.view.Selection#_lastRangeBackward
   */
		this._lastRangeBackward = false;

		/**
   * Specifies whether selection instance is fake.
   *
   * @private
   * @member {Boolean} engine.view.Selection#_isFake
   */
		this._isFake = false;

		/**
   * Fake selection's label.
   *
   * @private
   * @member {String} engine.view.Selection#_fakeSelectionLabel
   */
		this._fakeSelectionLabel = '';
	}

	/**
  * Sets this selection instance to be marked as `fake`. A fake selection does not render as browser native selection
  * over selected elements and is hidden to the user. This way, no native selection UI artifacts are displayed to
  * the user and selection over elements can be represented in other way, for example by applying proper CSS class.
  *
  * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM (and be
  * properly handled by screen readers).
  *
  * @fires engine.view.Selection#change
  * @param {Boolean} [value=true] If set to true selection will be marked as `fake`.
  * @param {Object} [options] Additional options.
  * @param {String} [options.label=''] Fake selection label.
  */


	createClass(Selection, [{
		key: 'setFake',
		value: function setFake() {
			var value = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
			var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

			this._isFake = value;
			this._fakeSelectionLabel = value ? options.label || '' : '';

			this.fire('change');
		}

		/**
   * Returns true if selection instance is marked as `fake`.
   *
   * @see {@link engine.view.Selection#setFake}
   * @returns {Boolean}
   */

	}, {
		key: 'addRange',


		/**
   * Adds a range to the selection. Added range is copied. This means that passed range is not saved in the
   * selection instance and you can safely operate on it.
   *
   * Accepts a flag describing in which way the selection is made - passed range might be selected from
   * {@link engine.view.Range#start start} to {@link engine.view.Range#end end}
   * or from {@link engine.view.Range#end end} to {@link engine.view.Range#start start}.
   * The flag is used to set {@link engine.view.Selection#anchor anchor} and
   * {@link engine.view.Selection#focus focus} properties.
   *
   * Throws {@link utils.CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
   * with ranges already stored in Selection instance.
   *
   * @fires engine.view.Selection#change
   * @param {engine.view.Range} range
   */
		value: function addRange(range, isBackward) {
			if (!(range instanceof Range$2)) {
				throw new CKEditorError('view-selection-invalid-range: Invalid Range.');
			}

			this._pushRange(range);
			this._lastRangeBackward = !!isBackward;
			this.fire('change');
		}

		/**
   * Returns an iterator that contains copies of all ranges added to the selection.
   *
   * @returns {Iterator.<engine.view.Range>}
   */

	}, {
		key: 'getRanges',
		value: regeneratorRuntime.mark(function getRanges() {
			var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, range;

			return regeneratorRuntime.wrap(function getRanges$(_context) {
				while (1) {
					switch (_context.prev = _context.next) {
						case 0:
							_iteratorNormalCompletion = true;
							_didIteratorError = false;
							_iteratorError = undefined;
							_context.prev = 3;
							_iterator = this._ranges[Symbol.iterator]();

						case 5:
							if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
								_context.next = 12;
								break;
							}

							range = _step.value;
							_context.next = 9;
							return Range$2.createFromRange(range);

						case 9:
							_iteratorNormalCompletion = true;
							_context.next = 5;
							break;

						case 12:
							_context.next = 18;
							break;

						case 14:
							_context.prev = 14;
							_context.t0 = _context['catch'](3);
							_didIteratorError = true;
							_iteratorError = _context.t0;

						case 18:
							_context.prev = 18;
							_context.prev = 19;

							if (!_iteratorNormalCompletion && _iterator.return) {
								_iterator.return();
							}

						case 21:
							_context.prev = 21;

							if (!_didIteratorError) {
								_context.next = 24;
								break;
							}

							throw _iteratorError;

						case 24:
							return _context.finish(21);

						case 25:
							return _context.finish(18);

						case 26:
						case 'end':
							return _context.stop();
					}
				}
			}, getRanges, this, [[3, 14, 18, 26], [19,, 21, 25]]);
		})

		/**
   * Returns copy of the first range in the selection. First range is the one which
   * {@link engine.view.Range#start start} position {@link engine.view.Position#isBefore is before} start
   * position of all other ranges (not to confuse with the first range added to the selection).
   * Returns `null` if no ranges are added to selection.
   *
   * @returns {engine.view.Range|null}
   */

	}, {
		key: 'getFirstRange',
		value: function getFirstRange() {
			var first = null;

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = this._ranges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var range = _step2.value;

					if (!first || range.start.isBefore(first.start)) {
						first = range;
					}
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			return first ? Range$2.createFromRange(first) : null;
		}

		/**
   * Returns copy of the last range in the selection. Last range is the one which {@link engine.view.Range#end end}
   * position {@link engine.view.Position#isAfter is after} end position of all other ranges (not to confuse
   * with the last range added to the selection). Returns `null` if no ranges are added to selection.
   *
   * @returns {engine.view.Range|null}
   */

	}, {
		key: 'getLastRange',
		value: function getLastRange() {
			var last = null;

			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = this._ranges[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var range = _step3.value;

					if (!last || range.end.isAfter(last.end)) {
						last = range;
					}
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}

			return last ? Range$2.createFromRange(last) : null;
		}

		/**
   * Returns copy of the first position in the selection. First position is the position that
   * {@link engine.view.Position#isBefore is before} any other position in the selection ranges.
   * Returns `null` if no ranges are added to selection.
   *
   * @returns {engine.view.Position|null}
   */

	}, {
		key: 'getFirstPosition',
		value: function getFirstPosition() {
			var firstRange = this.getFirstRange();

			return firstRange ? Position$1.createFromPosition(firstRange.start) : null;
		}

		/**
   * Returns copy of the last position in the selection. Last position is the position that
   * {@link engine.view.Position#isAfter is after} any other position in the selection ranges.
   * Returns `null` if no ranges are added to selection.
   *
   * @returns {engine.view.Position|null}
   */

	}, {
		key: 'getLastPosition',
		value: function getLastPosition() {
			var lastRange = this.getLastRange();

			return lastRange ? Position$1.createFromPosition(lastRange.end) : null;
		}

		/**
   * Checks whether, this selection is equal to given selection. Selections equal if they have the same ranges and directions.
   *
   * @param {engine.view.Selection} otherSelection Selection to compare with.
   * @returns {Boolean} `true` if selections are equal, `false` otherwise.
   */

	}, {
		key: 'isEqual',
		value: function isEqual(otherSelection) {
			var rangeCount = this.rangeCount;

			if (rangeCount != otherSelection.rangeCount) {
				return false;
			}

			if (this.isFake != otherSelection.isFake) {
				return false;
			}

			if (this.isFake && this.fakeSelectionLabel != otherSelection.fakeSelectionLabel) {
				return false;
			}

			for (var i = 0; i < this.rangeCount; i++) {
				if (!this._ranges[i].isEqual(otherSelection._ranges[i])) {
					return false;
				}
			}

			return this._lastRangeBackward === otherSelection._lastRangeBackward;
		}

		/**
   * Removes all ranges that were added to the selection.
   *
   * @fires engine.view.Selection#change
   */

	}, {
		key: 'removeAllRanges',
		value: function removeAllRanges() {
			if (this._ranges.length) {
				this._ranges = [];
				this.fire('change');
			}
		}

		/**
   * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
   * is treated like the last added range and is used to set {@link engine.view.Selection#anchor anchor} and
   * {@link engine.view.Selection#focus focus}. Accepts a flag describing in which way the selection is made
   * (see {@link engine.view.Selection#addRange addRange}).
   *
   * @fires engine.view.Selection#change
   * @param {Array.<engine.view.Range>} newRanges Array of ranges to set.
   * @param {Boolean} [isLastBackward] Flag describing if last added range was selected forward - from start to end
   * (`false`) or backward - from end to start (`true`). Defaults to `false`.
   */

	}, {
		key: 'setRanges',
		value: function setRanges(newRanges, isLastBackward) {
			this._ranges = [];

			var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
				for (var _iterator4 = newRanges[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var range = _step4.value;

					if (!(range instanceof Range$2)) {
						throw new CKEditorError('view-selection-invalid-range: Invalid Range.');
					}

					this._pushRange(range);
				}
			} catch (err) {
				_didIteratorError4 = true;
				_iteratorError4 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion4 && _iterator4.return) {
						_iterator4.return();
					}
				} finally {
					if (_didIteratorError4) {
						throw _iteratorError4;
					}
				}
			}

			this._lastRangeBackward = !!isLastBackward;
			this.fire('change');
		}

		/**
   * Sets this selection's ranges and direction to the ranges and direction of the given selection.
   *
   * @param {engine.view.Selection} otherSelection
   */

	}, {
		key: 'setTo',
		value: function setTo(otherSelection) {
			this._isFake = otherSelection._isFake;
			this._fakeSelectionLabel = otherSelection._fakeSelectionLabel;

			this.setRanges(otherSelection.getRanges(), otherSelection.isBackward);
		}

		/**
   * Sets collapsed selection in the specified location.
   *
   * The location can be specified in the same form as {@link engine.view.Position.createAt} parameters.
   *
   * @fires engine.view.Selection#change
   * @param {engine.view.Item|engine.view.Position} itemOrPosition
   * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when
   * first parameter is a {@link engine.view.Item view item}.
   */

	}, {
		key: 'collapse',
		value: function collapse(itemOrPosition, offset) {
			var pos = Position$1.createAt(itemOrPosition, offset);
			var range = new Range$2(pos, pos);

			this.setRanges([range]);
		}

		/**
   * Collapses selection to the selection's {@link engine.view.Selection#getFirstPosition first position}.
   * All ranges, besides the collapsed one, will be removed. Nothing will change if there are no ranges stored
   * inside selection.
   *
   * @fires engine.view.Selection#change
   */

	}, {
		key: 'collapseToStart',
		value: function collapseToStart() {
			var startPosition = this.getFirstPosition();

			if (startPosition !== null) {
				this.setRanges([new Range$2(startPosition, startPosition)]);
			}
		}

		/**
   * Collapses selection to the selection's {@link engine.view.Selection#getLastPosition last position}.
   * All ranges, besides the collapsed one, will be removed. Nothing will change if there are no ranges stored
   * inside selection.
   *
   * @fires engine.view.Selection#change
   */

	}, {
		key: 'collapseToEnd',
		value: function collapseToEnd() {
			var endPosition = this.getLastPosition();

			if (endPosition !== null) {
				this.setRanges([new Range$2(endPosition, endPosition)]);
			}
		}

		/**
   * Sets {@link engine.view.Selection#focus} to the specified location.
   *
   * The location can be specified in the same form as {@link engine.view.Position.createAt} parameters.
   *
   * @fires engine.view.Selection#change:range
   * @param {engine.view.Item|engine.view.Position} itemOrPosition
   * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when
   * first parameter is a {@link engine.view.Item view item}.
   */

	}, {
		key: 'setFocus',
		value: function setFocus(itemOrPosition, offset) {
			if (this.anchor === null) {
				/**
     * Cannot set selection focus if there are no ranges in selection.
     *
     * @error view-selection-setFocus-no-ranges
     */
				throw new CKEditorError('view-selection-setFocus-no-ranges: Cannot set selection focus if there are no ranges in selection.');
			}

			var newFocus = Position$1.createAt(itemOrPosition, offset);

			if (newFocus.compareWith(this.focus) == 'same') {
				return;
			}

			var anchor = this.anchor;

			this._ranges.pop();

			if (newFocus.compareWith(anchor) == 'before') {
				this.addRange(new Range$2(newFocus, anchor), true);
			} else {
				this.addRange(new Range$2(anchor, newFocus));
			}
		}

		/**
   * Creates and returns an instance of `Selection` that is a clone of given selection, meaning that it has same
   * ranges and same direction as this selection.
   *
   * @params {engine.view.Selection} otherSelection Selection to be cloned.
   * @returns {engine.view.Selection} `Selection` instance that is a clone of given selection.
   */

	}, {
		key: '_pushRange',


		/**
   * Adds range to selection - creates copy of given range so it can be safely used and modified.
   *
   * Throws {@link utils.CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
   * with ranges already stored in selection instance.
   *
   * @private
   * @param {engine.view.Range} range
   */
		value: function _pushRange(range) {
			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = this._ranges[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var storedRange = _step5.value;

					if (range.isIntersecting(storedRange)) {
						/**
       * Trying to add a range that intersects with another range from selection.
       *
       * @error selection-range-intersects
       * @param {engine.view.Range} addedRange Range that was added to the selection.
       * @param {engine.view.Range} intersectingRange Range from selection that intersects with `addedRange`.
       */
						throw new CKEditorError('view-selection-range-intersects: Trying to add a range that intersects with another range from selection.', { addedRange: range, intersectingRange: storedRange });
					}
				}
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5.return) {
						_iterator5.return();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}

			this._ranges.push(Range$2.createFromRange(range));
		}
	}, {
		key: 'isFake',
		get: function get() {
			return this._isFake;
		}

		/**
   * Returns fake selection label.
   *
   * @see {@link engine.view.Selection#setFake}
   * @returns {String}
   */

	}, {
		key: 'fakeSelectionLabel',
		get: function get() {
			return this._fakeSelectionLabel;
		}

		/**
   * Selection anchor. Anchor may be described as a position where the selection starts. Together with
   * {@link engine.view.Selection#focus focus} they define the direction of selection, which is important
   * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
   * It may be a bit unintuitive when there are multiple ranges in selection.
   *
   * @see engine.view.Selection#focus
   * @type {engine.view.Position}
   */

	}, {
		key: 'anchor',
		get: function get() {
			if (!this._ranges.length) {
				return null;
			}
			var range = this._ranges[this._ranges.length - 1];
			var anchor = this._lastRangeBackward ? range.end : range.start;

			return Position$1.createFromPosition(anchor);
		}

		/**
   * Selection focus. Focus is a position where the selection ends.
   *
   * @see engine.view.Selection#anchor
   * @type {engine.view.Position}
   */

	}, {
		key: 'focus',
		get: function get() {
			if (!this._ranges.length) {
				return null;
			}
			var range = this._ranges[this._ranges.length - 1];
			var focus = this._lastRangeBackward ? range.start : range.end;

			return Position$1.createFromPosition(focus);
		}

		/**
   * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
   * collapsed.
   *
   * @type {Boolean}
   */

	}, {
		key: 'isCollapsed',
		get: function get() {
			return this.rangeCount === 1 && this._ranges[0].isCollapsed;
		}

		/**
   * Returns number of ranges in selection.
   *
   * @type {Number}
      */

	}, {
		key: 'rangeCount',
		get: function get() {
			return this._ranges.length;
		}

		/**
   * Specifies whether the {@link engine.view.Selection#focus} precedes {@link engine.view.Selection#anchor}.
   *
   * @type {Boolean}
   */

	}, {
		key: 'isBackward',
		get: function get() {
			return !this.isCollapsed && this._lastRangeBackward;
		}

		/**
   * {@link engine.view.EditableElement EditableElement} instance that contains this selection, or `null`
   * if the selection is not inside an editable element.
   *
   * @type {engine.view.EditableElement|null}
   */

	}, {
		key: 'editableElement',
		get: function get() {
			if (this.anchor) {
				return this.anchor.editableElement;
			}

			return null;
		}
	}], [{
		key: 'createFromSelection',
		value: function createFromSelection(otherSelection) {
			var selection = new Selection();
			selection.setTo(otherSelection);

			return selection;
		}
	}]);
	return Selection;
}();

mix(Selection$1, EmitterMixin);

/**
 * Fired whenever selection ranges are changed through {@link engine.view.Selection Selection API}.
 *
 * @event engine.view.Selection#change
 */

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* globals window, Range, Text */

/**
 * Set of utils related to block and inline fillers handling.
 *
 * Browsers do not allow to put caret in elements which does not have height. Because of it, we need to fill all
 * empty elements which should be selectable with elements or characters called "fillers". Unfortunately there is no one
 * universal filler, this is why two types are uses:
 *
 * * Block filler is an element which fill block elements, like `<p>`. CKEditor uses `<br>` as a block filler during the editing,
 * as browsers do natively. So instead of an empty `<p>` there will be `<p><br></p>`. The advantage of block filler is that
 * it is transparent for the selection, so when the caret is before the `<br>` and user presses right arrow he will be
 * moved to the next paragraph, not after the `<br>`. The disadvantage is that it breaks a block, so it can not be used
 * in the middle of a line of text. The {@link engine.view.filler.BR_FILLER `<br>` filler} can be replaced with any other
 * character in the data output, for instance {@link engine.view.filler.NBSP_FILLER non-breaking space}.
 *
 * * Inline filler is a filler which does not break a line of text, so it can be used inside the text, for instance in the empty
 * `<b>` surrendered by text: `foo<b></b>bar`, if we want to put the caret there. CKEditor uses a sequence of the zero-width
 * spaces as an {@link engine.view.filler.INLINE_FILLER inline filler} having the predetermined
 * {@link engine.view.filler.INLINE_FILLER_LENGTH length}. A sequence is used, instead of a single character to
 * avoid treating random zero-width spaces as the inline filler. Disadvantage of the inline filler is that it is not
 * transparent for the selection. The arrow key moves the caret between zero-width spaces characters, so the additional
 * code is needed to handle the caret.
 *
 * Both inline and block fillers are handled by the {@link engine.view.renderer renderer} and are not present in the
 * view.
 *
 * @namespace engine.view.filler
 */

/**
 * `<br> filler creator. This is a function which creates `<br data-cke-filler="true">` element.
 * It defines how the filler is created.
 *
 * @see engine.view.filler.NBSP_FILLER_FILLER
 * @member {Function} engine.view.filler.BR_FILLER
 */
var BR_FILLER = function BR_FILLER(domDocument) {
  var fillerBr = domDocument.createElement('br');
  fillerBr.dataset.ckeFiller = true;

  return fillerBr;
};

/**
 * Non-breaking space filler creator. This is a function which creates `&nbsp;` text node.
 * It defines how the filler is created.
 *
 * @see engine.view.filler.BR_FILLER
 * @member {Function} engine.view.filler.NBSP_FILLER_FILLER
 */
var NBSP_FILLER = function NBSP_FILLER(domDocument) {
  return domDocument.createTextNode(' ');
};

/**
 * Length of the {@link engine.view.filler.INLINE_FILLER INLINE_FILLER}.
 *
 * @member {Function} engine.view.filler.INLINE_FILLER_LENGTH
 */
var INLINE_FILLER_LENGTH = 7;

/**
 * Inline filler which is sequence of the zero width spaces.
 *
 * @member {String} engine.view.filler.INLINE_FILLER
 */
var INLINE_FILLER = '';

for (var i = 0; i < INLINE_FILLER_LENGTH; i++) {
  INLINE_FILLER += '​';
}

/**
 * Checks if the node is a text node which starts with the {@link engine.view.filler.INLINE_FILLER inline filler}.
 *
 *		startsWithFiller( document.createTextNode( INLINE_FILLER ) ); // true
 *		startsWithFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ); // true
 *		startsWithFiller( document.createTextNode( 'foo' ) ); // false
 *		startsWithFiller( document.createElement( 'p' ) ); // false
 *
 * @param {Node} domNode DOM node.
 * @returns {Boolean} True if the text node starts with the {@link engine.view.filler.INLINE_FILLER inline filler}.
 */
function startsWithFiller(domNode) {
  return domNode instanceof Text && domNode.data.substr(0, INLINE_FILLER_LENGTH) === INLINE_FILLER;
}

/**
 * Checks if the text node contains only the {@link engine.view.filler.INLINE_FILLER inline filler}.
 *
 *		isInlineFiller( document.createTextNode( INLINE_FILLER ) ); // true
 *		isInlineFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ); // false
 *
 * @param {Text} domText DOM text node.
 * @returns {Boolean} True if the text node contains only the {@link engine.view.filler.INLINE_FILLER inline filler}.
 */
function isInlineFiller(domText) {
  return domText.data.length == INLINE_FILLER_LENGTH && startsWithFiller(domText);
}

/**
 * Get string data from the text node, removing an {@link engine.view.filler.INLINE_FILLER inline filler} from it,
 * if text node contains it.
 *
 *		getDataWithoutFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ) == 'foo' // true
 *		getDataWithoutFiller( document.createTextNode( 'foo' ) ) == 'foo' // true
 *
 * @param {Text} domText DOM text node, possible with inline filler.
 * @returns {String} Data without filler.
 */
function getDataWithoutFiller(domText) {
  if (startsWithFiller(domText)) {
    return domText.data.slice(INLINE_FILLER_LENGTH);
  } else {
    return domText.data;
  }
}

// Cache block fillers templates to improve performance.
var templateBlockFillers = new WeakMap();

/**
 * Checks if the node is an instance of the block filler of the given type.
 *
 *		const brFillerInstance = BR_FILLER( document );
 *		isBlockFiller( brFillerInstance, BR_FILLER ); // true
 *
 * @param {Node} domNode DOM node to check.
 * @param {Function} blockFiller Block filler creator.
 * @returns {Boolean} True if text node contains only {@link engine.view.filler.INLINE_FILLER inline filler}.
 */
function isBlockFiller(domNode, blockFiller) {
  var templateBlockFiller = templateBlockFillers.get(blockFiller);

  if (!templateBlockFiller) {
    templateBlockFiller = blockFiller(window.document);
    templateBlockFillers.set(blockFiller, templateBlockFiller);
  }

  return domNode.isEqualNode(templateBlockFiller);
}

/**
 * Assign key observer which move cursor from the end of the inline filler to the begging of it when
 * the left arrow is pressed, so the filler does not break navigation.
 *
 * @param {engine.view.Document} document Document instance we should inject quirks handling on.
 */
function injectQuirksHandling(document) {
  document.on('keydown', jumpOverInlineFiller);
}

// Move cursor from the end of the inline filler to the begging of it when, so the filler does not break navigation.
function jumpOverInlineFiller(evt, data) {
  if (data.keyCode == keyCodes.arrowleft) {
    var domSelection = data.domTarget.ownerDocument.defaultView.getSelection();

    if (domSelection.rangeCount == 1 && domSelection.getRangeAt(0).collapsed) {
      var domParent = domSelection.getRangeAt(0).startContainer;
      var domOffset = domSelection.getRangeAt(0).startOffset;

      if (startsWithFiller(domParent) && domOffset <= INLINE_FILLER_LENGTH) {
        var domRange = new Range();
        domRange.setStart(domParent, 0);
        domRange.collapse(true);
        domSelection.removeAllRanges();
        domSelection.addRange(domRange);
      }
    }
  }
}

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

// The following code is based on the "O(NP) Sequence Comparison Algorithm"
// by Sun Wu, Udi Manber, Gene Myers, Webb Miller.

/**
 * Calculates the difference between two arrays or strings producing an array containing a list of changes
 * necessary to transform input into output.
 *
 *		diff( 'aba', 'acca' ); // [ 'equal', 'insert', 'insert', 'delete', 'equal' ]
 *
 * @method utils.diff
 * @param {Array|String} a Input array or string.
 * @param {Array|String} b Output array or string.
 * @param {Function} [cmp] Optional function used to compare array values, by default === is used.
 * @returns {Array} Array of changes.
 */
function diff(a, b, cmp) {
	// Set the comparator function.
	cmp = cmp || function (a, b) {
		return a === b;
	};

	// Temporary action type statics.
	var _insert = void 0,
	    _delete = void 0;

	// Swapped the arrays to use the shorter one as the first one.
	if (b.length < a.length) {
		var tmp = a;

		a = b;
		b = tmp;

		// We swap the action types as well.
		_insert = 'delete';
		_delete = 'insert';
	} else {
		_insert = 'insert';
		_delete = 'delete';
	}

	var m = a.length;
	var n = b.length;
	var delta = n - m;

	// Edit scripts, for each diagonal.
	var es = {};
	// Furthest points, the furthest y we can get on each diagonal.
	var fp = {};

	function snake(k) {
		// We use -1 as an alternative below to handle initial values ( instead of filling the fp with -1 first ).
		// Furthest points (y) on the diagonal below k.
		var y1 = (fp[k - 1] !== undefined ? fp[k - 1] : -1) + 1;
		// Furthest points (y) on the diagonal above k.
		var y2 = fp[k + 1] !== undefined ? fp[k + 1] : -1;
		// The way we should go to get further.
		var dir = y1 > y2 ? -1 : 1;

		// Clone previous changes array (if any).
		if (es[k + dir]) {
			es[k] = es[k + dir].slice(0);
		}

		// Create changes array.
		if (!es[k]) {
			es[k] = [];
		}

		// Push the action.
		es[k].push(y1 > y2 ? _insert : _delete);

		// Set the beginning coordinates.
		var y = Math.max(y1, y2);
		var x = y - k;

		// Traverse the diagonal as long as the values match.
		while (x < m && y < n && cmp(a[x], b[y])) {
			x++;
			y++;
			// Push no change action.
			es[k].push('equal');
		}

		return y;
	}

	var p = 0;
	var k = void 0;

	// Traverse the graph until we reach the end of the longer string.
	do {
		// Updates furthest points and edit scripts for diagonals below delta.
		for (k = -p; k < delta; k++) {
			fp[k] = snake(k);
		}

		// Updates furthest points and edit scripts for diagonals above delta.
		for (k = delta + p; k > delta; k--) {
			fp[k] = snake(k);
		}

		// Updates furthest point and edit script for the delta diagonal.
		// note that the delta diagonal is the one which goes through the sink (m, n).
		fp[delta] = snake(delta);

		p++;
	} while (fp[delta] !== n);

	// Return the final list of edit changes.
	// We remove the first item that represents the action for the injected nulls.
	return es[delta].slice(1);
}

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Inserts node to the parent at given index.
 *
 * @method utils.dom.insertAt
 * @param {Element} parentElement Parent element.
 * @param {Number} index Insertions index.
 * @param {Node} nodeToInsert Node to insert.
 */
function insertAt(parentElement, index, nodeToInsert) {
  parentElement.insertBefore(nodeToInsert, parentElement.childNodes[index] || null);
}

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Removes given node from parent.
 *
 * @method utils.dom.remove
 * @param {Node} node Node to remove.
 */
function remove$4(node) {
  var parent = node.parentNode;

  if (parent) {
    parent.removeChild(node);
  }
}

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* global Range */

/**
 * Renderer updates DOM structure and selection, to make them a reflection of the view structure and selection.
 *
 * View nodes which may need to be rendered needs to be {@link engine.view.Renderer#markToSync marked}.
 * Then, on {@link engine.view.Renderer#render render}, renderer compares the view nodes with the DOM nodes
 * in order to check which ones really need to be refreshed. Finally, it creates DOM nodes from these view nodes,
 * {@link engine.view.DomConverter#bindElements binds} them and inserts into the DOM tree.
 *
 * Every time {@link engine.view.Renderer#render render} is called, renderer additionally checks if
 * {@link engine.view.Renderer#selection selection} needs update and updates it if so.
 *
 * Renderer uses {@link engine.view.DomConverter} to transform and bind nodes.
 *
 * @memberOf engine.view
 */

var Renderer = function () {
	/**
  * Creates a renderer instance.
  *
  * @param {engine.view.DomConverter} domConverter Converter instance.
  * @param {engine.view.Selection} selection View selection.
  */
	function Renderer(domConverter, selection) {
		classCallCheck(this, Renderer);

		/**
   * Set of DOM Documents instances.
   *
   * @member {Set.<Document>} engine.view.Renderer#domDocuments
   */
		this.domDocuments = new Set();

		/**
   * Converter instance.
   *
   * @readonly
   * @member {engine.view.DomConverter} engine.view.Renderer#domConverter
   */
		this.domConverter = domConverter;

		/**
   * Set of nodes which attributes changed and may need to be rendered.
   *
   * @readonly
   * @member {Set.<engine.view.Node>} engine.view.Renderer#markedAttributes
   */
		this.markedAttributes = new Set();

		/**
   * Set of elements which child lists changed and may need to be rendered.
   *
   * @readonly
   * @member {Set.<engine.view.Node>} engine.view.Renderer#markedChildren
   */
		this.markedChildren = new Set();

		/**
   * Set of text nodes which text data changed and may need to be rendered.
   *
   * @readonly
   * @member {Set.<engine.view.Node>} engine.view.Renderer#markedTexts
   */
		this.markedTexts = new Set();

		/**
   * View selection. Renderer updates DOM Selection to make it match this one.
   *
   * @readonly
   * @member {engine.view.Selection} engine.view.Renderer#selection
   */
		this.selection = selection;

		/**
   * The text node in which the inline filler was rendered.
   *
   * @private
   * @member {Text} engine.view.Renderer#_inlineFiller
   */
		this._inlineFiller = null;

		/**
   * Indicates if view document is focused and selection can be rendered. Selection will not be rendered if
   * this is set to `false`.
   *
   * @member {Boolean} engine.view.Renderer#isFocused
   */
		this.isFocused = false;

		/**
   * DOM element containing fake selection.
   *
   * @private
   * @type {null|HTMLElement}
   */
		this._fakeSelectionContainer = null;
	}

	/**
  * Mark node to be synchronized.
  *
  * Note that only view nodes which parents have corresponding DOM elements need to be marked to be synchronized.
  *
  * @see engine.view.Renderer#markedAttributes
  * @see engine.view.Renderer#markedChildren
  * @see engine.view.Renderer#markedTexts
  *
  * @param {engine.view.ChangeType} type Type of the change.
  * @param {engine.view.Node} node Node to be marked.
  */


	createClass(Renderer, [{
		key: 'markToSync',
		value: function markToSync(type, node) {
			if (type === 'text') {
				if (this.domConverter.getCorrespondingDom(node.parent)) {
					this.markedTexts.add(node);
				}
			} else {
				// If the node has no DOM element it is not rendered yet,
				// its children/attributes do not need to be marked to be sync.
				if (!this.domConverter.getCorrespondingDom(node)) {
					return;
				}

				if (type === 'attributes') {
					this.markedAttributes.add(node);
				} else if (type === 'children') {
					this.markedChildren.add(node);
				} else {
					/**
      * Unknown type passed to Renderer.markToSync.
      *
      * @error renderer-unknown-type
      */
					throw new CKEditorError('view-renderer-unknown-type: Unknown type passed to Renderer.markToSync.');
				}
			}
		}

		/**
   * Render method checks {@link engine.view.Renderer#markedAttributes},
   * {@link engine.view.Renderer#markedChildren} and {@link engine.view.Renderer#markedTexts} and updates all
   * nodes which need to be updated. Then it clears all three sets. Also, every time render is called it compares and
   * if needed updates the selection.
   *
   * Renderer tries not to break text composition (e.g. IME) and x-index of the selection,
   * so it does as little as it is needed to update the DOM.
   *
   * For attributes it adds new attributes to DOM elements, updates values and removes
   * attributes which do not exist in the view element.
   *
   * For text nodes it updates the text string if it is different. Note that if parent element is marked as an element
   * which changed child list, text node update will not be done, because it may not be possible do find a
   * {@link engine.view.DomConverter#getCorrespondingDomText corresponding DOM text}. The change will be handled
   * in the parent element.
   *
   * For elements, which child lists have changed, it calculates a {@link diff} and adds or removes children which have changed.
   *
   * Rendering also handles {@link engine.view.filler fillers}. Especially, it checks if the inline filler is needed
   * at selection position and adds or removes it. To prevent breaking text composition inline filler will not be
   * removed as long selection is in the text node which needed it at first.
   */

	}, {
		key: 'render',
		value: function render() {
			var inlineFillerPosition = void 0;

			// There was inline filler rendered in the DOM but it's not
			// at the selection position any more, so we can remove it
			// (cause even if it's needed, it must be placed in another location).
			if (this._inlineFiller && !this._isSelectionInInlineFiller()) {
				this._removeInlineFiller();
			}

			// If we've got the filler, let's try to guess its position in the view.
			if (this._inlineFiller) {
				inlineFillerPosition = this._getInlineFillerPosition();
			}
			// Othewise, if it's needed, create it at the selection position.
			else if (this._needsInlineFillerAtSelection()) {
					inlineFillerPosition = this.selection.getFirstPosition();

					// Do not use `markToSync` so it will be added even if the parent is already added.
					this.markedChildren.add(inlineFillerPosition.parent);
				}

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = this.markedTexts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var node = _step.value;

					if (!this.markedChildren.has(node.parent) && this.domConverter.getCorrespondingDom(node.parent)) {
						this._updateText(node, { inlineFillerPosition: inlineFillerPosition });
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = this.markedAttributes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var element = _step2.value;

					this._updateAttrs(element);
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = this.markedChildren[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var _element = _step3.value;

					this._updateChildren(_element, { inlineFillerPosition: inlineFillerPosition });
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}

			this._updateSelection();
			this._updateFocus();

			this.markedTexts.clear();
			this.markedAttributes.clear();
			this.markedChildren.clear();

			// Remember the filler by its node.
			this._inlineFiller = this._getInlineFillerNode(inlineFillerPosition);
		}

		/**
   * Gets the text node in which the inline filler is kept.
   *
   * @private
   * @param {engine.view.Position} fillerPosition The position on which the filler is needed in the view.
   * @returns {Text} The text node with the filler.
   */

	}, {
		key: '_getInlineFillerNode',
		value: function _getInlineFillerNode(fillerPosition) {
			if (!fillerPosition) {
				this._inlineFiller = null;

				return;
			}

			var domPosition = this.domConverter.viewPositionToDom(fillerPosition);

			/* istanbul ignore if */
			if (!domPosition || !startsWithFiller(domPosition.parent)) {
				/**
     * Cannot find filler node by its position.
     *
     * @error view-renderer-cannot-find-filler
     */
				throw new CKEditorError('view-renderer-cannot-find-filler: Cannot find filler node by its position.');
			}

			return domPosition.parent;
		}

		/**
   * Gets the position of the inline filler based on the current selection.
   * Here, we assume that we know that the filler is needed and
   * {@link #_isSelectionInInlineFiller is at the selection position}, and, since it's needed,
   * it's somewhere at the selection postion.
   *
   * Note: we cannot restore the filler position based on the filler's DOM text node, because
   * when this method is called (before rendering) the bindings will often be broken. View to DOM
   * bindings are only dependable after rendering.
   *
   * @private
   * @returns {engine.view.Position}
   */

	}, {
		key: '_getInlineFillerPosition',
		value: function _getInlineFillerPosition() {
			var firstPos = this.selection.getFirstPosition();

			if (firstPos.parent instanceof Text$2) {
				return Position$1.createBefore(this.selection.getFirstPosition().parent);
			} else {
				return firstPos;
			}
		}

		/**
   * Returns `true` if the selection hasn't left the inline filler's text node.
   * If it is `true` it means that the filler had been added for a reason and the selection does not
   * left the filler's text node. E.g. the user can be in the middle of a composition so it should not be touched.
   *
   * @private
   * @returns {Boolean} True if the inline filler and selection are in the same place.
   */

	}, {
		key: '_isSelectionInInlineFiller',
		value: function _isSelectionInInlineFiller() {
			if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
				return false;
			}

			// Note, we can't check if selection's position equals position of the
			// this._inlineFiller node, because of #663. We may not be able to calculate
			// the filler's position in the view at this stage.
			// Instead, we check it the other way – whether selection is anchored in
			// that text node or next to it.

			// Possible options are:
			// "FILLER{}"
			// "FILLERadded-text{}"

			var selectionPosition = this.selection.getFirstPosition();

			// If we cannot convert this position's parent it means that selection is in not yet rendered
			// node, which means that the filler can't be there.
			if (!this.domConverter.getCorrespondingDom(selectionPosition.parent)) {
				return false;
			}

			var _domConverter$viewPos = this.domConverter.viewPositionToDom(selectionPosition);

			var domParent = _domConverter$viewPos.parent;


			if (this.domConverter.isText(domParent) && startsWithFiller(domParent)) {
				return true;
			}

			return false;
		}

		/**
   * Removes the inline filler.
   *
   * @private
   */

	}, {
		key: '_removeInlineFiller',
		value: function _removeInlineFiller() {
			var domFillerNode = this._inlineFiller;

			// Something weird happened and the stored node doesn't contain the filler's text.
			if (!startsWithFiller(domFillerNode)) {
				/**
     * The inline filler node was lost. Most likely, something overwrote the filler text node
     * in the DOM.
     *
     * @error view-renderer-filler-was-lost
     */
				throw new CKEditorError('view-renderer-filler-was-lost: The inline filler node was lost.');
			}

			if (isInlineFiller(domFillerNode)) {
				domFillerNode.parentNode.removeChild(domFillerNode);
			} else {
				domFillerNode.data = domFillerNode.data.substr(INLINE_FILLER_LENGTH);
			}

			this._inlineFiller = null;
		}

		/**
   * Checks if the inline {@link engine.view.filler filler} should be added.
   *
   * @private
   * @returns {Boolean} True if the inline fillers should be added.
   */

	}, {
		key: '_needsInlineFillerAtSelection',
		value: function _needsInlineFillerAtSelection() {
			if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
				return false;
			}

			var selectionPosition = this.selection.getFirstPosition();
			var selectionParent = selectionPosition.parent;
			var selectionOffset = selectionPosition.offset;

			// If there is no DOM root we do not care about fillers.
			if (!this.domConverter.getCorrespondingDomElement(selectionParent.root)) {
				return false;
			}

			if (!(selectionParent instanceof Element$1)) {
				return false;
			}

			// We have block filler, we do not need inline one.
			if (selectionOffset === selectionParent.getFillerOffset()) {
				return false;
			}

			var nodeBefore = selectionPosition.nodeBefore;
			var nodeAfter = selectionPosition.nodeAfter;

			if (nodeBefore instanceof Text$2 || nodeAfter instanceof Text$2) {
				return false;
			}

			return true;
		}

		/**
   * Checks if text needs to be updated and possibly updates it.
   *
   * @private
   * @param {engine.view.Text} viewText View text to update.
   * @param {Object} options
   * @param {engine.view.Position} options.inlineFillerPosition The position on which the inline
   * filler should be rendered.
   */

	}, {
		key: '_updateText',
		value: function _updateText(viewText, options) {
			var domText = this.domConverter.getCorrespondingDom(viewText);
			var newDomText = this.domConverter.viewToDom(viewText, domText.ownerDocument);

			var actualText = domText.data;
			var expectedText = newDomText.data;

			var filler = options.inlineFillerPosition;

			if (filler && filler.parent == viewText.parent && filler.offset == viewText.index) {
				expectedText = INLINE_FILLER + expectedText;
			}

			if (actualText != expectedText) {
				domText.data = expectedText;
			}
		}

		/**
   * Checks if attributes list needs to be updated and possibly updates it.
   *
   * @private
   * @param {engine.view.Element} viewElement View element to update.
   */

	}, {
		key: '_updateAttrs',
		value: function _updateAttrs(viewElement) {
			var domElement = this.domConverter.getCorrespondingDom(viewElement);
			var domAttrKeys = Array.from(domElement.attributes).map(function (attr) {
				return attr.name;
			});
			var viewAttrKeys = viewElement.getAttributeKeys();

			// Add or overwrite attributes.
			var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
				for (var _iterator4 = viewAttrKeys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var key = _step4.value;

					domElement.setAttribute(key, viewElement.getAttribute(key));
				}

				// Remove from DOM attributes which do not exists in the view.
			} catch (err) {
				_didIteratorError4 = true;
				_iteratorError4 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion4 && _iterator4.return) {
						_iterator4.return();
					}
				} finally {
					if (_didIteratorError4) {
						throw _iteratorError4;
					}
				}
			}

			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = domAttrKeys[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var _key = _step5.value;

					if (!viewElement.hasAttribute(_key)) {
						domElement.removeAttribute(_key);
					}
				}
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5.return) {
						_iterator5.return();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}
		}

		/**
   * Checks if elements child list needs to be updated and possibly updates it.
   *
   * @private
   * @param {engine.view.Element} viewElement View element to update.
   * @param {Object} options
   * @param {engine.view.Position} options.inlineFillerPosition The position on which the inline
   * filler should be rendered.
   */

	}, {
		key: '_updateChildren',
		value: function _updateChildren(viewElement, options) {
			var domConverter = this.domConverter;
			var domElement = domConverter.getCorrespondingDom(viewElement);
			var domDocument = domElement.ownerDocument;

			var filler = options.inlineFillerPosition;

			var actualDomChildren = domElement.childNodes;
			var expectedDomChildren = Array.from(domConverter.viewChildrenToDom(viewElement, domDocument, { bind: true }));

			if (filler && filler.parent == viewElement) {
				var expectedNodeAfterFiller = expectedDomChildren[filler.offset];

				if (this.domConverter.isText(expectedNodeAfterFiller)) {
					expectedNodeAfterFiller.data = INLINE_FILLER + expectedNodeAfterFiller.data;
				} else {
					expectedDomChildren.splice(filler.offset, 0, domDocument.createTextNode(INLINE_FILLER));
				}
			}

			var actions = diff(actualDomChildren, expectedDomChildren, sameNodes);

			var i = 0;

			var _iteratorNormalCompletion6 = true;
			var _didIteratorError6 = false;
			var _iteratorError6 = undefined;

			try {
				for (var _iterator6 = actions[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
					var action = _step6.value;

					if (action === 'insert') {
						insertAt(domElement, i, expectedDomChildren[i]);
						i++;
					} else if (action === 'delete') {
						remove$4(actualDomChildren[i]);
					} else {
						// 'equal'
						i++;
					}
				}
			} catch (err) {
				_didIteratorError6 = true;
				_iteratorError6 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion6 && _iterator6.return) {
						_iterator6.return();
					}
				} finally {
					if (_didIteratorError6) {
						throw _iteratorError6;
					}
				}
			}

			function sameNodes(actualDomChild, expectedDomChild) {
				// Elements.
				if (actualDomChild === expectedDomChild) {
					return true;
				}
				// Texts.
				else if (domConverter.isText(actualDomChild) && domConverter.isText(expectedDomChild)) {
						return actualDomChild.data === expectedDomChild.data;
					}
					// Block fillers.
					else if (isBlockFiller(actualDomChild, domConverter.blockFiller) && isBlockFiller(expectedDomChild, domConverter.blockFiller)) {
							return true;
						}

				// Not matching types.
				return false;
			}
		}

		/**
   * Checks if selection needs to be updated and possibly updates it.
   *
   * @private
   */

	}, {
		key: '_updateSelection',
		value: function _updateSelection() {
			// If there is no selection - remove DOM and fake selections.
			if (this.selection.rangeCount === 0) {
				this._removeDomSelection();
				this._removeFakeSelection();

				return;
			}

			var domRoot = this.domConverter.getCorrespondingDomElement(this.selection.editableElement);

			// Do nothing if there is no focus, or there is no DOM element corresponding to selection's editable element.
			if (!this.isFocused || !domRoot) {
				return;
			}

			// Render selection.
			if (this.selection.isFake) {
				this._updateFakeSelection(domRoot);
			} else {
				this._removeFakeSelection();
				this._updateDomSelection(domRoot);
			}
		}

		/**
   * Updates fake selection.
   *
   * @private
   * @param {HTMLElement} domRoot Valid DOM root where fake selection container should be added.
   */

	}, {
		key: '_updateFakeSelection',
		value: function _updateFakeSelection(domRoot) {
			var domDocument = domRoot.ownerDocument;

			// Create fake selection container if one does not exist.
			if (!this._fakeSelectionContainer) {
				this._fakeSelectionContainer = domDocument.createElement('div');
				this._fakeSelectionContainer.style.position = 'fixed';
				this._fakeSelectionContainer.style.top = 0;
				this._fakeSelectionContainer.style.left = '-9999px';
				this._fakeSelectionContainer.appendChild(domDocument.createTextNode(' '));
			}

			// Add fake container if not already added.
			if (!this._fakeSelectionContainer.parentElement) {
				domRoot.appendChild(this._fakeSelectionContainer);
			}

			// Update contents.
			var content = this.selection.fakeSelectionLabel || ' ';
			this._fakeSelectionContainer.firstChild.data = content;

			// Update selection.
			var domSelection = domDocument.getSelection();
			domSelection.removeAllRanges();
			var domRange = new Range();
			domRange.selectNodeContents(this._fakeSelectionContainer);
			domSelection.addRange(domRange);

			// Bind fake selection container with current selection.
			this.domConverter.bindFakeSelection(this._fakeSelectionContainer, this.selection);
		}

		/**
   * Updates DOM selection.
   *
   * @private
   * @param {HTMLElement} domRoot Valid DOM root where DOM selection should be rendered.
   */

	}, {
		key: '_updateDomSelection',
		value: function _updateDomSelection(domRoot) {
			var domSelection = domRoot.ownerDocument.defaultView.getSelection();
			var oldViewSelection = domSelection && this.domConverter.domSelectionToView(domSelection);

			if (oldViewSelection && this.selection.isEqual(oldViewSelection)) {
				return;
			}

			// Multi-range selection is not available in most browsers, and, at least in Chrome, trying to
			// set such selection, that is not continuous, throws an error. Because of that, we will just use anchor
			// and focus of view selection.
			// Since we are not supporting multi-range selection, we also do not need to check if proper editable is
			// selected. If there is any editable selected, it is okay (editable is taken from selection anchor).
			var anchor = this.domConverter.viewPositionToDom(this.selection.anchor);
			var focus = this.domConverter.viewPositionToDom(this.selection.focus);

			domSelection.collapse(anchor.parent, anchor.offset);
			domSelection.extend(focus.parent, focus.offset);
		}

		/**
   * Removes DOM selection.
   *
   * @private
   */

	}, {
		key: '_removeDomSelection',
		value: function _removeDomSelection() {
			var _iteratorNormalCompletion7 = true;
			var _didIteratorError7 = false;
			var _iteratorError7 = undefined;

			try {
				for (var _iterator7 = this.domDocuments[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
					var doc = _step7.value;

					var domSelection = doc.getSelection();

					if (domSelection.rangeCount) {
						var activeDomElement = doc.activeElement;
						var viewElement = this.domConverter.getCorrespondingViewElement(activeDomElement);

						if (activeDomElement && viewElement) {
							doc.getSelection().removeAllRanges();
						}
					}
				}
			} catch (err) {
				_didIteratorError7 = true;
				_iteratorError7 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion7 && _iterator7.return) {
						_iterator7.return();
					}
				} finally {
					if (_didIteratorError7) {
						throw _iteratorError7;
					}
				}
			}
		}

		/**
   * Removes fake selection.
   *
   * @private
   */

	}, {
		key: '_removeFakeSelection',
		value: function _removeFakeSelection() {
			var container = this._fakeSelectionContainer;

			if (container) {
				container.remove();
			}
		}

		/**
   * Checks if focus needs to be updated and possibly updates it.
   *
   * @private
   */

	}, {
		key: '_updateFocus',
		value: function _updateFocus() {
			if (this.isFocused) {
				var editable = this.selection.editableElement;

				if (editable) {
					this.domConverter.focus(editable);
				}
			}
		}
	}]);
	return Renderer;
}();

mix(Renderer, ObservableMixin);

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Returns index of the node in the parent element.
 *
 * @method utils.dom.indexOf
 * @param {Node} node Node which index is tested.
 * @returns {Number} Index of the node in the parent element. Returns 0 if node has no parent.
 */
function indexOf$1(node) {
  var index = 0;

  while (node.previousSibling) {
    node = node.previousSibling;
    index++;
  }

  return index;
}

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* globals Node */

/**
 * Returns all ancestors of given DOM node, starting from the top-most (root). Includes the given node itself. If the
 * node is a part of `DocumentFragment` that `DocumentFragment` will be returned. In contrary, if the node is
 * appended to a `Document`, that `Document` will not be returned (algorithms operating on DOM tree care for `Document#documentElement`
 * at most, which will be returned).
 *
 * @param {Node} node DOM node.
 * @returns {Array.<Node|DocumentFragment>} Array of given `node` parents.
 */
function getAncestors(node) {
  var nodes = [];

  // We are interested in `Node`s `DocumentFragment`s only.
  while (node && node.nodeType != Node.DOCUMENT_NODE) {
    nodes.unshift(node);
    node = node.parentNode;
  }

  return nodes;
}

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Searches and returns the lowest common ancestor of two given nodes.
 *
 * @param {Node} nodeA First node.
 * @param {Node} nodeB Second node.
 * @returns {Node|DocumentFragment|Document|null} Lowest common ancestor of both nodes or `null` if nodes do not have a common ancestor.
 */
function getCommonAncestor(nodeA, nodeB) {
  var ancestorsA = getAncestors(nodeA);
  var ancestorsB = getAncestors(nodeB);

  var i = 0;

  // It does not matter which array is shorter.
  while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
    i++;
  }

  return i === 0 ? null : ancestorsA[i - 1];
}

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* globals Range, Node, NodeFilter */

/**
 * DomConverter is a set of tools to do transformations between DOM nodes and view nodes. It also handles
 * {@link engine.view.DomConverter#bindElements binding} these nodes.
 *
 * DomConverter does not check which nodes should be rendered (use {@link engine.view.Renderer}), does not keep a
 * state of a tree nor keeps synchronization between tree view and DOM tree (use {@link engine.view.Document}).
 *
 * DomConverter keeps DOM elements to View element bindings, so when the converter will be destroyed, the binding will
 * be lost. Two converters will keep separate binding maps, so one tree view can be bound with two DOM trees.
 *
 * @memberOf engine.view
 */

var DomConverter = function () {
	/**
  * Creates DOM converter.
  *
  * @param {Object} options Object with configuration options.
  * @param {Function} [options.blockFiller=engine.view.filler.BR_FILLER] Block filler creator.
  */
	function DomConverter() {
		var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
		classCallCheck(this, DomConverter);

		// Using WeakMap prevent memory leaks: when the converter will be destroyed all referenced between View and DOM
		// will be removed. Also because it is a *Weak*Map when both view and DOM elements will be removed referenced
		// will be also removed, isn't it brilliant?
		//
		// Yes, PJ. It is.
		//
		// You guys so smart.
		//
		// I've been here. Seen stuff. Afraid of code now.

		/**
   * Block {@link engine.view.filler filler} creator, which is used to create all block fillers during the
   * view to DOM conversion and to recognize block fillers during the DOM to view conversion.
   *
   * @readonly
   * @member {Function} engine.view.DomConverter#blockFiller
   */
		this.blockFiller = options.blockFiller || BR_FILLER;

		/**
   * Tag names of DOM `Element`s which are considered pre-formatted elements.
   *
   * @member {Array.<String>} engine.view.DomConverter#preElements
   */
		this.preElements = ['pre'];

		/**
   * Tag names of DOM `Element`s which are considered block elements.
   *
   * @member {Array.<String>} engine.view.DomConverter#blockElements
   */
		this.blockElements = ['p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'];

		/**
   * DOM to View mapping.
   *
   * @private
   * @member {WeakMap} engine.view.DomConverter#_domToViewMapping
   */
		this._domToViewMapping = new WeakMap();

		/**
   * View to DOM mapping.
   *
   * @private
   * @member {WeakMap} engine.view.DomConverter#_viewToDomMapping
   */
		this._viewToDomMapping = new WeakMap();

		/**
   * Holds mapping between fake selection containers and corresponding view selections.
   *
   * @private
   * @member {WeakMap} engine.view.DomConverter#_fakeSelectionMapping
   */
		this._fakeSelectionMapping = new WeakMap();
	}

	/**
  * Binds given DOM element that represents fake selection to {@link engine.view.Selection view selection}.
  * View selection copy is stored and can be retrieved by {@link engine.view.DomConverter#fakeSelectionToView} method.
  *
  * @param {HTMLElement} domElement
  * @param {engine.view.Selection} viewSelection
  */


	createClass(DomConverter, [{
		key: 'bindFakeSelection',
		value: function bindFakeSelection(domElement, viewSelection) {
			this._fakeSelectionMapping.set(domElement, Selection$1.createFromSelection(viewSelection));
		}

		/**
   * Returns {@link engine.view.Selection view selection} instance corresponding to given DOM element that represents fake
   * selection. Returns `undefined` if binding to given DOM element does not exists.
   *
   * @param {HTMLElement} domElement
   * @returns {engine.view.Selection|undefined}
   */

	}, {
		key: 'fakeSelectionToView',
		value: function fakeSelectionToView(domElement) {
			return this._fakeSelectionMapping.get(domElement);
		}

		/**
   * Binds DOM and View elements, so it will be possible to get corresponding elements using
   * {@link engine.view.DomConverter#getCorrespondingViewElement getCorrespondingViewElement} and
   * {@link engine.view.DomConverter#getCorrespondingDomElement getCorrespondingDomElement}.
   *
   * @param {HTMLElement} domElement DOM element to bind.
   * @param {engine.view.Element} viewElement View element to bind.
   */

	}, {
		key: 'bindElements',
		value: function bindElements(domElement, viewElement) {
			this._domToViewMapping.set(domElement, viewElement);
			this._viewToDomMapping.set(viewElement, domElement);
		}

		/**
   * Binds DOM and View document fragments, so it will be possible to get corresponding document fragments using
   * {@link engine.view.DomConverter#getCorrespondingViewDocumentFragment getCorrespondingViewDocumentFragment} and
   * {@link engine.view.DomConverter#getCorrespondingDomDocumentFragment getCorrespondingDomDocumentFragment}.
   *
   * @param {DocumentFragment} domFragment DOM document fragment to bind.
   * @param {engine.view.DocumentFragment} viewFragment View document fragment to bind.
   */

	}, {
		key: 'bindDocumentFragments',
		value: function bindDocumentFragments(domFragment, viewFragment) {
			this._domToViewMapping.set(domFragment, viewFragment);
			this._viewToDomMapping.set(viewFragment, domFragment);
		}

		/**
   * Converts view to DOM. For all text nodes, not bound elements and document fragments new items will
   * be created. For bound elements and document fragments function will return corresponding items.
   *
   * @param {engine.view.Node|engine.view.DocumentFragment} viewNode View node or document fragment to transform.
   * @param {document} domDocument Document which will be used to create DOM nodes.
   * @param {Object} [options] Conversion options.
   * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.
   * @param {Boolean} [options.withChildren=true] If true node's and document fragment's children  will be converted too.
   * @returns {Node|DocumentFragment} Converted node or DocumentFragment.
   */

	}, {
		key: 'viewToDom',
		value: function viewToDom(viewNode, domDocument) {
			var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

			if (viewNode instanceof Text$2) {
				var textData = this._processDataFromViewText(viewNode);

				return domDocument.createTextNode(textData);
			} else {
				if (this.getCorrespondingDom(viewNode)) {
					return this.getCorrespondingDom(viewNode);
				}

				var domElement = void 0;

				if (viewNode instanceof DocumentFragment$1) {
					// Create DOM document fragment.
					domElement = domDocument.createDocumentFragment();

					if (options.bind) {
						this.bindDocumentFragments(domElement, viewNode);
					}
				} else {
					// Create DOM element.
					domElement = domDocument.createElement(viewNode.name);

					if (options.bind) {
						this.bindElements(domElement, viewNode);
					}

					// Copy element's attributes.
					var _iteratorNormalCompletion = true;
					var _didIteratorError = false;
					var _iteratorError = undefined;

					try {
						for (var _iterator = viewNode.getAttributeKeys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
							var key = _step.value;

							domElement.setAttribute(key, viewNode.getAttribute(key));
						}
					} catch (err) {
						_didIteratorError = true;
						_iteratorError = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion && _iterator.return) {
								_iterator.return();
							}
						} finally {
							if (_didIteratorError) {
								throw _iteratorError;
							}
						}
					}
				}

				if (options.withChildren || options.withChildren === undefined) {
					var _iteratorNormalCompletion2 = true;
					var _didIteratorError2 = false;
					var _iteratorError2 = undefined;

					try {
						for (var _iterator2 = this.viewChildrenToDom(viewNode, domDocument, options)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
							var child = _step2.value;

							domElement.appendChild(child);
						}
					} catch (err) {
						_didIteratorError2 = true;
						_iteratorError2 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion2 && _iterator2.return) {
								_iterator2.return();
							}
						} finally {
							if (_didIteratorError2) {
								throw _iteratorError2;
							}
						}
					}
				}

				return domElement;
			}
		}

		/**
   * Converts children of the view element to DOM using {@link engine.view.DomConverter#viewToDom} method.
   * Additionally this method adds block {@link engine.view.filler filler} to the list of children, if needed.
   *
   * @param {engine.view.Element|engine.view.DocumentFragment} viewElement Parent view element.
   * @param {document} domDocument Document which will be used to create DOM nodes.
   * @param {Object} options See {@link engine.view.DomConverter#viewToDom} options parameter.
   * @returns {Iterable.<Node>} DOM nodes.
   */

	}, {
		key: 'viewChildrenToDom',
		value: regeneratorRuntime.mark(function viewChildrenToDom(viewElement, domDocument) {
			var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

			var fillerPositionOffset, offset, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, childView;

			return regeneratorRuntime.wrap(function viewChildrenToDom$(_context) {
				while (1) {
					switch (_context.prev = _context.next) {
						case 0:
							fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();
							offset = 0;
							_iteratorNormalCompletion3 = true;
							_didIteratorError3 = false;
							_iteratorError3 = undefined;
							_context.prev = 5;
							_iterator3 = viewElement.getChildren()[Symbol.iterator]();

						case 7:
							if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
								_context.next = 18;
								break;
							}

							childView = _step3.value;

							if (!(fillerPositionOffset === offset)) {
								_context.next = 12;
								break;
							}

							_context.next = 12;
							return this.blockFiller(domDocument);

						case 12:
							_context.next = 14;
							return this.viewToDom(childView, domDocument, options);

						case 14:

							offset++;

						case 15:
							_iteratorNormalCompletion3 = true;
							_context.next = 7;
							break;

						case 18:
							_context.next = 24;
							break;

						case 20:
							_context.prev = 20;
							_context.t0 = _context['catch'](5);
							_didIteratorError3 = true;
							_iteratorError3 = _context.t0;

						case 24:
							_context.prev = 24;
							_context.prev = 25;

							if (!_iteratorNormalCompletion3 && _iterator3.return) {
								_iterator3.return();
							}

						case 27:
							_context.prev = 27;

							if (!_didIteratorError3) {
								_context.next = 30;
								break;
							}

							throw _iteratorError3;

						case 30:
							return _context.finish(27);

						case 31:
							return _context.finish(24);

						case 32:
							if (!(fillerPositionOffset === offset)) {
								_context.next = 35;
								break;
							}

							_context.next = 35;
							return this.blockFiller(domDocument);

						case 35:
						case 'end':
							return _context.stop();
					}
				}
			}, viewChildrenToDom, this, [[5, 20, 24, 32], [25,, 27, 31]]);
		})

		/**
   * Converts view {@link engine.view.Range} to DOM range.
   * Inline and block {@link engine.view.filler fillers} are handled during the conversion.
   *
   * @param {engine.view.Range} viewRange View range.
   * @returns {Range} DOM range.
   */

	}, {
		key: 'viewRangeToDom',
		value: function viewRangeToDom(viewRange) {
			var domStart = this.viewPositionToDom(viewRange.start);
			var domEnd = this.viewPositionToDom(viewRange.end);

			var domRange = new Range();
			domRange.setStart(domStart.parent, domStart.offset);
			domRange.setEnd(domEnd.parent, domEnd.offset);

			return domRange;
		}

		/**
   * Converts view {@link engine.view.Position} to DOM parent and offset.
   *
   * Inline and block {@link engine.view.filler fillers} are handled during the conversion.
   * If the converted position is directly before inline filler it is moved inside the filler.
   *
   * @param {engine.view.position} viewPosition View position.
   * @returns {Object} position
   * @returns {Node} position.parent DOM position parent.
   * @returns {Number} position.offset DOM position offset.
   */

	}, {
		key: 'viewPositionToDom',
		value: function viewPositionToDom(viewPosition) {
			var viewParent = viewPosition.parent;

			if (viewParent instanceof Text$2) {
				var domParent = this.getCorrespondingDomText(viewParent);
				var offset = viewPosition.offset;

				if (startsWithFiller(domParent)) {
					offset += INLINE_FILLER_LENGTH;
				}

				return { parent: domParent, offset: offset };
			}
			// viewParent instance of ViewElement.
			else {
					var _domParent = void 0,
					    domBefore = void 0,
					    domAfter = void 0;

					if (viewPosition.offset === 0) {
						_domParent = this.getCorrespondingDom(viewPosition.parent);
						domAfter = _domParent.childNodes[0];
					} else {
						domBefore = this.getCorrespondingDom(viewPosition.nodeBefore);
						_domParent = domBefore.parentNode;
						domAfter = domBefore.nextSibling;
					}

					// If there is an inline filler at position return position inside the filler. We should never return
					// the position before the inline filler.
					if (this.isText(domAfter) && startsWithFiller(domAfter)) {
						return { parent: domAfter, offset: INLINE_FILLER_LENGTH };
					}

					var _offset = domBefore ? indexOf$1(domBefore) + 1 : 0;

					return { parent: _domParent, offset: _offset };
				}
		}

		/**
   * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will
   * be created. For bound elements and document fragments function will return corresponding items. For
   * {@link engine.view.filler fillers} `null` will be returned.
   *
   * @param {Node|DocumentFragment} domNode DOM node or document fragment to transform.
   * @param {Object} [options] Conversion options.
   * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.
   * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.
   * @param {Boolean} [options.keepOriginalCase=false] If `false`, node's tag name will be converter to lower case.
   * @returns {engine.view.Node|engine.view.DocumentFragment|null} Converted node or document fragment or `null`
   * if DOM node is a {@link engine.view.filler filler} or the given node is an empty text node.
   */

	}, {
		key: 'domToView',
		value: function domToView(domNode) {
			var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

			if (isBlockFiller(domNode, this.blockFiller)) {
				return null;
			}

			if (this.isText(domNode)) {
				if (isInlineFiller(domNode)) {
					return null;
				} else {
					var textData = this._processDataFromDomText(domNode);

					return textData === '' ? null : new Text$2(textData);
				}
			} else {
				if (this.getCorrespondingView(domNode)) {
					return this.getCorrespondingView(domNode);
				}

				var viewElement = void 0;

				if (this.isDocumentFragment(domNode)) {
					// Create view document fragment.
					viewElement = new DocumentFragment$1();

					if (options.bind) {
						this.bindDocumentFragments(domNode, viewElement);
					}
				} else {
					// Create view element.
					var viewName = options.keepOriginalCase ? domNode.tagName : domNode.tagName.toLowerCase();
					viewElement = new Element$1(viewName);

					if (options.bind) {
						this.bindElements(domNode, viewElement);
					}

					// Copy element's attributes.
					var attrs = domNode.attributes;

					for (var i = attrs.length - 1; i >= 0; i--) {
						viewElement.setAttribute(attrs[i].name, attrs[i].value);
					}
				}

				if (options.withChildren || options.withChildren === undefined) {
					var _iteratorNormalCompletion4 = true;
					var _didIteratorError4 = false;
					var _iteratorError4 = undefined;

					try {
						for (var _iterator4 = this.domChildrenToView(domNode, options)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
							var child = _step4.value;

							viewElement.appendChildren(child);
						}
					} catch (err) {
						_didIteratorError4 = true;
						_iteratorError4 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion4 && _iterator4.return) {
								_iterator4.return();
							}
						} finally {
							if (_didIteratorError4) {
								throw _iteratorError4;
							}
						}
					}
				}

				return viewElement;
			}
		}

		/**
   * Converts children of the DOM element to view nodes using {@link engine.view.DomConverter#domToView} method.
   * Additionally this method omits block {@link engine.view.filler filler}, if it exists in the DOM parent.
   *
   * @param {HTMLElement} domElement Parent DOM element.
   * @param {Object} options See {@link engine.view.DomConverter#domToView} options parameter.
   * @returns {Iterable.<engine.view.Node>} View nodes.
   */

	}, {
		key: 'domChildrenToView',
		value: regeneratorRuntime.mark(function domChildrenToView(domElement) {
			var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
			var i, domChild, viewChild;
			return regeneratorRuntime.wrap(function domChildrenToView$(_context2) {
				while (1) {
					switch (_context2.prev = _context2.next) {
						case 0:
							i = 0;

						case 1:
							if (!(i < domElement.childNodes.length)) {
								_context2.next = 10;
								break;
							}

							domChild = domElement.childNodes[i];
							viewChild = this.domToView(domChild, options);

							if (!(viewChild !== null)) {
								_context2.next = 7;
								break;
							}

							_context2.next = 7;
							return viewChild;

						case 7:
							i++;
							_context2.next = 1;
							break;

						case 10:
						case 'end':
							return _context2.stop();
					}
				}
			}, domChildrenToView, this);
		})

		/**
   * Converts DOM selection to view {@link engine.view.Selection}.
   * Ranges which cannot be converted will be omitted.
   *
   * @param {Selection} domSelection DOM selection.
   * @returns {engine.view.Selection} View selection.
   */

	}, {
		key: 'domSelectionToView',
		value: function domSelectionToView(domSelection) {
			// DOM selection might be placed in fake selection container.
			// If container contains fake selection - return corresponding view selection.
			if (domSelection.rangeCount === 1) {
				var container = domSelection.getRangeAt(0).startContainer;

				// The DOM selection might be moved to the text node inside the fake selection container.
				if (this.isText(container)) {
					container = container.parentNode;
				}

				var _viewSelection = this.fakeSelectionToView(container);

				if (_viewSelection) {
					return _viewSelection;
				}
			}

			var viewSelection = new Selection$1();
			var isBackward = this.isDomSelectionBackward(domSelection);

			for (var i = 0; i < domSelection.rangeCount; i++) {
				// DOM Range have correct start and end, no matter what is the DOM Selection direction. So we don't have to fix anything.
				var domRange = domSelection.getRangeAt(i);
				var viewRange = this.domRangeToView(domRange);

				if (viewRange) {
					viewSelection.addRange(viewRange, isBackward);
				}
			}

			return viewSelection;
		}

		/**
   * Converts DOM Range to view {@link engine.view.range}.
   * If the start or end position can not be converted `null` is returned.
   *
   * @param {Range} domRange DOM range.
   * @returns {engine.view.Range|null} View range.
   */

	}, {
		key: 'domRangeToView',
		value: function domRangeToView(domRange) {
			var viewStart = this.domPositionToView(domRange.startContainer, domRange.startOffset);
			var viewEnd = this.domPositionToView(domRange.endContainer, domRange.endOffset);

			if (viewStart && viewEnd) {
				return new Range$2(viewStart, viewEnd);
			}

			return null;
		}

		/**
   * Converts DOM parent and offset to view {@link engine.view.Position}.
   *
   * If the position is inside a {@link engine.view.filler filler} which has no corresponding view node,
   * position of the filler will be converted and returned.
   *
   * If structures are too different and it is not possible to find corresponding position then `null` will be returned.
   *
   * @param {Node} domParent DOM position parent.
   * @param {Number} domOffset DOM position offset.
   * @returns {engine.view.Position} viewPosition View position.
   */

	}, {
		key: 'domPositionToView',
		value: function domPositionToView(domParent, domOffset) {
			if (isBlockFiller(domParent, this.blockFiller)) {
				return this.domPositionToView(domParent.parentNode, indexOf$1(domParent));
			}

			if (this.isText(domParent)) {
				if (isInlineFiller(domParent)) {
					return this.domPositionToView(domParent.parentNode, indexOf$1(domParent));
				}

				var viewParent = this.getCorrespondingViewText(domParent);
				var offset = domOffset;

				if (!viewParent) {
					return null;
				}

				if (startsWithFiller(domParent)) {
					offset -= INLINE_FILLER_LENGTH;
					offset = offset < 0 ? 0 : offset;
				}

				return new Position$1(viewParent, offset);
			}
			// domParent instanceof HTMLElement.
			else {
					if (domOffset === 0) {
						var _viewParent = this.getCorrespondingView(domParent);

						if (_viewParent) {
							return new Position$1(_viewParent, 0);
						}
					} else {
						var viewBefore = this.getCorrespondingView(domParent.childNodes[domOffset - 1]);

						// TODO #663
						if (viewBefore && viewBefore.parent) {
							return new Position$1(viewBefore.parent, viewBefore.index + 1);
						}
					}

					return null;
				}
		}

		/**
   * Gets corresponding view item. This function use
   * {@link engine.view.DomConverter#getCorrespondingViewElement getCorrespondingViewElement}
   * for elements, {@link  engine.view.DomConverter#getCorrespondingViewText getCorrespondingViewText} for text
   * nodes and {@link engine.view.DomConverter#getCorrespondingViewDocumentFragment getCorrespondingViewDocumentFragment}
   * for document fragments.
   *
   * Note that for the block or inline {@link engine.view.filler filler} this method returns `null`.
   *
   * @param {Node|DocumentFragment} domNode DOM node or document fragment.
   * @returns {engine.view.Node|engine.view.DocumentFragment|null} Corresponding view item.
   */

	}, {
		key: 'getCorrespondingView',
		value: function getCorrespondingView(domNode) {
			if (this.isElement(domNode)) {
				return this.getCorrespondingViewElement(domNode);
			} else if (this.isDocumentFragment(domNode)) {
				return this.getCorrespondingViewDocumentFragment(domNode);
			} else if (this.isText(domNode)) {
				return this.getCorrespondingViewText(domNode);
			}

			return null;
		}

		/**
   * Gets corresponding view element. Returns element if an view element was
   * {@link engine.view.DomConverter#bindElements bound} to the given DOM element or `null` otherwise.
   *
   * @param {HTMLElement} domElement DOM element.
   * @returns {engine.view.Element|null} Corresponding element or `null` if no element was bound.
   */

	}, {
		key: 'getCorrespondingViewElement',
		value: function getCorrespondingViewElement(domElement) {
			return this._domToViewMapping.get(domElement);
		}

		/**
   * Gets corresponding view document fragment. Returns document fragment if an view element was
   * {@link engine.view.DomConverter#bindDocumentFragments bound} to the given DOM fragment or `null` otherwise.
   *
   * @param {DocumentFragment} domFragment DOM element.
   * @returns {engine.view.DocumentFragment|null} Corresponding document fragment or `null` if none element was bound.
   */

	}, {
		key: 'getCorrespondingViewDocumentFragment',
		value: function getCorrespondingViewDocumentFragment(domFragment) {
			return this._domToViewMapping.get(domFragment);
		}

		/**
   * Gets corresponding text node. Text nodes are not {@link engine.view.DomConverter#bindElements bound},
   * corresponding text node is returned based on the sibling or parent.
   *
   * If the directly previous sibling is a {@link engine.view.DomConverter#bindElements bound} element, it is used
   * to find the corresponding text node.
   *
   * If this is a first child in the parent and the parent is a {@link engine.view.DomConverter#bindElements bound}
   * element, it is used to find the corresponding text node.
   *
   * Otherwise `null` is returned.
   *
   * Note that for the block or inline {@link engine.view.filler filler} this method returns `null`.
   *
   * @param {Text} domText DOM text node.
   * @returns {engine.view.Text|null} Corresponding view text node or `null`, if it was not possible to find a
   * corresponding node.
   */

	}, {
		key: 'getCorrespondingViewText',
		value: function getCorrespondingViewText(domText) {
			if (isInlineFiller(domText)) {
				return null;
			}

			var previousSibling = domText.previousSibling;

			// Try to use previous sibling to find the corresponding text node.
			if (previousSibling) {
				if (!this.isElement(previousSibling)) {
					// The previous is text or comment.
					return null;
				}

				var viewElement = this.getCorrespondingViewElement(previousSibling);

				if (viewElement) {
					var nextSibling = viewElement.nextSibling;

					// It might be filler which has no corresponding view node.
					if (nextSibling instanceof Text$2) {
						return viewElement.nextSibling;
					} else {
						return null;
					}
				}
			}
			// Try to use parent to find the corresponding text node.
			else {
					var _viewElement = this.getCorrespondingViewElement(domText.parentNode);

					if (_viewElement) {
						var firstChild = _viewElement.getChild(0);

						// It might be filler which has no corresponding view node.
						if (firstChild instanceof Text$2) {
							return firstChild;
						} else {
							return null;
						}
					}
				}

			return null;
		}

		/**
   * Gets corresponding DOM item. This function uses
   * {@link engine.view.DomConverter#getCorrespondingDomElement getCorrespondingDomElement} for
   * elements, {@link engine.view.DomConverter#getCorrespondingDomText getCorrespondingDomText} for text nodes
   * and {@link engine.view.DomConverter#getCorrespondingDomDocumentFragment getCorrespondingDomDocumentFragment}
   * for document fragments.
   *
   * @param {engine.view.Node|engine.view.DocumentFragment} viewNode View node or document fragment.
   * @returns {Node|DocumentFragment|null} Corresponding DOM node or document fragment.
   */

	}, {
		key: 'getCorrespondingDom',
		value: function getCorrespondingDom(viewNode) {
			if (viewNode instanceof Element$1) {
				return this.getCorrespondingDomElement(viewNode);
			} else if (viewNode instanceof DocumentFragment$1) {
				return this.getCorrespondingDomDocumentFragment(viewNode);
			} else if (viewNode instanceof Text$2) {
				return this.getCorrespondingDomText(viewNode);
			}

			return null;
		}

		/**
   * Gets corresponding DOM element. Returns element if an DOM element was
   * {@link engine.view.DomConverter#bindElements bound} to the given view element or `null` otherwise.
   *
   * @param {engine.view.Element} viewElement View element.
   * @returns {HTMLElement|null} Corresponding element or `null` if none element was bound.
   */

	}, {
		key: 'getCorrespondingDomElement',
		value: function getCorrespondingDomElement(viewElement) {
			return this._viewToDomMapping.get(viewElement);
		}

		/**
   * Gets corresponding DOM document fragment. Returns document fragment if an DOM element was
   * {@link engine.view.DomConverter#bindDocumentFragments bound} to the given view document fragment or `null` otherwise.
   *
   * @param {engine.view.DocumentFragment} viewDocumentFragment View document fragment.
   * @returns {DocumentFragment|null} Corresponding document fragment or `null` if no fragment was bound.
   */

	}, {
		key: 'getCorrespondingDomDocumentFragment',
		value: function getCorrespondingDomDocumentFragment(viewDocumentFragment) {
			return this._viewToDomMapping.get(viewDocumentFragment);
		}

		/**
   * Gets corresponding text node. Text nodes are not {@link engine.view.DomConverter#bindElements bound},
   * corresponding text node is returned based on the sibling or parent.
   *
   * If the directly previous sibling is a {@link engine.view.DomConverter#bindElements bound} element, it is used
   * to find the corresponding text node.
   *
   * If this is a first child in the parent and the parent is a {@link engine.view.DomConverter#bindElements bound}
   * element, it is used to find the corresponding text node.
   *
   * Otherwise `null` is returned.
   *
   * @param {engine.view.Text} viewText View text node.
   * @returns {Text|null} Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.
   */

	}, {
		key: 'getCorrespondingDomText',
		value: function getCorrespondingDomText(viewText) {
			var previousSibling = viewText.previousSibling;

			// Try to use previous sibling to find the corresponding text node.
			if (previousSibling && this.getCorrespondingDom(previousSibling)) {
				return this.getCorrespondingDom(previousSibling).nextSibling;
			}

			// If this is a first node, try to use parent to find the corresponding text node.
			if (!previousSibling && viewText.parent && this.getCorrespondingDom(viewText.parent)) {
				return this.getCorrespondingDom(viewText.parent).childNodes[0];
			}

			return null;
		}

		/**
   * Focuses DOM editable that is corresponding to provided {@link engine.view.EditableElement EditableElement}.
   *
   * @param {engine.view.EditableElement} viewEditable
   */

	}, {
		key: 'focus',
		value: function focus(viewEditable) {
			var domEditable = this.getCorrespondingDomElement(viewEditable);

			if (domEditable && domEditable.ownerDocument.activeElement !== domEditable) {
				domEditable.focus();
			}
		}

		/**
   * Returns `true` when `node.nodeType` equals `Node.TEXT_NODE`.
   *
   * @param {Node} node Node to check.
   * @returns {Boolean}
   */

	}, {
		key: 'isText',
		value: function isText(node) {
			return node && node.nodeType == Node.TEXT_NODE;
		}

		/**
   * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.
   *
   * @param {Node} node Node to check.
   * @returns {Boolean}
   */

	}, {
		key: 'isElement',
		value: function isElement(node) {
			return node && node.nodeType == Node.ELEMENT_NODE;
		}

		/**
   * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.
   *
   * @param {Node} node Node to check.
   * @returns {Boolean}
   */

	}, {
		key: 'isDocumentFragment',
		value: function isDocumentFragment(node) {
			return node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
		}

		/**
   * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.
   *
   * @param {Selection} DOM Selection instance to check.
   * @returns {Boolean}
   */

	}, {
		key: 'isDomSelectionBackward',
		value: function isDomSelectionBackward(selection) {
			if (selection.isCollapsed) {
				return false;
			}

			// Since it takes multiple lines of code to check whether a "DOM Position" is before/after another "DOM Position",
			// we will use the fact that range will collapse if it's end is before it's start.
			var range = new Range();

			range.setStart(selection.anchorNode, selection.anchorOffset);
			range.setEnd(selection.focusNode, selection.focusOffset);

			var backward = range.collapsed;

			range.detach();

			return backward;
		}

		/**
   * Takes text data from given {@link engine.view.Text#data} and processes it so it is correctly displayed in DOM.
   *
   * Following changes are done:
   * * multiple spaces are replaced to a chain of spaces and `&nbsp;`,
   * * space at the beginning of the text node is changed to `&nbsp;` if it is a first text node in it's container
   * element or if previous text node ends by space character,
   * * space at the end of the text node is changed to `&nbsp;` if it is a last text node in it's container.
   *
   * @private
   * @param {engine.view.Text} node View text node to process.
   * @returns {String} Processed text data.
   */

	}, {
		key: '_processDataFromViewText',
		value: function _processDataFromViewText(node) {
			var _this = this;

			var data = node.data;

			// If any of node ancestors has a name which is in `preElements` array, then currently processed
			// view text node is (will be) in preformatted element. We should not change whitespaces then.
			if (node.getAncestors().some(function (parent) {
				return _this.preElements.includes(parent.name);
			})) {
				return data;
			}

			var prevNode = this._getTouchingViewTextNode(node, false);
			var nextNode = this._getTouchingViewTextNode(node, true);

			// Second part of text data, from the space after the last non-space character to the end.
			// We separate `textEnd` and `textStart` because `textEnd` needs some special handling.
			var textEnd = data.match(/ *$/)[0];
			// First part of data, between first and last part of data.
			var textStart = data.substr(0, data.length - textEnd.length);

			// If previous text node does not exist or it ends by space character, replace space character at the beginning of text.
			// ` x`			-> `_x`
			// `  x`		-> `_ x`
			// `   x`		-> `_  x`
			if (!prevNode || prevNode.data.charAt(prevNode.data.length - 1) == ' ') {
				textStart = textStart.replace(/^ /, ' ');
			}

			// Multiple consecutive spaces. Change them to ` &nbsp;` pairs.
			// `_x  x`		-> `_x _x`
			// `_ x  x`		-> `_ x _x`
			// `_  x  x`	-> `_ _x _x`
			// `_  x   x`	-> `_ _x _ x`
			// `_  x    x`	-> `_ _x _ _x`
			// `_   x    x` -> `_ _ x _ _x`
			textStart = textStart.replace(/  /g, '  ');

			// Process `textEnd` only if there is anything to process.
			if (textEnd.length > 0) {
				// (1) We need special treatment for the last part of text node, it has to end on `&nbsp;`, not space:
				// `x `		-> `x_`
				// `x  `	-> `x _`
				// `x   `	-> `x_ _`
				// `x    `	-> `x _ _`
				// (2) Different case when there is a node after:
				// `x <b>b</b>`		-> `x <b>b</b>`
				// `x  <b>b</b>`	-> `x _<b>b</b>`
				// `x   <b>b</b>`	-> `x _ <b>b</b>`
				// `x    <b>b</b>`	-> `x _ _<b>b</b>`
				// (3) But different, when that node starts by &nbsp; (or space that will be converted to &nbsp;):
				// `x <b>_b</b>`	-> `x <b>_b</b>`
				// `x  <b>_b</b>`	-> `x_ <b>_b</b>`
				// `x   <b>_b</b>`	-> `x _ <b>_b</b>`
				// `x    <b>_b</b>`	-> `x_ _ <b>_b</b>`
				// Let's assume that starting from space is normal behavior, because starting from &nbsp; is a less frequent case.
				var textEndStartsFromNbsp = false;

				if (!nextNode) {
					// (1)
					if (textEnd.length % 2) {
						textEndStartsFromNbsp = true;
					}
				} else if (nextNode.data.charAt(0) == ' ' || nextNode.data.charAt(0) == ' ') {
					// (3)
					if (textEnd.length % 2 === 0) {
						textEndStartsFromNbsp = true;
					}
				}

				if (textEndStartsFromNbsp) {
					textEnd = ' ' + textEnd.substr(0, textEnd.length - 1);
				}

				textEnd = textEnd.replace(/  /g, '  ');
			}

			return textStart + textEnd;
		}

		/**
   * Helper function. For given {@link engine.view.Text view text node}, it finds previous or next sibling that is contained
   * in the same block element. If there is no such sibling, `null` is returned.
   *
   * @private
   * @param {engine.view.Text} node
   * @param {Boolean} getNext
   * @returns {engine.view.Text}
   */

	}, {
		key: '_getTouchingViewTextNode',
		value: function _getTouchingViewTextNode(node, getNext) {
			if (!node.parent) {
				return null;
			}

			var treeWalker = new TreeWalker$1({
				startPosition: getNext ? Position$1.createAfter(node) : Position$1.createBefore(node),
				direction: getNext ? 'forward' : 'backward'
			});

			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = treeWalker[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var value = _step5.value;

					if (value.item instanceof ContainerElement) {
						// ViewContainerElement is found on a way to next ViewText node, so given `node` was first/last
						// text node in it's container element.
						return null;
					} else if (value.item instanceof Text$2) {
						// Found a text node in the same container element.
						return value.item;
					}
				}
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5.return) {
						_iterator5.return();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}

			return null;
		}

		/**
   * Takes text data from native `Text` node and processes it to a correct {@link engine.view.Text view text node} data.
   *
   * Following changes are done:
   * * multiple whitespaces are replaced to a single space,
   * * space at the beginning of the text node is removed, if it is a first text node in it's container
   * element or if previous text node ends by space character,
   * * space at the end of the text node is removed, if it is a last text node in it's container.
   *
   * @param {Node} node DOM text node to process.
   * @returns {String} Processed data.
   * @private
   */

	}, {
		key: '_processDataFromDomText',
		value: function _processDataFromDomText(node) {
			var data = getDataWithoutFiller(node);

			if (_hasDomParentOfType(node, this.preElements)) {
				return data;
			}

			// Change all consecutive whitespace characters to a single space character. That's how multiple whitespaces
			// are treated when rendered, so we normalize those whitespaces.
			// Note that &nbsp; (`\u00A0`) should not be treated as a whitespace because it is rendered.
			data = data.replace(/[^\S\u00A0]{2,}/g, ' ');

			var prevNode = this._getTouchingDomTextNode(node, false);
			var nextNode = this._getTouchingDomTextNode(node, true);

			// If previous dom text node does not exist or it ends by whitespace character, remove space character from the beginning
			// of this text node. Such space character is treated as a whitespace.
			if (!prevNode || /[^\S\u00A0]/.test(prevNode.data.charAt(prevNode.data.length - 1))) {
				data = data.replace(/^ /, '');
			}

			// If next text node does not exist remove space character from the end of this text node.
			if (!nextNode) {
				data = data.replace(/ $/, '');
			}
			// At this point we should have removed all whitespaces from DOM text data.

			// Now we have to change &nbsp; chars, that were in DOM text data because of rendering reasons, to spaces.
			// First, change all ` \u00A0` pairs (space + &nbsp;) to two spaces. DOM converter changes two spaces from model/view as
			// ` \u00A0` to ensure proper rendering. Since here we convert back, we recognize those pairs and change them
			// to `  ` which is what we expect to have in model/view.
			data = data.replace(/ \u00A0/g, '  ');
			// Then, change &nbsp; character that is at the beginning of the text node to space character.
			// As above, that &nbsp; was created for rendering reasons but it's real meaning is just a space character.
			// We do that replacement only if this is the first node or the previous node ends on whitespace character.
			if (!prevNode || /[^\S\u00A0]/.test(prevNode.data.charAt(prevNode.data.length - 1))) {
				data = data.replace(/^\u00A0/, ' ');
			}
			// Since input text data could be: `x_ _`, we would not replace the first &nbsp; after `x` character.
			// We have to fix it. Since we already change all ` &nbsp;`, we will have something like this at the end of text data:
			// `x_ _ _` -> `x_    `. Find &nbsp; at the end of string (can be followed only by spaces).
			// We do that replacement only if this is the last node or the next node starts by &nbsp;.
			if (!nextNode || nextNode.data.charAt(0) == ' ') {
				data = data.replace(/\u00A0( *)$/, ' $1');
			}

			// At this point, all whitespaces should be removed and all &nbsp; created for rendering reasons should be
			// changed to normal space. All left &nbsp; are &nbsp; inserted intentionally.
			return data;
		}

		/**
   * Helper function. For given `Text` node, it finds previous or next sibling that is contained in the same block element.
   * If there is no such sibling, `null` is returned.
   *
   * @private
   * @param {Text} node
   * @param {Boolean} getNext
   * @returns {Text|null}
   */

	}, {
		key: '_getTouchingDomTextNode',
		value: function _getTouchingDomTextNode(node, getNext) {
			if (!node.parentNode) {
				return null;
			}

			var direction = getNext ? 'nextNode' : 'previousNode';
			var document = node.ownerDocument;
			var treeWalker = document.createTreeWalker(document.childNodes[0], NodeFilter.SHOW_TEXT);

			treeWalker.currentNode = node;

			var touchingNode = treeWalker[direction]();

			if (touchingNode !== null) {
				var lca = getCommonAncestor(node, touchingNode);

				// If there is common ancestor between the text node and next/prev text node,
				// and there are no block elements on a way from the text node to that ancestor,
				// and there are no block elements on a way from next/prev text node to that ancestor...
				if (lca && !_hasDomParentOfType(node, this.blockElements, lca) && !_hasDomParentOfType(touchingNode, this.blockElements, lca)) {
					// Then they are in the same container element.
					return touchingNode;
				}
			}

			return null;
		}
	}]);
	return DomConverter;
}();

function _hasDomParentOfType(node, types, boundaryParent) {
	var parents = getAncestors(node);

	if (boundaryParent) {
		parents = parents.slice(parents.indexOf(boundaryParent) + 1);
	}

	return parents.some(function (parent) {
		return parent.tagName && types.includes(parent.tagName.toLowerCase());
	});
}

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Class representing a single root in the data view. A root can be either {@link #isReadOnly editable or read-only}, but
 * in both cases it is called "an editable". Roots can contain other {@link engine.view.EditableElement editable elements}
 * making them "nested editables".
 *
 * @memberOf engine.view
 * @extends engine.view.EditableElement
 */

var RootEditableElement = function (_EditableElement) {
	inherits(RootEditableElement, _EditableElement);

	/**
  * Creates root editable element.
  *
  * @param {engine.view.Document} document {@link engine.view.Document} that is an owner of the root.
  * @param {String} name Node name.
  * @param {String} [rootName='main'] Root name inside parent {@link engine.view.Document}.
  */
	function RootEditableElement(document, name) {
		var rootName = arguments.length <= 2 || arguments[2] === undefined ? 'main' : arguments[2];
		classCallCheck(this, RootEditableElement);

		/**
   * Name of this root inside {@link engine.view.Document} that is an owner of this root.
   *
   * @readonly
   * @member {String} engine.view.RootEditableElement#rootName
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(RootEditableElement).call(this, document, name));

		_this.rootName = rootName;
		return _this;
	}

	return RootEditableElement;
}(EditableElement);

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Abstract base observer class. Observers are classes which observe changes on DOM elements, do the preliminary
 * processing and fire events on the {@link engine.view.Document} objects. Observers can also add features to the view,
 * for instance by updating its status or marking elements which need refresh on DOM events.
 *
 * @abstract
 * @memberOf engine.view.observer
 */
var Observer = function () {
	/**
  * Creates an instance of the observer.
  *
  * @param {engine.view.Document} document
  */
	function Observer(document) {
		classCallCheck(this, Observer);

		/**
   * Reference to the {@link engine.view.Document} object.
   *
   * @readonly
   * @member {engine.view.Document} engine.view.observer.Observer#document
   */
		this.document = document;

		/**
   * State of the observer. If it is disabled events will not be fired.
   *
   * @readonly
   * @member {Boolean} engine.view.observer.Observer#isEnabled
   */
		this.isEnabled = false;
	}

	/**
  * Enables the observer. This method is called when then observer is registered to the
  * {@link engine.view.Document} and after {@link engine.view.Document#render rendering}
  * (all observers are {@link engine.view.observer.Observer#disable disabled} before rendering).
  *
  * A typical use case for disabling observers is that mutation observers need to be disabled for the rendering.
  * However, a child class may not need to be disabled, so it can implement an empty method.
  *
  * @see engine.view.observer.Observer#disable
  */


	createClass(Observer, [{
		key: "enable",
		value: function enable() {
			this.isEnabled = true;
		}

		/**
   * Disables the observer. This method is called before
   * {@link engine.view.Document#render rendering} to prevent firing events during rendering.
   *
   * @see engine.view.observer.Observer#enable
   */

	}, {
		key: "disable",
		value: function disable() {
			this.isEnabled = false;
		}

		/**
   * Starts observing the given root element.
   *
   * @method engine.view.observer.Observer#observe
   * @param {HTMLElement} domElement
   * @param {String} name The name of the root element.
   */

	}]);
	return Observer;
}();

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* globals window */

/**
 * Mutation observer class observes changes in the DOM, fires {@link engine.view.Document#mutations} event, mark view elements
 * as changed and call {@link engine.view.render}. Because all mutated nodes are marked as "to be rendered" and the
 * {@link engine.view.render} is called, all changes will be reverted, unless the mutation will be handled by the
 * {@link engine.view.Document#mutations} event listener. It means user will see only handled changes, and the editor will
 * block all changes which are not handled.
 *
 * Mutation Observer also take care of reducing number of mutations which are fired. It removes duplicates and
 * mutations on elements which do not have corresponding view elements. Also
 * {@link engine.view.Document.MutatatedText text mutation} is fired only if parent element do not change child list.
 *
 * Note that this observer is attached by the {@link engine.view.Document} and is available by default.
 *
 * @memberOf engine.view.observer
 * @extends engine.view.observer.Observer
 */

var MutationObserver = function (_Observer) {
	inherits(MutationObserver, _Observer);

	function MutationObserver(document) {
		classCallCheck(this, MutationObserver);

		/**
   * Native mutation observer config.
   *
   * @private
   * @member {Object} engine.view.observer.MutationObserver#_config
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(MutationObserver).call(this, document));

		_this._config = {
			childList: true,
			characterData: true,
			characterDataOldValue: true,
			subtree: true
		};

		/**
   * Reference to the {@link engine.view.Document#domConverter}.
   *
   * @member {engine.view.DomConverter} engine.view.observer.MutationObserver#domConverter
   */
		_this.domConverter = document.domConverter;

		/**
   * Reference to the {@link engine.view.Document#renderer}.
   *
   * @member {engine.view.Renderer} engine.view.observer.MutationObserver#renderer
   */
		_this.renderer = document.renderer;

		/**
   * Observed DOM elements.
   *
   * @private
   * @member {Array.<HTMLElement>} engine.view.observer.MutationObserver#_domElements
   */
		_this._domElements = [];

		/**
   * Native mutation observer.
   *
   * @private
   * @member {MutationObserver} engine.view.observer.MutationObserver#_mutationObserver
   */
		_this._mutationObserver = new window.MutationObserver(_this._onMutations.bind(_this));
		return _this;
	}

	/**
  * Synchronously fires {@link engine.view.Document#mutations} event with all mutations in record queue.
  * At the same time empties the queue so mutations will not be fired twice.
  */


	createClass(MutationObserver, [{
		key: 'flush',
		value: function flush() {
			this._onMutations(this._mutationObserver.takeRecords());
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'observe',
		value: function observe(domElement) {
			this._domElements.push(domElement);

			if (this.isEnabled) {
				this._mutationObserver.observe(domElement, this._config);
			}
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'enable',
		value: function enable() {
			get(Object.getPrototypeOf(MutationObserver.prototype), 'enable', this).call(this);

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = this._domElements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var domElement = _step.value;

					this._mutationObserver.observe(domElement, this._config);
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'disable',
		value: function disable() {
			get(Object.getPrototypeOf(MutationObserver.prototype), 'disable', this).call(this);

			this._mutationObserver.disconnect();
		}

		/**
   * Handles mutations. Deduplicates, mark view elements to sync, fire event and call render.
   *
   * @private
   * @method engine.view.observer.MutationObserver#_onMutations
   * @param {Array.<Object>} domMutations Array of native mutations.
   */

	}, {
		key: '_onMutations',
		value: function _onMutations(domMutations) {
			// As a result of this.flush() we can have an empty collection.
			if (domMutations.length === 0) {
				return;
			}

			var domConverter = this.domConverter;

			// Use　map and set for deduplication.
			var mutatedTexts = new Map();
			var mutatedElements = new Set();

			// Handle `childList` mutations first, so we will be able to check if the `characterData` mutation is in the
			// element with changed structure anyway.
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = domMutations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var mutation = _step2.value;

					if (mutation.type === 'childList') {
						var element = domConverter.getCorrespondingViewElement(mutation.target);

						if (element) {
							mutatedElements.add(element);
						}
					}
				}

				// Handle `characterData` mutations later, when we have the full list of nodes which changed structure.
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = domMutations[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var _mutation = _step3.value;

					if (_mutation.type === 'characterData') {
						var text = domConverter.getCorrespondingViewText(_mutation.target);

						if (text && !mutatedElements.has(text.parent)) {
							// Use text as a key, for deduplication. If there will be another mutation on the same text element
							// we will have only one in the map.
							mutatedTexts.set(text, {
								type: 'text',
								oldText: text.data,
								newText: getDataWithoutFiller(_mutation.target),
								node: text
							});
						}
						// When we added first letter to the text node which had only inline filler, for the DOM it is mutation
						// on text, but for the view, where filler text node did not existed, new text node was created, so we
						// need to fire 'children' mutation instead of 'text'.
						else if (!text && startsWithFiller(_mutation.target)) {
								mutatedElements.add(domConverter.getCorrespondingViewElement(_mutation.target.parentNode));
							}
					}
				}

				// Now we build the list of mutations to fire and mark elements. We did not do it earlier to avoid marking the
				// same node multiple times in case of duplication.

				// List of mutations we will fire.
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}

			var viewMutations = [];

			var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
				for (var _iterator4 = mutatedTexts.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var mutatedText = _step4.value;

					this.renderer.markToSync('text', mutatedText.node);
					viewMutations.push(mutatedText);
				}
			} catch (err) {
				_didIteratorError4 = true;
				_iteratorError4 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion4 && _iterator4.return) {
						_iterator4.return();
					}
				} finally {
					if (_didIteratorError4) {
						throw _iteratorError4;
					}
				}
			}

			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = mutatedElements[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var viewElement = _step5.value;

					var domElement = domConverter.getCorrespondingDomElement(viewElement);
					var viewChildren = viewElement.getChildren();
					var newViewChildren = domConverter.domChildrenToView(domElement);

					this.renderer.markToSync('children', viewElement);
					viewMutations.push({
						type: 'children',
						oldChildren: Array.from(viewChildren),
						newChildren: Array.from(newViewChildren),
						node: viewElement
					});
				}

				// Retrieve `domSelection` using `ownerDocument` of one of mutated nodes.
				// There should not be simultaneous mutation in multiple documents, so it's fine.
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5.return) {
						_iterator5.return();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}

			var domSelection = domMutations[0].target.ownerDocument.getSelection();

			var viewSelection = null;

			if (domSelection && domSelection.anchorNode) {
				// If `domSelection` is inside a dom node that is already bound to a view node from view tree, get
				// corresponding selection in the view and pass it together with `viewMutations`. The `viewSelection` may
				// be used by features handling mutations.
				// Only one range is supported.

				var viewSelectionAnchor = domConverter.domPositionToView(domSelection.anchorNode, domSelection.anchorOffset);
				var viewSelectionFocus = domConverter.domPositionToView(domSelection.focusNode, domSelection.focusOffset);

				// Anchor and focus has to be properly mapped to view.
				if (viewSelectionAnchor && viewSelectionFocus) {
					viewSelection = new Selection$1();
					viewSelection.collapse(viewSelectionAnchor);
					viewSelection.setFocus(viewSelectionFocus);
				}
			}

			this.document.fire('mutations', viewMutations, viewSelection);

			// If nothing changes on `mutations` event, at this point we have "dirty DOM" (changed) and de-synched
			// view (which has not been changed). In order to "reset DOM" we render the view again.
			this.document.render();
		}
	}]);
	return MutationObserver;
}(Observer);

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Selection observer class observes selection changes in the document. If selection changes on the document this
 * observer checks if there are any mutations and if DOM selection is different than the
 * {@link engine.view.Document#selection view selection}. Selection observer fires
 * {@link engine.view.Document#selectionChange} event only if selection change was the only change in the document
 * and DOM selection is different then the view selection.
 *
 * Note that this observer is attached by the {@link engine.view.Document} and is available by default.
 *
 * @see engine.view.MutationObserver
 * @memberOf engine.view.observer
 * @extends engine.view.observer.Observer
 */

var SelectionObserver = function (_Observer) {
	inherits(SelectionObserver, _Observer);

	function SelectionObserver(document) {
		classCallCheck(this, SelectionObserver);

		/**
   * Instance of the mutation observer. Selection observer calls
   * {@link engine.view.observer.MutationObserver#flush} to ensure that the mutations will be handled before the
   * {@link engine.view.Document#selectionChange} event is fired.
   *
   * @readonly
   * @member {engine.view.observer.MutationObserver} engine.view.observer.SelectionObserver#mutationObserver
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(SelectionObserver).call(this, document));

		_this.mutationObserver = document.getObserver(MutationObserver);

		/**
   * Reference to the {@link engine.view.Document} object.
   *
   * @readonly
   * @member {engine.view.Document} engine.view.observer.SelectionObserver#document
   */
		_this.document = document;

		/**
   * Reference to the view {@link engine.view.Selection} object used to compare new selection with it.
   *
   * @readonly
   * @member {engine.view.Selection} engine.view.observer.SelectionObserver#selection
   */
		_this.selection = document.selection;

		/**
   * Reference to the {@link engine.view.Document#domConverter}.
   *
   * @readonly
   * @member {engine.view.DomConverter} engine.view.observer.SelectionObserver#domConverter
   */
		_this.domConverter = document.domConverter;

		/**
   * Set of documents which have added "selectionchange" listener to avoid adding listener twice to the same
   * document.
   *
   * @private
   * @member {WeakSet.<Document>} engine.view.observer.SelectionObserver#_documents
   */
		_this._documents = new WeakSet();

		/**
   * Private property to store the last selection, to check if the code does not enter infinite loop.
   *
   * @private
   * @member {engine.view.Selection} engine.view.observer.SelectionObserver#_lastSelection
   */

		/**
   * Private property to store the last but one selection, to check if the code does not enter infinite loop.
   *
   * @private
   * @member {engine.view.Selection} engine.view.observer.SelectionObserver#_lastButOneSelection
   */

		/**
   * Private property to check if the code does not enter infinite loop.
   *
   * @private
   * @member {Number} engine.view.observer.SelectionObserver#_loopbackCounter
   */
		return _this;
	}

	/**
  * @inheritDoc
  */


	createClass(SelectionObserver, [{
		key: 'observe',
		value: function observe(domElement) {
			var _this2 = this;

			var domDocument = domElement.ownerDocument;

			// Add listener once per each document.
			if (this._documents.has(domDocument)) {
				return;
			}

			domDocument.addEventListener('selectionchange', function () {
				return _this2._handleSelectionChange(domDocument);
			});

			this._documents.add(domDocument);
		}

		/**
   * Selection change listener. {@link engine.view.observer.MutationObserver#flush Flush} mutations, check if
   * selection changes and fires {@link engine.view.Document#selectionChange} event.
   *
   * @private
   * @param {Document} domDocument DOM document.
   */

	}, {
		key: '_handleSelectionChange',
		value: function _handleSelectionChange(domDocument) {
			if (!this.isEnabled || !this.document.isFocused) {
				return;
			}

			// Ensure the mutation event will be before selection event on all browsers.
			this.mutationObserver.flush();

			// If there were mutations then the view will be re-rendered by the mutation observer and selection
			// will be updated, so selections will equal and event will not be fired, as expected.
			var domSelection = domDocument.defaultView.getSelection();
			var newViewSelection = this.domConverter.domSelectionToView(domSelection);

			if (this.selection.isEqual(newViewSelection)) {
				return;
			}

			// Ensure we are not in the infinite loop (#400).
			if (this._isInfiniteLoop(newViewSelection)) {
				/**
     * Selection change observer detected an infinite rendering loop.
     * Most probably you try to put the selection in the position which is not allowed
     * by the browser and browser fixes it automatically what causes `selectionchange` event on
     * which a loopback through a model tries to re-render the wrong selection and again.
     *
     * @error selectionchange-infinite-loop
     */
				log.warn('selectionchange-infinite-loop: Selection change observer detected an infinite rendering loop.');

				return;
			}

			// Should be fired only when selection change was the only document change.
			this.document.fire('selectionChange', {
				oldSelection: this.selection,
				newSelection: newViewSelection,
				domSelection: domSelection
			});

			// If nothing changes on `selectionChange` event, at this point we have "dirty DOM" (changed) and de-synched
			// view (which has not been changed). In order to "reset DOM" we render the view again.
			this.document.render();
		}

		/**
   * Checks if selection rendering entered an infinite loop.
   *
   * See https://github.com/ckeditor/ckeditor5-engine/issues/400.
   *
   * @private
   * @param {engine.view.Selection} newSelection DOM selection converted to view.
   * @returns {Boolean} True is the same selection repeat more then 10 times.
   */

	}, {
		key: '_isInfiniteLoop',
		value: function _isInfiniteLoop(newSelection) {
			// If the position is the same a the last one or the last but one we increment the counter.
			// We need to check last two selections because the browser will first fire a selectionchange event
			// for an incorrect selection and then for a corrected one.
			if (this._lastSelection && this._lastButOneSelection && (newSelection.isEqual(this._lastSelection) || newSelection.isEqual(this._lastButOneSelection))) {
				this._loopbackCounter++;
			} else {
				this._lastButOneSelection = this._lastSelection;
				this._lastSelection = newSelection;
				this._loopbackCounter = 0;
			}

			if (this._loopbackCounter > 10) {
				return true;
			}

			return false;
		}
	}]);
	return SelectionObserver;
}(Observer);

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Information about a DOM event in context of the {@link engine.view.Document}.
 * It wraps the native event, which usually should not be used as the wrapper contains
 * additional data (like key code for keyboard events).
 *
 * @memberOf engine.view.observer
 */

var DomEventData = function () {
	/**
  * @param {engine.view.Document} document The instance of the tree view Document.
  * @param {Event} domEvent The DOM event.
  * @param {Object} [additionalData] Additional properties that the instance should contain.
  */
	function DomEventData(document, domEvent, additionalData) {
		classCallCheck(this, DomEventData);

		/**
   * The instance of the document.
   *
   * @readonly
   * @member {engine.view.Document} engine.view.observer.DomEvent#view
   */
		this.document = document;

		/**
   * The DOM event.
   *
   * @readonly
   * @member {Event} engine.view.observer.DomEvent#domEvent
   */
		this.domEvent = domEvent;

		/**
   * The DOM target.
   *
   * @readonly
   * @member {HTMLElement} engine.view.observer.DomEvent#target
   */
		this.domTarget = domEvent.target;

		assignIn(this, additionalData);
	}

	/**
  * The tree view element representing the target.
  *
  * @readonly
  * @type engine.view.Element
  */


	createClass(DomEventData, [{
		key: 'preventDefault',


		/**
   * Prevents the native's event default action.
   */
		value: function preventDefault() {
			this.domEvent.preventDefault();
		}

		/**
   * Stops native event propagation.
   */

	}, {
		key: 'stopPropagation',
		value: function stopPropagation() {
			this.domEvent.stopPropagation();
		}
	}, {
		key: 'target',
		get: function get() {
			return this.document.domConverter.getCorrespondingViewElement(this.domTarget);
		}
	}]);
	return DomEventData;
}();

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Base class for DOM event observers. This class handles
 * {@link engine.view.observer.Observer#observe adding} listeners to DOM elements,
 * {@link engine.view.observer.Observer#disable disabling} and
 * {@link engine.view.observer.Observer#enable re-enabling} events.
 * Child class needs to define
 * {@link engine.view.observer.DomEventObserver#domEventType DOM event type} and
 * {@link engine.view.observer.DomEventObserver#onDomEvent callback}.
 *
 * For instance:
 *
 *		class ClickObserver extends DomEventObserver {
 *			// It can also be defined as a normal property in the constructor.
 *			get domEventType() {
 *				return 'click';
 *			}
 *
 *			onDomEvent( domEvent ) {
 *				this.fire( 'click', domEvent );
 *			}
 *		}
 *
 * @memberOf engine.view.observer
 * @extends engine.view.observer.Observer
 */

var DomEventObserver = function (_Observer) {
	inherits(DomEventObserver, _Observer);

	function DomEventObserver() {
		classCallCheck(this, DomEventObserver);
		return possibleConstructorReturn(this, Object.getPrototypeOf(DomEventObserver).apply(this, arguments));
	}

	createClass(DomEventObserver, [{
		key: 'observe',

		/**
   * Type of the DOM event the observer should listen on. Array of types can be defined
   * if the obsever should listen to multiple DOM events.
   *
   * @readonly
   * @member {String|Array.<String>} engine.view.observer.DomEventObserver#domEventType
   */

		/**
   * Callback which should be called when the DOM event occurred. Note that the callback will not be called if
   * observer {@link engine.view.observer.DomEventObserver#isEnabled is not enabled}.
   *
   * @see engine.view.observer.DomEventObserver#domEventType
   * @abstract
   * @method engine.view.observer.DomEventObserver#onDomEvent
   */

		/**
   * @inheritDoc
   */
		value: function observe(domElement) {
			var _this2 = this;

			var types = typeof this.domEventType == 'string' ? [this.domEventType] : this.domEventType;

			types.forEach(function (type) {
				domElement.addEventListener(type, function (domEvent) {
					return _this2.isEnabled && _this2.onDomEvent(domEvent);
				});
			});
		}

		/**
   * Calls {@link engine.view.Document#fire} if observer
   * {@link engine.view.observer.DomEventObserver#isEnabled is enabled}.
   *
   * @see engine.view.Document#fire
   * @param {String} eventType The event type (name).
   * @param {Event} domEvent The DOM event.
   * @param {Object} [additionalData] The additional data which should extend the
   * {@link engine.view.observer.DomEventData event data} object.
   */

	}, {
		key: 'fire',
		value: function fire(eventType, domEvent, additionalData) {
			if (this.isEnabled) {
				this.document.fire(eventType, new DomEventData(this.document, domEvent, additionalData));
			}
		}
	}]);
	return DomEventObserver;
}(Observer);

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * {@link engine.view.Document#focus Focus} and {@link engine.view.Document#blur blur} events observer.
 * Focus observer handle also {@link engine.view.RootEditableElement#isFocused isFocused} property of the
 * {@link engine.view.RootEditableElement root elements}.
 *
 * Note that this observer is attached by the {@link engine.view.Document} and is available by default.
 *
 * @memberOf engine.view.observer
 * @extends engine.view.observer.DomEventObserver
 */

var FocusObserver = function (_DomEventObserver) {
  inherits(FocusObserver, _DomEventObserver);

  function FocusObserver(document) {
    classCallCheck(this, FocusObserver);

    var _this = possibleConstructorReturn(this, Object.getPrototypeOf(FocusObserver).call(this, document));

    _this.domEventType = ['focus', 'blur'];

    document.on('focus', function () {
      document.isFocused = true;
    });

    document.on('blur', function (evt, data) {
      var selectedEditable = document.selection.editableElement;

      if (selectedEditable === null || selectedEditable === data.target) {
        document.isFocused = false;
      }
    });
    return _this;
  }

  createClass(FocusObserver, [{
    key: 'onDomEvent',
    value: function onDomEvent(domEvent) {
      this.fire(domEvent.type, domEvent);
    }
  }]);
  return FocusObserver;
}(DomEventObserver);

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * {@link engine.view.Document#keydown Key down} event observer.
 *
 * Note that this observer is attached by the {@link engine.view.Document} and is available by default.
 *
 * @memberOf engine.view.observer
 * @extends engine.view.observer.DomEventObserver
 */

var KeyObserver = function (_DomEventObserver) {
  inherits(KeyObserver, _DomEventObserver);

  function KeyObserver(document) {
    classCallCheck(this, KeyObserver);

    var _this = possibleConstructorReturn(this, Object.getPrototypeOf(KeyObserver).call(this, document));

    _this.domEventType = 'keydown';
    return _this;
  }

  createClass(KeyObserver, [{
    key: 'onDomEvent',
    value: function onDomEvent(domEvt) {
      this.fire('keydown', domEvt, {
        keyCode: domEvt.keyCode,

        altKey: domEvt.altKey,
        ctrlKey: domEvt.ctrlKey || domEvt.metaKey,
        shiftKey: domEvt.shiftKey,

        get keystroke() {
          return getCode(this);
        }
      });
    }
  }]);
  return KeyObserver;
}(DomEventObserver);

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Fake selection observer class. If view selection is fake it is placed in dummy DOM container. This observer listens
 * on {@link engine.view.Document#keydown keydown} events and handles moving fake view selection to the correct place
 * if arrow keys are pressed.
 * Fires {@link engine.view.Document#selectionChage selectionChange event} simulating natural behaviour of
 * {@link engine.view.observer.SelectionObserver SelectionObserver}.
 *
 * @memberOf engine.view.observer
 * @extends engine.view.observer.Observer
 */

var FakeSelectionObserver = function (_Observer) {
	inherits(FakeSelectionObserver, _Observer);

	/**
  * Creates new FakeSelectionObserver instance.
  *
  * @param {engine.view.Document} document
  */
	function FakeSelectionObserver(document) {
		classCallCheck(this, FakeSelectionObserver);
		return possibleConstructorReturn(this, Object.getPrototypeOf(FakeSelectionObserver).call(this, document));
	}

	/**
  * @inheritDoc
  */


	createClass(FakeSelectionObserver, [{
		key: 'observe',
		value: function observe() {
			var _this2 = this;

			var document = this.document;

			document.on('keydown', function (eventInfo, data) {
				var selection = document.selection;

				if (selection.isFake && _isArrowKeyCode(data.keyCode) && _this2.isEnabled) {
					// Prevents default key down handling - no selection change will occur.
					data.preventDefault();

					_this2._handleSelectionMove(data.keyCode);
				}
			}, { priority: 'lowest' });
		}

		/**
   * Handles collapsing view selection according to given key code. If left or up key is provided - new selection will be
   * collapsed to left. If right or down key is pressed - new selection will be collapsed to right.
   *
   * This method fires {@link engine.view.Document#selectionChange} event imitating behaviour of
   * {@link engine.view.observer.SelectionObserver}.
   *
   * @private
   * @param {Number} keyCode
   * @fires engine.view.Document#selectionChage
   */

	}, {
		key: '_handleSelectionMove',
		value: function _handleSelectionMove(keyCode) {
			var selection = this.document.selection;
			var newSelection = Selection$1.createFromSelection(selection);
			newSelection.setFake(false);

			// Left or up arrow pressed - move selection to start.
			if (keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup) {
				newSelection.collapseToStart();
			}

			// Right or down arrow pressed - move selection to end.
			if (keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowdown) {
				newSelection.collapseToEnd();
			}

			// Fire dummy selection change event.
			this.document.fire('selectionChange', {
				oldSelection: selection,
				newSelection: newSelection,
				domSelection: null
			});
		}
	}]);
	return FakeSelectionObserver;
}(Observer);

function _isArrowKeyCode(keyCode) {
	return keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup || keyCode == keyCodes.arrowdown;
}

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Document class creates an abstract layer over the content editable area.
 * It combines the actual tree of view elements, tree of DOM elements,
 * {@link engine.view.DomConverter DOM Converter}, {@link engine.view.Renderer renderer} and all
 * {@link engine.view.Observer observers}.
 *
 * If you want to only transform the tree of view elements to the DOM elements you can use the
 * {@link engine.view.DomConverter DomConverter}.
 *
 * Note that the following observers are added by the class constructor and are always available:
 *
 * * {@link view.observer.MutationObserver},
 * * {@link view.observer.SelectionObserver},
 * * {@link view.observer.FocusObserver},
 * * {@link view.observer.KeyObserver},
 * * {@link view.observer.FakeSelectionObserver}.
 *
 * @memberOf engine.view
 * @mixes utils.EmitterMixin
 */

var Document$1 = function () {
	/**
  * Creates a Document instance.
  */
	function Document() {
		var _this = this;

		classCallCheck(this, Document);

		/**
   * Roots of the DOM tree. Map on the `HTMLElement`s with roots names as keys.
   *
   * @readonly
   * @member {Map} engine.view.Document#domRoots
   */
		this.domRoots = new Map();

		/**
   * Selection done on this document.
   *
   * @readonly
   * @member {engine.view.Selection} engine.view.Document#selection
   */
		this.selection = new Selection$1();

		/**
   * Instance of the {@link engine.view.DomConverter domConverter} use by
   * {@link engine.view.Document#renderer renderer} and {@link engine.view.observer.Observer observers}.
   *
   * @readonly
   * @member {engine.view.DomConverter} engine.view.Document#domConverter
   */
		this.domConverter = new DomConverter();

		/**
   * Roots of the view tree. Map of the {engine.view.Element view elements} with roots names as keys.
   *
   * @readonly
   * @member {Map} engine.view.Document#roots
   */
		this.roots = new Map();

		/**
   * True if document is focused.
   *
   * This property is updated by the {@link engine.view.obsever.FocusObserver}.
   * If the {@link engine.view.obsever.FocusObserver} is disabled this property will not change.
   *
   * @readonly
   * @observable
   * @member {Boolean} engine.view.Document#isFocused
   */
		this.set('isFocused', false);

		/**
   * Instance of the {@link engine.view.Document#renderer renderer}.
   *
   * @readonly
   * @member {engine.view.Renderer} engine.view.Document#renderer
   */
		this.renderer = new Renderer(this.domConverter, this.selection);
		this.renderer.bind('isFocused').to(this, 'isFocused');

		/**
   * Map of registered {@link engine.view.Observer observers}.
   *
   * @private
   * @member {Map.<Function, engine.view.Observer>} engine.view.Document#_observers
   */
		this._observers = new Map();

		// Add default observers.
		this.addObserver(MutationObserver);
		this.addObserver(SelectionObserver);
		this.addObserver(FocusObserver);
		this.addObserver(KeyObserver);
		this.addObserver(FakeSelectionObserver);

		injectQuirksHandling(this);

		// Listens `render` event on default priority.
		// This way we can attach other listeners before or after rendering execution.
		this.on('render', function () {
			_this.disableObservers();
			_this.renderer.render();
			_this.enableObservers();
		});
	}

	/**
  * Creates observer of the given type if not yet created, {@link engine.view.Observer#enable enables} it
  * and {@link engine.view.observer.Observer#observe attaches} to all existing and future
  * {@link engine.view.Document#domRoots DOM roots}.
  *
  * Note: Observers are recognized by their constructor (classes). A single observer will be instantiated and used only
  * when registered for the first time. This means that features and other components can register a single observer
  * multiple times without caring whether it has been already added or not.
  *
  * @param {Function} Observer The constructor of an observer to add.
  * Should create an instance inheriting from {@link engine.view.observer.Observer}.
  * @returns {engine.view.observer.Observer} Added observer instance.
  */


	createClass(Document, [{
		key: 'addObserver',
		value: function addObserver(Observer) {
			var observer = this._observers.get(Observer);

			if (observer) {
				return observer;
			}

			observer = new Observer(this);

			this._observers.set(Observer, observer);

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = this.domRoots[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var _step$value = slicedToArray(_step.value, 2);

					var name = _step$value[0];
					var domElement = _step$value[1];

					observer.observe(domElement, name);
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			observer.enable();

			return observer;
		}

		/**
   * Returns observer of the given type or `undefined` if such observer has not been added yet.
   *
   * @param {Function} Observer The constructor of an observer to get.
   * @returns {engine.view.observer.Observer|undefined} Observer instance or undefined.
   */

	}, {
		key: 'getObserver',
		value: function getObserver(Observer) {
			return this._observers.get(Observer);
		}

		/**
   * Creates a {@link engine.view.Document#roots view root element}.
   *
   * If the DOM element is passed as a first parameter it will be automatically
   * {@link engine.view.Document#attachDomRoot attached}:
   *
   *		document.createRoot( document.querySelector( 'div#editor' ) ); // Will call document.attachDomRoot.
   *
   * However, if the string is passed, then only the view element will be created and the DOM element have to be
   * attached separately:
   *
   *		document.createRoot( 'body' );
   *		document.attachDomRoot( document.querySelector( 'body#editor' ) );
   *
   * In both cases, {@link engine.view.RootEditableElement#name element name} is always transformed to lower case.
   *
   * @param {Element|String} domRoot DOM root element or the tag name of view root element if the DOM element will be
   * attached later.
   * @param {String} [name='main'] Name of the root.
   * @returns {engine.view.RootEditableElement} The created view root element.
   */

	}, {
		key: 'createRoot',
		value: function createRoot(domRoot) {
			var _this2 = this;

			var name = arguments.length <= 1 || arguments[1] === undefined ? 'main' : arguments[1];

			var rootTag = typeof domRoot == 'string' ? domRoot : domRoot.tagName;

			var viewRoot = new RootEditableElement(this, rootTag.toLowerCase(), name);

			this.roots.set(name, viewRoot);

			// Mark changed nodes in the renderer.
			viewRoot.on('change:children', function (evt, node) {
				return _this2.renderer.markToSync('children', node);
			});
			viewRoot.on('change:attributes', function (evt, node) {
				return _this2.renderer.markToSync('attributes', node);
			});
			viewRoot.on('change:text', function (evt, node) {
				return _this2.renderer.markToSync('text', node);
			});

			if (this.domConverter.isElement(domRoot)) {
				this.attachDomRoot(domRoot, name);
			}

			return viewRoot;
		}

		/**
   * Attaches DOM root element to the view element and enable all observers on that element. This method also
   * {@link engine.view.Renderer#markToSync mark element} to be synchronized with the view what means that all child
   * nodes will be removed and replaced with content of the view root.
   *
   * Note that {@link engine.view.Document#createRoot} will call this method automatically if the DOM element is
   * passed to it.
   *
   * @param {Element|String} domRoot DOM root element.
   * @param {String} [name='main'] Name of the root.
   */

	}, {
		key: 'attachDomRoot',
		value: function attachDomRoot(domRoot) {
			var name = arguments.length <= 1 || arguments[1] === undefined ? 'main' : arguments[1];

			var viewRoot = this.getRoot(name);

			this.domRoots.set(name, domRoot);

			this.domConverter.bindElements(domRoot, viewRoot);

			this.renderer.markToSync('children', viewRoot);
			this.renderer.domDocuments.add(domRoot.ownerDocument);

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = this._observers.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var observer = _step2.value;

					observer.observe(domRoot, name);
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}
		}

		/**
   * Gets a {@link engine.view.Document#roots view root element} with the specified name. If the name is not
   * specific "main" root is returned.
   *
   * @param {String} [name='main'] Name of the root.
   * @returns {engine.view.RootEditableElement} The view root element with the specified name.
   */

	}, {
		key: 'getRoot',
		value: function getRoot() {
			var name = arguments.length <= 0 || arguments[0] === undefined ? 'main' : arguments[0];

			return this.roots.get(name);
		}

		/**
   * Gets DOM root element.
   *
   * @param {String} [name='main']  Name of the root.
   * @returns {Element} DOM root element instance.
   */

	}, {
		key: 'getDomRoot',
		value: function getDomRoot() {
			var name = arguments.length <= 0 || arguments[0] === undefined ? 'main' : arguments[0];

			return this.domRoots.get(name);
		}

		/**
   * Renders all changes. In order to avoid triggering the observers (e.g. mutations) all observers are disabled
   * before rendering and re-enabled after that.
   *
   * @fires engine.view.Document#render
   */

	}, {
		key: 'render',
		value: function render() {
			this.fire('render');
		}

		/**
   * Focuses document. It will focus {@link engine.view.EditableElement EditableElement} that is currently having
   * selection inside.
   */

	}, {
		key: 'focus',
		value: function focus() {
			if (!this.isFocused) {
				var editable = this.selection.editableElement;

				if (editable) {
					this.domConverter.focus(editable);
					this.render();
				} else {
					/**
      * Before focusing view document, selection should be placed inside one of the view's editables.
      * Normally its selection will be converted from model document (which have default selection), but
      * when using view document on its own, we need to manually place selection before focusing it.
      *
      * @error view-focus-no-selection
      */
					log.warn('view-focus-no-selection: There is no selection in any editable to focus.');
				}
			}
		}

		/**
   * Disables all added observers.
   */

	}, {
		key: 'disableObservers',
		value: function disableObservers() {
			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = this._observers.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var observer = _step3.value;

					observer.disable();
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}
		}

		/**
   * Enables all added observers.
   */

	}, {
		key: 'enableObservers',
		value: function enableObservers() {
			var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
				for (var _iterator4 = this._observers.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var observer = _step4.value;

					observer.enable();
				}
			} catch (err) {
				_didIteratorError4 = true;
				_iteratorError4 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion4 && _iterator4.return) {
						_iterator4.return();
					}
				} finally {
					if (_didIteratorError4) {
						throw _iteratorError4;
					}
				}
			}
		}
	}]);
	return Document;
}();

mix(Document$1, ObservableMixin);

/**
 * Enum representing type of the change.
 *
 * Possible values:
 *
 * * `children` - for child list changes,
 * * `attributes` - for element attributes changes,
 * * `text` - for text nodes changes.
 *
 * @typedef {String} engine.view.ChangeType
 */

/**
 * Fired when {@link engine.view.Document#render render} method is called. Actual rendering is executed as a listener to
 * this event with default priority. This way other listeners can be used to run code before or after rendering.
 *
 * @event engine.view.Document.render
 */

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Contains {@link engine.view.Selection view selection} to {@link engine.model.Selection model selection} conversion
 * helper.
 *
 * @namespace engine.conversion.viewSelectionToModel
 */

/**
 * Function factory, creates a callback function which converts a {@link engine.view.Selection view selection} taken
 * from the {@link engine.view.Document#selectionChange} event and sets in on the {@link engine.model.Document#selection model}.
 *
 * **Note**: because there is no view selection change dispatcher nor any other advanced view selection to model
 * conversion mechanism, the callback should be set directly on view document.
 *
 *		view.document.on( 'selectionChange', convertSelectionChange( modelDocument, mapper ) );
 *
 * @function engine.conversion.viewSelectionToModel.convertSelectionChange
 * @param {engine.model.Document} modelDocument Model document on which selection should be updated.
 * @param {engine.conversion.Mapper} mapper Conversion mapper.
 * @returns {Function} {@link engine.view.Document#selectionChange} callback function.
 */
function convertSelectionChange(modelDocument, mapper) {
  return function (evt, data) {
    modelDocument.enqueueChanges(function () {
      var viewSelection = data.newSelection;
      var ranges = [];

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = viewSelection.getRanges()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var viewRange = _step.value;

          ranges.push(mapper.toModelRange(viewRange));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      modelDocument.selection.setRanges(ranges, viewSelection.isBackward);
    });
  };
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Contains {@link engine.model.Selection model selection} to {@link engine.view.Selection view selection} converters for
 * {@link engine.conversion.ModelConversionDispatcher}.
 *
 * @namespace engine.conversion.modelSelectionToView
 */

/**
 * Function factory, creates a converter that converts non-collapsed {@link engine.model.Selection model selection} to
 * {@link engine.view.Selection view selection}. The converter consumes appropriate value from `consumable` object
 * and maps model positions from selection to view positions.
 *
 *		modelDispatcher.on( 'selection', convertRangeSelection() );
 *
 * @external engine.conversion.modelSelectionToView
 * @function engine.conversion.modelSelectionToView.convertRangeSelection
 * @returns {Function} Selection converter.
 */
function convertRangeSelection() {
  return function (evt, data, consumable, conversionApi) {
    var selection = data.selection;

    if (selection.isCollapsed) {
      return;
    }

    if (!consumable.consume(selection, 'selection')) {
      return;
    }

    conversionApi.viewSelection.removeAllRanges();

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = selection.getRanges()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var range = _step.value;

        var viewRange = conversionApi.mapper.toViewRange(range);
        conversionApi.viewSelection.addRange(viewRange, selection.isBackward);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  };
}

/**
 * Function factory, creates a converter that converts collapsed {@link engine.model.Selection model selection} to
 * {@link engine.view.Selection view selection}. The converter consumes appropriate value from `consumable` object,
 * maps model selection position to view position and breaks {@link engine.view.AttributeElement attribute elements}
 * at the selection position.
 *
 *		modelDispatcher.on( 'selection', convertCollapsedSelection() );
 *
 * Example of view state before and after converting collapsed selection:
 *
 *		   <p><strong>f^oo<strong>bar</p>
 *		-> <p><strong>f</strong>^<strong>oo</strong>bar</p>
 *
 * By breaking attribute elements like `<strong>`, selection is in correct element. See also complementary
 * {@link engine.conversion.modelSelectionToView.convertSelectionAttribute attribute converter} for selection attributes,
 * which wraps collapsed selection into view elements. Those converters together ensure, that selection ends up in
 * appropriate attribute elements.
 *
 * See also {@link engine.conversion.modelSelectionToView.clearAttributes} which does a clean-up by merging attributes.
 *
 * @external engine.conversion.modelSelectionToView
 * @function engine.conversion.modelSelectionToView.convertCollapsedSelection
 * @returns {Function} Selection converter.
 */
function convertCollapsedSelection() {
  return function (evt, data, consumable, conversionApi) {
    var selection = data.selection;

    if (!selection.isCollapsed) {
      return;
    }

    if (!consumable.consume(selection, 'selection')) {
      return;
    }

    var modelPosition = selection.getFirstPosition();
    var viewPosition = conversionApi.mapper.toViewPosition(modelPosition);
    var brokenPosition = viewWriter.breakAttributes(viewPosition);

    conversionApi.viewSelection.removeAllRanges();
    conversionApi.viewSelection.addRange(new Range$2(brokenPosition, brokenPosition));
  };
}

/**
 * Function factory, creates a converter that converts {@link engine.model.Selection model selection} attributes to
 * {@link engine.view.AttributeElement view attribute elements}. The converter works only for collapsed selection.
 * The converter consumes appropriate value from `consumable` object, maps model selection position to view position and
 * wraps that position into a view attribute element.
 *
 * The wrapping node depends on passed parameter. If {@link engine.view.Element} was passed, it will be cloned and
 * the copy will become the wrapping element. If `Function` is provided, it is passed all the parameters of the
 * {@link engine.conversion.ModelConversionDispatcher#event:selectionAttribute selectionAttribute event}. It's expected that
 * the function returns a {@link engine.view.AttributeElement}. The result of the function will be the wrapping element.
 *
 *		modelDispatcher.on( 'selectionAttribute:italic', convertSelectionAttribute( new ViewAttributeElement( 'em' ) ) );
 *
 *		function styleElementCreator( styleValue ) {
 *			if ( styleValue == 'important' ) {
 *				return new ViewAttributeElement( 'strong', { style: 'text-transform:uppercase;' } );
 *			} else if ( styleValue == 'gold' ) {
 *				return new ViewAttributeElement( 'span', { style: 'color:yellow;' } );
 *			}
 *		}
 *		modelDispatcher.on( 'selectionAttribute:style', convertSelectionAttribute( styleCreator ) );
 *
 * **Note:** You can use the same `elementCreator` function for this converter factory and {@link engine.conversion.modelToView.wrap}
 * model to view converter, as long as the `elementCreator` function uses only the first parameter (attribute value).
 *
 *		modelDispatcher.on( 'selection', convertCollapsedSelection() );
 *		modelDispatcher.on( 'selectionAttribute:italic', convertSelectionAttribute( new ViewAttributeElement( 'em' ) ) );
 *		modelDispatcher.on( 'selectionAttribute:bold', convertSelectionAttribute( new ViewAttributeElement( 'strong' ) ) );
 *
 * Example of view states before and after converting collapsed selection:
 *
 *		   <p><em>f^oo</em>bar</p>
 *		-> <p><em>f</em>^<em>oo</em>bar</p>
 *		-> <p><em>f^oo</em>bar</p>
 *
 * Example of view state after converting collapsed selection. The scenario is: selection is inside bold text (`<strong>` element)
 * but it does not have bold attribute itself and has italic attribute instead (let's assume that user turned off bold and turned
 * on italic with selection collapsed):
 *
 *		   <p><strong>f^oo<strong>bar</p>
 *		-> <p><strong>f</strong>^<strong>oo<strong>bar</p>
 *		-> <p><strong>f</strong><em>^</em><strong>oo</strong>bar</p>
 *
 * In first example, nothing has changed, because first `<em>` element got broken by `convertCollapsedSelection()` converter,
 * but then it got wrapped-back by `convertSelectionAttribute()` converter. In second example, notice how `<strong>` element
 * is broken to prevent putting selection in it, since selection has no `bold` attribute.
 *
 * @external engine.conversion.modelSelectionToView
 * @function engine.conversion.modelSelectionToView.convertCollapsedSelection
 * @param {engine.view.AttributeElement|Function} elementCreator View element, or function returning a view element, which will
 * be used for wrapping.
 * @returns {Function} Selection converter.
 */
function convertSelectionAttribute(elementCreator) {
  return function (evt, data, consumable, conversionApi) {
    var selection = data.selection;

    if (!selection.isCollapsed) {
      return;
    }

    if (!consumable.consume(selection, 'selectionAttribute:' + data.key)) {
      return;
    }

    var viewPosition = conversionApi.viewSelection.getFirstPosition();
    conversionApi.viewSelection.removeAllRanges();

    var viewElement = elementCreator instanceof Element$1 ? elementCreator.clone(true) : elementCreator(data.value, data, selection, consumable, conversionApi);

    viewPosition = viewWriter.wrapPosition(viewPosition, viewElement);

    conversionApi.viewSelection.addRange(new Range$2(viewPosition, viewPosition));
  };
}

/**
 * Function factory, creates a converter that clears artifacts after the previous
 * {@link engine.model.Selection model selection} conversion. It removes all empty
 * {@link engine.view.AttributeElement view attribute elements} and merge sibling attributes at all start and end
 * positions of all ranges.
 *
 *		   <p><strong>^</strong></p>
 *		-> <p>^</p>
 *
 *		   <p><strong>foo</strong>^<strong>bar</strong>bar</p>
 *		-> <p><strong>foo^bar<strong>bar</p>
 *
 *		   <p><strong>foo</strong><em>^</em><strong>bar</strong>bar</p>
 *		-> <p><strong>foo^bar<strong>bar</p>
 *
 * This listener should be assigned before any converter for the new selection:
 *
 *		modelDispatcher.on( 'selection', clearAttributes() );
 *
 * See {@link engine.conversion.modelSelectionToView.convertCollapsedSelection} which do the opposite by breaking
 * attributes in the selection position.
 *
 * @external engine.conversion.modelSelectionToView
 * @function engine.conversion.modelSelectionToView.clearAttributes
 * @returns {Function} Selection converter.
 */
function clearAttributes() {
  return function (evt, data, consumable, conversionApi) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = conversionApi.viewSelection.getRanges()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var range = _step2.value;

        // Not collapsed selection should not have artifacts.
        if (range.isCollapsed) {
          // Position might be in the node removed by the view writer.
          if (range.end.parent.document) {
            viewWriter.mergeAttributes(range.start);
          }
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    conversionApi.viewSelection.removeAllRanges();
  };
}

/**
 * Function factory, creates a converter that clears fake selection marking after the previous
 * {@link engine.model.Selection model selection} conversion.
 */
function clearFakeSelection() {
  return function (evt, data, consumable, conversionApi) {
    return conversionApi.viewSelection.setFake(false);
  };
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Controller for the editing pipeline. The editing pipeline controls {@link engine.controller.EditingController#model model} rendering,
 * including selection handling. It also creates {@link engine.controller.EditingController#view view document} which build a
 * browser-independent virtualization over the DOM elements. Editing controller also attach default converters.
 *
 * @memberOf engine.controller
 */

var EditingController = function () {
	/**
  * Creates editing controller instance.
  *
  * @param {engine.model.Document} model Document model.
  */
	function EditingController(model) {
		var _this = this;

		classCallCheck(this, EditingController);

		/**
   * Document model.
   *
   * @readonly
   * @member {engine.model.document} engine.controller.EditingController#model
   */
		this.model = model;

		/**
   * View document.
   *
   * @readonly
   * @member {engine.view.document} engine.controller.EditingController#view
   */
		this.view = new Document$1();

		/**
   * Mapper which describes model-view binding.
   *
   * @readonly
   * @member {engine.conversion.Mapper} engine.controller.EditingController#mapper
   */
		this.mapper = new Mapper();

		/**
   * Model to view conversion dispatcher, which converts changes from the model to
   * {@link engine.controller.EditingController#view editing view}.
   *
   * To attach model to view converter to the editing pipeline you need to add lister to this property:
   *
   *		editing.modelToView( 'insert:$element', customInsertConverter );
   *
   * Or use {@link engine.conversion.ModelConverterBuilder}:
   *
   *		buildModelConverter().for( editing.modelToView ).fromAttribute( 'bold' ).toElement( 'b' );
   *
   * @readonly
   * @member {engine.conversion.ModelConversionDispatcher} engine.controller.EditingController#modelToView
   */
		this.modelToView = new ModelConversionDispatcher({
			mapper: this.mapper,
			viewSelection: this.view.selection
		});

		/**
   * Property keeping all listenters attached by controller on other objects, so it can
   * stop listening on {@link engine.controller.EditingController#destroy}.
   *
   * @private
   * @member {utils.EmitterMixin} engine.controller.EditingController#_listenter
   */
		this._listenter = Object.create(EmitterMixin);

		// Convert changes in model to view.
		this._listenter.listenTo(this.model, 'change', function (evt, type, changes) {
			_this.modelToView.convertChange(type, changes);
		}, { priority: 'low' });

		// Convert model selection to view.
		this._listenter.listenTo(this.model, 'changesDone', function () {
			_this.modelToView.convertSelection(model.selection);
			_this.view.render();
		}, { priority: 'low' });

		// Convert view selection to model.
		this._listenter.listenTo(this.view, 'selectionChange', convertSelectionChange(model, this.mapper));

		// Attach default content converters.
		this.modelToView.on('insert:$text', insertText(), { priority: 'lowest' });
		this.modelToView.on('remove', remove(), { priority: 'low' });
		this.modelToView.on('move', move(), { priority: 'low' });
		this.modelToView.on('rename', rename(), { priority: 'low' });

		// Attach default selection converters.
		this.modelToView.on('selection', clearAttributes(), { priority: 'low' });
		this.modelToView.on('selection', clearFakeSelection(), { priority: 'low' });
		this.modelToView.on('selection', convertRangeSelection(), { priority: 'low' });
		this.modelToView.on('selection', convertCollapsedSelection(), { priority: 'low' });
	}

	/**
  * {@link engine.view.Document#createRoot Creates} a view root and {@link engine.conversion.Mapper#bindElements binds}
  * the model root with view root and and view root with DOM element:
  *
  *		editing.createRoot( document.querySelector( div#editor ) );
  *
  * If the DOM element is not available at the time you want to create a view root, for instance it is iframe body
  * element, it is possible to create view element and bind the DOM element later:
  *
  *		editing.createRoot( 'body' );
  *		editing.view.attachDomRoot( iframe.contentDocument.body );
  *
  * @param {Element|String} domRoot DOM root element or the name of view root element if the DOM element will be
  * attached later.
  * @param {String} [name='main'] Root name.
  * @returns {engine.view.ContainerElement} View root element.
  */


	createClass(EditingController, [{
		key: 'createRoot',
		value: function createRoot(domRoot) {
			var name = arguments.length <= 1 || arguments[1] === undefined ? 'main' : arguments[1];

			var viewRoot = this.view.createRoot(domRoot, name);
			var modelRoot = this.model.getRoot(name);

			this.mapper.bindElements(modelRoot, viewRoot);

			return viewRoot;
		}

		/**
   * Removes all event listeners attached by the EditingController.
   */

	}, {
		key: 'destroy',
		value: function destroy() {
			this._listenter.stopListening();
		}
	}]);
	return EditingController;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* globals HTMLTextAreaElement */

/**
 * Gets data from a given source element.
 *
 * @method utils.dom.getDataFromElement
 * @param {HTMLElement} el The element from which the data will be retrieved.
 * @returns {String} The data string.
 */
function getDataFromElement(el) {
  if (el instanceof HTMLTextAreaElement) {
    return el.value;
  }

  return el.innerHTML;
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* globals HTMLTextAreaElement */

/**
 * Sets data in a given element.
 *
 * @method utils.dom.setDataInElement
 * @param {HTMLElement} el The element in which the data will be set.
 * @param {String} data The data string.
 */
function setDataInElement(el, data) {
  if (el instanceof HTMLTextAreaElement) {
    el.value = data;
  }

  el.innerHTML = data;
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Class representing a typical browser-based editor. It handles a single source element and
 * uses {@link engine.controller.EditingController}.
 *
 * @memberOf core.editor
 */

var StandardEditor = function (_Editor) {
	inherits(StandardEditor, _Editor);

	/**
  * Creates a new instance of the standard editor.
  *
  * @param {HTMLElement} element The DOM element that will be the source
  * for the created editor.
  * @param {Object} config The editor config.
  */
	function StandardEditor(element, config) {
		classCallCheck(this, StandardEditor);

		/**
   * The element on which the editor has been initialized.
   *
   * @readonly
   * @member {HTMLElement} core.editor.StandardEditor#element
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(StandardEditor).call(this, config));

		_this.element = element;

		// Documented in Editor.
		_this.editing = new EditingController(_this.document);

		/**
   * Instance of the {@link core.KeystrokeHandler}.
   *
   * @readonly
   * @member {core.KeystrokeHandler} core.editor.StandardEditor#keystrokes
   */
		_this.keystrokes = new KeystrokeHandler(_this);

		/**
   * Editor UI instance.
   *
   * This property is set by more specialized editor constructors. However, it's required
   * for features to work (their UI-related part will try to interact with editor UI),
   * so every editor class which is meant to work with default features should set this property.
   *
   * @readonly
   * @member {ui.editorUI.EditorUI} core.editor.StandardEditor#ui
   */
		return _this;
	}

	/**
  * @inheritDoc
  */


	createClass(StandardEditor, [{
		key: 'destroy',
		value: function destroy() {
			var _this2 = this;

			return Promise.resolve().then(function () {
				return _this2.editing.destroy();
			}).then(get(Object.getPrototypeOf(StandardEditor.prototype), 'destroy', this).call(this));
		}

		/**
   * Sets the data in the editor's main root.
   *
   * @param {*} data The data to load.
   */

	}, {
		key: 'setData',
		value: function setData(data) {
			this.data.set(data);
		}

		/**
   * Gets the data from the editor's main root.
   */

	}, {
		key: 'getData',
		value: function getData() {
			return this.data.get();
		}

		/**
   * Updates the {@link core.editor.StandardEditor#element editor element}'s content with the data.
   */

	}, {
		key: 'updateEditorElement',
		value: function updateEditorElement() {
			setDataInElement(this.element, this.getData());
		}

		/**
   * Loads the data from the {@link core.editor.StandardEditor#element editor element} to the main root.
   */

	}, {
		key: 'loadDataFromEditorElement',
		value: function loadDataFromEditorElement() {
			this.setData(getDataFromElement(this.element));
		}

		/**
   * Creates a standard editor instance.
   *
   * @param {HTMLElement} element See {@link core.editor.StandardEditor}'s param.
   * @param {Object} config See {@link core.editor.StandardEditor}'s param.
   * @returns {Promise} Promise resolved once editor is ready.
   * @returns {core.editor.StandardEditor} return.editor The editor instance.
   */

	}], [{
		key: 'create',
		value: function create(element, config) {
			var _this3 = this;

			return new Promise(function (resolve) {
				var editor = new _this3(element, config);

				resolve(editor.initPlugins().then(function () {
					return editor;
				}));
			});
		}
	}]);
	return StandardEditor;
}(Editor);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* globals document */

/**
 * Basic HTML writer, it uses the native `innerHTML` property for basic conversion
 * from DocumentFragment to an HTML string.
 *
 * @memberOf engine.dataProcessor
 * @implements engine.dataProcessor.HtmlWriter
 */
var BasicHtmlWriter = function () {
	function BasicHtmlWriter() {
		classCallCheck(this, BasicHtmlWriter);
	}

	createClass(BasicHtmlWriter, [{
		key: 'getHtml',

		/**
   * Returns HTML string created from DocumentFragment.
   *
   * @param {DocumentFragment} fragment
   * @returns {String}
   */
		value: function getHtml(fragment) {
			var doc = document.implementation.createHTMLDocument('');
			var container = doc.createElement('div');
			container.appendChild(fragment);

			return container.innerHTML;
		}
	}]);
	return BasicHtmlWriter;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* globals document, DOMParser */

/**
 * HtmlDataProcessor class.
 * This data processor implementation uses HTML as input/output data.
 *
 * @memberOf engine.dataProcessor
 * @implements engine.dataProcessor.DataProcessor
 */

var HtmlDataProcessor = function () {
	/**
  * Creates a new instance of the HtmlDataProcessor class.
  */
	function HtmlDataProcessor() {
		classCallCheck(this, HtmlDataProcessor);

		/**
   * DOMParser instance used to parse HTML string to HTMLDocument.
   *
   * @private
   * @member {DOMParser} engine.dataProcessor.HtmlDataProcessor#_domParser
   */
		this._domParser = new DOMParser();

		/**
   * DOM converter used to convert DOM elements to view elements.
   *
   * @private
   * @member {engine.view.DomConverter} engine.dataProcessor.HtmlDataProcessor#_domConverter.
   */
		this._domConverter = new DomConverter({ blockFiller: NBSP_FILLER });

		/**
   * BasicHtmlWriter instance used to convert DOM elements to HTML string.
   *
   * @private
   * @member {engine.dataProcessor.BasicHtmlWriter} engine.dataProcessor.HtmlDataProcessor#_htmlWriter
   */
		this._htmlWriter = new BasicHtmlWriter();
	}

	/**
  * Converts provided {@link engine.view.DocumentFragment DocumentFragment} to data format - in this case HTML string.
  *
  * @param {engine.view.DocumentFragment} viewFragment
  * @returns {String} HTML string.
  */


	createClass(HtmlDataProcessor, [{
		key: 'toData',
		value: function toData(viewFragment) {
			// Convert view DocumentFragment to DOM DocumentFragment.
			var domFragment = this._domConverter.viewToDom(viewFragment, document);

			// Convert DOM DocumentFragment to HTML output.
			return this._htmlWriter.getHtml(domFragment);
		}

		/**
   * Converts provided HTML string to view tree.
   *
   * @param {String} data HTML string.
   * @returns {engine.view.Node|engine.view.DocumentFragment|null} Converted view element.
   */

	}, {
		key: 'toView',
		value: function toView(data) {
			// Convert input HTML data to DOM DocumentFragment.
			var domFragment = this._toDom(data);

			// Convert DOM DocumentFragment to view DocumentFragment.
			return this._domConverter.domToView(domFragment);
		}

		/**
   * Converts HTML String to its DOM representation. Returns DocumentFragment, containing nodes parsed from
   * provided data.
   *
   * @private
   * @param {String} data
   * @returns {DocumentFragment}
   */

	}, {
		key: '_toDom',
		value: function _toDom(data) {
			var document = this._domParser.parseFromString(data, 'text/html');
			var fragment = document.createDocumentFragment();
			var nodes = document.body.childNodes;

			while (nodes.length > 0) {
				fragment.appendChild(nodes[0]);
			}

			return fragment;
		}
	}]);
	return HtmlDataProcessor;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Collections are ordered sets of objects. Items in the collection can be retrieved by their indexes
 * in the collection (like in an array) or by their ids.
 *
 * If an object without an `id` property is being added to the collection, the `id` property will be generated
 * automatically. Note that the automatically generated id is unique only within this single collection instance.
 *
 * By default an item in the collection is identified by its `id` property. The name of the identifier can be
 * configured through the constructor of the collection.
 *
 * @memberOf utils
 * @mixes EventEmitter
 */

var Collection = function () {
	/**
  * Creates a new Collection instance.
  *
  * @param {Iterable} [items] Items to be added to the collection.
  * @param {Object} options The options object.
  * @param {String} [options.idProperty='id'] The name of the property which is considered to identify an item.
  */
	function Collection(options) {
		classCallCheck(this, Collection);

		/**
   * The internal list of items in the collection.
   *
   * @private
   * @type {Object[]}
   */
		this._items = [];

		/**
   * The internal map of items in the collection.
   *
   * @private
   * @type {Map}
   */
		this._itemMap = new Map();

		/**
   * The name of the property which is considered to identify an item.
   *
   * @private
   * @type {String}
   */
		this._idProperty = options && options.idProperty || 'id';
	}

	/**
  * The number of items available in the collection.
  *
  * @property length
  */


	createClass(Collection, [{
		key: 'add',


		/**
   * Adds an item into the collection.
   *
   * If the item does not have an id, then it will be automatically generated and set on the item.
   *
   * @chainable
   * @param {Object} item
   * @param {Number} [index] The position of the item in the collection. The item
   * is pushed to the collection when `index` not specified.
   * @fires utils.Collection#add
   */
		value: function add(item, index) {
			var itemId = void 0;
			var idProperty = this._idProperty;

			if (idProperty in item) {
				itemId = item[idProperty];

				if (typeof itemId != 'string') {
					/**
      * This item's id should be a string.
      *
      * @error collection-add-invalid-id
      */
					throw new CKEditorError('collection-add-invalid-id');
				}

				if (this.get(itemId)) {
					/**
      * This item already exists in the collection.
      *
      * @error collection-add-item-already-exists
      */
					throw new CKEditorError('collection-add-item-already-exists');
				}
			} else {
				itemId = this._getNextId();
				item[idProperty] = itemId;
			}

			// TODO: Use ES6 default function argument.
			if (index === undefined) {
				index = this._items.length;
			} else if (index > this._items.length || index < 0) {
				/**
     * The index number has invalid value.
     *
     * @error collection-add-item-bad-index
     */
				throw new CKEditorError('collection-add-item-invalid-index');
			}

			this._items.splice(index, 0, item);

			this._itemMap.set(itemId, item);

			this.fire('add', item, index);

			return this;
		}

		/**
   * Gets item by its id or index.
   *
   * @param {String|Number} idOrIndex The item id or index in the collection.
   * @returns {Object} The requested item or `null` if such item does not exist.
   */

	}, {
		key: 'get',
		value: function get(idOrIndex) {
			var item = void 0;

			if (typeof idOrIndex == 'string') {
				item = this._itemMap.get(idOrIndex);
			} else if (typeof idOrIndex == 'number') {
				item = this._items[idOrIndex];
			} else {
				/**
     * Index or id must be given.
     *
     * @error collection-get-invalid-arg
     */
				throw new CKEditorError('collection-get-invalid-arg: Index or id must be given.');
			}

			return item || null;
		}

		/**
   * Removes an item from the collection.
   *
   * @param {Object|Number|String} subject The item to remove, its id or index in the collection.
   * @returns {Object} The removed item.
   * @fires utils.Collection#remove
   */

	}, {
		key: 'remove',
		value: function remove(subject) {
			var index = void 0,
			    id = void 0,
			    item = void 0;
			var itemDoesNotExist = false;
			var idProperty = this._idProperty;

			if (typeof subject == 'string') {
				id = subject;
				item = this._itemMap.get(id);
				itemDoesNotExist = !item;

				if (item) {
					index = this._items.indexOf(item);
				}
			} else if (typeof subject == 'number') {
				index = subject;
				item = this._items[index];
				itemDoesNotExist = !item;

				if (item) {
					id = item[idProperty];
				}
			} else {
				item = subject;
				id = item[idProperty];
				index = this._items.indexOf(item);
				itemDoesNotExist = index == -1 || !this._itemMap.get(id);
			}

			if (itemDoesNotExist) {
				/**
     * Item not found.
     *
     * @error collection-remove-404
     */
				throw new CKEditorError('collection-remove-404: Item not found.');
			}

			this._items.splice(index, 1);
			this._itemMap.delete(id);

			this.fire('remove', item);

			return item;
		}

		/**
   * Executes the callback for each item in the collection and composes an array or values returned by this callback.
   *
   * @param {Function} callback
   * @param {Item} callback.item
   * @param {Number} callback.index
   * @params {Object} ctx Context in which the `callback` will be called.
   * @returns {Array} The result of mapping.
   */

	}, {
		key: 'map',
		value: function map(callback, ctx) {
			return this._items.map(callback, ctx);
		}

		/**
   * Finds the first item in the collection for which the `callback` returns a true value.
   *
   * @param {Function} callback
   * @param {Object} callback.item
   * @param {Number} callback.index
   * @returns {Object} The item for which `callback` returned a true value.
   * @params {Object} ctx Context in which the `callback` will be called.
   */

	}, {
		key: 'find',
		value: function find(callback, ctx) {
			return this._items.find(callback, ctx);
		}

		/**
   * Returns an array with items for which the `callback` returned a true value.
   *
   * @param {Function} callback
   * @param {Object} callback.item
   * @param {Number} callback.index
   * @params {Object} ctx Context in which the `callback` will be called.
   * @returns {Object[]} The array with matching items.
   */

	}, {
		key: 'filter',
		value: function filter(callback, ctx) {
			return this._items.filter(callback, ctx);
		}

		/**
   * Removes all items from the collection.
   */

	}, {
		key: 'clear',
		value: function clear() {
			while (this.length) {
				this.remove(0);
			}
		}

		/**
   * Collection iterator.
   */

	}, {
		key: Symbol.iterator,
		value: function value() {
			return this._items[Symbol.iterator]();
		}

		/**
   * Generates next (not yet used) id for unidentified item being add to the collection.
   *
   * @private
   * @returns {String} The next id.
   */

	}, {
		key: '_getNextId',
		value: function _getNextId() {
			var id = void 0;

			do {
				id = String(uid());
			} while (this._itemMap.has(id));

			return id;
		}
	}, {
		key: 'length',
		get: function get() {
			return this._items.length;
		}
	}]);
	return Collection;
}();

mix(Collection, EmitterMixin);

/**
 * Fired when an item is added to the collection.
 *
 * @event utils.Collection#add
 * @param {Object} item The added item.
 */

/**
 * Fired when an item is removed from the collection.
 *
 * @event utils.Collection#remove
 * @param {Object} item The removed item.
 */

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Manages UI Controllers.
 *
 * @memberOf ui
 * @extends utils.Collection
 */

var ControllerCollection = function (_Collection) {
	inherits(ControllerCollection, _Collection);

	/**
  * Creates an instance of the controller collection, initializing it with a name:
  *
  *		const collection = new ControllerCollection( 'foo' );
  *		collection.add( someController );
  *
  * **Note**: If needed, controller collection can stay in sync with a collection of models to
  * manage list–like components. See {@link ui.ControllerCollection#bind} to learn more.
  *
  * @param {String} name Name of the collection.
  * @param {utils.Locale} [locale] The {@link core.editor.Editor#locale editor's locale} instance.
  */
	function ControllerCollection(name, locale) {
		classCallCheck(this, ControllerCollection);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ControllerCollection).call(this));

		if (!name) {
			/**
    * ControllerCollection must be initialized with a name.
    *
    * @error ui-controllercollection-no-name
    */
			throw new CKEditorError('ui-controllercollection-no-name: ControllerCollection must be initialized with a name.');
		}

		/**
   * Name of this collection.
   *
   * @member {String} ui.ControllerCollection#name
   */
		_this.name = name;

		/**
   * See {@link ui.View#locale}
   *
   * @readonly
   * @member {utils.Locale} ui.ControllerCollection#locale
   */
		_this.locale = locale;

		/**
   * Parent controller of this collection.
   *
   * @member {ui.Controller} ui.ControllerCollection#parent
   */
		_this.parent = null;
		return _this;
	}

	/**
  * Adds a child controller to the collection. If {@link ui.ControllerCollection#parent} {@link ui.Controller}
  * instance is ready, the child view is initialized when added.
  *
  * @param {ui.Controller} controller A child controller.
  * @param {Number} [index] Index at which the child will be added to the collection.
  * @returns {Promise} A Promise resolved when the child {@link ui.Controller#init} is done.
  */


	createClass(ControllerCollection, [{
		key: 'add',
		value: function add(controller, index) {
			get(Object.getPrototypeOf(ControllerCollection.prototype), 'add', this).call(this, controller, index);

			// ChildController.init() returns Promise.
			var promise = Promise.resolve();

			if (this.parent && this.parent.ready && !controller.ready) {
				promise = promise.then(function () {
					return controller.init();
				});
			}

			return promise;
		}

		/**
   * Synchronizes controller collection with a {@link utils.Collection} of {@link ui.Model} instances.
   * The entire collection of controllers reflects changes to the collection of the models, working as a factory.
   *
   * This method helps bringing complex list–like UI components to life out of the data (like models). The process
   * can be automatic:
   *
   *		// This collection stores models.
   *		const models = new Collection( { idProperty: 'label' } );
   *
   *		// This controller collection will become a factory for the collection of models.
   *		const controllers = new ControllerCollection( 'foo', locale );
   *
   *		// Activate the binding – since now, this controller collection works like a **factory**.
   *		controllers.bind( models ).as( FooController, FooView );
   *
   *		// As new models arrive to the collection, each becomes an instance of FooController (FooView)
   *		// in the controller collection.
   *		models.add( new Model( { label: 'foo' } ) );
   *		models.add( new Model( { label: 'bar' } ) );
   *
   *		console.log( controllers.length == 2 );
   *
   *		// Controller collection is updated as the model is removed.
   *		models.remove( 0 );
   *		console.log( controllers.length == 1 );
   *
   * or the factory can be driven by a custom callback:
   *
   *		// This collection stores any kind of data.
   *		const data = new Collection();
   *
   *		// This controller collection will become a custom factory for the data.
   *		const controllers = new ControllerCollection( 'foo', locale );
   *
   *		// Activate the binding – the **factory** is driven by a custom callback.
   *		controllers.bind( data ).as( ( item, locale ) => {
   *			if ( !item.foo ) {
   *				return null;
   *			} else if ( item.foo == 'bar' ) {
   *				return new BarController( ..., BarView( locale ) );
   *			} else {
   *				return new DifferentController( ..., DifferentView( locale ) );
   *			}
   *		} );
   *
   *		// As new data arrive to the collection, each is handled individually by the callback.
   *		// This will produce BarController.
   *		data.add( { foo: 'bar' } );
   *
   *		// And this one will become DifferentController.
   *		data.add( { foo: 'baz' } );
   *
   *		// Also there will be no controller for data without property `foo`.
   *		data.add( {} );
   *
   *		console.log( controllers.length == 2 );
   *
   *		// Controller collection is updated as the data is removed.
   *		data.remove( 0 );
   *		console.log( controllers.length == 1 );
   *
   * @param {utils.Collection.<ui.Model>} collection Models to be synchronized with this controller collection.
   * @returns {Function} The `as` function in the `bind( collection ).as( ... )` chain.
   * It activates factory using controller and view classes or uses a custom callback to produce
   * controller (view) instances.
   * @returns {Function} return.ControllerClassOrFunction Specifies the constructor of the controller to be used or
   * a custom callback function which produces controllers.
   * @returns {Function} [return.ViewClass] Specifies constructor of the view to be used. If not specified,
   * `ControllerClassOrFunction` works as as custom callback function.
   */

	}, {
		key: 'bind',
		value: function bind(collection) {
			var controllerMap = new Map();
			var that = this;

			return {
				as: function as(ControllerClassOrFunction, ViewClass) {
					var handler = ViewClass ? defaultControllerHandler(ControllerClassOrFunction, ViewClass) : genericControllerHandler(ControllerClassOrFunction);

					var _iteratorNormalCompletion = true;
					var _didIteratorError = false;
					var _iteratorError = undefined;

					try {
						for (var _iterator = collection[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
							var item = _step.value;

							handler.add(item);
						}

						// Updated controller collection when a new item is added.
					} catch (err) {
						_didIteratorError = true;
						_iteratorError = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion && _iterator.return) {
								_iterator.return();
							}
						} finally {
							if (_didIteratorError) {
								throw _iteratorError;
							}
						}
					}

					collection.on('add', function (evt, item, index) {
						handler.add(item, index);
					});

					// Update controller collection when a item is removed.
					collection.on('remove', function (evt, item) {
						handler.remove(item);
					});
				}
			};

			function genericControllerHandler(createController) {
				return {
					add: function add(data, index) {
						var controller = createController(data, that.locale);

						controllerMap.set(data, controller);

						if (controller) {
							that.add(controller, typeof index == 'number' ? recalculateIndex(index) : undefined);
						}
					},
					remove: function remove(data) {
						var controller = controllerMap.get(data);

						controllerMap.delete(controller);

						if (controller) {
							that.remove(controller);
						}
					}
				};
			}

			// Decrement index for each item which has no corresponding controller.
			function recalculateIndex(index) {
				var outputIndex = index;

				for (var i = 0; i < index; i++) {
					// index -> data -> controller
					if (!controllerMap.get(collection.get(i))) {
						outputIndex--;
					}
				}

				return outputIndex;
			}

			function defaultControllerHandler(ControllerClass, ViewClass) {
				return genericControllerHandler(function (model) {
					return new ControllerClass(model, new ViewClass(that.locale));
				}, controllerMap);
			}
		}

		/**
   * Delegates selected events coming from within controller models in the collection to desired
   * {@link utils.EmitterMixin}. For instance:
   *
   *		const modelA = new Model();
   *		const modelB = new Model();
   *		const modelC = new Model();
   *
   *		const controllers = new ControllerCollection( 'name' );
   *
   *		controllers.delegate( 'eventX' ).to( modelB );
   *		controllers.delegate( 'eventX', 'eventY' ).to( modelC );
   *
   *		controllers.add( new Controller( modelA, ... ) );
   *
   * then `eventX` is delegated (fired by) `modelB` and `modelC` along with `customData`:
   *
   *		modelA.fire( 'eventX', customData );
   *
   * and `eventY` is delegated (fired by) `modelC` along with `customData`:
   *
   *		modelA.fire( 'eventY', customData );
   *
   * See {@link utils.EmitterMixin#delegate}.
   *
   * @param {...String} events {@link ui.Controller#model} event names to be delegated to another {@link utils.EmitterMixin}.
   * @returns {ui.ControllerCollection#delegate#to}
   */

	}, {
		key: 'delegate',
		value: function delegate() {
			var _this2 = this;

			for (var _len = arguments.length, events = Array(_len), _key = 0; _key < _len; _key++) {
				events[_key] = arguments[_key];
			}

			if (!events.length || !isStringArray$1(events)) {
				/**
     * All event names must be strings.
     *
     * @error ui-controllercollection-delegate-wrong-events
     */
				throw new CKEditorError('ui-controllercollection-delegate-wrong-events: All event names must be strings.');
			}

			return {
				/**
     * Selects destination for {@link utils.EmitterMixin#delegate} events.
     *
     * @method ui.ControllerCollection.delegate#to
     * @param {utils.EmitterMixin} dest An `EmitterMixin` instance which is the destination for delegated events.
     */
				to: function to(dest) {
					// Activate delegating on existing controllers in this collection.
					var _iteratorNormalCompletion2 = true;
					var _didIteratorError2 = false;
					var _iteratorError2 = undefined;

					try {
						for (var _iterator2 = _this2[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
							var controller = _step2.value;
							var _iteratorNormalCompletion5 = true;
							var _didIteratorError5 = false;
							var _iteratorError5 = undefined;

							try {
								for (var _iterator5 = events[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
									var evtName = _step5.value;

									controller.model.delegate(evtName).to(dest);
								}
							} catch (err) {
								_didIteratorError5 = true;
								_iteratorError5 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion5 && _iterator5.return) {
										_iterator5.return();
									}
								} finally {
									if (_didIteratorError5) {
										throw _iteratorError5;
									}
								}
							}
						}

						// Activate delegating on future controllers in this collection.
					} catch (err) {
						_didIteratorError2 = true;
						_iteratorError2 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion2 && _iterator2.return) {
								_iterator2.return();
							}
						} finally {
							if (_didIteratorError2) {
								throw _iteratorError2;
							}
						}
					}

					_this2.on('add', function (evt, controller) {
						var _iteratorNormalCompletion3 = true;
						var _didIteratorError3 = false;
						var _iteratorError3 = undefined;

						try {
							for (var _iterator3 = events[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
								var evtName = _step3.value;

								controller.model.delegate(evtName).to(dest);
							}
						} catch (err) {
							_didIteratorError3 = true;
							_iteratorError3 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion3 && _iterator3.return) {
									_iterator3.return();
								}
							} finally {
								if (_didIteratorError3) {
									throw _iteratorError3;
								}
							}
						}
					});

					// Deactivate delegating when controller is removed from this collection.
					_this2.on('remove', function (evt, controller) {
						var _iteratorNormalCompletion4 = true;
						var _didIteratorError4 = false;
						var _iteratorError4 = undefined;

						try {
							for (var _iterator4 = events[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
								var evtName = _step4.value;

								controller.model.stopDelegating(evtName, dest);
							}
						} catch (err) {
							_didIteratorError4 = true;
							_iteratorError4 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion4 && _iterator4.return) {
									_iterator4.return();
								}
							} finally {
								if (_didIteratorError4) {
									throw _iteratorError4;
								}
							}
						}
					});
				}
			};
		}
	}]);
	return ControllerCollection;
}(Collection);

function isStringArray$1(arr) {
	return arr.every(function (a) {
		return typeof a == 'string';
	});
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

var anon = '$anonymous';

/**
 * Basic Controller class.
 *
 * @memberOf ui
 * @mixes utils.EmitterMixin
 */

var Controller = function () {
	/**
  * Creates an instance of the {@link ui.Controller} class.
  *
  * @param {ui.Model} [model] Model of this Controller.
  * @param {ui.View} [view] View instance of this Controller.
  */
	function Controller(model, view) {
		var _this = this;

		classCallCheck(this, Controller);

		/**
   * Model of this controller.
   *
   * @member {ui.Model} ui.Controller#model
   */
		this.model = model || null;

		/**
   * Set `true` after {@link #init}.
   *
   * @member {Boolean} ui.Controller#ready
   */
		this.ready = false;

		/**
   * View of this controller.
   *
   * @member {ui.View} ui.Controller#view
   */
		this.view = view || null;

		/**
   * A collection of {@link ControllerCollection} instances containing
   * child controllers.
   *
   * @member {utils.Collection} ui.Controller#collections
   */
		this.collections = new Collection({
			idProperty: 'name'
		});

		/**
   * Anonymous collection of this controller instance. It groups child controllers
   * which are not to be handled by `Controller#collections`–to–`View#region`
   * automation. It also means their views must be handled individually
   * by the view, i.e. passed as members of {@link ui.TemplateDefinition#children}.
   *
   * @protected
   * @member {ui.ControllerCollection} ui.Controller#_anonymousCollection
   */
		this.collections.add(this._anonymousCollection = new ControllerCollection(anon));

		// Listen to {@link ControllerCollection#add} and {@link ControllerCollection#remove}
		// of newly added Collection to synchronize this controller's view and children
		// controllers' views in the future.
		this.collections.on('add', function (evt, collection) {
			// Set the {@link ControllerCollection#parent} to this controller.
			// It allows the collection to determine the {@link #ready} state of this controller
			// and accordingly initialize a child controller when added.
			collection.parent = _this;

			_this.listenTo(collection, 'add', function (evt, childController, index) {
				// Child view is added to corresponding region in this controller's view
				// when a new Controller joins the collection.
				if (_this.ready && childController.view) {
					_this.view.regions.get(collection.name).views.add(childController.view, index);
				}
			});

			_this.listenTo(collection, 'remove', function (evt, childController) {
				// Child view is removed from corresponding region in this controller's view
				// when a new Controller is removed from the the collection.
				if (_this.ready && childController.view) {
					_this.view.regions.get(collection.name).views.remove(childController.view);
				}
			});
		});

		this.collections.on('remove', function (evt, collection) {
			// Release the collection. Once removed from {@link #collections}, it can be
			// moved to another controller.
			collection.parent = null;

			_this.stopListening(collection);
		});
	}

	/**
  * Initializes the controller instance. The process includes:
  *
  * 1. Initialization of the child {@link #view}.
  * 2. Initialization of child controllers in {@link #collections}.
  * 3. Setting {@link #ready} flag `true`.
  *
  * @returns {Promise} A Promise resolved when the initialization process is finished.
  */


	createClass(Controller, [{
		key: 'init',
		value: function init() {
			var _this2 = this;

			if (this.ready) {
				/**
     * This Controller already been initialized.
     *
     * @error ui-controller-init-reinit
     */
				throw new CKEditorError('ui-controller-init-reinit: This Controller already been initialized.');
			}

			return Promise.resolve().then(this._initView.bind(this)).then(this._initCollections.bind(this)).then(function () {
				_this2.ready = true;
				_this2.fire('ready');
			});
		}

		/**
   * Destroys the controller instance. The process includes:
   *
   * 1. Destruction of the child {@link #view}.
   * 2. Destruction of child controllers in {@link #collections}.
   *
   * @returns {Promise} A Promise resolved when the destruction process is finished.
   */

	}, {
		key: 'destroy',
		value: function destroy() {
			var _this3 = this;

			var promises = [];
			var collection = void 0,
			    childController = void 0;

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = this.collections[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					collection = _step.value;
					var _iteratorNormalCompletion2 = true;
					var _didIteratorError2 = false;
					var _iteratorError2 = undefined;

					try {
						for (var _iterator2 = collection[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
							childController = _step2.value;

							promises.push(childController.destroy());
						}
					} catch (err) {
						_didIteratorError2 = true;
						_iteratorError2 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion2 && _iterator2.return) {
								_iterator2.return();
							}
						} finally {
							if (_didIteratorError2) {
								throw _iteratorError2;
							}
						}
					}

					collection.clear();
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			this.collections.clear();

			if (this.view) {
				promises.push(Promise.resolve().then(function () {
					return _this3.view.destroy();
				}));
			}

			promises.push(Promise.resolve().then(function () {
				_this3.model = _this3.ready = _this3.view = _this3.collections = null;
			}));

			return Promise.all(promises);
		}

		/**
   * Adds a new collection to {@link ui.Controller#collections}.
   *
   * @param {String} collectionName Name of the controller collection.
   * @returns {ui.ControllerCollection} The new collection instance.
   */

	}, {
		key: 'addCollection',
		value: function addCollection(collectionName) {
			var collection = new ControllerCollection(collectionName, this.view && this.view.locale);

			this.collections.add(collection);

			return collection;
		}

		/**
   * Adds a child {@link Controller} instance to {@link #collections} at given index.
   *
   *		// Adds child to the specified collection. The collection name
   *		// must correspond with the region name in parent.view#regions.
   *		parent.add( 'collection-name', child );
   *
   *		// Adds child to the specified collection at specific index.
   *		// The collection name must correspond with the region name in parent.view#regions.
   *		parent.add( 'collection-name', child, 3 );
   *
   *		// Adds child to the {@link ui.Controller#_anonymousCollection} in the parent. In such case,
   *		// parent#view must put the child#view in the correct place in parent.view#template
   *		// because there's no association between the {@link ui.Controller#_anonymousCollection}
   *		// and any of the regions.
   *		parent.add( child );
   *
   * @param {String|ui.Controller} collectionNameOrController Name of the collection or the controller instance.
   * @param {ui.Controller} [controller] A controller instance to be added.
   * @param {Number} [index] An index in the collection.
   * @returns {Promise} A Promise resolved when the child {@link ui.Controller#init} is done.
   */

	}, {
		key: 'add',
		value: function add() {
			if ((arguments.length <= 0 ? undefined : arguments[0]) instanceof Controller) {
				var _anonymousCollection;

				return (_anonymousCollection = this._anonymousCollection).add.apply(_anonymousCollection, arguments);
			} else {
				return this.collections.get(arguments.length <= 0 ? undefined : arguments[0]).add(arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);
			}
		}

		/**
   * Removes a child {@link ui.Controller} instance from one of {@link ui.Controller#collections}.
   *
   * **Note**: To remove children from {@link ui.Controller#_anonymousCollection}, use the following syntax
   *
   *		parent.remove( child );
   *
   * @param {String|ui.Controller} collectionNameOrController Name of the collection or the controller instance.
   * @param {ui.Controller|Number} [toRemove] A Controller instance or index to be removed.
   * @returns {Object} The removed item.
   */

	}, {
		key: 'remove',
		value: function remove(collectionNameOrController, toRemove) {
			if (collectionNameOrController instanceof Controller) {
				return this._anonymousCollection.remove(collectionNameOrController);
			} else {
				return this.collections.get(collectionNameOrController).remove(toRemove);
			}
		}

		/**
   * Initializes the {@link #view} of this controller instance.
   *
   * @protected
   * @returns {Promise} A Promise resolved when initialization process is finished.
   */

	}, {
		key: '_initView',
		value: function _initView() {
			var promise = Promise.resolve();

			if (this.view) {
				promise = promise.then(this.view.init.bind(this.view));
			}

			return promise;
		}

		/**
   * Initializes the {@link #collections} of this controller instance.
   *
   * @protected
   * @returns {Promise} A Promise resolved when initialization process is finished.
   */

	}, {
		key: '_initCollections',
		value: function _initCollections() {
			var promises = [];
			var collection = void 0,
			    childController = void 0;

			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = this.collections[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					collection = _step3.value;
					var _iteratorNormalCompletion4 = true;
					var _didIteratorError4 = false;
					var _iteratorError4 = undefined;

					try {
						for (var _iterator4 = collection[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
							childController = _step4.value;

							// Anonymous collection {@link ui.Controller#_anonymousCollection} does not allow
							// automated controller-to-view binding, because there's no such thing as
							// anonymous Region in the View instance.
							if (!isAnonymous(collection) && this.view && childController.view) {
								this.view.regions.get(collection.name).views.add(childController.view);
							}

							promises.push(childController.init());
						}
					} catch (err) {
						_didIteratorError4 = true;
						_iteratorError4 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion4 && _iterator4.return) {
								_iterator4.return();
							}
						} finally {
							if (_didIteratorError4) {
								throw _iteratorError4;
							}
						}
					}
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}

			return Promise.all(promises);
		}
	}]);
	return Controller;
}();

mix(Controller, EmitterMixin);

// Checks whether the collection is anonymous.
//
// @private
// @param {ui.ControllerCollection} collection
// @returns {Boolean}
function isAnonymous(collection) {
	return collection.name == anon;
}

/**
 * Fired when the controller is fully initialized.
 *
 * @event ui.Controller#ready
 */

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Class implementing the UI component factory.
 *
 * Factories of specific UI components can be registered under their unique names. Registered
 * components can be later instantiated by providing the name of the component. The model is shared between all
 * instances of that component and has to be provided upon registering its factory.
 *
 * The main use case for the component factory is the {@link ui.editorUI.EditorUI#featureComponents} factory.
 *
 * @memberOf ui
 */

var ComponentFactory = function () {
	/**
  * Creates ComponentFactory instance.
  *
  * @constructor
  * @param {core.editor.Editor} editor The editor instance.
  */
	function ComponentFactory(editor) {
		classCallCheck(this, ComponentFactory);

		/**
   * @readonly
   * @member {core.editor.Editor} ui.ComponentFactory#editor
   */
		this.editor = editor;

		/**
   * Registered component factories.
   *
   * @private
   * @member {Map} ui.ComponentFactory#_components
   */
		this._components = new Map();
	}

	/**
  * Registers a component factory.
  *
  * @param {String} name The name of the component.
  * @param {Function} ControllerClass The component controller constructor.
  * @param {Function} ViewClass The component view constructor.
  * @param {ui.Model} model The model of the component.
  */


	createClass(ComponentFactory, [{
		key: 'add',
		value: function add(name, ControllerClass, ViewClass, model) {
			if (this._components.get(name)) {
				throw new CKEditorError('componentfactory-item-exists: The item already exists in the component factory.', { name: name });
			}

			this._components.set(name, {
				ControllerClass: ControllerClass,
				ViewClass: ViewClass,
				model: model
			});
		}

		/**
   * Creates a component instance.
   *
   * @param {String} name The name of the component.
   * @returns {ui.Controller} The instantiated component.
   */

	}, {
		key: 'create',
		value: function create(name) {
			var component = this._components.get(name);

			var model = component.model;
			var view = new component.ViewClass(model, this.editor.locale);
			var controller = new component.ControllerClass(model, view, this.editor);

			return controller;
		}
	}]);
	return ComponentFactory;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The icon manager controller class. It provides SVG icons, which then can
 * be used by {@link ui.icon.Icon} component and similar.
 *
 *		const model = new Model( {
 *			icons: [ 'bold', 'italic', ... ],
 *			sprite: '...' // SVG sprite
 *		} );
 *
 *		// An instance of IconManager.
 *		new IconManager( model, new IconManagerView() );
 *
 * See {@link ui.iconManager.IconManagerView}.
 *
 * @memberOf ui.iconManager
 * @extends ui.Controller
 */

var IconManager = function (_Controller) {
  inherits(IconManager, _Controller);

  /**
   * Creates an instance of {@link ui.iconManager.IconManager} class.
   *
   * @param {ui.iconManager.IconManagerModel} model Model of this IconManager.
   * @param {ui.View} view View of this IconManager.
   */
  function IconManager(model, view) {
    classCallCheck(this, IconManager);

    var _this = possibleConstructorReturn(this, Object.getPrototypeOf(IconManager).call(this, model, view));

    view.bind('sprite').to(model);
    return _this;
  }

  return IconManager;
}(Controller);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Basic Region class.
 *
 * @memberOf ui
 */

var Region = function () {
	/**
  * Creates an instance of the {@link ui.Region} class.
  *
  * @param {String} name The name of the Region.
  */
	function Region(name) {
		classCallCheck(this, Region);

		/**
   * The name of the region.
   *
   * @member {String} ui.Region#name
   */
		this.name = name;

		/**
   * Views which belong to the region.
   *
   * @member {utils.Collection} ui.Region#views
   */
		this.views = new Collection();

		/**
   * Element of this region (see {@link #init}).
   *
   * @member {HTMLElement} ui.Region#element
   */
		this.element = null;
	}

	/**
  * Initializes region instance with an element. Usually it comes from {@link View#init}.
  *
  * @param {HTMLElement} regionElement Element of this region.
  */


	createClass(Region, [{
		key: 'init',
		value: function init(regionElement) {
			this.element = regionElement;

			if (regionElement) {
				this.views.on('add', function (evt, childView, index) {
					regionElement.insertBefore(childView.element, regionElement.childNodes[index]);
				});

				this.views.on('remove', function (evt, childView) {
					childView.element.remove();
				});
			}
		}

		/**
   * Destroys region instance.
   */

	}, {
		key: 'destroy',
		value: function destroy() {
			if (this.element) {
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = this.views[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var view = _step.value;

						view.element.remove();
						this.views.remove(view);
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
			}

			// Drop the reference to HTMLElement but don't remove it from DOM.
			// Element comes as a parameter and it could be a part of the View.
			// Then it's up to the View what to do with it when the View is destroyed.
			this.element = this.views = null;
		}
	}]);
	return Region;
}();

/**
 * This method is like `_.cloneWith` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @param {Function} [customizer] The function to customize cloning.
 * @returns {*} Returns the deep cloned value.
 * @see _.cloneWith
 * @example
 *
 * function customizer(value) {
 *   if (_.isElement(value)) {
 *     return value.cloneNode(true);
 *   }
 * }
 *
 * var el = _.cloneDeepWith(document.body, customizer);
 *
 * console.log(el === document.body);
 * // => false
 * console.log(el.nodeName);
 * // => 'BODY'
 * console.log(el.childNodes.length);
 * // => 20
 */
function cloneDeepWith(value, customizer) {
  return baseClone(value, true, true, customizer);
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* global document */

var xhtmlNs = 'http://www.w3.org/1999/xhtml';

/**
 * A basic Template class. It renders DOM HTMLElement or Text from {@link ui.TemplateDefinition} and supports
 * element attributes, children, bindings to {@link utils.Observable} instances and DOM events
 * propagation. For example:
 *
 *		new Template( {
 *			tag: 'p',
 *			attributes: {
 *				class: 'foo',
 *				style: {
 *					backgroundColor: 'yellow'
 *				}
 *			},
 *			children: [
 *				'A paragraph.'
 *			]
 *		} ).render();
 *
 * will render the following HTMLElement:
 *
 *		<p class="foo" style="background-color: yellow;">A paragraph.</p>
 *
 * See {@link ui.TemplateDefinition} to know more about templates and complex template definitions.
 *
 * @memberOf ui
 */

var Template = function () {
	/**
  * Creates an instance of the {@link ui.Template} class.
  *
  * @param {ui.TemplateDefinition} def The definition of the template.
  */
	function Template(def) {
		classCallCheck(this, Template);

		Object.assign(this, normalize$4(clone$1(def)));

		/**
   * Tag of this template, i.e. `div`, indicating that the instance will render
   * to an HTMLElement.
   *
   * @member {String} ui.Template#tag
   */

		/**
   * Text of this template, indicating that the instance will render to a DOM Text.
   *
   * @member {Array.<String|ui.TemplateValueSchema> ui.Template#text
   */

		/**
   * Attributes of this template, i.e. `{ id: [ 'ck-id' ] }`, corresponding with
   * HTML attributes on HTMLElement.
   *
   * Note: Only when {@link ui.Template#tag} is defined.
   *
   * @member {Object} ui.Template#attributes
   */

		/**
   * Children of this template; sub–templates. Each one is an independent
   * instance of {@link ui.Template}.
   *
   * Note: Only when {@link ui.Template#tag} is defined.
   *
   * @member {utils.Collection.<ui.Template>} ui.Template#children
   */

		/**
   * DOM event listeners of this template.
   *
   * @member {Object} ui.Template#eventListeners
   */
	}

	/**
  * Renders a DOM Node (`HTMLElement` or `Text`) out of the template.
  *
  * @see {@link ui.Template#apply}.
  *
  * @returns {HTMLElement|Text}
  */


	createClass(Template, [{
		key: 'render',
		value: function render() {
			return this._renderNode(undefined, true);
		}

		/**
   * Applies the template to an existing DOM Node, either `HTMLElement` or `Text`.
   *
   * **Note:** No new DOM nodes (HTMLElement or Text) will be created. Applying extends
   * attributes ({@link ui.TemplateDefinition#attributes}) and listeners ({@link ui.TemplateDefinition#on}) only.
   *
   *		const element = document.createElement( 'div' );
   *		const bind = Template.bind( observableInstance, emitterInstance );
   *
   *		new Template( {
   *			attrs: {
   *				id: 'first-div',
   *				class: bind.to( 'divClass' )
   *			},
   *			on: {
   *				click: bind( 'elementClicked' ) // Will be fired by the observableInstance.
   *			}
   *			children: [
   *				'Div text.'
   *			]
   *		} ).apply( element );
   *
   *		element.outerHTML == "<div id="first-div" class="my-div">Div text.</div>"
   *
   * @see ui.Template#render
   * @param {Node} element Root element for the template to apply.
   */

	}, {
		key: 'apply',
		value: function apply(node) {
			if (!node) {
				/**
     * No DOM Node specified.
     *
     * @error ui-template-wrong-syntax
     */
				throw new CKEditorError('ui-template-wrong-node: No DOM Node specified.');
			}

			return this._renderNode(node);
		}

		/**
   * An entry point to the interface which allows binding DOM nodes to {@link utils.Observable}.
   * There are two types of bindings:
   *
   * * `HTMLElement` attributes or Text Node `textContent` can be synchronized with {@link utils.Observable}
   * instance attributes. See {@link ui.Template.bind#to} and {@link ui.Template.bind#if}.
   *
   * * DOM events fired on `HTMLElement` can be propagated through {@link utils.Observable}.
   * See {@link ui.Template.bind#to}.
   *
   * @param {utils.Observable} observable An instance of ObservableMixin class.
   * @param {utils.Emitter} emitter An instance of `Emitter` class. It listens
   * to `observable` attribute changes and DOM Events, depending on the binding. Usually {@link ui.View} instance.
   * @returns {Object}
   */

	}, {
		key: '_renderNode',


		/**
   * Renders a DOM Node (either `HTMLElement` or `Text`) out of the template.
   *
   * @protected
   * @param {Node} applyNode If specified, this template will be applied to an existing DOM Node.
   * @param {Boolean} intoFragment If set, children are rendered into `DocumentFragment`.
   * @returns {HTMLElement|Text} A rendered Node.
   */
		value: function _renderNode(applyNode, intoFragment) {
			var isInvalid = void 0;

			if (applyNode) {
				// When applying, a definition cannot have "tag" and "text" at the same time.
				isInvalid = this.tag && this.text;
			} else {
				// When rendering, a definition must have either "tag" or "text": XOR( this.tag, this.text ).
				isInvalid = this.tag ? this.text : !this.text;
			}

			if (isInvalid) {
				/**
     * Node definition cannot have "tag" and "text" properties at the same time.
     * Node definition must have either "tag" or "text" when rendering new Node.
     *
     * @error ui-template-wrong-syntax
     */
				throw new CKEditorError('ui-template-wrong-syntax: Node definition must have either "tag" or "text" when rendering new Node.');
			}

			return this.text ? this._renderText(applyNode) : this._renderElement(applyNode, intoFragment);
		}

		/**
   * Renders an `HTMLElement` out of the template.
   *
   * @protected
   * @param {HTMLElement} applyElement If specified, this template will be applied to an existing `HTMLElement`.
   * @param {Boolean} intoFragment If set, children are rendered into `DocumentFragment`.
   * @returns {HTMLElement} A rendered `HTMLElement`.
   */

	}, {
		key: '_renderElement',
		value: function _renderElement(applyElement, intoFragment) {
			var el = applyElement || document.createElementNS(this.ns || xhtmlNs, this.tag);

			this._renderAttributes(el);

			// Invoke children recursively.
			if (intoFragment) {
				var docFragment = document.createDocumentFragment();

				this._renderElementChildren(docFragment);

				el.appendChild(docFragment);
			} else {
				this._renderElementChildren(el, !!applyElement);
			}

			// Setup DOM bindings event listeners.
			this._setUpListeners(el);

			return el;
		}

		/**
   * Renders a `Text` node out of {@link ui.Template#text}.
   *
   * @protected
   * @param {HTMLElement} textNode If specified, this template instance will be applied to an existing `Text` Node.
   * @returns {Text} A rendered `Text` node in DOM.
   */

	}, {
		key: '_renderText',
		value: function _renderText() {
			var textNode = arguments.length <= 0 || arguments[0] === undefined ? document.createTextNode('') : arguments[0];

			// Check if this Text Node is bound to Observable. Cases:
			//		{ text: [ Template.bind( ... ).to( ... ) ] }
			//		{ text: [ 'foo', Template.bind( ... ).to( ... ), ... ] }
			if (hasTemplateBinding(this.text)) {
				this._bindToObservable(this.text, textNode, getTextUpdater(textNode));
			}

			// Simply set text. Cases:
			// 		{ text: [ 'all', 'are', 'static' ] }
			// 		{ text: [ 'foo' ] }
			else {
					textNode.textContent = this.text.join('');
				}

			return textNode;
		}

		/**
   * Renders an `HTMLElement` attributes out of {@link ui.Template#attributes}.
   *
   * @protected
   * @param {HTMLElement} el `HTMLElement` which attributes are to be rendered.
   */

	}, {
		key: '_renderAttributes',
		value: function _renderAttributes(el) {
			var attrName = void 0,
			    attrValue = void 0,
			    attrNs = void 0;

			if (!this.attributes) {
				return;
			}

			for (attrName in this.attributes) {
				attrValue = this.attributes[attrName];

				// Detect custom namespace:
				// 		{ class: { ns: 'abc', value: Template.bind( ... ).to( ... ) } }
				attrNs = isObject(attrValue[0]) && attrValue[0].ns ? attrValue[0].ns : null;

				// Activate binding if one is found. Cases:
				// 		{ class: [ Template.bind( ... ).to( ... ) ] }
				// 		{ class: [ 'bar', Template.bind( ... ).to( ... ), 'baz' ] }
				// 		{ class: { ns: 'abc', value: Template.bind( ... ).to( ... ) } }
				if (hasTemplateBinding(attrValue)) {
					this._bindToObservable(
					// Normalize attributes with additional data like namespace:
					//		{ class: { ns: 'abc', value: [ ... ] } }
					attrNs ? attrValue[0].value : attrValue, el, getAttributeUpdater(el, attrName, attrNs));
				}

				// Style attribute could be an Object so it needs to be parsed in a specific way.
				//		style: {
				//			width: '100px',
				//			height: Template.bind( ... ).to( ... )
				//		}
				else if (attrName == 'style' && typeof attrValue[0] !== 'string') {
						this._renderStyleAttribute(attrValue[0], el);
					}

					// Otherwise simply set the static attribute.
					// 		{ class: [ 'foo' ] }
					// 		{ class: [ 'all', 'are', 'static' ] }
					// 		{ class: [ { ns: 'abc', value: [ 'foo' ] } ] }
					else {
							attrValue = attrValue
							// Retrieve "values" from { class: [ { ns: 'abc', value: [ ... ] } ] }
							.map(function (v) {
								return v ? v.value || v : v;
							})
							// Flatten the array.
							.reduce(function (p, n) {
								return p.concat(n);
							}, [])
							// Convert into string.
							.reduce(arrayValueReducer, '');

							if (!isFalsy(attrValue)) {
								el.setAttributeNS(attrNs, attrName, attrValue);
							}
						}
			}
		}

		/**
   * Renders `style` attribute of an `HTMLElement` based on {@link ui.Template#attributes}.
   *
   * Style attribute is an {Object} with static values:
   *
   *		attributes: {
   * 			style: {
   * 				color: 'red'
   * 			}
   * 		}
   *
   * or values bound to {@link ui.Model} properties:
   *
   *		attributes: {
   * 			style: {
   * 				color: bind.to( ... )
   * 			}
   * 		}
   *
   * Note: `style` attribute is rendered without setting the namespace. It does not seem to be
   * needed.
   *
   * @private
   * @param {ui.TemplateDefinition.attributes.styles} styles Styles definition.
   * @param {HTMLElement} el `HTMLElement` which `style` attribute is rendered.
   */

	}, {
		key: '_renderStyleAttribute',
		value: function _renderStyleAttribute(styles, el) {
			for (var styleName in styles) {
				var styleValue = styles[styleName];

				// style: {
				//	color: bind.to( 'attribute' )
				// }
				if (hasTemplateBinding(styleValue)) {
					this._bindToObservable([styleValue], el, getStyleUpdater(el, styleName));
				}

				// style: {
				//	color: 'red'
				// }
				else {
						el.style[styleName] = styleValue;
					}
			}
		}

		/**
   * Recursively renders `HTMLElement` children from {@link ui.Template#children}.
   *
   * @protected
   * @param {HTMLElement} elOrDocFragment `HTMLElement` or `DocumentFragment` which is being rendered.
   * @param {Boolean} shouldApply Traverse existing DOM structure only, don't modify DOM.
   */

	}, {
		key: '_renderElementChildren',
		value: function _renderElementChildren(elOrDocFragment, shouldApply) {
			var childIndex = 0;

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var child = _step.value;

					if (isView(child)) {
						if (!shouldApply) {
							elOrDocFragment.appendChild(child.element);
						}
					} else {
						if (shouldApply) {
							child._renderNode(elOrDocFragment.childNodes[childIndex++]);
						} else {
							elOrDocFragment.appendChild(child.render());
						}
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		}

		/**
   * Activates {@link ui.Template#on} listeners on a passed `HTMLElement`.
   *
   * @protected
   * @param {HTMLElement} el `HTMLElement` which is being rendered.
   */

	}, {
		key: '_setUpListeners',
		value: function _setUpListeners(el) {
			var _this = this;

			if (!this.eventListeners) {
				return;
			}

			var _loop = function _loop(key) {
				var _key$split = key.split('@');

				var _key$split2 = slicedToArray(_key$split, 2);

				var domEvtName = _key$split2[0];
				var domSelector = _key$split2[1];


				_this.eventListeners[key].forEach(function (schemaItem) {
					schemaItem.activateDomEventListener(el, domEvtName, domSelector);
				});
			};

			for (var key in this.eventListeners) {
				_loop(key);
			}
		}

		/**
   * For given {@link ui.TemplateValueSchema} containing {@link ui.TemplateBinding} it activates the
   * binding and sets its initial value.
   *
   * Note: {@link ui.TemplateValueSchema} can be for HTMLElement attributes or Text Node `textContent`.
   *
   * @protected
   * @param {ui.TemplateValueSchema} valueSchema
   * @param {Node} node DOM Node to be updated when {@link utils.Observable} changes.
   * @param {Function} domUpdater A function which updates DOM (like attribute or text).
   */

	}, {
		key: '_bindToObservable',
		value: function _bindToObservable(valueSchema) {
			var _arguments = arguments;

			valueSchema
			// Filter "falsy" (false, undefined, null, '') value schema components out.
			.filter(function (item) {
				return !isFalsy(item);
			})
			// Filter inactive bindings from schema, like static strings ('foo'), numbers (42), etc.
			.filter(function (item) {
				return item.observable;
			})
			// Once only the actual binding are left, let the emitter listen to observable change:attribute event.
			// TODO: Reduce the number of listeners attached as many bindings may listen
			// to the same observable attribute.
			.forEach(function (templateBinding) {
				return templateBinding.activateAttributeListener.apply(templateBinding, _arguments);
			});

			// Set initial values.
			syncValueSchemaValue.apply(undefined, arguments);
		}
	}], [{
		key: 'bind',
		value: function bind(observable, emitter) {
			return {
				/**
     * Binds {@link utils.Observable} instance to:
     *  * HTMLElement attribute or Text Node `textContent` so remains in sync with the Observable when it changes:
     *  * HTMLElement DOM event, so the DOM events are propagated through Observable.
     *
     *		const bind = Template.bind( observableInstance, emitterInstance );
     *
     *		new Template( {
     *			tag: 'p',
     *			attributes: {
     *				// class="..." attribute gets bound to `observableInstance#a`
     *				'class': bind.to( 'a' )
     *			},
     *			children: [
     *				// <p>...</p> gets bound to `observableInstance#b`; always `toUpperCase()`.
     *				{ text: bind.to( 'b', ( value, node ) => value.toUpperCase() ) }
     *			],
     *			on: {
     *				click: [
     *					// "clicked" event will be fired on `observableInstance` when "click" fires in DOM.
     *					bind.to( 'clicked' ),
     *
     *					// A custom callback function will be executed when "click" fires in DOM.
     *					bind.to( () => {
     *						...
     *					} )
     *				]
     *			}
     *		} ).render();
     *
     *		const bind = Template.bind( observableInstance, emitterInstance );
     *
     *		new Template( {
     *			tag: 'p',
     *		} ).render();
     *
     * @static
     * @method ui.Template.bind#to
     * @param {String|Function} eventNameOrFunctionOrAttribute An attribute name of {@link utils.Observable} or a DOM
     * event name or an event callback.
     * @param {Function} [callback] Allows processing of the value. Accepts `Node` and `value` as arguments.
     * @return {ui.TemplateBinding}
     */
				to: function to(eventNameOrFunctionOrAttribute, callback) {
					return new TemplateToBinding({
						eventNameOrFunction: eventNameOrFunctionOrAttribute,
						attribute: eventNameOrFunctionOrAttribute,
						observable: observable, emitter: emitter, callback: callback
					});
				},


				/**
     * Binds {@link utils.Observable} to HTMLElement attribute or Text Node `textContent`
     * so remains in sync with the Model when it changes. Unlike {@link ui.Template.bind#to},
     * it controls the presence of the attribute/`textContent` depending on the "falseness" of
     * {@link utils.Observable} attribute.
     *
     *		const bind = Template.bind( observableInstance, emitterInstance );
     *
     *		new Template( {
     *			tag: 'input',
     *			attributes: {
     *				// <input checked> when `observableInstance#a` is not undefined/null/false/''
     *				// <input> when `observableInstance#a` is undefined/null/false
     *				checked: bind.if( 'a' )
     *			},
     *			children: [
     *				{
     *					// <input>"b-is-not-set"</input> when `observableInstance#b` is undefined/null/false/''
     *					// <input></input> when `observableInstance#b` is not "falsy"
     *					text: bind.if( 'b', 'b-is-not-set', ( value, node ) => !value )
     *				}
     *			]
     *		} ).render();
     *
     * @static
     * @method ui.Template.bind#if
     * @param {String} attribute An attribute name of {@link utils.Observable} used in the binding.
     * @param {String} [valueIfTrue] Value set when {@link utils.Observable} attribute is not undefined/null/false/''.
     * @param {Function} [callback] Allows processing of the value. Accepts `Node` and `value` as arguments.
     * @return {ui.TemplateBinding}
     */
				if: function _if(attribute, valueIfTrue, callback) {
					return new TemplateIfBinding({
						observable: observable, emitter: emitter, attribute: attribute, valueIfTrue: valueIfTrue, callback: callback
					});
				}
			};
		}

		/**
   * Extends {@link ui.Template} instance with additional content from {@link ui.TemplateDefinition}.
   *
   *		const bind = Template.bind( observable, emitterInstance );
   *		const instance = new Template( {
   *			tag: 'p',
   *			attributes: {
   *				class: 'a',
   *				data-x: bind.to( 'foo' )
   *			},
   *			children: [
   *				{
   *					tag: 'span',
   *					attributes: {
   *						class: 'b'
   *					},
   *					children: [
   *						'Span'
   *					]
   *				}
   *			]
   *		 } );
   *
   *		// Instance-level extension.
   *		Template.extend( instance, {
   *			attributes: {
   *				class: 'b',
   *				data-x: bind.to( 'bar' )
   *			},
   *			children: [
   *				{
   *					attributes: {
   *						class: 'c'
   *					}
   *				}
   *			]
   *		} );
   *
   *		// Child extension.
   *		Template.extend( instance.children.get( 0 ), {
   *			attributes: {
   *				class: 'd'
   *			}
   *		} );
   *
   * the `instance.render().outerHTML` is
   *
   *		<p class="a b" data-x="{ observable.foo } { observable.bar }">
   *			<span class="b c d">Span</span>
   *		</p>
   *
   * @param {ui.Template} template Existing Template instance to be extended.
   * @param {ui.TemplateDefinition} def An extension to existing an template instance.
   */

	}, {
		key: 'extend',
		value: function extend(template, def) {
			extendTemplate(template, normalize$4(clone$1(def)));
		}
	}]);
	return Template;
}();

mix(Template, EmitterMixin);

/**
 * Describes a binding created by {@link ui.Template#bind} interface.
 *
 * @protected
 * @memberOf ui
 */
var TemplateBinding = function () {
	/**
  * Creates an instance of the {@link ui.TemplateBinding} class.
  *
  * @param {ui.TemplateBindingDefinition} def The definition of the binding.
  */
	function TemplateBinding(def) {
		classCallCheck(this, TemplateBinding);

		Object.assign(this, def);

		/**
   * An observable instance of the binding. It provides the attribute
   * with the value or passes the event when a corresponding DOM event is fired.
   *
   * @member {utils.Observable} ui.TemplateBinding#observable
   */

		/**
   * An {@link utils.Emitter} instance used by the binding
   * to (either):
   *
   * * listen to the attribute change in the {@link ui.TemplateBinding#observable},
   * * listen to the event in the DOM.
   *
   * @member {utils.Emitter} ui.TemplateBinding#emitter
   */

		/**
   * The name of the attribute of {@link ui.TemplateBinding#observable} which is observed.
   *
   * @member {String} ui.TemplateBinding#attribute
   */

		/**
   * A custom function to process the value of {@link ui.TemplateBinding#attribute}.
   *
   * @member {Function} [ui.TemplateBinding#callback]
   */
	}

	/**
  * Returns the value of the binding, which is the value of {@link ui.TemplateBinding#attribute} in
  * {@link ui.TemplateBinding#observable}.
  *
  * @param {Node} [node] A native DOM node, passed to the custom {@link ui.TemplateBinding#callback}.
  * @returns {*} The value of {@link ui.TemplateBinding#attribute} in {@link ui.TemplateBinding#observable}.
  */


	createClass(TemplateBinding, [{
		key: 'getValue',
		value: function getValue(domNode) {
			var value = this.observable[this.attribute];

			return this.callback ? this.callback(value, domNode) : value;
		}

		/**
   * Activates the listener for the changes of {@link ui.TemplateBinding#attribute} in
   * {@link ui.TemplateBinding#observable}, which then updates the DOM with the aggregated
   * value of {@link ui.TemplateValueSchema}.
   *
   * For instance, the `class` attribute of the `Template` element can be be bound to
   * the observable `foo` attribute in `ObservableMixin` instance.
   *
   * @param {ui.TemplateValueSchema} valueSchema A full schema to generate an attribute or text in DOM.
   * @param {Node} node A native DOM node, which attribute or text is to be updated.
   * @param {Function} updater A DOM updater function used to update native DOM attribute or text.
   */

	}, {
		key: 'activateAttributeListener',
		value: function activateAttributeListener(valueSchema, node, updater) {
			this.emitter.listenTo(this.observable, 'change:' + this.attribute, function () {
				syncValueSchemaValue(valueSchema, node, updater);
			});
		}
	}]);
	return TemplateBinding;
}();

/**
 * Describes either
 *
 * * a binding to {@link utils.Observable}
 * * or a native DOM event binding
 *
 * created by {@link ui.Template.bind#to} method.
 *
 * @protected
 * @memberOf ui
 */
var TemplateToBinding = function (_TemplateBinding) {
	inherits(TemplateToBinding, _TemplateBinding);

	function TemplateToBinding() {
		classCallCheck(this, TemplateToBinding);
		return possibleConstructorReturn(this, Object.getPrototypeOf(TemplateToBinding).apply(this, arguments));
	}

	createClass(TemplateToBinding, [{
		key: 'activateDomEventListener',

		/**
   * Activates the listener for the native DOM event, which when fired, is propagated by
   * the {@link ui.TemplateBinding#emitter}.
   *
   * @param {HTMLElement} element An element on which listening to the native DOM event.
   * @param {String} domEvtName A name of the native DOM event.
   * @param {String} [domSelector] A selector in DOM to filter delegated events.
   */
		value: function activateDomEventListener(el, domEvtName, domSelector) {
			var _this3 = this;

			this.emitter.listenTo(el, domEvtName, function (evt, domEvt) {
				if (!domSelector || domEvt.target.matches(domSelector)) {
					if (typeof _this3.eventNameOrFunction == 'function') {
						_this3.eventNameOrFunction(domEvt);
					} else {
						_this3.observable.fire(_this3.eventNameOrFunction, domEvt);
					}
				}
			});
		}
	}]);
	return TemplateToBinding;
}(TemplateBinding);

/**
 * Describes a binding to {@link utils.Observable} created by {@link ui.Template.bind#if} method.
 *
 * @protected
 * @memberOf ui
 */
var TemplateIfBinding = function (_TemplateBinding2) {
	inherits(TemplateIfBinding, _TemplateBinding2);

	function TemplateIfBinding() {
		classCallCheck(this, TemplateIfBinding);
		return possibleConstructorReturn(this, Object.getPrototypeOf(TemplateIfBinding).apply(this, arguments));
	}

	createClass(TemplateIfBinding, [{
		key: 'getValue',

		/**
   * @inheritDoc
   */
		value: function getValue(domNode) {
			var value = get(Object.getPrototypeOf(TemplateIfBinding.prototype), 'getValue', this).call(this, domNode);

			return isFalsy(value) ? false : this.valueIfTrue || true;
		}

		/**
   * The value of the DOM attribute/text to be set if the {@link ui.TemplateBinding#attribute} in
   * {@link ui.TemplateBinding#observable} is `true`.
   *
   * @member {String} [ui.TemplateIfBinding#valueIfTrue]
   */

	}]);
	return TemplateIfBinding;
}(TemplateBinding);

// Checks whether given {@link ui.TemplateValueSchema} contains a
// {@link ui.TemplateBinding}.
//
// @param {ui.TemplateValueSchema} valueSchema
// @returns {Boolean}
function hasTemplateBinding(valueSchema) {
	if (!valueSchema) {
		return false;
	}

	// Normalize attributes with additional data like namespace:
	// 		class: { ns: 'abc', value: [ ... ] }
	if (valueSchema.value) {
		valueSchema = valueSchema.value;
	}

	if (Array.isArray(valueSchema)) {
		return valueSchema.some(hasTemplateBinding);
	} else if (valueSchema instanceof TemplateBinding) {
		return true;
	}

	return false;
}

// Assembles the value using {@link ui.TemplateValueSchema} and stores it in a form of
// an Array. Each entry of an Array corresponds to one of {@link ui.TemplateValueSchema}
// items.
//
// @param {ui.TemplateValueSchema} valueSchema
// @param {Node} node DOM Node updated when {@link utils.Observable} changes.
// @return {Array}
function getValueSchemaValue(valueSchema, domNode) {
	return valueSchema.map(function (schemaItem) {
		// Process {@link ui.TemplateBinding} bindings.
		if (schemaItem instanceof TemplateBinding) {
			return schemaItem.getValue(domNode);
		}

		// All static values like strings, numbers, and "falsy" values (false, null, undefined, '', etc.) just pass.
		return schemaItem;
	});
}

// A function executed each time bound Observable attribute changes, which updates DOM with a value
// constructed from {@link ui.TemplateValueSchema}.
//
// @param {ui.TemplateValueSchema} valueSchema
// @param {Node} node DOM Node updated when {@link utils.Observable} changes.
// @param {Function} domUpdater A function which updates DOM (like attribute or text).
function syncValueSchemaValue(valueSchema, domNode, domUpdater) {
	var value = getValueSchemaValue(valueSchema, domNode);

	// Check if valueSchema is a single Template.bind.if, like:
	//		{ class: Template.bind.if( 'foo' ) }
	if (valueSchema.length == 1 && valueSchema[0] instanceof TemplateIfBinding) {
		value = value[0];
	} else {
		value = value.reduce(arrayValueReducer, '');
	}

	if (isFalsy(value)) {
		domUpdater.remove();
	} else {
		domUpdater.set(value);
	}
}

// Returns an object consisting of `set` and `remove` functions, which
// can be used in the context of DOM Node to set or reset `textContent`.
// @see ui.View#_bindToObservable
//
// @param {Node} node DOM Node to be modified.
// @returns {Object}
function getTextUpdater(node) {
	return {
		set: function set(value) {
			node.textContent = value;
		},
		remove: function remove() {
			node.textContent = '';
		}
	};
}

// Returns an object consisting of `set` and `remove` functions, which
// can be used in the context of DOM Node to set or reset an attribute.
// @see ui.View#_bindToObservable
//
// @param {Node} node DOM Node to be modified.
// @param {String} attrName Name of the attribute to be modified.
// @param {String} [ns=null] Namespace to use.
// @returns {Object}
function getAttributeUpdater(el, attrName) {
	var ns = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	return {
		set: function set(value) {
			el.setAttributeNS(ns, attrName, value);
		},
		remove: function remove() {
			el.removeAttributeNS(ns, attrName);
		}
	};
}

// Returns an object consisting of `set` and `remove` functions, which
// can be used in the context of CSSStyleDeclaration to set or remove a style.
// @see ui.View#_bindToObservable
//
// @param {Node} node DOM Node to be modified.
// @param {String} styleName Name of the style to be modified.
// @returns {Object}
function getStyleUpdater(el, styleName) {
	return {
		set: function set(value) {
			el.style[styleName] = value;
		},
		remove: function remove() {
			el.style[styleName] = null;
		}
	};
}

// Clones definition of the template.
//
// @param {ui.TemplateDefinition} def
// @returns {ui.TemplateDefinition}
function clone$1(def) {
	var clone = cloneDeepWith(def, function (value) {
		// Don't clone the `Template.bind`* bindings because of the references to Observable
		// and DOMEmitterMixin instances inside, which would also be traversed and cloned by greedy
		// cloneDeepWith algorithm. There's no point in cloning Observable/DOMEmitterMixins
		// along with the definition.
		//
		// Also don't clone View instances if provided as a child of the Template. The template
		// instance will be extracted from the View during the normalization and there's no need
		// to clone it.
		if (value && (value instanceof TemplateBinding || isView(value))) {
			return value;
		}
	});

	return clone;
}

// Normalizes given {@link ui.TemplateDefinition}.
//
// See:
//  * {@link normalizeAttributes}
//  * {@link normalizeListeners}
//  * {@link normalizePlainTextDefinition}
//  * {@link normalizeTextDefinition}
//
// @param {ui.TemplateDefinition} def
// @returns {ui.TemplateDefinition} Normalized definition.
function normalize$4(def) {
	if (typeof def == 'string') {
		def = normalizePlainTextDefinition(def);
	} else if (def.text) {
		normalizeTextDefinition(def);
	}

	if (def.on) {
		def.eventListeners = normalizeListeners(def.on);

		// Template mixes EmitterMixin, so delete #on to avoid collision.
		delete def.on;
	}

	if (!def.text) {
		if (def.attributes) {
			normalizeAttributes(def.attributes);
		}

		var children = new Collection();

		if (def.children) {
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = def.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var child = _step2.value;

					children.add(isView(child) ? child : new Template(child));
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}
		}

		def.children = children;
	}

	return def;
}

// Normalizes "attributes" section of {@link ui.TemplateDefinition}.
//
//		attributes: {
//			a: 'bar',
//			b: {@link ui.TemplateBinding},
//			c: {
//				value: 'bar'
//			}
//		}
//
// becomes
//
//		attributes: {
//			a: [ 'bar' ],
//			b: [ {@link ui.TemplateBinding} ],
//			c: {
//				value: [ 'bar' ]
//			}
//		}
//
// @param {Object} attrs
function normalizeAttributes(attrs) {
	for (var a in attrs) {
		if (attrs[a].value) {
			attrs[a].value = [].concat(attrs[a].value);
		}

		arrayify(attrs, a);
	}
}

// Normalizes "on" section of {@link ui.TemplateDefinition}.
//
//		on: {
//			a: 'bar',
//			b: {@link ui.TemplateBinding},
//			c: [ {@link ui.TemplateBinding}, () => { ... } ]
//		}
//
// becomes
//
//		on: {
//			a: [ 'bar' ],
//			b: [ {@link ui.TemplateBinding} ],
//			c: [ {@link ui.TemplateBinding}, () => { ... } ]
//		}
//
// @param {Object} listeners
// @returns {Object} Object containing normalized listeners.
function normalizeListeners(listeners) {
	for (var l in listeners) {
		arrayify(listeners, l);
	}

	return listeners;
}

// Normalizes "string" {@link ui.TemplateDefinition}.
//
//		"foo"
//
// becomes
//
//		{ text: [ 'foo' ] },
//
// @param {String} def
// @returns {ui.TemplateDefinition} Normalized template definition.
function normalizePlainTextDefinition(def) {
	return {
		text: [def]
	};
}

// Normalizes text {@link ui.TemplateDefinition}.
//
//		children: [
//			{ text: 'def' },
//			{ text: {@link ui.TemplateBinding} }
//		]
//
// becomes
//
//		children: [
//			{ text: [ 'def' ] },
//			{ text: [ {@link ui.TemplateBinding} ] }
//		]
//
// @param {ui.TemplateDefinition} def
function normalizeTextDefinition(def) {
	if (!Array.isArray(def.text)) {
		def.text = [def.text];
	}
}

// Wraps an entry in Object in an Array, if not already one.
//
//		{
//			x: 'y',
//			a: [ 'b' ]
//		}
//
// becomes
//
//		{
//			x: [ 'y' ],
//			a: [ 'b' ]
//		}
//
// @param {Object} obj
// @param {String} key
function arrayify(obj, key) {
	if (!Array.isArray(obj[key])) {
		obj[key] = [obj[key]];
	}
}

// A helper which concatenates the value avoiding unwanted
// leading white spaces.
//
// @param {String} prev
// @param {String} cur
// @returns {String}
function arrayValueReducer(prev, cur) {
	if (isFalsy(cur)) {
		return prev;
	} else if (isFalsy(prev)) {
		return cur;
	} else {
		return prev + ' ' + cur;
	}
}

// Extends one object defined in the following format:
//
//		{
//			key1: [Array1],
//			key2: [Array2],
//			...
//			keyN: [ArrayN]
//		}
//
// with another object of the same data format.
//
// @param {Object} obj Base object.
// @param {Object} ext Object extending base.
// @returns {String}
function extendObjectValueArray(obj, ext) {
	for (var a in ext) {
		if (obj[a]) {
			var _obj$a;

			(_obj$a = obj[a]).push.apply(_obj$a, toConsumableArray(ext[a]));
		} else {
			obj[a] = ext[a];
		}
	}
}

// A helper for {@link ui.Template#extend}. Recursively extends {@link ui.Template} instance
// with content from {ui.TemplateDefinition}. See {@link ui.Template#extend} to learn more.
//
// @param {ui.Template} def A template instance to be extended.
// @param {ui.TemplateDefinition} def A definition which is to extend the template instance.
function extendTemplate(template, def) {
	if (def.attributes) {
		if (!template.attributes) {
			template.attributes = {};
		}

		extendObjectValueArray(template.attributes, def.attributes);
	}

	if (def.eventListeners) {
		if (!template.eventListeners) {
			template.eventListeners = {};
		}

		extendObjectValueArray(template.eventListeners, def.eventListeners);
	}

	if (def.text) {
		var _template$text;

		(_template$text = template.text).push.apply(_template$text, toConsumableArray(def.text));
	}

	if (def.children && def.children.length) {
		if (template.children.length != def.children.length) {
			/**
    * The number of children in extended definition does not match.
    *
    * @error ui-template-extend-children-mismatch
    */
			throw new CKEditorError('ui-template-extend-children-mismatch: The number of children in extended definition does not match.');
		}

		var childIndex = 0;

		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;

		try {
			for (var _iterator3 = def.children[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var childDef = _step3.value;

				extendTemplate(template.children.get(childIndex++), childDef);
			}
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}
	}
}

// Checks if value is "falsy".
// Note: 0 (Number) is not "falsy" in this context.
//
// @private
// @param {*} value Value to be checked.
function isFalsy(value) {
	return !value && value !== 0;
}

// Checks if the item is an instance of {@link ui.View}
//
// @private
// @param {*} value Value to be checked.
function isView(item) {
	return item instanceof View;
}

/**
 * A definition of {@link ui.Template}.
 * See: {@link ui.TemplateValueSchema}.
 *
 *		new Template( {
 *			tag: 'p',
 *			children: [
 *				{
 *					tag: 'span',
 *					attributes: { ... },
 *					children: [ ... ],
 *					...
 *				},
 *				{
 *					text: 'static–text'
 *				},
 *				'also-static–text',
 *				<{@link ui.View} instance>
 *				...
 *			],
 *			attributes: {
 *				class: {@link ui.TemplateValueSchema},
 *				id: {@link ui.TemplateValueSchema},
 *				style: {@link ui.TemplateValueSchema}
 *				...
 *			},
 *			on: {
 *				'click': {@link ui.TemplateListenerSchema}
 *				'keyup@.some-class': {@link ui.TemplateListenerSchema},
 *				...
 *			}
 *		} );
 *
 * @typedef ui.TemplateDefinition
 * @type Object
 * @property {String} tag
 * @property {Array.<ui.TemplateDefinition>} [children]
 * @property {Object.<String,ui.TemplateValueSchema>} [attributes]
 * @property {String|ui.TemplateValueSchema|Array.<String|ui.TemplateValueSchema>} [text]
 * @property {Object.<String,ui.TemplateListenerSchema>} [on]
 */

/**
 * Describes a value of HTMLElement attribute or `textContent`. See:
 *  * {@link ui.TemplateDefinition},
 *  * {@link ui.Template#bind},
 *
 *		const bind = Template.bind( observableInstance, emitterInstance );
 *
 *		new Template( {
 *			tag: 'p',
 *			attributes: {
 *				// Plain String schema.
 *				class: 'static-text'
 *
 *				// Object schema, an `ObservableMixin` binding.
 *				class: bind.to( 'foo' )
 *
 *				// Array schema, combines the above.
 *				class: [
 *					'static-text',
 *					bind.to( 'bar', () => { ... } )
 *				],
 *
 *				// Array schema, with custom namespace.
 *				class: {
 *					ns: 'http://ns.url',
 *					value: [
 *						bind.if( 'baz', 'value-when-true' )
 *						'static-text'
 *					]
 *				},
 *
 *				// Object literal schema, specific for styles.
 *				style: {
 *					color: 'red',
 *					backgroundColor: bind.to( 'qux', () => { ... } )
 *				}
 *			}
 *		} );
 *
 * @typedef ui.TemplateValueSchema
 * @type {Object|String|Array}
 */

/**
 * Describes a listener attached to HTMLElement. See: {@link ui.TemplateDefinition}.
 *
 *		new Template( {
 *			tag: 'p',
 *			on: {
 *				// Plain String schema.
 *				click: 'clicked'
 *
 *				// Object schema, an `ObservableMixin` binding.
 *				click: {@link ui.TemplateBinding}
 *
 *				// Array schema, combines the above.
 *				click: [
 *					'clicked',
 *					{@link ui.TemplateBinding}
 *				],
 *
 *				// Array schema, with custom callback.
 *				// Note: It will work for "click" event on class=".foo" children only.
 *				'click@.foo': {
 *					'clicked',
 *					{@link ui.TemplateBinding},
 *					() => { ... }
 *				}
 *			}
 *		} );
 *
 * @typedef ui.TemplateListenerSchema
 * @type {Object|String|Array}
 */

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Basic View class.
 *
 * @memberOf ui
 * @mixes DOMEmitterMixin
 * @mixes ObservableMixin
 */

var View = function () {
	/**
  * Creates an instance of the {@link ui.View} class.
  *
  * @param {utils.Locale} [locale] The {@link core.editor.Editor#locale editor's locale} instance.
  */
	function View(locale) {
		classCallCheck(this, View);

		/**
   * @readonly
   * @member {utils.Locale} ui.View#locale
   */
		this.locale = locale;

		/**
   * Shorthand for {@link utils.Locale#t}.
   *
   * Note: If locale instance hasn't been passed to the view this method may not be available.
   *
   * @see utils.Locale#t
   * @method ui.View#t
   */
		this.t = locale && locale.t;

		/**
   * Regions of this view. See {@link ui.View#register}.
   *
   * @member {utils.Collection} ui.View#regions
   */
		this.regions = new Collection({
			idProperty: 'name'
		});

		/**
   * Template of this view.
   *
   * @member {ui.Template} ui.View#template
   */

		/**
   * Region selectors of this view. See {@link ui.View#register}.
   *
   * @private
   * @member {Object} ui.View#_regionSelectors
   */
		this._regionSelectors = {};

		/**
   * Element of this view.
   *
   * @private
   * @member {HTMLElement} ui.View.#_element
   */

		/**
   * Cached {@link ui.Template} binder object specific for this instance.
   * See {@link ui.View#bindTemplate}.
   *
   * @private
   * @member {Object} ui.View.#_bindTemplate
   */
	}

	/**
  * Element of this view. The element is rendered on first reference
  * using {@link ui.View#template} definition.
  *
  * @type {HTMLElement}
  */


	createClass(View, [{
		key: 'init',


		/**
   * Initializes the view.
   *
   * Note: {@link ui.Controller} supports if a promise is returned by this method,
   * what means that view initialization may be asynchronous.
   */
		value: function init() {
			this._initRegions();
		}

		/**
   * Registers a region in {@link ui.View#regions}.
   *
   *		let view = new View();
   *
   *		// region.name == "foo", region.element == view.element.firstChild
   *		view.register( 'foo', el => el.firstChild );
   *
   *		// region.name == "bar", region.element == view.element.querySelector( 'span' )
   *		view.register( new Region( 'bar' ), 'span' );
   *
   *		// region.name == "bar", region.element == view.element.querySelector( '#div#id' )
   *		view.register( 'bar', 'div#id', true );
   *
   *		// region.name == "baz", region.element == null
   *		view.register( 'baz', true );
   *
   * @param {String|Region} stringOrRegion The name or an instance of the Region
   * to be registered. If `String`, the region will be created on the fly.
   * @param {String|Function|true} regionSelector The selector to retrieve region's element
   * in DOM when the region instance is initialized (see {@link Region#init}, {@link ui.View#init}).
   * @param {Boolean} [override] When set `true` it will allow overriding of registered regions.
   */

	}, {
		key: 'register',
		value: function register() {
			var region = void 0,
			    regionName = void 0;

			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			if (typeof args[0] === 'string') {
				regionName = args[0];
				region = this.regions.get(regionName) || new Region(regionName);
			} else if (args[0] instanceof Region) {
				regionName = args[0].name;
				region = args[0];
			} else {
				/**
     * A name of the region or an instance of Region is required.
     *
     * @error ui-view-register-wrongtype
     */
				throw new CKEditorError('ui-view-register-wrongtype');
			}

			var regionSelector = args[1];

			if (!regionSelector || !isValidRegionSelector(regionSelector)) {
				/**
     * The selector must be String, Function or `true`.
     *
     * @error ui-view-register-badselector
     */
				throw new CKEditorError('ui-view-register-badselector');
			}

			var registered = this.regions.get(regionName);

			if (!registered) {
				this.regions.add(region);
			} else {
				if (registered !== region) {
					if (!args[2]) {
						/**
       * Overriding is possible only when `override` flag is set.
       *
       * @error ui-view-register-override
       */
						throw new CKEditorError('ui-view-register-override');
					}

					this.regions.remove(registered);
					this.regions.add(region);
				}
			}

			this._regionSelectors[regionName] = regionSelector;
		}

		/**
   * Destroys the view instance. The process includes:
   *
   * 1. Removal of child views from {@link ui.View#regions}.
   * 2. Destruction of the {@link ui.View#regions}.
   * 3. Removal of {@link #_el} from DOM.
   */

	}, {
		key: 'destroy',
		value: function destroy() {
			var childView = void 0;

			this.stopListening();

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = this.regions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var region = _step.value;

					while (childView = region.views.get(0)) {
						region.views.remove(childView);
					}

					this.regions.remove(region).destroy();
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			if (this.template) {
				this.element.remove();
			}

			this.model = this.regions = this.template = this.locale = this.t = null;
			this._regionSelectors = this._element = null;
		}

		/**
   * Initializes {@link ui.View#regions} of this view by passing a DOM element
   * generated from {@link ui.View#_regionSelectors} into {@link Region#init}.
   *
   * @protected
   */

	}, {
		key: '_initRegions',
		value: function _initRegions() {
			var region = void 0,
			    regionEl = void 0,
			    regionSelector = void 0;

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = this.regions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					region = _step2.value;

					regionSelector = this._regionSelectors[region.name];

					if (typeof regionSelector == 'string') {
						regionEl = this.element.querySelector(regionSelector);
					} else if (typeof regionSelector == 'function') {
						regionEl = regionSelector(this.element);
					} else {
						regionEl = null;
					}

					region.init(regionEl);
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}
		}
	}, {
		key: 'element',
		get: function get() {
			if (this._element) {
				return this._element;
			}

			// No template means no element (a virtual view).
			if (!this.template) {
				return null;
			}

			return this._element = this.template.render();
		}

		/**
   * @type {HTMLElement}
   */
		,
		set: function set(el) {
			this._element = el;
		}

		/**
   * Shorthand for {@link ui.Template#bind}, bound to {@link ui.View} on the first access.
   *
   * Cached {@link ui.Template#bind} object is stored in {@link ui.View.#_bindTemplate}.
   *
   * @method ui.View#bindTemplate
   */

	}, {
		key: 'bindTemplate',
		get: function get() {
			if (this._bindTemplate) {
				return this._bindTemplate;
			}

			return this._bindTemplate = Template.bind(this, this);
		}
	}]);
	return View;
}();

mix(View, DOMEmitterMixin);
mix(View, ObservableMixin);

var validSelectorTypes = new Set(['string', 'boolean', 'function']);

/**
 * Check whether region selector is valid.
 *
 * @ignore
 * @private
 * @param {*} selector Selector to be checked.
 * @returns {Boolean}
 */
function isValidRegionSelector(selector) {
	return validSelectorTypes.has(typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) && selector !== false;
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* globals document */

/**
 * The icon manager view class.
 *
 * See {@link ui.iconManager.IconManager}.
 *
 * @memberOf ui.iconManager
 * @extends ui.View
 */

var IconManagerView = function (_View) {
	inherits(IconManagerView, _View);

	function IconManagerView(locale) {
		classCallCheck(this, IconManagerView);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(IconManagerView).call(this, locale));

		_this.template = new Template({
			tag: 'svg',
			ns: 'http://www.w3.org/2000/svg',
			attributes: {
				class: 'ck-icon-manager__sprite'
			}
		});

		/**
   * The actual SVG (HTML) of the icons to be injected in DOM.
   *
   * @observable
   * @member {String} ui.iconManager.IconManagerView#sprite
   */
		return _this;
	}

	createClass(IconManagerView, [{
		key: 'init',
		value: function init() {
			// Note: In MS Edge it's not enough to set:
			//
			//		this.element.innerHTML = this.sprite;
			//
			// because for some reason the browser won't parse the symbols string
			// properly as svg content. Instead, an explicit parsing is needed (#55).
			var tmp = document.createElement('div');

			tmp.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg">' + this.sprite + '</svg>';

			var symbols = tmp.firstChild.childNodes;

			// Pick symbols from the tmp and put them into icon manager.
			// Note: MS Edge does not support forEach or Symbol.iterator for NodeList.
			for (var i = 0; i < symbols.length; ++i) {
				this.element.appendChild(document.importNode(symbols[i], true));
			}

			return get(Object.getPrototypeOf(IconManagerView.prototype), 'init', this).call(this);
		}
	}]);
	return IconManagerView;
}(View);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The base MVC model class.
 *
 * @memberOf ui
 * @mixes utils.ObservaleMixin
 */

var Model =
/**
 * Creates a new Model instance.
 *
 * @param {Object} [attributes] The model state attributes to be defined during the instance creation.
 * @param {Object} [properties] The (out of state) properties to be appended to the instance during creation.
 */
function Model(attributes, properties) {
	classCallCheck(this, Model);

	// Extend this instance with the additional (out of state) properties.
	if (properties) {
		assignIn(this, properties);
	}

	// Initialize the attributes.
	if (attributes) {
		this.set(attributes);
	}
};

mix(Model, ObservableMixin);

var iconIds = ['ck-icon-align-center', 'ck-icon-align-left', 'ck-icon-align-right', 'ck-icon-bold', 'ck-icon-bold', 'ck-icon-bulletedlist', 'ck-icon-image', 'ck-icon-italic', 'ck-icon-italic', 'ck-icon-link', 'ck-icon-numberedlist', 'ck-icon-picker', 'ck-icon-quote', 'ck-icon-redo', 'ck-icon-source', 'ck-icon-table', 'ck-icon-underline', 'ck-icon-undo', 'ck-icon-unlink'];
var iconPrefix = 'ck-icon-';

var iconManagerModel = new Model({
  icons: iconIds.map(function (i) {
    return i.slice(iconPrefix.length);
  }),
  sprite: '<symbol viewBox="0 0 20 20" id="ck-icon-align-center"><title>align-center</title><path d="M16 10v1H4v-1h12zm-1 6v1H5v-1h10zm3-3v1H2v-1h16zm-2-9v1H4V4h12zm2 3v1H2V7h16z" fill="#444" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-align-left"><title>align-left</title><path d="M3 10v1h12v-1H3zm0 6v1h10v-1H3zm0-3v1h15v-1H3zm0-9v1h12V4H3zm0 3v1h15V7H3z" fill="#444" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-align-right"><title>align-right</title><path d="M17 10v1H5v-1h12zm0 6v1H7v-1h10zm0-3v1H2v-1h15zm0-9v1H5V4h12zm0 3v1H2V7h15z" fill="#444" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-bold"><title>bold</title><path d="M15.135 10.409c.361.248.654.56.88.934.225.375.338.816.338 1.324 0 .609-.128 1.123-.385 1.543-.256.42-.624.751-1.103.994a5.908 5.908 0 0 1-1.755.55c-.663.107-1.442.16-2.338.16H4.539v-.66a22.5 22.5 0 0 0 .66-.076c.265-.033.45-.073.558-.118.208-.085.35-.196.427-.334.076-.138.114-.317.114-.537V5.732c0-.203-.031-.372-.093-.507s-.211-.254-.448-.355a3.326 3.326 0 0 0-.61-.182 14.136 14.136 0 0 0-.608-.114v-.66h6.52c1.64 0 2.825.226 3.552.677.727.45 1.09 1.116 1.09 1.995 0 .406-.08.763-.244 1.07a2.388 2.388 0 0 1-.702.8 4.214 4.214 0 0 1-.99.54c-.383.153-.795.28-1.234.381v.16c.44.046.896.143 1.37.292.473.15.885.343 1.234.58zm-2.723-3.611c0-.665-.187-1.184-.562-1.556-.375-.372-.937-.558-1.687-.558-.107 0-.247.004-.419.012l-.444.021v4.449h.44c.913 0 1.587-.213 2.021-.639.434-.425.651-1.002.651-1.73zm.592 5.759c0-.835-.248-1.475-.744-1.92-.496-.445-1.21-.668-2.14-.668a22.977 22.977 0 0 0-.82.034v4.389c.05.208.209.385.474.528.265.144.586.216.964.216.67 0 1.216-.225 1.636-.676.42-.452.63-1.086.63-1.903z" fill="#454545" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-bold"><title>bold</title><path d="M15.135 10.409c.361.248.654.56.88.934.225.375.338.816.338 1.324 0 .609-.128 1.123-.385 1.543-.256.42-.624.751-1.103.994a5.908 5.908 0 0 1-1.755.55c-.663.107-1.442.16-2.338.16H4.539v-.66a22.5 22.5 0 0 0 .66-.076c.265-.033.45-.073.558-.118.208-.085.35-.196.427-.334.076-.138.114-.317.114-.537V5.732c0-.203-.031-.372-.093-.507s-.211-.254-.448-.355a3.326 3.326 0 0 0-.61-.182 14.136 14.136 0 0 0-.608-.114v-.66h6.52c1.64 0 2.825.226 3.552.677.727.45 1.09 1.116 1.09 1.995 0 .406-.08.763-.244 1.07a2.388 2.388 0 0 1-.702.8 4.214 4.214 0 0 1-.99.54c-.383.153-.795.28-1.234.381v.16c.44.046.896.143 1.37.292.473.15.885.343 1.234.58zm-2.723-3.611c0-.665-.187-1.184-.562-1.556-.375-.372-.937-.558-1.687-.558-.107 0-.247.004-.419.012l-.444.021v4.449h.44c.913 0 1.587-.213 2.021-.639.434-.425.651-1.002.651-1.73zm.592 5.759c0-.835-.248-1.475-.744-1.92-.496-.445-1.21-.668-2.14-.668a22.977 22.977 0 0 0-.82.034v4.389c.05.208.209.385.474.528.265.144.586.216.964.216.67 0 1.216-.225 1.636-.676.42-.452.63-1.086.63-1.903z" fill="#454545" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-bulletedlist"><title>bulletedlist</title><path d="M6 16v1h10v-1H6zM6 4v1h12V4H6zm0 6v1h11v-1H6zM1 4.5C1 3.672 1.666 3 2.5 3 3.328 3 4 3.666 4 4.5 4 5.328 3.334 6 2.5 6 1.672 6 1 5.334 1 4.5zm0 6C1 9.672 1.666 9 2.5 9c.828 0 1.5.666 1.5 1.5 0 .828-.666 1.5-1.5 1.5-.828 0-1.5-.666-1.5-1.5zm0 6c0-.828.666-1.5 1.5-1.5.828 0 1.5.666 1.5 1.5 0 .828-.666 1.5-1.5 1.5-.828 0-1.5-.666-1.5-1.5z" fill="#454545" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-image"><title>image</title><path d="M2 14.994C2 16.102 2.895 17 3.994 17h12.012A2 2 0 0 0 18 14.994V5.006A2.001 2.001 0 0 0 16.006 3H3.994A2 2 0 0 0 2 5.006v9.988zm1-9.992C3 4.45 3.45 4 4.007 4h11.986A1.01 1.01 0 0 1 17 5.002v9.996C17 15.55 16.55 16 15.993 16H4.007A1.01 1.01 0 0 1 3 14.998V5.002zm1.024 10H16v-3.096l-2.89-4.263-3.096 5.257-3.003-2.103L4 13.96l.024 1.043zM6.406 6A1.4 1.4 0 0 0 5 7.393a1.4 1.4 0 0 0 1.406 1.393 1.4 1.4 0 0 0 1.407-1.393A1.4 1.4 0 0 0 6.406 6z" fill="#454545" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-italic"><title>italic</title><path d="M13.825 3.914l-.126.558a5.701 5.701 0 0 0-.685.076c-.282.045-.49.088-.626.127-.237.073-.406.186-.508.338a1.586 1.586 0 0 0-.22.5l-2.03 8.769a1.24 1.24 0 0 0-.034.27c.001.13.03.24.086.33.056.09.157.17.304.237.085.04.27.086.558.14.288.053.502.086.643.097l-.127.558H5.656l.127-.558.677-.05c.293-.023.501-.057.625-.102a1.11 1.11 0 0 0 .5-.326c.112-.138.188-.306.228-.503l2.02-8.778a1.428 1.428 0 0 0 .035-.305.59.59 0 0 0-.072-.295c-.048-.085-.148-.161-.3-.229a3.457 3.457 0 0 0-.622-.19 5.001 5.001 0 0 0-.58-.106l.128-.558h5.403z" fill="#454545" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-italic"><title>italic</title><path d="M13.825 3.914l-.126.558a5.701 5.701 0 0 0-.685.076c-.282.045-.49.088-.626.127-.237.073-.406.186-.508.338a1.586 1.586 0 0 0-.22.5l-2.03 8.769a1.24 1.24 0 0 0-.034.27c.001.13.03.24.086.33.056.09.157.17.304.237.085.04.27.086.558.14.288.053.502.086.643.097l-.127.558H5.656l.127-.558.677-.05c.293-.023.501-.057.625-.102a1.11 1.11 0 0 0 .5-.326c.112-.138.188-.306.228-.503l2.02-8.778a1.428 1.428 0 0 0 .035-.305.59.59 0 0 0-.072-.295c-.048-.085-.148-.161-.3-.229a3.457 3.457 0 0 0-.622-.19 5.001 5.001 0 0 0-.58-.106l.128-.558h5.403z" fill="#454545" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-link"><title>link</title><g transform="rotate(45 5.793 16.243)" fill="#222" fill-rule="evenodd"><path d="M8 6.56V4.824A3.995 3.995 0 0 0 4 .828a4 4 0 0 0-4 3.997v2.93a3.995 3.995 0 0 0 4 3.997c.551 0 1.077-.112 1.555-.314H5.12v-.903A2.99 2.99 0 0 1 4 10.752c-1.657 0-3-1.336-3-2.997v-2.93a3 3 0 0 1 6 0v1.734h1z"/><path d="M2.636 6.902A3.99 3.99 0 0 1 4 6.662c2.21 0 4 1.786 4 3.997v2.93a4 4 0 0 1-4 3.997c-2.21 0-4-1.785-4-3.996v-1.927h1v1.927a3 3 0 0 0 6 0v-2.931a2.995 2.995 0 0 0-3-2.996c-.49 0-.954.118-1.364.327V6.902z"/></g></symbol><symbol viewBox="0 0 20 20" id="ck-icon-numberedlist"><title>numberedlist</title><g transform="translate(2 2)" fill="#454545" fill-rule="evenodd"><path d="M5 15h10v-1H5v1zM4 2v1h13V2H4zm1 6v1h11V8H5zM0 .5c0 .277.223.5.5.5H1v3.5a.499.499 0 1 0 1 0v-4c0-.277-.223-.5-.5-.5h-1C.223 0 0 .223 0 .5zM.5 6a.499.499 0 1 0 0 1H2v1H.5c-.277 0-.5.223-.5.5v2c0 .277.223.5.5.5h2a.499.499 0 1 0 0-1H1V9h1.5a.46.46 0 0 0 .188-.031.45.45 0 0 0 .28-.281A.461.461 0 0 0 3 8.5v-2a.46.46 0 0 0-.031-.187.45.45 0 0 0-.281-.282.463.463 0 0 0-.126-.03H.5V6zM2.852 16.853a.493.493 0 0 0 .148-.35v-4.005A.493.493 0 0 0 2.505 12H.495a.494.494 0 0 0-.495.5c0 .268.222.5.495.5H2v1H.495a.494.494 0 0 0-.495.5c0 .268.222.5.495.5H2v1H.495a.494.494 0 0 0-.495.5c0 .268.222.5.495.5h2.01a.49.49 0 0 0 .351-.146z"/></g></symbol><symbol viewBox="0 0 20 20" id="ck-icon-picker"><title>picker</title><path d="M9.635 7.529l-6.252 6.474A2 2 0 0 0 6.26 16.78l6.252-6.473-.72-.695-6.251 6.474a1 1 0 0 1-1.439-1.39l6.252-6.473-.72-.695zm5.125.746c.115-.096.238-.21.369-.346 1.332-1.379 1.76-3.127.955-3.903-.805-.777-2.537-.29-3.868 1.09-.131.136-.241.262-.332.38l2.876 2.779zm-4.755-3.27l4.774 4.61-.662.685-4.774-4.61.662-.685z" fill="#454545" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-quote"><title>quote</title><path d="M12.061 15.51v-.882c1.395-.847 2.345-1.633 2.85-2.358.37-.533.554-1.162.554-1.887 0-.437-.082-.759-.246-.964-.15-.205-.328-.307-.533-.307-.137 0-.328.048-.574.143-.37.123-.67.185-.902.185-.547 0-1.033-.205-1.456-.615-.424-.41-.636-.923-.636-1.538 0-.698.212-1.238.636-1.62a3.002 3.002 0 0 1 2.05-.78c.93 0 1.757.39 2.482 1.17.724.778 1.087 1.742 1.087 2.89 0 1.614-.602 3.084-1.805 4.41-.807.875-1.976 1.593-3.507 2.153zm-8.386 0v-.882c1.394-.847 2.345-1.633 2.85-2.358.37-.533.554-1.162.554-1.887 0-.437-.082-.759-.246-.964-.15-.205-.328-.307-.533-.307-.137 0-.328.048-.574.143-.37.123-.67.185-.903.185-.547 0-1.032-.205-1.456-.615-.424-.41-.636-.923-.636-1.538 0-.698.212-1.238.636-1.62a3.002 3.002 0 0 1 2.051-.78c.93 0 1.757.39 2.481 1.17.725.778 1.087 1.742 1.087 2.89 0 1.614-.601 3.084-1.804 4.41-.807.875-1.976 1.593-3.507 2.153z" fill="#454545" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-redo"><title>redo</title><path d="M10 16l1-3.982c-3.417 0-8.616.869-10 3.982 0-5.983 6.601-7.96 10-7.96 0-.85-1-3.32-1-4.04l8 6-8 6z" fill="#454545" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-source"><title>source</title><path d="M15.116 7.961l2.426 2.206-.01-.417-.01-.525-5.87 5.831.916.923 5.87-5.832.485-.482-.506-.46-2.419-2.198-.882.954zm-2.96-2.69l-.483-.44.874-.961.491.446-.882.955zm-7.041 7.612l-2.442-2.22-.507-.46.486-.483 5.87-5.83.915.922-5.87 5.83-.02-.941 2.45 2.227-.882.955zm2.96 2.69l.467.425.875-.962-.46-.417-.882.955zM4.518 17.43L17.475 3.422l-.954-.882L3.564 16.548l.954.882z" fill="#232323" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-table"><title>table</title><path d="M3.994 4A2 2 0 0 0 2 6.006v9.988C2 17.102 2.895 18 3.994 18h12.012A2 2 0 0 0 18 15.994V6.006A2.001 2.001 0 0 0 16.006 4H3.994zM3 6.018h4v3H3v-3zm5 0h4v3H8v-3zm5 0h4v3h-4v-3zm-10 4h4v3H3v-3zm5 0h4v3H8v-3zm5 0h4v3h-4v-3zm-10 4h4v3H3v-3zm5 0h4v3H8v-3zm5 0h4v3h-4v-3z" fill="#454545" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-underline"><title>underline</title><g transform="translate(4 3)" fill="none" fill-rule="evenodd"><path d="M12.628 1.5c-.154.006-.38.039-.678.1a2.11 2.11 0 0 0-.726.272c-.188.127-.317.388-.388.785-.072.396-.108.88-.108 1.453v5.096c0 .65-.135 1.214-.405 1.693-.27.479-.624.873-1.065 1.18a4.49 4.49 0 0 1-1.375.641c-.482.13-.943.194-1.383.194-.705 0-1.333-.092-1.883-.277-.55-.184-1.013-.433-1.388-.747a3.143 3.143 0 0 1-.834-1.078 2.986 2.986 0 0 1-.28-1.268V2.615c0-.192-.032-.353-.096-.483-.063-.13-.191-.249-.384-.359a1.93 1.93 0 0 0-.528-.186A4.137 4.137 0 0 0 .578 1.5V.914H5.46V1.5c-.154.006-.348.03-.582.075a3.874 3.874 0 0 0-.516.124c-.188.066-.313.176-.376.33a1.313 1.313 0 0 0-.095.504v6.475c0 .313.034.642.103.987.069.344.205.664.409.962.215.303.506.55.875.743.37.193.876.29 1.52.29.606 0 1.114-.097 1.524-.29.41-.193.733-.446.97-.76.226-.297.386-.608.48-.933.093-.325.14-.652.14-.983V4.218c0-.612-.045-1.111-.133-1.5-.088-.388-.217-.642-.388-.763-.192-.138-.455-.245-.788-.322a5.096 5.096 0 0 0-.764-.133V.914h4.79V1.5z" fill="#454545"/><path fill="#585858" d="M0 14h12v1H0z"/></g></symbol><symbol viewBox="0 0 20 20" id="ck-icon-undo"><title>undo</title><path d="M2 10l8 6-1-3.982c3.417 0 8.616.869 10 3.982 0-5.983-6.601-7.96-10-7.96 0-.85 1-3.32 1-4.04l-8 6z" fill="#454545" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-unlink"><title>unlink</title><g transform="rotate(45 5.793 16.243)" fill="#222" fill-rule="evenodd"><path d="M8 6.56V4.824A3.995 3.995 0 0 0 4 .828a4 4 0 0 0-4 3.997v2.93a3.995 3.995 0 0 0 4 3.997c.551 0 1.077-.112 1.555-.314H5.12v-.903A2.99 2.99 0 0 1 4 10.752c-1.657 0-3-1.336-3-2.997v-2.93a3 3 0 0 1 6 0v1.734h1z"/><path d="M12.13 9.692V6.076h-1.02v3.616H7.793v1.02h3.317v3.616h1.02v-3.616h3.915v-1.02H12.13zm-4.604-1.05A4.067 4.067 0 0 0 2.689 6.98v1.123c.418-.216.891-.338 1.392-.338 1.166 0 2.18.656 2.697 1.625l.748-.748zm.636 3.752v1.484c0 2.276-1.83 4.122-4.08 4.122C1.825 18 0 16.159 0 13.878v-1.987h1.02v1.987c0 1.713 1.37 3.09 3.061 3.09 1.687 0 3.061-1.383 3.061-3.09v-2.504l1.02 1.02z"/></g></symbol>'
});

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The editor UI controller class. It's a base class for the editor
 * main view controllers.
 *
 *		// An instance of EditorUI.
 *		new EditorUI( editor );
 *
 * See {@link ui.editorUI.EditorUIView}, {@link ui.iconManager.IconManager}.
 *
 * @memberOf ui.editorUI
 * @extends ui.Controller
 * @mixes utils.ObservaleMixin
 */

var EditorUI = function (_Controller) {
	inherits(EditorUI, _Controller);

	/**
  * Creates an instance of {@link ui.editorUI.EditorUI} class.
  *
  * @param {core.editor.Editor} editor
  */
	function EditorUI(editor) {
		classCallCheck(this, EditorUI);

		/**
   * @readonly
   * @member {core.editor.Editor} ui.editorUI.EditorUI#editor
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(EditorUI).call(this));

		_this.editor = editor;

		/**
   * @readonly
   * @member {ui.ComponentFactory} ui.editorUI.EditorUI#featureComponents
   */
		_this.featureComponents = new ComponentFactory(editor);

		_this.addCollection('body');
		return _this;
	}

	/**
  * Initializes EditorUI instance.
  *
  * @returns {Promise}
  */


	createClass(EditorUI, [{
		key: 'init',
		value: function init() {
			this._setupIconManager();

			return get(Object.getPrototypeOf(EditorUI.prototype), 'init', this).call(this);
		}

		/**
   * Injects the {@link ui.iconManager.IconManager} into DOM.
   *
   * @protected
   */

	}, {
		key: '_setupIconManager',
		value: function _setupIconManager() {
			/**
    * Icons available in the UI.
    *
    * @readonly
    * @member {Array} ui.editorUI.EditorUI#icons
    */
			this.icons = iconManagerModel.icons;

			this.collections.get('body').add(new IconManager(iconManagerModel, new IconManagerView()));
		}
	}]);
	return EditorUI;
}(Controller);

mix(EditorUI, ObservableMixin);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The boxed editor UI controller class. This class controls an editor interface
 * consisting of a toolbar and an editable area, enclosed within a box.
 *
 *		// An instance of BoxedEditorUI.
 *		new BoxedEditorUI( editor );
 *
 * See {@link ui.editorUI.boxed.BoxedEditorUIView}.
 *
 * @member ui.editorUI.boxed
 * @extends ui.editorUI.EditorUI
 */

var BoxedEditorUI = function (_EditorUI) {
	inherits(BoxedEditorUI, _EditorUI);

	/**
  * Creates a boxed editor UI instance.
  *
  * @param {core.editor.Editor} editor
  */
	function BoxedEditorUI(editor) {
		classCallCheck(this, BoxedEditorUI);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(BoxedEditorUI).call(this, editor));

		_this.addCollection('top');
		_this.addCollection('main');

		var config = editor.config;

		/**
   * The editor's width. Defaults to {@link core.editor.config.ui.width}.
   *
   * Note: a specific creator that was used must support this setting.
   *
   * @observable
   * @property {Number} width
   */
		_this.set('width', config.get('ui.width'));

		/**
   * The editor's height. Defaults to {@link core.editor.config.ui.height}.
   *
   * Note: a specific creator that was used must support this setting.
   *
   * @observable
   * @property {Number} height
   */
		_this.set('height', config.get('ui.height'));
		return _this;
	}

	return BoxedEditorUI;
}(EditorUI);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The editable UI controller class. It glues the engine editable
 * {@link engine.view.RootEditableElement} with the UI.
 *
 *		// An instance of EditableUI.
 *		new EditableUI( editor, editable, new EditableUIView() );
 *
 * See {@link ui.editableUI.EditableUIView}.
 *
 * @memberOf ui.editableUI
 * @extends ui.Controller
 */

var EditableUI = function (_Controller) {
  inherits(EditableUI, _Controller);

  /**
   * Creates an instance of {@link ui.editableUI.EditableUI} class.
   *
   * @param {engine.view.RootEditableElement} editable The editable element (in the engine).
   * Also the {@link ui.editableUI.EditableUIModel} for editable UI instance.
   * @param {ui.View} [view] An instance of EditableUIView.
   * @param {core.editor.Editor} [editor] The editor instance.
   */
  function EditableUI(editable, view, editor) {
    classCallCheck(this, EditableUI);

    /**
     * The editor instance.
     *
     * @readonly
     * @member {core.editor.Editor} ui.editableUI.EditableUI#editor
     */
    var _this = possibleConstructorReturn(this, Object.getPrototypeOf(EditableUI).call(this, editable, view));

    _this.editor = editor;

    view.bind('isReadOnly', 'isFocused').to(editable);
    view.set('name', editable.rootName);
    return _this;
  }

  return EditableUI;
}(Controller);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The editable UI view class.
 *
 * See {@link ui.editableUI.EditableUI}.
 *
 * @memberOf ui.editableUI
 * @extends ui.View
 */

var EditableUIView = function (_View) {
	inherits(EditableUIView, _View);

	/**
  * Creates an instance of {@link ui.editableUI.EditableUIView} class.
  *
  * @param {utils.Locale} [locale] The {@link core.editor.Editor#locale editor's locale} instance.
  * @param {HTMLElement} [editableElement] The editable element. If not specified, this view
  * should create it. Otherwise, the existing element should be used.
  */
	function EditableUIView(locale, editableElement) {
		classCallCheck(this, EditableUIView);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(EditableUIView).call(this, locale));

		var bind = _this.bindTemplate;

		if (editableElement) {
			_this.element = _this.editableElement = editableElement;
		}

		_this.template = new Template({
			tag: 'div',
			attributes: {
				class: [bind.to('isFocused', function (value) {
					return value ? 'ck-focused' : 'ck-blurred';
				}), 'ck-editor__editable'],
				contenteditable: bind.to('isReadOnly', function (value) {
					return !value;
				})
			}
		});

		/**
   * The element which is the main editable element (usually the one with `contentEditable="true"`).
   *
   * @readonly
   * @member {HTMLElement} ui.editableUI.EditableUIView#editableElement
   */

		/**
   * Controls whether the editable is writable or not.
   *
   * @observable
   * @member {Boolean} ui.editableUI.EditableUIView#isReadOnly
   */

		/**
   * Controls whether the editable is focused, i.e. the user is typing in it.
   *
   * @observable
   * @member {Boolean} ui.editableUI.EditableUIView#isFocused
   */

		/**
   * The name of the editable UI view.
   *
   * @observable
   * @member {String} ui.editableUI.EditableUIView#name
   */
		return _this;
	}

	/**
  * Initializes the View by either applying the {@link template} to the existing
  * {@link editableElement} or assigns {@link element} as {@link editableElement}.
  */


	createClass(EditableUIView, [{
		key: 'init',
		value: function init() {
			if (this.editableElement) {
				this.template.apply(this.editableElement);
			} else {
				this.editableElement = this.element;
			}

			get(Object.getPrototypeOf(EditableUIView.prototype), 'init', this).call(this);
		}
	}, {
		key: 'destroy',
		value: function destroy() {
			get(Object.getPrototypeOf(EditableUIView.prototype), 'destroy', this).call(this);

			this.editableElement.contentEditable = false;
		}
	}]);
	return EditableUIView;
}(View);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The inline editable UI class implementing an inline {@link ui.editableUI.EditableUIView}.
 *
 * See {@link ui.editableUI.EditableUI}, {@link ui.editableUI.EditableUIView}.
 *
 * @memberOf ui.editableUI.inline
 * @extends ui.editableUI.EditableUIView
 */

var InlineEditableUIView = function (_EditableUIView) {
	inherits(InlineEditableUIView, _EditableUIView);

	/**
  * Creates an instance of the InlineEditableUIView class.
  *
  * @param {utils.Locale} [locale] The {@link core.editor.Editor#locale editor's locale} instance.
  * @param {HTMLElement} [editableElement] The editable element. If not specified, the {@link EditableUIView}
  * should create it. Otherwise, the existing element should be used.
  */
	function InlineEditableUIView(locale, editableElement) {
		classCallCheck(this, InlineEditableUIView);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(InlineEditableUIView).call(this, locale, editableElement));

		var bind = _this.bindTemplate;
		var t = _this.t;

		var getLabel = function getLabel(value) {
			return t('Rich Text Editor, %0', [value]);
		};

		Template.extend(_this.template, {
			attributes: {
				role: 'textbox',
				'aria-label': bind.to('name', getLabel),
				title: bind.to('name', getLabel),
				class: 'ck-editor__editable_inline'
			}
		});
		return _this;
	}

	return InlineEditableUIView;
}(EditableUIView);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Mixin that injects the common Toolbar–like bindings.
 *
 * See {@link ui.bindings.Toolbar}.
 *
 * @mixin ui.bindings.ToolbarBindingsMixin
 */
var ToolbarBindingsMixin = {
	/**
  * Adds items like buttons to the toolbar. Buttons are generated by the
  * {@link ui.editorUI.EditorUI#featureComponents} factory.
  */
	bindToolbarItems: function bindToolbarItems() {
		var _this = this;

		/**
   * Collection of toolbar items.
   *
   * @member {utils.Collection} ui.bindings.ToolbarBindingsMixin#items
   */
		this.items = new Collection();

		if (this.model.config) {
			// Translate config to dynamic item collection.
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = this.model.config[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var name = _step.value;

					this.items.add({ name: name });
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		}

		this.collections.get('items').bind(this.items).as(function (_ref) {
			var name = _ref.name;

			return _this.editor.ui.featureComponents.create(name);
		});
	}
};

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The toolbar controller class.
 *
 *		const model = new Model();
 *
 *		// An instance of Toolbar.
 *		new Toolbar( model, new ToolbarView() );
 *
 * See {@link ui.toolbar.ToolbarView}.
 *
 * @memberOf ui.toolbar
 * @extends ui.Controller
 */

var Toolbar = function (_Controller) {
  inherits(Toolbar, _Controller);

  /**
   * Creates an instance of {@link ui.toolbar.Toolbar} class.
   *
   * @param {ui.Model} model Model of this toolbar.
   * @param {ui.View} view View of this toolbar.
   */
  function Toolbar(model, view) {
    classCallCheck(this, Toolbar);

    var _this = possibleConstructorReturn(this, Object.getPrototypeOf(Toolbar).call(this, model, view));

    _this.addCollection('items');
    return _this;
  }

  return Toolbar;
}(Controller);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The sticky toolbar controller class.
 *
 *		const model = new Model( {
 *			isActive: false
 *		} );
 *
 *		// An instance of StickyToolbar.
 *		new StickyToolbar( model, new StickyToolbarView() );
 *
 * See {@link ui.stickyToolbar.StickyToolbarView}.
 *
 * @memberOf ui.stickyToolbar
 * @extends ui.Controller
 */

var StickyToolbar$1 = function (_Toolbar) {
  inherits(StickyToolbar, _Toolbar);

  /**
   * Creates an instance of {@link ui.stickyToolbar.StickyToolbar} class.
   *
   * @param {ui.stickyToolbar.StickyToolbarModel} model Model of this sticky toolbar.
   * @param {ui.View} view View of this sticky toolbar.
   */
  function StickyToolbar(model, view) {
    classCallCheck(this, StickyToolbar);

    var _this = possibleConstructorReturn(this, Object.getPrototypeOf(StickyToolbar).call(this, model, view));

    view.bind('isActive', 'limiterElement').to(model);
    return _this;
  }

  return StickyToolbar;
}(Toolbar);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The editor sticky toolbar controller class.
 *
 * See {@link ui.stickyToolbar.StickyToolbar}.
 *
 * @memberOf ui.bindings
 * @extends ui.stickyToolbar.StickyToolbar
 */

var StickyToolbar = function (_BaseStickyToolbar) {
	inherits(StickyToolbar, _BaseStickyToolbar);

	/**
  * Creates an instance of {@link ui.bindings.StickyToolbar} class.
  *
  * @param {ui.stickyToolbar.StickyToolbarModel} model Model of this sticky toolbar.
  * @param {ui.View} view View of this sticky toolbar.
  * @param {core.editor.Editor} editor
  */
	function StickyToolbar(model, view, editor) {
		classCallCheck(this, StickyToolbar);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(StickyToolbar).call(this, model, view));

		_this.editor = editor;
		return _this;
	}

	createClass(StickyToolbar, [{
		key: 'init',
		value: function init() {
			this.bindToolbarItems();

			return get(Object.getPrototypeOf(StickyToolbar.prototype), 'init', this).call(this);
		}
	}]);
	return StickyToolbar;
}(StickyToolbar$1);

mix(StickyToolbar, ToolbarBindingsMixin);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The toolbar view class.
 *
 * See {@link ui.toolbar.Toolbar}.
 *
 * @memberOf ui.toolbar
 * @extends ui.View
 */

var ToolbarView = function (_View) {
	inherits(ToolbarView, _View);

	/**
  * @inheritDoc
  */
	function ToolbarView(locale) {
		classCallCheck(this, ToolbarView);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ToolbarView).call(this, locale));

		_this.template = new Template({
			tag: 'div',
			attributes: {
				class: ['ck-toolbar']
			}
		});

		_this.register('items', function (el) {
			return el;
		});
		return _this;
	}

	return ToolbarView;
}(View);

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Returns a helper function, which adds a desired trailing
 * `unit` to the passed value.
 *
 * @method utils.dom.toUnit
 * @param {String} unit An unit like "px" or "em".
 * @returns {utils.dom.toUnit.helper}
 */
function toUnit(unit) {
  /**
   * A function, which adds a pre–defined trailing `unit`
   * to the passed `value`.
   *
   * @function utils.dom.toUnit.helper
  	 * @param {*} value A value to be given the unit.
  	 * @returns {String} A value with the trailing unit.
   */
  return function (value) {
    return value + unit;
  };
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* globals document, window */

var toPx = toUnit('px');

/**
 * The sticky toolbar view class.
 *
 * See {@link ui.stickyToolbar.StickyToolbar}, {@link ui.toolbar.ToolbarView}.
 *
 * @memberOf ui.stickyToolbar
 * @extends ui.toolbar.ToolbarView
 */

var StickyToolbarView = function (_ToolbarView) {
	inherits(StickyToolbarView, _ToolbarView);

	/**
  * @inheritDoc
  */
	function StickyToolbarView(locale) {
		classCallCheck(this, StickyToolbarView);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(StickyToolbarView).call(this, locale));

		var bind = _this.bindTemplate;

		_this.set('isSticky', false);
		_this.set('limiterElement', null);
		_this.set('limiterOffset', 50);

		_this.set('_left', null);
		_this.set('_marginLeft', null);
		_this.set('_isStickyToTheLimiter', false);

		Template.extend(_this.template, {
			attributes: {
				class: [
				// Toggle class of the toolbar when "sticky" state changes in the view.
				bind.if('isSticky', 'ck-toolbar_sticky'), bind.if('_isStickyToTheLimiter', 'ck-toolbar_sticky_bottom-limit')],
				style: {
					width: bind.to('isSticky', function (isSticky) {
						if (isSticky) {
							var toolbarComputedStyle = window.getComputedStyle(_this.element);

							return toPx(_this._elementPlaceholder.getBoundingClientRect().width +

							// getBoundingClientRect returns dimensions including the border width.
							// When going sticky, the toolbar gets the border. If the border is not
							// considered, the sticky toolbar becomes narrower than the placeholder.
							parseFloat(toolbarComputedStyle.borderLeftWidth) + parseFloat(toolbarComputedStyle.borderRightWidth));
						}

						return null;
					}),

					top: bind.to('_isStickyToTheLimiter', function (_isStickyToTheLimiter) {
						return _isStickyToTheLimiter ? toPx(window.scrollY + _this._limiterRect.bottom - _this._toolbarRect.height - _this.limiterOffset) : null;
					}),

					left: bind.to('_left'),
					marginLeft: bind.to('_marginLeft')
				}
			}
		});

		/**
   * A dummy element which visually fills the space as long as the
   * actual toolbar is sticky. It prevents flickering of the UI.
   *
   * @private
   * @property {HTMLElement} ui.stickyToobar.StickyToolbarView#_elementPlaceholder
   */
		_this._elementPlaceholder = new Template({
			tag: 'div',
			attributes: {
				class: ['ck-toolbar__placeholder'],
				style: {
					display: bind.to('isSticky', function (isSticky) {
						return isSticky ? 'block' : 'none';
					}),
					height: bind.to('isSticky', function (isSticky) {
						return isSticky ? toPx(_this._toolbarRect.height) : null;
					})
				}
			}
		}).render();

		/**
   * The DOM bounding client rect of the {@link ui.View#element} of the toolbar.
   *
   * @protected
   * @member {Object} ui.stickyToobar.StickyToolbarView#_toolbarRect
   */

		/**
   * The DOM bounding client rect of the {@link ui.stickyToobar.StickyToolbarView#limiterElement}
   * of the toolbar.
   *
   * @protected
   * @member {Object} ui.stickyToobar.StickyToolbarView#_limiterRect
   */

		/**
   * Controls whether the sticky toolbar should be active. When any editable
   * is focused in the editor, toolbar becomes active.
   *
   * @readonly
   * @observable
   * @member {Boolean} ui.stickyToobar.StickyToolbarView#isActive
   */

		/**
   * Controls whether the sticky toolbar is in the "sticky" state.
   *
   * @readonly
   * @observable
   * @member {Boolean} ui.stickyToobar.StickyToolbarView#isSticky
   */

		/**
   * The limiter element for the sticky toolbar instance. Its bounding rect limits
   * the "stickyness" of the toolbar, i.e. when the toolbar reaches the bottom
   * edge of the limiter, it becomes sticky to that edge and does not float
   * off the limiter. It is mandatory for the toolbar to work properly and once
   * set, it cannot be changed.
   *
   * @readonly
   * @observable
   * @member {HTMLElement} ui.stickyToobar.StickyToolbarView#limiterElement
   */

		/**
   * The offset from the bottom edge of {@link ui.stickyToobar.StickyToolbarView#limiterElement}
   * which stops the toolbar from stickying any further to prevent limiter's content
   * from being completely covered.
   *
   * @readonly
   * @observable
   * @default 50
   * @member {Number} ui.stickyToobar.StickyToolbarView#limiterOffset
   */

		/**
   * Controls the `left` CSS style of the toolbar.
   *
   * @protected
   * @readonly
   * @observable
   * @member {String} ui.stickyToobar.StickyToolbarView#_left
   */

		/**
   * Controls the `margin-left` CSS style of the toolbar.
   *
   * @protected
   * @readonly
   * @observable
   * @member {String} ui.stickyToobar.StickyToolbarView#_marginLeft
   */

		/**
   * Set `true` if the sticky toolbar reached the bottom edge of the
   * {@link ui.stickyToobar.StickyToolbarView#limiterElement}.
   *
   * @protected
   * @readonly
   * @observable
   * @member {Boolean} ui.stickyToobar.StickyToolbarView#_isStickyToTheLimiter
   */
		return _this;
	}

	createClass(StickyToolbarView, [{
		key: 'init',
		value: function init() {
			var _this2 = this;

			get(Object.getPrototypeOf(StickyToolbarView.prototype), 'init', this).call(this);

			this.element.parentNode.insertBefore(this._elementPlaceholder, this.element);

			// Update sticky state of the toolbar as the window is being scrolled.
			this.listenTo(window, 'scroll', function () {
				_this2._checkIfShouldBeSticky();
			});

			// Synchronize with `model.isActive` because sticking an inactive toolbar is pointless.
			this.listenTo(this, 'change:isActive', function () {
				_this2._checkIfShouldBeSticky();
			});
		}

		/**
   * Destroys the toolbar and removes the {@link _elementPlaceholder}.
   */

	}, {
		key: 'destroy',
		value: function destroy() {
			get(Object.getPrototypeOf(StickyToolbarView.prototype), 'destroy', this).call(this);

			this._elementPlaceholder.remove();
		}

		/**
   * Analyzes the environment to decide whether the toolbar should
   * be sticky or not. Then, it uses {@link _stick} and {@link _detach}
   * methods to manage the state of the toolbar.
   *
   * @protected
   */

	}, {
		key: '_checkIfShouldBeSticky',
		value: function _checkIfShouldBeSticky() {
			var limiterRect = this._limiterRect = this.limiterElement.getBoundingClientRect();
			var toolbarRect = this._toolbarRect = this.element.getBoundingClientRect();

			// The toolbar must be active to become sticky.
			this.isSticky = this.isActive &&
			// The limiter's top edge must be beyond the upper edge of the visible viewport.
			limiterRect.top < 0 &&
			// The model#limiterElement's height mustn't be smaller than the toolbar's height and model#limiterOffset.
			// There's no point in entering the sticky mode if the model#limiterElement is very, very small, because
			// it would immediately set model#_isStickyToTheLimiter true and, given model#limiterOffset, the toolbar
			// would be positioned before the model#limiterElement.
			this._toolbarRect.height + this.limiterOffset < limiterRect.height;

			// Stick the toolbar to the top edge of the viewport simulating CSS position:sticky.
			// TODO: Possibly replaced by CSS in the future http://caniuse.com/#feat=css-sticky
			if (this.isSticky) {
				this._isStickyToTheLimiter = limiterRect.bottom < toolbarRect.height + this.limiterOffset;

				if (this._isStickyToTheLimiter) {
					this._left = toPx(limiterRect.left - document.body.getBoundingClientRect().left);
					this._marginLeft = null;
				} else {
					this._left = null;
					this._marginLeft = toPx(-window.scrollX - 1);
				}
			}
			// Detach the toolbar from the top edge of the viewport.
			else {
					this._isStickyToTheLimiter = false;
					this._marginLeft = this._left = null;
				}
		}
	}]);
	return StickyToolbarView;
}(ToolbarView);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Classic editor UI. Uses inline editable and sticky toolbar, all
 * enclosed in a boxed UI.
 *
 * @memberOf editor-classic
 * @extends ui.editorUI.boxed.BoxedEditorUI
 */

var ClassicEditorUI = function (_BoxedEditorUI) {
	inherits(ClassicEditorUI, _BoxedEditorUI);

	/**
  * Creates an instance of the classic editor UI.
  *
  * @param {core.editor.Editor} editor
  */
	function ClassicEditorUI(editor) {
		classCallCheck(this, ClassicEditorUI);

		/**
   * Toolbar controller.
   *
   * @readonly
   * @member {ui.toolbar.Toolbar} editor-classic.ClassicEditorUI#toolbar
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ClassicEditorUI).call(this, editor));

		_this.toolbar = _this._createToolbar();

		/**
   * Editable UI controller.
   *
   * @readonly
   * @member {ui.editableUI.EditableUI} editor-classic.ClassicEditorUI#editable
   */
		_this.editable = _this._createEditableUI();
		return _this;
	}

	/**
  * @inheritDoc
  */


	createClass(ClassicEditorUI, [{
		key: 'init',
		value: function init() {
			this.toolbar.model.set('limiterElement', this.editor.ui.view.element);

			return get(Object.getPrototypeOf(ClassicEditorUI.prototype), 'init', this).call(this);
		}

		/**
   * The editing host.
   *
   * @readonly
   * @type {HTMLElement}
   */

	}, {
		key: '_createToolbar',


		/**
   * Creates the sticky toolbar of the editor.
   *
   * @protected
   * @returns {ui.toolbar.Toolbar}
   */
		value: function _createToolbar() {
			var editor = this.editor;
			var model = new Model({
				config: this.editor.config.get('toolbar')
			});

			model.bind('isActive').to(editor.focusTracker, 'isFocused');

			var toolbar = new StickyToolbar(model, new StickyToolbarView(editor.locale), editor);
			this.add('top', toolbar);

			return toolbar;
		}

		/**
   * Creates the main editable of the editor and registers it in {@link core.editor.Editor#focusTracker}.
   *
   * @protected
   * @returns {ui.editableUI.EditableUI}
   */

	}, {
		key: '_createEditableUI',
		value: function _createEditableUI() {
			var editor = this.editor;

			var editable = editor.editing.view.getRoot();
			var editableUI = new EditableUI(editable, new InlineEditableUIView(editor.locale), editor);

			this.add('main', editableUI);

			// @TODO: Do it automatically ckeditor5-core#23
			editor.focusTracker.add(editableUI.view.element);

			return editableUI;
		}
	}, {
		key: 'editableElement',
		get: function get() {
			return this.editable.view.element;
		}
	}]);
	return ClassicEditorUI;
}(BoxedEditorUI);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* globals document */

/**
 * The editor UI view class. Base class for the editor main views.
 *
 * See {@link ui.editorUI.EditorUI}.
 *
 * @memberOf ui.editorUI
 * @extends ui.View
 */

var EditorUIView = function (_View) {
	inherits(EditorUIView, _View);

	/**
  * Creates an instance of the editor UI view class.
  *
  * @param {utils.Locale} [locale] The {@link core.editor.Editor#locale editor's locale} instance.
  */
	function EditorUIView(locale) {
		classCallCheck(this, EditorUIView);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(EditorUIView).call(this, locale));

		_this._createBodyRegion();

		/**
   * The element holding elements of the 'body' region.
   *
   * @private
   * @member {HTMLElement} ui.editorUI.EditorUIView#_bodyRegionContainer
   */
		return _this;
	}

	createClass(EditorUIView, [{
		key: 'destroy',
		value: function destroy() {
			this._bodyRegionContainer.remove();
			this._bodyRegionContainer = null;
		}

		/**
   * Creates and appends to `<body>` the 'body' region container.
   *
   * @private
   */

	}, {
		key: '_createBodyRegion',
		value: function _createBodyRegion() {
			var bodyElement = document.createElement('div');
			document.body.appendChild(bodyElement);

			new Template({
				attributes: {
					class: 'ck-body ck-rounded-corners ck-reset_all'
				}
			}).apply(bodyElement);

			this._bodyRegionContainer = bodyElement;

			this.register('body', function () {
				return bodyElement;
			});
		}
	}]);
	return EditorUIView;
}(View);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The boxed editor UI view class. This class represents an editor interface
 * consisting of a toolbar and an editable area, enclosed within a box.
 *
 * See {@link ui.editorUI.boxed.BoxedEditorUI}.
 *
 * @member ui.editorUI.boxed
 * @extends ui.editorUI.EditorUIView
 */

var BoxedEditorUIView = function (_EditorUIView) {
	inherits(BoxedEditorUIView, _EditorUIView);

	/**
  * @inheritDoc
  */
	function BoxedEditorUIView(locale) {
		classCallCheck(this, BoxedEditorUIView);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(BoxedEditorUIView).call(this, locale));

		var t = _this.t;
		var ariaLabelUid = uid();

		_this.template = new Template({
			tag: 'div',

			attributes: {
				class: ['ck-reset', 'ck-editor', 'ck-rounded-corners'],
				role: 'application',
				dir: 'ltr',
				lang: locale.lang,
				'aria-labelledby': 'cke-editor__aria-label_' + ariaLabelUid
			},

			children: [{
				tag: 'span',
				attributes: {
					id: 'cke-editor__aria-label_' + ariaLabelUid,
					class: 'cke-voice-label',
					children: [
					// TODO: Editor name?
					t('Rich Text Editor')]
				}
			}, {
				tag: 'div',
				attributes: {
					class: 'ck-editor__top ck-reset_all',
					role: 'presentation'
				}
			}, {
				tag: 'div',
				attributes: {
					class: 'ck-editor__main',
					role: 'presentation'
				}
			}]
		});

		_this.register('top', '.ck-editor__top');
		_this.register('main', '.ck-editor__main');
		return _this;
	}

	return BoxedEditorUIView;
}(EditorUIView);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Utility class allowing to hide existing HTML elements or replace them with given ones in a way that doesn't remove
 * the original elements from the DOM.
 *
 * @memberOf utils
 */
var ElementReplacer = function () {
	function ElementReplacer() {
		classCallCheck(this, ElementReplacer);

		/**
   * The elements replaced by {@link #replace} and their replacements.
   *
   * @private
   * @member {Array.<Object>} utils.ElementReplacer#_replacedElements
   */
		this._replacedElements = [];
	}

	/**
  * Hides the `element` and, if specified, inserts the the given element next to it.
  *
  * The effect of this method can be reverted by {@link #restore}.
  *
  * @param {HTMLElement} element The element to replace.
  * @param {HTMLElement} [newElement] The replacement element. If not passed, then the `element` will just be hidden.
  */


	createClass(ElementReplacer, [{
		key: 'replace',
		value: function replace(element, newElement) {
			this._replacedElements.push({ element: element, newElement: newElement });

			element.style.display = 'none';

			if (newElement) {
				element.parentNode.insertBefore(newElement, element.nextSibling);
			}
		}

		/**
   * Restores what {@link #replace} did.
   */

	}, {
		key: 'restore',
		value: function restore() {
			this._replacedElements.forEach(function (_ref) {
				var element = _ref.element;
				var newElement = _ref.newElement;

				element.style.display = '';

				if (newElement) {
					newElement.remove();
				}
			});

			this._replacedElements = [];
		}
	}]);
	return ElementReplacer;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Classic editor. Uses inline editable and sticky toolbar, all
 * enclosed in a boxed UI.
 *
 * @memberOf editor-classic
 * @extends core.editor.StandardEditor
 */

var ClassicEditor$1 = function (_StandardEditor) {
	inherits(ClassicEditor, _StandardEditor);

	/**
  * Creates an instance of the classic editor.
  *
  * @param {HTMLElement} element The DOM element that will be the source for the created editor.
  * The data will be loaded from it and loaded back to it once the editor is destroyed.
  * @param {Object} config The editor configuration.
  */
	function ClassicEditor(element, config) {
		classCallCheck(this, ClassicEditor);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ClassicEditor).call(this, element, config));

		_this.document.createRoot();

		_this.editing.createRoot('div');

		_this.data.processor = new HtmlDataProcessor();

		_this.ui = new ClassicEditorUI(_this);
		_this.ui.view = new BoxedEditorUIView(_this.locale);

		/**
   * The element replacer instance used to hide the editor element.
   *
   * @protected
   * @member {utils.ElementReplacer} editor-classic.Classic#_elementReplacer
   */
		_this._elementReplacer = new ElementReplacer();
		return _this;
	}

	/**
  * Destroys the editor instance, releasing all resources used by it.
  *
  * Updates the original editor element with the data.
  *
  * @returns {Promise}
  */


	createClass(ClassicEditor, [{
		key: 'destroy',
		value: function destroy() {
			var _this2 = this;

			this.updateEditorElement();
			this._elementReplacer.restore();

			return this.ui.destroy().then(function () {
				return get(Object.getPrototypeOf(ClassicEditor.prototype), 'destroy', _this2).call(_this2);
			});
		}

		/**
   * Creates a classic editor instance.
   *
   *		ClassicEditor.create( document.querySelector( '#editor' ), {
   *			features: [ Delete, Enter, Typing, Paragraph, Undo, Bold, Italic ],
   *			toolbar: [ 'bold', 'italic', 'undo', 'redo' ]
   *		} )
   *		.then( editor => {
   *			console.log( 'Editor was initialized', editor );
   *		} )
   *		.catch( err => {
   *			console.error( err.stack );
   *		} );
   *
   * @param {HTMLElement} element See {@link core.editor.ClassicEditor#constructor}'s parameters.
   * @param {Object} config See {@link core.editor.ClassicEditor#constructor}'s parameters.
   * @returns {Promise} A promise resolved once the editor is ready.
   * @returns {core.editor.StandardEditor} return.editor The editor instance.
   */

	}], [{
		key: 'create',
		value: function create(element, config) {
			return new Promise(function (resolve) {
				var editor = new ClassicEditor(element, config);

				resolve(editor.initPlugins().then(function () {
					return editor._elementReplacer.replace(element, editor.ui.view.element);
				}).then(function () {
					return editor.ui.init();
				}).then(function () {
					return editor.editing.view.attachDomRoot(editor.ui.editableElement);
				}).then(function () {
					return editor.loadDataFromEditorElement();
				}).then(function () {
					return editor;
				}));
			});
		}
	}]);
	return ClassicEditor;
}(StandardEditor);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The base class for CKEditor feature classes. Features are main way to enhance CKEditor abilities with tools,
 * utilities, services and components.
 *
 * The main responsibilities for Feature are:
 * * setting required dependencies (see {@link core.Plugin#requires},
 * * configuring, instantiating and registering commands to editor,
 * * registering converters to editor (if the feature operates on Tree Model),
 * * setting and registering UI components (if the feature uses it).
 *
 * @memberOf core
 */

var Feature = function (_Plugin) {
  inherits(Feature, _Plugin);

  function Feature() {
    classCallCheck(this, Feature);
    return possibleConstructorReturn(this, Object.getPrototypeOf(Feature).apply(this, arguments));
  }

  return Feature;
}(Plugin);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Provides chainable, high-level API to easily build basic model-to-view converters that are appended to given
 * dispatchers. In many cases, this is the API that should be used to specify how abstract model elements and
 * attributes should be represented in the view (and then later in DOM). Instances of this class are created by
 * {@link engine.conversion.buildModelConverter}.
 *
 * If you need more complex converters, see {@link engine.conversion.ModelConversionDispatcher},
 * {@link engine.conversion.modelToView}, {@link engine.conversion.ModelConsumable}, {@link engine.conversion.Mapper}.
 *
 * Using this API it is possible to create three kinds of converters:
 *
 * 1. Model element to view element converter. This is a converter that takes the model element and represents it
 * in the view.
 *
 *		buildModelConverter().for( dispatcher ).fromElement( 'paragraph' ).toElement( 'p' );
 *		buildModelConverter().for( dispatcher ).fromElement( 'image' ).toElement( 'img' );
 *
 * 2. Model attribute to view attribute converter. This is a converter that operates on model element attributes
 * and converts them to view element attributes. It is suitable for elements like `image` (`src`, `title` attributes).
 *
 *		buildModelConverter().for( dispatcher ).fromElement( 'image' ).toElement( 'img' );
 *		buildModelConverter().for( dispatcher ).fromAttribute( 'src' ).toAttribute();
 *
 * 3. Model attribute to view element converter. This is a converter that takes model attributes and represents them
 * as view elements. Elements created by this kind of converter are wrapping other view elements. Wrapped view nodes
 * correspond to model nodes had converter attribute. It is suitable for attributes like `bold`, where `bold` attribute
 * set on model text nodes is converter to `strong` view element.
 *
 *		buildModelConverter().for( dispatcher ).fromAttribute( 'bold' ).toElement( 'strong' );
 *
 * It is possible to provide various different parameters for {@link engine.conversion.ModelConverterBuilder#toElement}
 * and {@link engine.conversion.ModelConverterBuilder#toAttribute} methods. See their descriptions to learn more.
 *
 * It is also possible to {@link engine.conversion.ModelConverterBuilder#withPriority change default priority}
 * of created converters to decide which converter should be fired earlier and which later. This is useful if you have
 * a general converter but also want to provide different special-case converters (i.e. given model element is converted
 * always to given view element, but if it has given attribute it is converter to other view element). For this,
 * use {@link engine.conversion.ModelConverterBuilder#withPriority withPriority} right after `from...` method.
 *
 * Note that `to...` methods are "terminators", which means that should be the last one used in building converter.
 *
 * You can use {@link engine.conversion.ViewConverterBuilder} to create "opposite" converters - from view to model.
 *
 * @memberOf engine.conversion
 */

var ModelConverterBuilder = function () {
	/**
  * Creates `ModelConverterBuilder` with given `dispatchers` registered to it.
  */
	function ModelConverterBuilder() {
		classCallCheck(this, ModelConverterBuilder);

		/**
   * Dispatchers to which converters will be attached.
   *
   * @type {Array.<engine.conversion.ModelConversionDispatcher>}
   * @private
   */
		this._dispatchers = [];

		/**
   * Contains data about registered "from" query.
   *
   * @type {Object}
   * @private
   */
		this._from = null;
	}

	/**
  * Set one or more dispatchers which the built converter will be attached to.
  *
  * @chainable
  * @param {...engine.conversion.ModelConversionDispatcher} dispatchers One or more dispatchers.
  * @returns {engine.conversion.ModelConverterBuilder}
  */


	createClass(ModelConverterBuilder, [{
		key: 'for',
		value: function _for() {
			for (var _len = arguments.length, dispatchers = Array(_len), _key = 0; _key < _len; _key++) {
				dispatchers[_key] = arguments[_key];
			}

			this._dispatchers = dispatchers;

			return this;
		}

		/**
   * Registers what model element should be converted.
   *
   * @chainable
   * @param {String} elementName Name of element to convert.
   * @returns {engine.conversion.ModelConverterBuilder}
   */

	}, {
		key: 'fromElement',
		value: function fromElement(elementName) {
			this._from = {
				type: 'element',
				name: elementName,
				priority: null
			};

			return this;
		}

		/**
   * Registers what model attribute should be converted.
   *
   * @chainable
   * @param {String} key Key of attribute to convert.
   * @returns {engine.conversion.ModelConverterBuilder}
   */

	}, {
		key: 'fromAttribute',
		value: function fromAttribute(key) {
			this._from = {
				type: 'attribute',
				key: key,
				priority: null
			};

			return this;
		}

		/**
   * Changes default priority for built converter. The lower the number, the earlier converter will be fired.
   * Default priority is `10`.
   *
   * **Note:** Keep in mind that event priority, that is set by this modifier, is used for attribute priority
   * when {@link engine.view.writer} is used. This changes how view elements are ordered,
   * i.e.: `<strong><em>foo</em></strong>` vs `<em><strong>foo</strong></em>`. Using priority you can also
   * prevent node merging, i.e.: `<span class="bold"><span class="theme">foo</span><span>` vs `<span class="bold theme">foo</span>`.
   * If you want to prevent merging, just set different priority for both converters.
   *
   *		buildModelConverter().for( dispatcher ).fromAttribute( 'bold' ).withPriority( 2 ).toElement( 'strong' );
   *		buildModelConverter().for( dispatcher ).fromAttribute( 'italic' ).withPriority( 3 ).toElement( 'em' );
   *
   * @chainable
   * @param {Number} priority Converter priority.
   * @returns {engine.conversion.ModelConverterBuilder}
   */

	}, {
		key: 'withPriority',
		value: function withPriority(priority) {
			this._from.priority = priority;

			return this;
		}

		/**
   * Registers what view element will be created by converter.
   *
   * Method accepts various ways of providing how the view element will be created. You can pass view element name as
   * `string`, view element instance which will be cloned and used, or creator function which returns view element that
   * will be used. Keep in mind that when you view element instance or creator function, it has to be/return a
   * proper type of view element: {@link engine.view.ViewContainerElement ViewContainerElement} if you convert
   * from element or {@link engine.view.ViewAttributeElement ViewAttributeElement} if you convert from attribute.
   *
   *		buildModelConverter().for( dispatcher ).fromElement( 'paragraph' ).toElement( 'p' );
   *
   *		buildModelConverter().for( dispatcher ).fromElement( 'image' ).toElement( new ViewContainerElement( 'img' ) );
   *
   *		buildModelConverter().for( dispatcher )
   *			.fromElement( 'header' )
   *			.toElement( ( data ) => new ViewContainerElement( 'h' + data.item.getAttribute( 'level' ) ) );
   *
   *		buildModelConverter().for( dispatcher ).fromAttribute( 'bold' ).toElement( new ViewAttributeElement( 'strong' ) );
   *
   * Creator function will be passed different values depending whether conversion is from element or from attribute:
   *
   * * from element: dispatcher's {@link engine.conversion.ModelConversionDispatcher#event:insert insert event} parameters
   * will be passed,
   * * from attribute: there is one parameter and it is attribute value.
   *
   * This method also registers model selection to view selection converter, if conversion is from attribute.
   *
   * This method creates the converter and adds it as a callback to a proper
   * {@link engine.conversion.ModelConversionDispatcher conversion dispatcher} event.
   *
   * @param {String|engine.view.ViewElement|Function} element Element created by converter.
   */

	}, {
		key: 'toElement',
		value: function toElement(element) {
			var priority = this._from.priority === null ? 'normal' : this._from.priority;

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = this._dispatchers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var dispatcher = _step.value;

					if (this._from.type == 'element') {
						// From model element to view element -> insert element.
						element = typeof element == 'string' ? new ContainerElement(element) : element;

						dispatcher.on('insert:' + this._from.name, insertElement(element), { priority: priority });
					} else {
						// From model attribute to view element -> wrap and unwrap.
						element = typeof element == 'string' ? new AttributeElement(element) : element;

						dispatcher.on('addAttribute:' + this._from.key, wrap(element), { priority: priority });
						dispatcher.on('changeAttribute:' + this._from.key, wrap(element), { priority: priority });
						dispatcher.on('removeAttribute:' + this._from.key, unwrap(element), { priority: priority });

						dispatcher.on('selectionAttribute:' + this._from.key, convertSelectionAttribute(element), { priority: priority });
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		}

		/**
   * Registers what view attribute will be created by converter. Keep in mind, that only model attribute to
   * view attribute conversion is supported.
   *
   * Method accepts various ways of providing how the view attribute will be created:
   *
   * * for no passed parameter, attribute key and value will be converted 1-to-1 to view attribute,
   * * if you pass one `string`, it will be used as new attribute key while attribute value will be copied,
   * * if you pass two `string`s, first one will be used as new attribute key and second one as new attribute value,
   * * if you pass a function, it is expected to return an object with `key` and `value` properties representing attribute key and value.
   * This function will be passed model attribute value and model attribute key as first two parameters and then
   * all dispatcher's {engine.conversion.ModelConversionDispatcher#event:changeAttribute changeAttribute event} parameters.
   *
   *		buildModelConverter().for( dispatcher ).fromAttribute( 'class' ).toAttribute( '' );
   *
   *		buildModelConverter().for( dispatcher ).fromAttribute( 'linkTitle' ).toAttribute( 'title' );
   *
   *		buildModelConverter().for( dispatcher ).fromAttribute( 'highlighted' ).toAttribute( 'style', 'background:yellow' );
   *
   *		buildModelConverter().for( dispatcher )
   *			.fromAttribute( 'theme' )
   *			.toAttribute( ( value ) => ( { key: 'class', value: value + '-theme' } ) );
   *
   * This method creates the converter and adds it as a callback to a proper
   * {@link engine.conversion.ModelConversionDispatcher conversion dispatcher} event.
   *
   * @param {String|Function} [keyOrCreator] Attribute key or a creator function.
   * @param {*} [value] Attribute value.
   */

	}, {
		key: 'toAttribute',
		value: function toAttribute(keyOrCreator, value) {
			if (this._from.type == 'element') {
				// Converting from model element to view attribute is unsupported.
				return;
			}

			var attributeCreator = void 0;

			if (!keyOrCreator) {
				// If `keyOrCreator` is not set, we assume default behavior which is 1:1 attribute re-write.
				// This is also a default behavior for `setAttribute` converter when no attribute creator is passed.
				attributeCreator = undefined;
			} else if (typeof keyOrCreator == 'string') {
				// `keyOrCreator` is an attribute key.

				if (value) {
					// If value is set, create "dumb" creator that always returns the same object.
					attributeCreator = function attributeCreator() {
						return { key: keyOrCreator, value: value };
					};
				} else {
					// If value is not set, take it from the passed parameter.
					attributeCreator = function attributeCreator(value) {
						return { key: keyOrCreator, value: value };
					};
				}
			} else {
				// `keyOrCreator` is an attribute creator function.
				attributeCreator = keyOrCreator;
			}

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = this._dispatchers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var dispatcher = _step2.value;

					var options = { priority: this._from.priority || 'normal' };

					dispatcher.on('addAttribute:' + this._from.key, setAttribute(attributeCreator), options);
					dispatcher.on('changeAttribute:' + this._from.key, setAttribute(attributeCreator), options);
					dispatcher.on('removeAttribute:' + this._from.key, removeAttribute(attributeCreator), options);
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}
		}
	}]);
	return ModelConverterBuilder;
}();

/**
 * Entry point for model-to-view converters builder. This chainable API makes it easy to create basic, most common
 * model-to-view converters and attach them to provided dispatchers. The method returns an instance of
 * {@link engine.conversion.ModelConverterBuilder}.
 *
 * @external engine.conversion.buildModelConverter
 * @memberOf engine.conversion
 */


function buildModelConverter() {
	return new ModelConverterBuilder();
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * View matcher class.
 * Instance of this class can be used to find {@link engine.view.Element elements} that match given pattern.
 *
 * @memberOf engine.view
 */
var Matcher = function () {
	/**
  * Creates new instance of Matcher.
  *
  * @param {String|RegExp|Object} [pattern] Match patterns. See {@link engine.view.Matcher#add add method} for
  * more information.
  */
	function Matcher() {
		classCallCheck(this, Matcher);

		this._patterns = [];

		this.add.apply(this, arguments);
	}

	/**
  * Adds pattern or patterns to matcher instance.
  *
  * Example patterns matching element's name:
  *
  *		// String.
  *		matcher.add( 'div' );
  *		matcher.add( { name: 'div' } );
  *
  *		// Regular expression.
  *		matcher.add( /^\w/ );
  *		matcher.add( { name: /^\w/ } );
  *
  * Example pattern matching element's attributes:
  *
  *		matcher.add( {
  *			attributes: {
  *				title: 'foobar',
  *				foo: /^\w+/
  *			}
  *		} );
  *
  * Example patterns matching element's classes:
  *
  *		// Single class.
  *		matcher.add( {
  *			class: 'foobar'
  *		} );
  *
  *		// Single class using regular expression.
  *		matcher.add( {
  *			class: /foo.../
  *		} );
  *
  *		// Multiple classes to match.
  *		matcher.add( {
  *			class: [ 'baz', 'bar', /foo.../ ]
  *		} ):
  *
  * Example pattern matching element's styles:
  *
  *		matcher.add( {
  *			style: {
  *				position: 'absolute',
  *				color: /^\w*blue$/
  *			}
  *		} );
  *
  * Example function pattern:
  *
  *		matcher.add( ( element ) => {
  *			// Result of this function will be included in `match`
  *			// property of the object returned from matcher.match() call.
  *			if ( element.name === 'div' && element.childCount > 0 ) {
  *				return { name: true };
  *			}
  *
  *			return null;
  *		} );
  *
  * Multiple patterns can be added in one call:
  *
  * 		matcher.add( 'div', { class: 'foobar' } );
  *
  * @param {Object|String|RegExp|function} pattern Object describing pattern details. If string or regular expression
  * is provided it will be used to match element's name. Pattern can be also provided in a form
  * of a function - then this function will be called with each {@link engine.view.Element element} as a parameter.
  * Function's return value will be stored under `match` key of the object returned from
  * {@link engine.view.Matcher#match match} or {@link engine.view.Matcher#matchAll matchAll} methods.
  * @param {String|RegExp} [pattern.name] Name or regular expression to match element's name.
  * @param {Object} [pattern.attribute] Object with key-value pairs representing attributes to match. Each object key
  * represents attribute name. Value under that key can be either a string or a regular expression and it will be
  * used to match attribute value.
  * @param {String|RegExp|Array} [pattern.class] Class name or array of class names to match. Each name can be
  * provided in a form of string or regular expression.
  * @param {Object} [pattern.style] Object with key-value pairs representing styles to match. Each object key
  * represents style name. Value under that key can be either a string or a regular expression and it will be used
  * to match style value.
  */


	createClass(Matcher, [{
		key: 'add',
		value: function add() {
			for (var _len = arguments.length, pattern = Array(_len), _key = 0; _key < _len; _key++) {
				pattern[_key] = arguments[_key];
			}

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = pattern[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var item = _step.value;

					// String or RegExp pattern is used as element's name.
					if (typeof item == 'string' || item instanceof RegExp) {
						item = { name: item };
					}

					// Single class name/RegExp can be provided.
					if (item.class && (typeof item.class == 'string' || item.class instanceof RegExp)) {
						item.class = [item.class];
					}

					this._patterns.push(item);
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		}

		/**
   * Matches elements for currently stored patterns. Returns match information about first found
   * {@link engine.view.Element element}, otherwise returns `null`.
   *
   * Example of returned object:
   *
   *		{
   *			element: <instance of found element>,
   *			pattern: <pattern used to match found element>,
   *			match: {
   *				name: true,
  	 *				attributes: [ 'title', 'href' ],
   *				classes: [ 'foo' ],
  	 *				styles: [ 'color', 'position' ]
   *			}
   *		}
   *
   * @see engine.view.Matcher#add
   * @see engine.view.Matcher#matchAll
   * @param {...core.view.Element} element View element to match against stored patterns.
   * @returns {Object|null} result
   * @returns {core.view.Element} result.element Matched view element.
   * @returns {Object|String|RegExp|function} result.pattern Pattern that was used to find matched element.
   * @returns {Object} result.match Object representing matched element parts.
   * @returns {Boolean} [result.match.name] True if name of the element was matched.
   * @returns {Array} [result.match.attribute] Array with matched attribute names.
   * @returns {Array} [result.match.class] Array with matched class names.
   * @returns {Array} [result.match.style] Array with matched style names.
   */

	}, {
		key: 'match',
		value: function match() {
			for (var _len2 = arguments.length, element = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				element[_key2] = arguments[_key2];
			}

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = element[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var singleElement = _step2.value;
					var _iteratorNormalCompletion3 = true;
					var _didIteratorError3 = false;
					var _iteratorError3 = undefined;

					try {
						for (var _iterator3 = this._patterns[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
							var _pattern = _step3.value;

							var match = isElementMatching(singleElement, _pattern);

							if (match) {
								return {
									element: singleElement,
									pattern: _pattern,
									match: match
								};
							}
						}
					} catch (err) {
						_didIteratorError3 = true;
						_iteratorError3 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion3 && _iterator3.return) {
								_iterator3.return();
							}
						} finally {
							if (_didIteratorError3) {
								throw _iteratorError3;
							}
						}
					}
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			return null;
		}

		/**
   * Matches elements for currently stored patterns. Returns array of match information with all found
   * {@link engine.view.Element elements}. If no element is found - returns `null`.
   *
   * @see engine.view.Matcher#add
   * @see engine.view.Matcher#match
   * @param {...engine.view.Element} element View element to match against stored patterns.
   * @returns {Array.<Object>|null} Array with match information about found elements or `null`. For more information
   * see {@link engine.view.Matcher#match match method} description.
   */

	}, {
		key: 'matchAll',
		value: function matchAll() {
			var results = [];

			for (var _len3 = arguments.length, element = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
				element[_key3] = arguments[_key3];
			}

			var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
				for (var _iterator4 = element[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var singleElement = _step4.value;
					var _iteratorNormalCompletion5 = true;
					var _didIteratorError5 = false;
					var _iteratorError5 = undefined;

					try {
						for (var _iterator5 = this._patterns[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
							var _pattern2 = _step5.value;

							var match = isElementMatching(singleElement, _pattern2);

							if (match) {
								results.push({
									element: singleElement,
									pattern: _pattern2,
									match: match
								});
							}
						}
					} catch (err) {
						_didIteratorError5 = true;
						_iteratorError5 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion5 && _iterator5.return) {
								_iterator5.return();
							}
						} finally {
							if (_didIteratorError5) {
								throw _iteratorError5;
							}
						}
					}
				}
			} catch (err) {
				_didIteratorError4 = true;
				_iteratorError4 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion4 && _iterator4.return) {
						_iterator4.return();
					}
				} finally {
					if (_didIteratorError4) {
						throw _iteratorError4;
					}
				}
			}

			return results.length > 0 ? results : null;
		}

		/**
   * Returns the name of the element to match if there is exactly one pattern added to the matcher instance
   * and it matches element name defined by `string` (not `RegExp`). Otherwise, returns `null`.
   *
   * @returns {String|null} Element name trying to match.
   */

	}, {
		key: 'getElementName',
		value: function getElementName() {
			return this._patterns.length == 1 && this._patterns[0].name && !(this._patterns[0].name instanceof RegExp) ? this._patterns[0].name : null;
		}
	}]);
	return Matcher;
}();

function isElementMatching(element, pattern) {
	// If pattern is provided as function - return result of that function;
	if (typeof pattern == 'function') {
		return pattern(element);
	}

	var match = {};
	// Check element's name.
	if (pattern.name) {
		match.name = matchName(pattern.name, element.name);

		if (!match.name) {
			return null;
		}
	}

	// Check element's attributes.
	if (pattern.attribute) {
		match.attribute = matchAttributes(pattern.attribute, element);

		if (!match.attribute) {
			return null;
		}
	}

	// Check element's classes.
	if (pattern.class) {
		match.class = matchClasses(pattern.class, element);

		if (!match.class) {
			return false;
		}
	}

	// Check element's styles.
	if (pattern.style) {
		match.style = matchStyles(pattern.style, element);

		if (!match.style) {
			return false;
		}
	}

	return match;
}

// Checks if name can be matched by provided pattern.
//
// @param {String|RegExp} pattern
// @param {String} name
// @returns {Boolean} Returns `true` if name can be matched, `false` otherwise.
function matchName(pattern, name) {
	// If pattern is provided as RegExp - test against this regexp.
	if (pattern instanceof RegExp) {
		return pattern.test(name);
	}

	return pattern === name;
}

// Checks if attributes of provided element can be matched against provided patterns.
//
// @param {Object} patterns Object with information about attributes to match. Each key of the object will be
// used as attribute name. Value of each key can be a string or regular expression to match against attribute value.
// @param {engine.view.Element} element Element which attributes will be tested.
// @returns {Array|null} Returns array with matched attribute names or `null` if no attributes were matched.
function matchAttributes(patterns, element) {
	var match = [];

	for (var name in patterns) {
		var pattern = patterns[name];

		if (element.hasAttribute(name)) {
			var attribute = element.getAttribute(name);

			if (pattern instanceof RegExp) {
				if (pattern.test(attribute)) {
					match.push(name);
				} else {
					return null;
				}
			} else if (attribute === pattern) {
				match.push(name);
			} else {
				return null;
			}
		} else {
			return null;
		}
	}

	return match;
}

// Checks if classes of provided element can be matched against provided patterns.
//
// @param {Array.<String|RegExp>} patterns Array of strings or regular expressions to match against element's classes.
// @param {engine.view.Element} element Element which classes will be tested.
// @returns {Array|null} Returns array with matched class names or `null` if no classes were matched.
function matchClasses(patterns, element) {
	var match = [];

	var _iteratorNormalCompletion6 = true;
	var _didIteratorError6 = false;
	var _iteratorError6 = undefined;

	try {
		for (var _iterator6 = patterns[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
			var pattern = _step6.value;

			if (pattern instanceof RegExp) {
				var classes = element.getClassNames();

				var _iteratorNormalCompletion7 = true;
				var _didIteratorError7 = false;
				var _iteratorError7 = undefined;

				try {
					for (var _iterator7 = classes[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
						var name = _step7.value;

						if (pattern.test(name)) {
							match.push(name);
						}
					}
				} catch (err) {
					_didIteratorError7 = true;
					_iteratorError7 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion7 && _iterator7.return) {
							_iterator7.return();
						}
					} finally {
						if (_didIteratorError7) {
							throw _iteratorError7;
						}
					}
				}

				if (match.length === 0) {
					return null;
				}
			} else if (element.hasClass(pattern)) {
				match.push(pattern);
			} else {
				return null;
			}
		}
	} catch (err) {
		_didIteratorError6 = true;
		_iteratorError6 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion6 && _iterator6.return) {
				_iterator6.return();
			}
		} finally {
			if (_didIteratorError6) {
				throw _iteratorError6;
			}
		}
	}

	return match;
}

// Checks if styles of provided element can be matched against provided patterns.
//
// @param {Object} patterns Object with information about styles to match. Each key of the object will be
// used as style name. Value of each key can be a string or regular expression to match against style value.
// @param {engine.view.Element} element Element which styles will be tested.
// @returns {Array|null} Returns array with matched style names or `null` if no styles were matched.
function matchStyles(patterns, element) {
	var match = [];

	for (var name in patterns) {
		var pattern = patterns[name];

		if (element.hasStyle(name)) {
			var style = element.getStyle(name);

			if (pattern instanceof RegExp) {
				if (pattern.test(style)) {
					match.push(name);
				} else {
					return null;
				}
			} else if (style === pattern) {
				match.push(name);
			} else {
				return null;
			}
		} else {
			return null;
		}
	}

	return match;
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Provides chainable, high-level API to easily build basic view-to-model converters that are appended to given
 * dispatchers. View-to-model converters are used when external data is added to the editor, i.e. when a user pastes
 * HTML content to the editor. Then, converters are used to translate this structure, possibly removing unknown/incorrect
 * nodes, and add it to the model. Also multiple, different elements might be translated into the same thing in the
 * model, i.e. `<b>` and `<strong>` elements might be converted to `bold` attribute (even though `bold` attribute will
 * be then converted only to `<strong>` tag). Instances of this class are created by {@link engine.conversion.buildViewConverter}.
 *
 * If you need more complex converters, see {@link engine.conversion.ViewConversionDispatcher},
 * {@link engine.conversion.viewToModel}, {@link engine.conversion.ViewConsumable}.
 *
 * Using this API it is possible to create various kind of converters:
 *
 * 1. View element to model element:
 *
 *		buildViewConverter().for( dispatcher ).fromElement( 'p' ).toElement( 'paragraph' );
 *
 * 2. View element to model attribute:
 *
 *		buildViewConverter().for( dispatcher ).fromElement( 'b' ).fromElement( 'strong' ).toAttribute( 'bold', 'true' );
 *
 * 3. View attribute to model attribute:
 *
 *		buildViewConverter().for( dispatcher ).fromAttribute( 'style', { 'font-weight': 'bold' } ).toAttribute( 'bold', 'true' );
 *		buildViewConverter().for( dispatcher )
 *			.fromAttribute( 'class' )
 *			.toAttribute( ( viewElement ) => ( { class: viewElement.getAttribute( 'class' ) } ) );
 *
 * 4. View elements and attributes to model attribute:
 *
 *		buildViewConverter().for( dispatcher )
 *			.fromElement( 'b' ).fromElement( 'strong' ).fromAttribute( 'style', { 'font-weight': 'bold' } )
 *			.toAttribute( 'bold', 'true' );
 *
 * 5. View {@link engine.view.Matcher view element matcher instance} or {@link engine.view.Matcher#add matcher pattern}
 * to model element or attribute:
 *
 *		const matcher = new ViewMatcher();
 *		matcher.add( 'div', { class: 'quote' } );
 *		buildViewConverter().for( dispatcher ).from( matcher ).toElement( 'quote' );
 *
 *		buildViewConverter().for( dispatcher ).from( { name: 'span', class: 'bold' } ).toAttribute( 'bold', 'true' );
 *
 * Note, that converters built using `ViewConverterBuilder` automatically check {@link engine.model.Schema schema}
 * if created model structure is valid. If given conversion would be invalid according to schema, it is ignored.
 *
 * It is possible to provide creator functions as parameters for {@link engine.conversion.ViewConverterBuilder#toElement}
 * and {@link engine.conversion.ViewConverterBuilder#toAttribute} methods. See their descriptions to learn more.
 *
 * By default, converter will {@link engine.conversion.ViewConsumable#consume consume} every value specified in
 * given `from...` query, i.e. `.from( { name: 'span', class: 'bold' } )` will make converter consume both `span` name
 * and `bold` class. It is possible to change this behavior using {@link engine.conversion.ViewConverterBuilder#consuming consuming}
 * modifier. The modifier alters the last `fromXXX` query used before it. To learn more about consuming values,
 * see {@link engine.conversion.ViewConsumable}.
 *
 * It is also possible to {@link engine.conversion.ViewConverterBuilder#withPriority change default priority}
 * of created converters to decide which converter should be fired earlier and which later. This is useful if you provide
 * a general converter but want to provide different converter for a specific-case (i.e. given view element is converted
 * always to given model element, but if it has given class it is converter to other model element). For this,
 * use {@link engine.conversion.ViewConverterBuilder#withPriority withPriority} modifier. The modifier alters
 * the last `from...` query used before it.
 *
 * Note that `to...` methods are "terminators", which means that should be the last one used in building converter.
 *
 * You can use {@link engine.conversion.ModelConverterBuilder} to create "opposite" converters - from model to view.
 *
 * @memberOf engine.conversion
 */

var ViewConverterBuilder = function () {
	/**
  * Creates `ViewConverterBuilder` with given `dispatchers` registered to it.
  */
	function ViewConverterBuilder() {
		classCallCheck(this, ViewConverterBuilder);

		/**
   * Dispatchers to which converters will be attached.
   *
   * @type {Array.<engine.conversion.ViewConversionDispatcher>}
   * @private
   */
		this._dispatchers = [];

		/**
   * Stores "from" queries.
   *
   * @type {Array}
   * @private
   */
		this._from = [];
	}

	/**
  * Set one or more dispatchers which the built converter will be attached to.
  *
  * @chainable
  * @param {...engine.conversion.ViewConversionDispatcher} dispatchers One or more dispatchers.
  * @returns {engine.conversion.ViewConverterBuilder}
  */


	createClass(ViewConverterBuilder, [{
		key: 'for',
		value: function _for() {
			for (var _len = arguments.length, dispatchers = Array(_len), _key = 0; _key < _len; _key++) {
				dispatchers[_key] = arguments[_key];
			}

			this._dispatchers = dispatchers;

			return this;
		}

		/**
   * Registers what view element should be converted.
   *
   *		buildViewConverter().for( dispatcher ).fromElement( 'p' ).toElement( 'paragraph' );
   *
   * @chainable
   * @param {String} elementName View element name.
   * @returns {engine.conversion.ViewConverterBuilder}
   */

	}, {
		key: 'fromElement',
		value: function fromElement(elementName) {
			return this.from({ name: elementName });
		}

		/**
   * Registers what view attribute should be converted.
   *
   *		buildViewConverter().for( dispatcher ).fromAttribute( 'style', { 'font-weight': 'bold' } ).toAttribute( 'bold', 'true' );
   *
   * @chainable
   * @param {String|RegExp} key View attribute key.
   * @param {String|RegExp} [value] View attribute value.
   * @returns {engine.conversion.ViewConverterBuilder}
   */

	}, {
		key: 'fromAttribute',
		value: function fromAttribute(key) {
			var value = arguments.length <= 1 || arguments[1] === undefined ? /.*/ : arguments[1];

			var pattern = {};
			pattern[key] = value;

			return this.from(pattern);
		}

		/**
   * Registers what view pattern should be converted. The method accepts either {@link engine.view.Matcher view matcher}
   * or view matcher pattern.
   *
   *		const matcher = new ViewMatcher();
   *		matcher.add( 'div', { class: 'quote' } );
   *		buildViewConverter().for( dispatcher ).from( matcher ).toElement( 'quote' );
   *
   *		buildViewConverter().for( dispatcher ).from( { name: 'span', class: 'bold' } ).toAttribute( 'bold', 'true' );
   *
   * @chainable
   * @param {Object|engine.view.Matcher} matcher View matcher or view matcher pattern.
   * @returns {engine.conversion.ViewConverterBuilder}
   */

	}, {
		key: 'from',
		value: function from(matcher) {
			if (!(matcher instanceof Matcher)) {
				matcher = new Matcher(matcher);
			}

			this._from.push({
				matcher: matcher,
				consume: false,
				priority: null
			});

			return this;
		}

		/**
   * Modifies which consumable values will be {@link engine.conversion.ViewConsumable#consume consumed} by built converter.
   * It modifies the last `from...` query. Can be used after each `from...` query in given chain. Useful for providing
   * more specific matches.
   *
   *		// This converter will only handle class bold conversion (to proper attribute) but span element
   *		// conversion will have to be done in separate converter.
   *		// Without consuming modifier, the converter would consume both class and name, so a converter for
   *		// span element would not be fired.
   *		buildViewConverter().for( dispatcher )
   *			.from( { name: 'span', class: 'bold' } ).consuming( { class: 'bold' } )
   *			.toAttribute( 'bold', 'true' } );
   *
   *		buildViewConverter().for( dispatcher )
   *			.fromElement( 'img' ).consuming( { name: true, attributes: [ 'src', 'title' ] } )
   *			.toElement( ( viewElement ) => new ModelElement( 'image', { src: viewElement.getAttribute( 'src' ),
   *																		title: viewElement.getAttribute( 'title' ) } );
   *
   * **Note:** All and only values from passed object has to be consumable on converted view element. This means that
   * using `consuming` method, you can either make looser conversion conditions (like in first example) or tighter
   * conversion conditions (like in second example). So, the view element, to be converter, has to match query of
   * `from...` method and then have to have enough consumable values to consume.
   *
   * @see engine.conversion.ViewConsumable
   * @chainable
   * @param {Object} consume Values to consume.
   * @returns {engine.conversion.ViewConverterBuilder}
   */

	}, {
		key: 'consuming',
		value: function consuming(consume) {
			var lastFrom = this._from[this._from.length - 1];
			lastFrom.consume = consume;

			return this;
		}

		/**
   * Changes default priority for built converter. It modifies the last `from...` query. Can be used after each
   * `from...` query in given chain. Useful for overwriting converters. The lower the number, the earlier converter will be fired.
   *
   *		buildViewConverter().for( dispatcher ).fromElement( 'p' ).toElement( 'paragraph' );
   *		// Register converter with proper priority, otherwise "p" element would get consumed by first
   *		// converter and the second converter would not be fired.
   *		buildViewConverter().for( dispatcher )
   *			.from( { name: 'p', class: 'custom' } ).withPriority( 9 )
   *			.toElement( 'customParagraph' );
   *
   * **Note:** `ViewConverterBuilder` takes care so all `toElement` conversions takes place before all `toAttribute`
   * conversions. This is done by setting default `toElement` priority to `10` and `toAttribute` priority to `1000`.
   * It is recommended to set converter priority for `toElement` conversions below `500` and `toAttribute` priority
   * above `500`. It is important that model elements are created before attributes, otherwise attributes would
   * not be applied or other errors may occur.
   *
   * @chainable
   * @param {Number} priority Converter priority.
   * @returns {engine.conversion.ViewConverterBuilder}
   */

	}, {
		key: 'withPriority',
		value: function withPriority(priority) {
			var lastFrom = this._from[this._from.length - 1];
			lastFrom.priority = priority;

			return this;
		}

		/**
   * Registers what model element will be created by converter.
   *
   * Method accepts two ways of providing what kind of model element will be created. You can pass model element
   * name as a `string` or a function that will return model element instance. If you provide creator function,
   * it will be passed converted view element as first and only parameter.
   *
   *		buildViewConverter().for( dispatcher ).fromElement( 'p' ).toElement( 'paragraph' );
   *		buildViewConverter().for( dispatcher )
   *			.fromElement( 'img' )
   *			.toElement( ( viewElement ) => new ModelElement( 'image', { src: viewElement.getAttribute( 'src' ) } );
   *
   * @param {String|Function} element Model element name or model element creator function.
   */

	}, {
		key: 'toElement',
		value: function toElement(element) {
			var eventCallbackGen = function eventCallbackGen(from) {
				return function (evt, data, consumable, conversionApi) {
					// There is one callback for all patterns in the matcher.
					// This will be usually just one pattern but we support matchers with many patterns too.
					var matchAll = from.matcher.matchAll(data.input);

					// If there is no match, this callback should not do anything.
					if (!matchAll) {
						return;
					}

					// Now, for every match between matcher and actual element, we will try to consume the match.
					var _iteratorNormalCompletion = true;
					var _didIteratorError = false;
					var _iteratorError = undefined;

					try {
						for (var _iterator = matchAll[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
							var match = _step.value;

							// Create model element basing on creator function or element name.
							var modelElement = element instanceof Function ? element(data.input) : new Element(element);

							// Check whether generated structure is okay with `Schema`.
							var keys = Array.from(modelElement.getAttributeKeys());

							if (!conversionApi.schema.check({ name: modelElement.name, attributes: keys, inside: data.context })) {
								continue;
							}

							// Try to consume appropriate values from consumable values list.
							if (!consumable.consume(data.input, from.consume || match.match)) {
								continue;
							}

							// If everything is fine, we are ready to start the conversion.
							// Add newly created `modelElement` to the parents stack.
							data.context.push(modelElement);

							// Convert children of converted view element and append them to `modelElement`.
							var modelChildren = conversionApi.convertChildren(data.input, consumable, data);
							var insertPosition = Position.createAt(modelElement, 'end');
							modelWriter.insert(insertPosition, modelChildren);

							// Remove created `modelElement` from the parents stack.
							data.context.pop();

							// Add `modelElement` as a result.
							data.output = modelElement;

							// Prevent multiple conversion if there are other correct matches.
							break;
						}
					} catch (err) {
						_didIteratorError = true;
						_iteratorError = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion && _iterator.return) {
								_iterator.return();
							}
						} finally {
							if (_didIteratorError) {
								throw _iteratorError;
							}
						}
					}
				};
			};

			this._setCallback(eventCallbackGen, 'normal');
		}

		/**
   * Registers what model attribute will be created by converter.
   *
   * Method accepts two ways of providing what kind of model attribute will be created. You can either pass two strings
   * representing attribute key and attribute value or a function that returns an object with `key` and `value` properties.
   * If you provide creator function, it will be passed converted view element as first and only parameter.
   *
   *		buildViewConverter().for( dispatcher ).fromAttribute( 'style', { 'font-weight': 'bold' } ).toAttribute( 'bold', 'true' );
   *		buildViewConverter().for( dispatcher )
   *			.fromAttribute( 'class' )
   *			.toAttribute( ( viewElement ) => ( { key: 'class', value: viewElement.getAttribute( 'class' ) } ) );
   *
   * @param {String|Function} keyOrCreator Attribute key or a creator function.
   * @param {String} [value] Attribute value. Required if `keyOrCreator` is a `string`. Ignored otherwise.
   */

	}, {
		key: 'toAttribute',
		value: function toAttribute(keyOrCreator, value) {
			var eventCallbackGen = function eventCallbackGen(from) {
				return function (evt, data, consumable, conversionApi) {
					// There is one callback for all patterns in the matcher.
					// This will be usually just one pattern but we support matchers with many patterns too.
					var matchAll = from.matcher.matchAll(data.input);

					// If there is no match, this callback should not do anything.
					if (!matchAll) {
						return;
					}

					// Now, for every match between matcher and actual element, we will try to consume the match.
					var _iteratorNormalCompletion2 = true;
					var _didIteratorError2 = false;
					var _iteratorError2 = undefined;

					try {
						for (var _iterator2 = matchAll[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
							var match = _step2.value;

							// Try to consume appropriate values from consumable values list.
							if (!consumable.consume(data.input, from.consume || match.match)) {
								continue;
							}

							// Since we are converting to attribute we need an output on which we will set the attribute.
							// If the output is not created yet, we will create it.
							if (!data.output) {
								data.output = conversionApi.convertChildren(data.input, consumable, data);
							}

							// Use attribute creator function, if provided.
							var attribute = keyOrCreator instanceof Function ? keyOrCreator(data.input) : { key: keyOrCreator, value: value };

							// Set attribute on current `output`. `Schema` is checked inside this helper function.
							setAttributeOn(data.output, attribute, data, conversionApi);

							// Prevent multiple conversion if there are other correct matches.
							break;
						}
					} catch (err) {
						_didIteratorError2 = true;
						_iteratorError2 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion2 && _iterator2.return) {
								_iterator2.return();
							}
						} finally {
							if (_didIteratorError2) {
								throw _iteratorError2;
							}
						}
					}
				};
			};

			this._setCallback(eventCallbackGen, 'low');
		}

		/**
   * Helper function that uses given callback generator to created callback function and sets it on registered dispatchers.
   *
   * @param eventCallbackGen
   * @param defaultPriority
   * @private
   */

	}, {
		key: '_setCallback',
		value: function _setCallback(eventCallbackGen, defaultPriority) {
			// We will add separate event callback for each registered `from` entry.
			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = this._from[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var from = _step3.value;

					// We have to figure out event name basing on matcher's patterns.
					// If there is exactly one pattern and it has `name` property we will used that name.
					var matcherElementName = from.matcher.getElementName();
					var eventName = matcherElementName ? 'element:' + matcherElementName : 'element';
					var eventCallback = eventCallbackGen(from);

					var priority = from.priority === null ? defaultPriority : from.priority;

					// Add event to each registered dispatcher.
					var _iteratorNormalCompletion4 = true;
					var _didIteratorError4 = false;
					var _iteratorError4 = undefined;

					try {
						for (var _iterator4 = this._dispatchers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
							var dispatcher = _step4.value;

							dispatcher.on(eventName, eventCallback, { priority: priority });
						}
					} catch (err) {
						_didIteratorError4 = true;
						_iteratorError4 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion4 && _iterator4.return) {
								_iterator4.return();
							}
						} finally {
							if (_didIteratorError4) {
								throw _iteratorError4;
							}
						}
					}
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}
		}
	}]);
	return ViewConverterBuilder;
}();

// Helper function that sets given attributes on given `engine.model.Node` or `engine.model.DocumentFragment`.


function setAttributeOn(toChange, attribute, data, conversionApi) {
	if (isIterable(toChange)) {
		var _iteratorNormalCompletion5 = true;
		var _didIteratorError5 = false;
		var _iteratorError5 = undefined;

		try {
			for (var _iterator5 = toChange[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
				var node = _step5.value;

				setAttributeOn(node, attribute, data, conversionApi);
			}
		} catch (err) {
			_didIteratorError5 = true;
			_iteratorError5 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion5 && _iterator5.return) {
					_iterator5.return();
				}
			} finally {
				if (_didIteratorError5) {
					throw _iteratorError5;
				}
			}
		}

		return;
	}

	var keys = Array.from(toChange.getAttributeKeys());
	keys.push(attribute.key);

	var schemaQuery = {
		name: toChange.name || '$text',
		attributes: keys,
		inside: data.context
	};

	if (conversionApi.schema.check(schemaQuery)) {
		toChange.setAttribute(attribute.key, attribute.value);
	}
}

/**
 * Entry point for view-to-model converters builder. This chainable API makes it easy to create basic, most common
 * view-to-model converters and attach them to provided dispatchers. The method returns an instance of
 * {@link engine.conversion.ViewConverterBuilder}.
 *
 * @external engine.conversion.buildViewConverter
 * @memberOf engine.conversion
 */
function buildViewConverter() {
	return new ViewConverterBuilder();
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The base class for CKEditor commands.
 *
 * Commands are main way to manipulate editor contents and state. They are mostly used by UI elements (or by other
 * commands) to make changes in Tree Model. Commands are available in every part of code that has access to
 * {@link core.editor.Editor} instance, since they are registered in it and executed through {@link core.editor.Editor#execute}.
 * Commands instances are available through {@link core.editor.Editor#commands}.
 *
 * This is an abstract base class for all commands.
 *
 * @memberOf core.command
 * @mixes utils.ObservableMixin
 */

var Command = function () {
	/**
  * Creates a new Command instance.
  *
  * @param {core.editor.Editor} editor Editor on which this command will be used.
  */
	function Command(editor) {
		var _this = this;

		classCallCheck(this, Command);

		/**
   * Editor on which this command will be used.
   *
   * @readonly
   * @member {core.editor.Editor} core.command.Command#editor
   */
		this.editor = editor;

		/**
   * Flag indicating whether a command is enabled or disabled.
   * A disabled command should do nothing upon it's execution.
   *
   * @observable
   * @member {Boolean} core.command.Command#isEnabled
   */
		this.set('isEnabled', true);

		// If schema checking function is specified, add it to the `refreshState` listeners.
		// Feature will be disabled if it does not apply to schema requirements.
		if (this._checkEnabled) {
			this.on('refreshState', function (evt, data) {
				data.isEnabled = _this._checkEnabled();
			});
		}
	}

	createClass(Command, [{
		key: 'destroy',
		value: function destroy() {
			this.stopListening();
		}

		/**
   * Fires `refreshState` event and checks it's resolve value to decide whether command should be enabled or not.
   * Other parts of code might listen to `refreshState` event on this command and add their callbacks. This
   * way the responsibility of deciding whether a command should be enabled is shared.
   *
   * @fires {@link core.command.Command#refreshState refreshState}
   */

	}, {
		key: 'refreshState',
		value: function refreshState() {
			var data = { isEnabled: true };
			this.fire('refreshState', data);

			this.isEnabled = data.isEnabled;
		}

		/**
   * Executes the command if it is enabled.
   *
   * @protected
   * @param {*} param Parameter passed to {@link core.command.Command#execute execute} method of this command.
   */

	}, {
		key: '_execute',
		value: function _execute(param) {
			if (this.isEnabled) {
				this._doExecute(param);
			}
		}

		/**
   * Disables the command. This should be used only by the command itself. Other parts of code should add
   * listeners to `refreshState` event.
   *
   * @protected
   */

	}, {
		key: '_disable',
		value: function _disable() {
			this.on('refreshState', disableCallback);
			this.refreshState();
		}

		/**
   * Enables the command (internally). This should be used only by the command itself. Command will be enabled if
   * other listeners does not return false on `refreshState` event callbacks. Firing {@link core.command.Command#_enable}
   * does not guarantee that {@link core.command.Command#isEnabled} will be set to true, as it depends on other listeners.
   *
   * @protected
   */

	}, {
		key: '_enable',
		value: function _enable() {
			this.off('refreshState', disableCallback);
			this.refreshState();
		}

		/**
   * Executes command.
   * This is an abstract method that should be overwritten in child classes.
   *
   * @protected
   */

	}, {
		key: '_doExecute',
		value: function _doExecute() {}

		/**
   * Checks if a command should be enabled according to its own rules. Mostly it will check schema to see if the command
   * is allowed to be executed in given position. This method can be defined in child class (but is not obligatory).
   * If it is defined, it will be added as a callback to `refreshState` event.
   *
   * @protected
   * @method core.command.Command#_checkEnabled
   * @returns {Boolean} `true` if command should be enabled according to {@link engine.model.Document#schema}. `false` otherwise.
   */

	}]);
	return Command;
}();

function disableCallback(evt, data) {
	data.isEnabled = false;
}

mix(Command, ObservableMixin);

/**
 * Fired whenever command has to have its {@link core.command.Command#isEnabled} property refreshed. Every feature,
 * command or other class which needs to disable command (set `isEnabled` to `false`) should listen to this
 * event.
 *
 * @event core.command.Command#refreshState
 * @param {Object} data
 * @param {Boolean} [data.isEnabled=true]
 */

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Walks through given array of ranges and removes parts of them that are not allowed by passed schema to have the
 * attribute set. This is done by breaking a range in two and omitting the not allowed part.
 *
 * @param {String} attribute Attribute key.
 * @param {Array.<engine.model.Range>} ranges Ranges to be validated.
 * @param {engine.model.Schema} schema Document schema.
 * @returns {Array.<engine.model.Range>} Ranges without invalid parts.
 */
function getSchemaValidRanges(attribute, ranges, schema) {
	var validRanges = [];

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var range = _step.value;

			var walker = new TreeWalker({ boundaries: range, mergeCharacters: true });
			var step = walker.next();

			var last = range.start;
			var from = range.start;
			var to = range.end;

			while (!step.done) {
				var name = step.value.item.name || '$text';

				if (!schema.check({ name: name, inside: last, attributes: attribute })) {
					if (!from.isEqual(last)) {
						validRanges.push(new Range$1(from, last));
					}

					from = walker.position;
				}

				last = walker.position;
				step = walker.next();
			}

			if (from && !from.isEqual(to)) {
				validRanges.push(new Range$1(from, to));
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return validRanges;
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Checks {@link engine.model.Document#schema} if attribute is allowed in selection:
 * * if selection is on range, the command is enabled if any of nodes in that range can have bold,
 * * if selection is collapsed, the command is enabled if text with bold is allowed in that node.
 *
 * @param {String} attribute Attribute key.
 * @param {engine.model.Selection} selection Selection which ranges will be validate.
 * @param {engine.model.Schema} schema Document schema.
 * @returns {Boolean}
 */
function isAttributeAllowedInSelection(attribute, selection, schema) {
	if (selection.isCollapsed) {
		// Check whether schema allows for a test with `attributeKey` in caret position.
		return schema.check({ name: '$text', inside: selection.getFirstPosition(), attributes: attribute });
	} else {
		var ranges = selection.getRanges();

		// For all ranges, check nodes in them until you find a node that is allowed to have `attributeKey` attribute.
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var range = _step.value;

				var walker = new TreeWalker({ boundaries: range, mergeCharacters: true });
				var last = walker.position;
				var step = walker.next();

				// Walk the range.
				while (!step.done) {
					// If returned item does not have name property, it is a model.TextFragment.
					var name = step.value.item.name || '$text';

					if (schema.check({ name: name, inside: last, attributes: attribute })) {
						// If we found a node that is allowed to have the attribute, return true.
						return true;
					}

					last = walker.position;
					step = walker.next();
				}
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}
	}

	// If we haven't found such node, return false.
	return false;
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * An extension of basic {@link core.command.Command} class, which provides utilities for a command that toggle a single
 * attribute on a text or element with value `true`. ToggleAttributeCommand uses {@link engine.model.Document#selection}
 * to decide which nodes (if any) should be changed, and applies or removes attributes from them.
 * See {@link engine.view.Converter#execute} for more.
 *
 * The command checks {@link engine.model.Document#schema} to decide if it should be enabled.
 * See {@link engine.view.Converter#checkSchema} for more.
 *
 * @memberOf core.command
 */

var ToggleAttributeCommand = function (_Command) {
	inherits(ToggleAttributeCommand, _Command);

	/**
  * @see core.command.Command
  * @param {core.editor.Editor} editor
  * @param {String} attributeKey Attribute that will be set by the command.
  */
	function ToggleAttributeCommand(editor, attributeKey) {
		classCallCheck(this, ToggleAttributeCommand);

		/**
   * Attribute that will be set by the command.
   *
   * @member {String} core.command.ToggleAttributeCommand#attributeKey
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ToggleAttributeCommand).call(this, editor));

		_this.attributeKey = attributeKey;

		/**
   * Flag indicating whether command is active. For collapsed selection it means that typed characters will have
   * the command's attribute set. For range selection it means that all nodes inside have the attribute applied.
   *
   * @observable
   * @member {Boolean} core.command.ToggleAttributeCommand#value
   */
		_this.set('value', false);

		_this.listenTo(_this.editor.document.selection, 'change:attribute', function () {
			_this.value = _this.editor.document.selection.hasAttribute(_this.attributeKey);
		});
		return _this;
	}

	/**
  * Checks if {@link engine.model.Document#schema} allows to create attribute in {@link engine.model.Document#selection}
  *
  * @private
  * @returns {Boolean}
  */


	createClass(ToggleAttributeCommand, [{
		key: '_checkEnabled',
		value: function _checkEnabled() {
			var document = this.editor.document;

			return isAttributeAllowedInSelection(this.attributeKey, document.selection, document.schema);
		}

		/**
   * Executes the command: adds or removes attributes to nodes or selection.
   *
   * If the command is active (`value == true`), it will remove attributes. Otherwise, it will set attributes.
   *
   * The execution result differs, depending on the {@link engine.model.Document#selection}:
   * * if selection is on a range, the command applies the attribute on all nodes in that ranges
   * (if they are allowed to have this attribute by the {@link engine.model.Schema schema}),
   * * if selection is collapsed in non-empty node, the command applies attribute to the {@link engine.model.Document#selection}
   * itself (note that typed characters copy attributes from selection),
   * * if selection is collapsed in empty node, the command applies attribute to the parent node of selection (note
   * that selection inherits all attributes from a node if it is in empty node).
   *
   * If the command is disabled (`isEnabled == false`) when it is executed, nothing will happen.
   *
   * @private
   * @param {Object} [options] Options of command.
   * @param {Boolean} [options.forceValue] If set it will force command behavior. If `true`, command will apply attribute,
   * otherwise command will remove attribute. If not set, command will look for it's current value to decide what it should do.
   * @param {engine.model.Batch} [options.batch] Batch to group undo steps.
   */

	}, {
		key: '_doExecute',
		value: function _doExecute() {
			var _this2 = this;

			var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

			var document = this.editor.document;
			var selection = document.selection;
			var value = options.forceValue === undefined ? !this.value : options.forceValue;

			// If selection has non-collapsed ranges, we change attribute on nodes inside those ranges.
			document.enqueueChanges(function () {
				if (selection.isCollapsed) {
					if (value) {
						selection.setAttribute(_this2.attributeKey, true);
					} else {
						selection.removeAttribute(_this2.attributeKey);
					}
				} else {
					var ranges = getSchemaValidRanges(_this2.attributeKey, selection.getRanges(), document.schema);

					// Keep it as one undo step.
					var batch = options.batch || document.batch();

					var _iteratorNormalCompletion = true;
					var _didIteratorError = false;
					var _iteratorError = undefined;

					try {
						for (var _iterator = ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
							var range = _step.value;

							if (value) {
								batch.setAttribute(range, _this2.attributeKey, value);
							} else {
								batch.removeAttribute(range, _this2.attributeKey);
							}
						}
					} catch (err) {
						_didIteratorError = true;
						_iteratorError = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion && _iterator.return) {
								_iterator.return();
							}
						} finally {
							if (_didIteratorError) {
								throw _iteratorError;
							}
						}
					}
				}
			});
		}
	}]);
	return ToggleAttributeCommand;
}(Command);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

var BOLD = 'bold';

/**
 * The bold engine feature.
 *
 * It registers the `bold` command and introduces the `bold` attribute in the model which renders to the view
 * as a `<strong>` element.
 *
 * @memberOf basic-styles
 * @extends core.Feature
 */

var BoldEngine = function (_Feature) {
	inherits(BoldEngine, _Feature);

	function BoldEngine() {
		classCallCheck(this, BoldEngine);
		return possibleConstructorReturn(this, Object.getPrototypeOf(BoldEngine).apply(this, arguments));
	}

	createClass(BoldEngine, [{
		key: 'init',

		/**
   * @inheritDoc
   */
		value: function init() {
			var editor = this.editor;
			var data = editor.data;
			var editing = editor.editing;

			// Allow bold attribute on all inline nodes.
			editor.document.schema.allow({ name: '$inline', attributes: [BOLD] });

			// Build converter from model to view for data and editing pipelines.
			buildModelConverter().for(data.modelToView, editing.modelToView).fromAttribute(BOLD).toElement('strong');

			// Build converter from view to model for data pipeline.
			buildViewConverter().for(data.viewToModel).fromElement('strong').fromElement('b').fromAttribute('style', { 'font-weight': 'bold' }).toAttribute(BOLD, true);

			// Create bold command.
			editor.commands.set(BOLD, new ToggleAttributeCommand(editor, BOLD));
		}
	}]);
	return BoldEngine;
}(Feature);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The icon controller class.
 *
 *		const model = new Model( {
 *			name: 'bold'
 *		} );
 *
 *		// An instance of "bold" Icon.
 *		new Icon( model, new IconView() );
 *
 * See {@link ui.icon.IconView}, {@link ui.iconManager.IconManager}.
 *
 * @memberOf ui.icon
 * @extends ui.Controller
 */

var Icon = function (_Controller) {
  inherits(Icon, _Controller);

  /**
   * Creates an instance of {@link ui.icon.Icon} class.
   *
   * @param {ui.icon.IconModel} model Model of this icon.
   * @param {ui.View} view View of this icon.
   */
  function Icon(model, view) {
    classCallCheck(this, Icon);

    var _this = possibleConstructorReturn(this, Object.getPrototypeOf(Icon).call(this, model, view));

    view.bind('name').to(model);
    return _this;
  }

  return Icon;
}(Controller);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The icon view class.
 *
 * See {@link ui.icon.Icon}.
 *
 * @memberOf ui.icon
 * @extends ui.View
 */

var IconView = function (_View) {
	inherits(IconView, _View);

	/**
  * @inheritDoc
  */
	function IconView() {
		classCallCheck(this, IconView);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(IconView).call(this));

		var bind = _this.bindTemplate;

		_this.template = new Template({
			tag: 'svg',
			ns: 'http://www.w3.org/2000/svg',
			attributes: {
				class: ['ck-icon']
			},
			children: [{
				tag: 'use',
				ns: 'http://www.w3.org/2000/svg',
				attributes: {
					href: {
						ns: 'http://www.w3.org/1999/xlink',
						value: bind.to('name', function (i) {
							return '#ck-icon-' + i;
						})
					}
				}
			}]
		});

		/**
   * The name of the icon. It corresponds with the name of the
   * file in the {@link ui.iconManager.IconManager}.
   *
   * @observable
   * @member {String} ui.icon.IconView#name
   */
		return _this;
	}

	return IconView;
}(View);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The button controller class. It uses {@link ui.icon.Icon} component
 * to display an icon.
 *
 *		const model = new Model( {
 *			label: 'Bold',
 *			isEnabled: true,
 *			isOn: false,
 *			icon: 'bold'
 *		} );
 *
 *		// An instance of Button with a label and an icon.
 *		new Button( model, new ButtonView() );
 *
 * See {@link ui.button.ButtonView}.
 *
 * @memberOf ui.button
 * @extends ui.Controller
 */

var Button = function (_Controller) {
  inherits(Button, _Controller);

  /**
   * Creates an instance of {@link ui.button.Button} class.
   *
   * @param {ui.button.ButtonModel} model Model of this Button.
   * @param {ui.View} view View of this Button.
   */
  function Button(model, view) {
    classCallCheck(this, Button);

    var _this = possibleConstructorReturn(this, Object.getPrototypeOf(Button).call(this, model, view));

    view.bind('label', 'isOn', 'isEnabled', 'withText', 'type').to(model);
    view.bind('title').to(model, 'label', model, 'keystroke', function (label, keystroke) {
      if (keystroke) {
        label += ' (' + getEnvKeystrokeText(keystroke) + ')';
      }

      return label;
    });

    if (model.icon) {
      view.bind('icon').to(model);
    }

    view.on('click', function () {
      return model.fire('execute');
    });
    return _this;
  }

  /**
   * @inheritDoc
   */


  createClass(Button, [{
    key: 'init',
    value: function init() {
      if (this.model.icon) {
        this.addCollection('children');

        var iconModel = new Model();
        iconModel.bind('name').to(this.model, 'icon');

        this.add('children', new Icon(iconModel, new IconView()));
      }

      return get(Object.getPrototypeOf(Button.prototype), 'init', this).call(this);
    }
  }]);
  return Button;
}(Controller);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The button view class.
 *
 * See {@link ui.button.Button}.
 *
 * @memberOf ui.button
 * @extends ui.View
 */

var ButtonView = function (_View) {
	inherits(ButtonView, _View);

	/**
  * @inheritDoc
  */
	function ButtonView() {
		classCallCheck(this, ButtonView);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ButtonView).call(this));

		var bind = _this.bindTemplate;

		_this.template = new Template({
			tag: 'button',

			attributes: {
				class: ['ck-button', bind.to('isEnabled', function (value) {
					return value ? 'ck-enabled' : 'ck-disabled';
				}), bind.to('isOn', function (value) {
					return value ? 'ck-on' : 'ck-off';
				}), bind.if('withText', 'ck-button_with-text')],
				title: [bind.to('title')],
				type: bind.to('type', function (value) {
					return value ? value : 'button';
				})
			},

			children: [{
				tag: 'span',

				attributes: {
					class: ['ck-button__label']
				},

				children: [{
					text: bind.to('label')
				}]
			}],

			on: {
				mousedown: bind.to(function (evt) {
					evt.preventDefault();
				}),

				click: bind.to(function (evt) {
					// We can't make the button disabled using the disabled attribute, because it won't be focusable.
					// Though, shouldn't this condition be moved to the button controller?
					if (_this.isEnabled) {
						_this.fire('click');
					} else {
						evt.preventDefault();
					}
				})
			}
		});

		_this.register('children', function (el) {
			return el;
		});

		/**
   * The label of the button view visible to the user.
   *
   * @observable
   * @member {String} ui.button.ButtonView#label
   */

		/**
   * The HTML type of the button. Default `button`.
   *
   * @observable
   * @member {'button'|'submit'|'reset'|'menu'} ui.button.ButtonView#type
   */

		/**
   * Controls whether the button view is "on", e.g. some feature which it represents
   * is currently enabled.
   *
   * @observable
   * @member {Boolean} ui.button.ButtonView#isOn
   */

		/**
   * Controls whether the button view is enabled (can be clicked).
   *
   * @observable
   * @member {Boolean} ui.button.ButtonView#isEnabled
   */

		/**
   * (Optional) Whether the label of the button is hidden (e.g. button with icon only).
   *
   * @observable
   * @member {Boolean} ui.button.ButtonView#withText
   */

		/**
   * (Optional) Title of the button displayed in the tooltip, i.e. when
   * hovering the button with the mouse cursor.
   *
   * @observable
   * @member {Boolean} ui.button.ButtonView#title
   */
		return _this;
	}

	return ButtonView;
}(View);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The bold feature. It introduces the Bold button and the <kbd>Ctrl+B</kbd> keystroke.
 *
 * It uses the {@link basic-styles.BoldEngine bold engine feature}.
 *
 * @memberOf basic-styles
 * @extends core.Feature
 */

var Bold = function (_Feature) {
	inherits(Bold, _Feature);

	function Bold() {
		classCallCheck(this, Bold);
		return possibleConstructorReturn(this, Object.getPrototypeOf(Bold).apply(this, arguments));
	}

	createClass(Bold, [{
		key: 'init',


		/**
   * @inheritDoc
   */
		value: function init() {
			var editor = this.editor;
			var t = editor.t;
			var command = editor.commands.get('bold');
			var keystroke = 'CTRL+B';

			// Create button model.
			var buttonModel = new Model({
				isEnabled: true,
				isOn: false,
				label: t('Bold'),
				icon: 'bold',
				keystroke: keystroke
			});

			// Bind button model to command.
			buttonModel.bind('isOn', 'isEnabled').to(command, 'value', 'isEnabled');

			// Execute command.
			this.listenTo(buttonModel, 'execute', function () {
				return editor.execute('bold');
			});

			// Add bold button to feature components.
			editor.ui.featureComponents.add('bold', Button, ButtonView, buttonModel);

			// Set the Ctrl+B keystroke.
			editor.keystrokes.set(keystroke, 'bold');
		}
	}], [{
		key: 'requires',

		/**
   * @inheritDoc
   */
		get: function get() {
			return [BoldEngine];
		}
	}]);
	return Bold;
}(Feature);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

var ITALIC = 'italic';

/**
 * The italic engine feature.
 *
 * It registers the `italic` command and introduces the `italic` attribute in the model which renders to the view
 * as an `<em>` element.
 *
 * @memberOf basic-styles
 * @extends core.Feature
 */

var ItalicEngine = function (_Feature) {
	inherits(ItalicEngine, _Feature);

	function ItalicEngine() {
		classCallCheck(this, ItalicEngine);
		return possibleConstructorReturn(this, Object.getPrototypeOf(ItalicEngine).apply(this, arguments));
	}

	createClass(ItalicEngine, [{
		key: 'init',

		/**
   * @inheritDoc
   */
		value: function init() {
			var editor = this.editor;
			var data = editor.data;
			var editing = editor.editing;

			// Allow italic attribute on all inline nodes.
			editor.document.schema.allow({ name: '$inline', attributes: [ITALIC] });

			// Build converter from model to view for data and editing pipelines.
			buildModelConverter().for(data.modelToView, editing.modelToView).fromAttribute(ITALIC).toElement('em');

			// Build converter from view to model for data pipeline.
			buildViewConverter().for(data.viewToModel).fromElement('em').fromElement('i').fromAttribute('style', { 'font-style': 'italic' }).toAttribute(ITALIC, true);

			// Create italic command.
			editor.commands.set(ITALIC, new ToggleAttributeCommand(editor, ITALIC));
		}
	}]);
	return ItalicEngine;
}(Feature);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The italic feature. It introduces the Italic button and the <kbd>Ctrl+I</kbd> keystroke.
 *
 * It uses the {@link basic-styles.ItalicEngine italic engine feature}.
 *
 * @memberOf basic-styles
 * @extends core.Feature
 */

var Italic = function (_Feature) {
	inherits(Italic, _Feature);

	function Italic() {
		classCallCheck(this, Italic);
		return possibleConstructorReturn(this, Object.getPrototypeOf(Italic).apply(this, arguments));
	}

	createClass(Italic, [{
		key: 'init',


		/**
   * @inheritDoc
   */
		value: function init() {
			var editor = this.editor;
			var t = editor.t;
			var command = editor.commands.get('italic');
			var keystroke = 'CTRL+I';

			// Create button model.
			var buttonModel = new Model({
				isEnabled: true,
				isOn: false,
				label: t('Italic'),
				icon: 'italic',
				keystroke: keystroke
			});

			// Bind button model to command.
			buttonModel.bind('isOn', 'isEnabled').to(command, 'value', 'isEnabled');

			// Execute command.
			this.listenTo(buttonModel, 'execute', function () {
				return editor.execute('italic');
			});

			// Add bold button to feature components.
			editor.ui.featureComponents.add('italic', Button, ButtonView, buttonModel);

			// Set the Ctrl+I keystroke.
			editor.keystrokes.set(keystroke, 'italic');
		}
	}], [{
		key: 'requires',

		/**
   * @inheritDoc
   */
		get: function get() {
			return [ItalicEngine];
		}
	}]);
	return Italic;
}(Feature);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Facade over the native [`DataTransfer`](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer) object.
 *
 * @memberOf clipboard
 */
var DataTransfer = function () {
	function DataTransfer(nativeDataTransfer) {
		classCallCheck(this, DataTransfer);

		/**
   * The native DataTransfer object.
   *
   * @private
   * @member {DataTransfer} clipboard.DataTransfer#_native
   */
		this._native = nativeDataTransfer;
	}

	/**
  * Gets data from the data transfer by its mime type.
  *
  *		dataTransfer.getData( 'text/plain' );
  *
  * @param {String} type The mime type. E.g. `text/html` or `text/plain`.
  * @returns {String}
  */


	createClass(DataTransfer, [{
		key: "getData",
		value: function getData(type) {
			return this._native.getData(type);
		}
	}]);
	return DataTransfer;
}();

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * {@link engine.view.Document#paste Paste} event observer.
 *
 * Note that this observer is not available by default. To make it available it needs to be added to {@link engine.view.Document}
 * by the {@link engine.view.Document#addObserver} method.
 *
 * @memberOf clipboard
 * @extends engine.view.observer.DomEventObserver
 */

var ClipboardObserver = function (_DomEventObserver) {
  inherits(ClipboardObserver, _DomEventObserver);

  function ClipboardObserver(doc) {
    classCallCheck(this, ClipboardObserver);

    var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ClipboardObserver).call(this, doc));

    _this.domEventType = 'paste';
    return _this;
  }

  createClass(ClipboardObserver, [{
    key: 'onDomEvent',
    value: function onDomEvent(domEvent) {
      this.fire(domEvent.type, domEvent, {
        dataTransfer: new DataTransfer(domEvent.clipboardData)
      });
    }
  }]);
  return ClipboardObserver;
}(DomEventObserver);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Converts plain text to its HTML-ized version.
 *
 * @function clipboard.utils.plainTextToHtml
 * @param {String} text The plain text to convert.
 * @returns {String} HTML generated from the plain text.
 */
function plainTextToHtml(text) {
	text = text
	// Encode <>.
	.replace(/</g, '&lt;').replace(/>/g, '&gt;')
	// Creates paragraphs for double line breaks and change single line breaks to spaces.
	// In the future single line breaks may be converted into <br>s.
	.replace(/\n\n/g, '</p><p>').replace(/\n/g, ' ')
	// Preserve trailing spaces (only the first and last one – the rest is handled below).
	.replace(/^\s/, '&nbsp;').replace(/\s$/, '&nbsp;')
	// Preserve other subsequent spaces now.
	.replace(/\s\s/g, ' &nbsp;');

	if (text.indexOf('</p><p>') > -1) {
		// If we created paragraphs above, add the trailing ones.
		text = '<p>' + text + '</p>';
	}

	// TODO:
	// * What about '\nfoo' vs ' foo'?

	return text;
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Removes some popular browser quirks out of the clipboard data (HTML).
 *
 * @function clipboard.utils.normalizeClipboardData
 * @param {String} data The HTML data to normalize.
 * @returns {String} Normalized HTML.
 */
function normalizeClipboardData(data) {
  return data.replace(/<span class="Apple-converted-space">(\s+)<\/span>/g, function (fullMatch, spaces) {
    // Handle the most popular and problematic case when even a single space becomes an nbsp;.
    // Decode those to normal spaces. Read more in https://github.com/ckeditor/ckeditor5-clipboard/issues/2.
    if (spaces.length == 1) {
      return ' ';
    }

    return spaces;
  });
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The clipboard feature. Currently, it's only responsible for intercepting the `paste` event and
 * passing the pasted content through the clipboard pipeline.
 *
 * ## Clipboard Pipeline
 *
 * The feature creates the clipboard pipeline which allows for processing clipboard content
 * before it gets inserted into the editor. The pipeline consists of two events on which
 * the features can listen in order to modify or totally override the default behavior.
 *
 * ### On {@link engine.view.Document#paste}
 *
 * The default action is to:
 *
 * 1. get HTML or plain text from the clipboard,
 * 2. fire {@link engine.view.Document#clipboardInput} with the clipboard data parsed to
 * a {@link engine.view.DocumentFragment view document fragment},
 * 3. prevent the default action of the native `paste` event.
 *
 * This action is performed by a low priority listener, so it can be overridden by a normal one.
 * You'd only need to do this when a deeper change in pasting behavior was needed. For example,
 * a feature which wants to differently read data from the clipboard (the {@link clipboard.DataTransfer `DataTransfer`}).
 * should plug a listener at this stage.
 *
 * ### On {@link engine.view.Document#clipboardInput}
 *
 * The default action is to insert the content (`data.content`, represented by a {@link engine.view.DocumentFragment})
 * to an editor if the data is not empty.
 *
 * This action is performed by a low priority listener, so it can be overridden by a normal one.
 *
 * At this stage the pasted content can be processed by the features. E.g. a feature which wants to transform
 * a pasted text into a link can be implemented in this way:
 *
 *		this.listenTo( editor.editing.view, 'clipboardInput', ( evt, data ) => {
 *			if ( data.content.childCount == 1 && isUrlText( data.content.getChild( 0 ) ) ) {
 *				const linkUrl = data.content.getChild( 0 ).data;
 *
 *				data.content = new ViewDocumentFragment( [
 *					ViewElement(
 *						'a',
 *						{ href: linkUrl },
 *						[ new ViewText( linkUrl ) ]
 *					)
 *				] );
 *			}
 *		} );
 *
 * @memberOf clipboard
 * @extends core.Feature
 */

var Clipboard = function (_Feature) {
  inherits(Clipboard, _Feature);

  function Clipboard() {
    classCallCheck(this, Clipboard);
    return possibleConstructorReturn(this, Object.getPrototypeOf(Clipboard).apply(this, arguments));
  }

  createClass(Clipboard, [{
    key: 'init',

    /**
     * @inheritDoc
     */
    value: function init() {
      var _this2 = this;

      var editor = this.editor;
      var editingView = editor.editing.view;

      /**
       * Data processor used to convert pasted HTML to a view structure.
       *
       * @private
       * @member {engine.dataProcessor.HtmlDataProcessor} clipboard.Clipboard#_htmlDataProcessor
       */
      this._htmlDataProcessor = new HtmlDataProcessor();

      editingView.addObserver(ClipboardObserver);

      // The clipboard pipeline.

      this.listenTo(editingView, 'paste', function (evt, data) {
        var dataTransfer = data.dataTransfer;
        var content = '';

        if (dataTransfer.getData('text/html')) {
          content = normalizeClipboardData(dataTransfer.getData('text/html'));
        } else if (dataTransfer.getData('text/plain')) {
          content = plainTextToHtml(dataTransfer.getData('text/plain'));
        }

        content = _this2._htmlDataProcessor.toView(content);

        data.preventDefault();

        editingView.fire('clipboardInput', { dataTransfer: dataTransfer, content: content });
      }, { priority: 'low' });

      this.listenTo(editingView, 'clipboardInput', function (evt, data) {
        if (!data.content.isEmpty) {
          (function () {
            var doc = editor.document;

            doc.enqueueChanges(function () {
              _this2.editor.data.insert(data.content, doc.selection);
            });
          })();
        }
      }, { priority: 'low' });
    }
  }]);
  return Clipboard;
}(Feature);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Enter command. It is used by the {@link enter.Enter Enter feature} to handle the <kbd>Enter</kbd> key.
 *
 * @member enter
 * @extends core.command.Command
 */

var EnterCommand = function (_Command) {
	inherits(EnterCommand, _Command);

	function EnterCommand() {
		classCallCheck(this, EnterCommand);
		return possibleConstructorReturn(this, Object.getPrototypeOf(EnterCommand).apply(this, arguments));
	}

	createClass(EnterCommand, [{
		key: '_doExecute',

		/**
   * @inheritDoc
   */
		value: function _doExecute() {
			var _this2 = this;

			var doc = this.editor.document;
			var batch = doc.batch();

			doc.enqueueChanges(function () {
				enterBlock(batch, doc.selection);

				_this2.fire('afterExecute', { batch: batch });
			});
		}
	}]);
	return EnterCommand;
}(Command);

function enterBlock(batch, selection) {
	var doc = batch.document;
	var isSelectionEmpty = selection.isCollapsed;
	var range = selection.getFirstRange();
	var startElement = range.start.parent;
	var endElement = range.end.parent;

	// Don't touch the root.
	if (startElement.root == startElement) {
		if (!isSelectionEmpty) {
			doc.composer.deleteContents(batch, selection);
		}

		return;
	}

	if (isSelectionEmpty) {
		splitBlock(batch, selection, range.start);
	} else {
		var shouldMerge = range.start.isAtStart && range.end.isAtEnd;
		var isContainedWithinOneElement = startElement == endElement;

		doc.composer.deleteContents(batch, selection, { merge: shouldMerge });

		if (!shouldMerge) {
			// Partially selected elements.
			//
			// <h>x[xx]x</h>		-> <h>x^x</h>			-> <h>x</h><h>^x</h>
			if (isContainedWithinOneElement) {
				splitBlock(batch, selection, selection.focus);
			}
			// Selection over multiple elements.
			//
			// <h>x[x</h><p>y]y<p>	-> <h>x^</h><p>y</p>	-> <h>x</h><p>^y</p>
			else {
					selection.collapse(endElement);
				}
		}
	}
}

function splitBlock(batch, selection, splitPos) {
	batch.split(splitPos);
	selection.collapse(splitPos.parent.nextSibling);
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Enter observer introduces the {@link engine.view.Document#enter} event.
 *
 * @memberOf enter
 * @extends engine.view.observer.Observer
 */

var EnterObserver = function (_Observer) {
  inherits(EnterObserver, _Observer);

  function EnterObserver(document) {
    classCallCheck(this, EnterObserver);

    var _this = possibleConstructorReturn(this, Object.getPrototypeOf(EnterObserver).call(this, document));

    document.on('keydown', function (evt, data) {
      if (_this.isEnabled && data.keyCode == keyCodes.enter) {
        document.fire('enter', new DomEventData(document, data.domEvent));
      }
    });
    return _this;
  }

  /**
   * @inheritDoc
   */


  createClass(EnterObserver, [{
    key: 'observe',
    value: function observe() {}
  }]);
  return EnterObserver;
}(Observer);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The Enter feature. Handles the <kbd>Enter</kbd> and <kbd>Shift + Enter</kbd> keys in the editor.
 *
 * @memberOf enter
 * @extends core.Feature
 */

var Enter = function (_Feature) {
	inherits(Enter, _Feature);

	function Enter() {
		classCallCheck(this, Enter);
		return possibleConstructorReturn(this, Object.getPrototypeOf(Enter).apply(this, arguments));
	}

	createClass(Enter, [{
		key: 'init',
		value: function init() {
			var editor = this.editor;
			var editingView = editor.editing.view;

			editingView.addObserver(EnterObserver);

			editor.commands.set('enter', new EnterCommand(editor));

			// TODO We may use the keystroke handler for that.
			this.listenTo(editingView, 'enter', function (evt, data) {
				editor.execute('enter');
				data.preventDefault();
			}, { priority: 'low' });
		}
	}]);
	return Enter;
}(Feature);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The paragraph feature for the editor.
 * Introduces the `<paragraph>` element in the model which renders as a `<p>` element in the DOM and data.
 *
 * @memberOf paragraph
 * @extends core.Feature
 */

var Paragraph = function (_Feature) {
	inherits(Paragraph, _Feature);

	function Paragraph() {
		classCallCheck(this, Paragraph);
		return possibleConstructorReturn(this, Object.getPrototypeOf(Paragraph).apply(this, arguments));
	}

	createClass(Paragraph, [{
		key: 'init',

		/**
   * @inheritDoc
   */
		value: function init() {
			var editor = this.editor;
			var data = editor.data;
			var editing = editor.editing;

			// Schema.
			editor.document.schema.registerItem('paragraph', '$block');

			// Build converter from model to view for data and editing pipelines.
			buildModelConverter().for(data.modelToView, editing.modelToView).fromElement('paragraph').toElement('p');

			// Build converter from view to model for data pipeline.
			buildViewConverter().for(data.viewToModel).fromElement('p').toElement('paragraph');
		}
	}]);
	return Paragraph;
}(Feature);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The heading command. It is used by the {@link heading.Heading heading feature} to apply headings.
 *
 * @memberOf heading
 * @extends core.command.Command
 */

var HeadingCommand = function (_Command) {
	inherits(HeadingCommand, _Command);

	/**
  * Creates an instance of the command.
  *
  * @param {core.editor.Editor} editor Editor instance.
  * @param {Array.<heading.HeadingFormat>} formats Heading formats to be used by the command instance.
  */
	function HeadingCommand(editor, formats) {
		classCallCheck(this, HeadingCommand);

		/**
   * Heading formats used by this command.
   *
   * @readonly
   * @member {heading.HeadingFormat} heading.HeadingCommand#formats
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(HeadingCommand).call(this, editor));

		_this.formats = formats;

		/**
   * The currently selected heading format.
   *
   * @readonly
   * @observable
   * @member {heading.HeadingFormat} heading.HeadingCommand#value
   */
		_this.set('value', _this.defaultFormat);

		// Listen on selection change and set current command's format to format in the current selection.
		_this.listenTo(editor.document.selection, 'change', function () {
			var position = editor.document.selection.getFirstPosition();
			var block = findTopmostBlock(position);

			if (block) {
				var format = _this._getFormatById(block.name);

				// TODO: What should happen if format is not found?
				_this.value = format;
			}
		});
		return _this;
	}

	/**
  * The default format.
  *
  * @type {heading.HeadingFormat}
  */


	createClass(HeadingCommand, [{
		key: '_doExecute',


		/**
   * Executes command.
   *
   * @protected
   * @param {Object} [options] Options for executed command.
   * @param {String} [options.formatId] The identifier of the heading format that should be applied. It should be one of the
   * {@link heading.HeadingFormat heading formats} provided to the command constructor. If this parameter is not provided,
   * the value from {@link heading.HeadingCommand#defaultFormat defaultFormat} will be used.
   * @param {engine.model.Batch} [options.batch] Batch to collect all the change steps.
   * New batch will be created if this option is not set.
   */
		value: function _doExecute() {
			var _this2 = this;

			var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

			// TODO: What should happen if format is not found?
			var formatId = options.formatId || this.defaultFormat.id;
			var doc = this.editor.document;
			var selection = doc.selection;
			var startPosition = selection.getFirstPosition();
			var elements = [];
			// Storing selection ranges and direction to fix selection after renaming. See ckeditor5-engine#367.
			var ranges = [].concat(toConsumableArray(selection.getRanges()));
			var isSelectionBackward = selection.isBackward;
			// If current format is same as new format - toggle already applied format back to default one.
			var shouldRemove = formatId === this.value.id;

			// Collect elements to change format.
			// This implementation may not be future proof but it's satisfactory at this stage.
			if (selection.isCollapsed) {
				var block = findTopmostBlock(startPosition);

				if (block) {
					elements.push(block);
				}
			} else {
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var range = _step.value;

						var startBlock = findTopmostBlock(range.start);
						var endBlock = findTopmostBlock(range.end, false);

						elements.push(startBlock);

						while (startBlock !== endBlock) {
							startBlock = startBlock.nextSibling;
							elements.push(startBlock);
						}
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
			}

			doc.enqueueChanges(function () {
				var batch = options.batch || doc.batch();

				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;

				try {
					for (var _iterator2 = elements[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var element = _step2.value;

						// When removing applied format.
						if (shouldRemove) {
							if (element.name === formatId) {
								batch.rename(element, _this2.defaultFormat.id);
							}
						}
						// When applying new format.
						else {
								batch.rename(element, formatId);
							}
					}

					// If range's selection start/end is placed directly in renamed block - we need to restore it's position
					// after renaming, because renaming puts new element there.
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2.return) {
							_iterator2.return();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}

				doc.selection.setRanges(ranges, isSelectionBackward);
			});
		}

		/**
   * Returns the format by a given ID.
   *
   * @private
   * @param {String} id
   * @returns {heading.HeadingFormat}
   */

	}, {
		key: '_getFormatById',
		value: function _getFormatById(id) {
			return this.formats.find(function (item) {
				return item.id === id;
			}) || this.defaultFormat;
		}
	}, {
		key: 'defaultFormat',
		get: function get() {
			// See https://github.com/ckeditor/ckeditor5/issues/98.
			return this._getFormatById('paragraph');
		}
	}]);
	return HeadingCommand;
}(Command);

function findTopmostBlock(position) {
	var nodeAfter = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	var parent = position.parent;

	// If position is placed inside root - get element after/before it.
	if (parent instanceof RootElement) {
		return nodeAfter ? position.nodeAfter : position.nodeBefore;
	}

	while (!(parent.parent instanceof RootElement)) {
		parent = parent.parent;
	}

	return parent;
}

/**
 * Heading format descriptor.
 *
 * @typedef {Object} heading.HeadingFormat
 * @property {String} id Format identifier. It will be used as the element's name in the model.
 * @property {String} viewElement The name of the view element that will be used to represent the model element in the view.
 * @property {String} label The display name of the format.
 */

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

var formats = [{ id: 'paragraph', viewElement: 'p', label: 'Paragraph' }, { id: 'heading1', viewElement: 'h2', label: 'Heading 1' }, { id: 'heading2', viewElement: 'h3', label: 'Heading 2' }, { id: 'heading3', viewElement: 'h4', label: 'Heading 3' }];

/**
 * The headings engine feature. It handles switching between block formats &ndash; headings and paragraph.
 * This class represents the engine part of the heading feature. See also {@link heading.Heading}.
 *
 * @memberOf heading
 * @extends core.Feature
 */

var HeadingEngine = function (_Feature) {
	inherits(HeadingEngine, _Feature);

	function HeadingEngine() {
		classCallCheck(this, HeadingEngine);
		return possibleConstructorReturn(this, Object.getPrototypeOf(HeadingEngine).apply(this, arguments));
	}

	createClass(HeadingEngine, [{
		key: 'init',


		/**
   * @inheritDoc
   */
		value: function init() {
			var editor = this.editor;
			var data = editor.data;
			var editing = editor.editing;

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = formats[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var format = _step.value;

					// Skip paragraph - it is defined in required Paragraph feature.
					if (format.id !== 'paragraph') {
						// Schema.
						editor.document.schema.registerItem(format.id, '$block');

						// Build converter from model to view for data and editing pipelines.
						buildModelConverter().for(data.modelToView, editing.modelToView).fromElement(format.id).toElement(format.viewElement);

						// Build converter from view to model for data pipeline.
						buildViewConverter().for(data.viewToModel).fromElement(format.viewElement).toElement(format.id);
					}
				}

				// Register the heading command.
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			var command = new HeadingCommand(editor, formats);
			editor.commands.set('heading', command);

			// If the enter command is added to the editor, alter its behavior.
			// Enter at the end of a heading element should create a paragraph.
			var enterCommand = editor.commands.get('enter');

			if (enterCommand) {
				this.listenTo(enterCommand, 'afterExecute', function (evt, data) {
					var positionParent = editor.document.selection.getFirstPosition().parent;
					var batch = data.batch;
					var isHeading = formats.some(function (format) {
						return format.id == positionParent.name;
					});

					if (isHeading && positionParent.name != command.defaultFormat.id && positionParent.childCount === 0) {
						batch.rename(positionParent, command.defaultFormat.id);
					}
				});
			}
		}
	}], [{
		key: 'requires',

		/**
   * @inheritDoc
   */
		get: function get() {
			return [Paragraph];
		}
	}]);
	return HeadingEngine;
}(Feature);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The dropdown button view class.
 *
 * See {@link ui.dropdown.Dropdown}, {@link ui.button.Button}, {@link ui.button.ButtonView}.
 *
 * @memberOf ui.dropdown
 * @extends ui.button.ButtonView
 */

var DropdownButtonView = function (_ButtonView) {
	inherits(DropdownButtonView, _ButtonView);

	/**
  * @inheritDoc
  */
	function DropdownButtonView() {
		classCallCheck(this, DropdownButtonView);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(DropdownButtonView).call(this));

		Template.extend(_this.template, {
			attributes: {
				class: 'ck-dropdown__button'
			}
		});
		return _this;
	}

	return DropdownButtonView;
}(ButtonView);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The dropdown panel controller class.
 *
 *		const model = new Model( {
 *			isVisible: false,
 *		} );
 *
 *		// An instance of DropdownPanelView.
 *		new DropdownPanel( model, new DropdownPanelView() );
 *
 * See {@link ui.dropdown.DropdownPanelView}.
 *
 * @memberOf ui.dropdown
 * @extends ui.Controller
 */

var DropdownPanel = function (_Controller) {
  inherits(DropdownPanel, _Controller);

  /**
   * Creates an instance of {@link ui.dropdown.DropdownPanel} class.
   *
   * @param {ui.dropdown.DropdownPanel} model Model of this dropdown panel.
   * @param {ui.View} view View of this dropdown panel.
   */
  function DropdownPanel(model, view) {
    classCallCheck(this, DropdownPanel);

    var _this = possibleConstructorReturn(this, Object.getPrototypeOf(DropdownPanel).call(this, model, view));

    view.bind('isVisible').to(model);

    _this.addCollection('content');
    return _this;
  }

  return DropdownPanel;
}(Controller);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The dropdown panel view class.
 *
 * See {@link ui.dropdown.DropdownPanel}.
 *
 * @memberOf ui.dropdown
 * @extends ui.View
 */

var DropdownPanelView = function (_View) {
	inherits(DropdownPanelView, _View);

	/**
  * @inheritDoc
  */
	function DropdownPanelView() {
		classCallCheck(this, DropdownPanelView);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(DropdownPanelView).call(this));

		var bind = _this.bindTemplate;

		_this.template = new Template({
			tag: 'div',

			attributes: {
				class: ['ck-reset', 'ck-dropdown__panel', bind.if('isVisible', 'ck-dropdown__panel-visible')]
			}
		});

		_this.register('content', function (el) {
			return el;
		});

		/**
   * Controls whether the panel is visible.
   *
   * @observable
   * @member {Boolean} ui.dropdown.DropdownPanelView#isVisible
   */
		return _this;
	}

	return DropdownPanelView;
}(View);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The dropdown controller class.
 *
 *		const model = new Model( {
 *			label: 'Dropdown',
 *			isEnabled: true,
 *			inOn: false
 *		} );
 *
 *		// An instance of Dropdown.
 *		new Dropdown( model, new DropdownView() );
 *
 * See {@link ui.dropdown.DropdownView}.
 *
 * @memberOf ui.dropdown
 * @extends ui.Controller
 */

var Dropdown = function (_Controller) {
	inherits(Dropdown, _Controller);

	/**
  * Creates an instance of {@link ui.dropdown.Dropdown} class.
  *
  * @param {ui.dropdown.DropdownModel} model Model of this dropdown.
  * @param {ui.View} view View of this dropdown.
  */
	function Dropdown(model, view) {
		classCallCheck(this, Dropdown);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(Dropdown).call(this, model, view));

		_this.addCollection('main');
		_this._createButton();
		_this._createPanel();
		return _this;
	}

	/**
  * Creates {@link ui.dropdown.Dropdown#button} of this dropdown.
  *
  * @protected
  */


	createClass(Dropdown, [{
		key: '_createButton',
		value: function _createButton() {
			var model = this.model;
			var view = this.view;
			var buttonModel = new Model();

			// Button needs a separate Model because otherwise it would fire #execute event
			// on the model shared between multiple dropdowns (they would all open at the same time).
			buttonModel.bind('label', 'isOn', 'isEnabled', 'withText').to(model);

			/**
    * Button of this dropdown.
    *
    * @readonly
    * @member {ui.button.Button} ui.dropdown.Dropdown#button
    */
			this.add('main', this.button = new Button(buttonModel, new DropdownButtonView()));

			// When ui.dropdown.Dropdown#button is clicked switch the open/closed state of the Dropdown.
			this.listenTo(buttonModel, 'execute', function () {
				return view.isOpen = !view.isOpen;
			});
		}

		/**
   * Creates {@link ui.dropdown.Dropdown#panel} of this dropdown.
   *
   * @protected
   */

	}, {
		key: '_createPanel',
		value: function _createPanel() {
			var panelModel = new Model();

			panelModel.bind('isVisible').to(this.view, 'isOpen');

			/**
    * Panel of this dropdown.
    *
    * @readonly
    * @member {ui.dropdown.DropdownPanel} ui.dropdown.Dropdown#panel
    */
			this.add('main', this.panel = new DropdownPanel(panelModel, new DropdownPanelView()));
		}
	}]);
	return Dropdown;
}(Controller);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The list item controller class.
 *
 * @memberOf ui.list
 * @extends ui.Controller
 */

var ListItem = function (_Controller) {
  inherits(ListItem, _Controller);

  /**
   * Creates an instance of {@link ui.list.ListItem} class.
   *
   * @param {ui.list.ListItemModel} model Model of this list item.
   * @param {ui.View} view View of this list item.
   */
  function ListItem(model, view) {
    classCallCheck(this, ListItem);

    var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ListItem).call(this, model, view));

    view.bind('label').to(model);

    if (model.style) {
      view.bind('style').to(model);
    }

    // TODO: Event delegation with altered event name.
    view.on('click', function () {
      return model.fire('execute');
    });
    return _this;
  }

  return ListItem;
}(Controller);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The list item view class.
 *
 * See {@link ui.list.ListItem}.
 *
 * @memberOf ui.list
 * @extends ui.View
 */

var ListItemView = function (_View) {
	inherits(ListItemView, _View);

	/**
  * @inheritDoc
  */
	function ListItemView() {
		classCallCheck(this, ListItemView);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ListItemView).call(this));

		var bind = _this.bindTemplate;

		_this.template = new Template({
			tag: 'li',

			attributes: {
				class: ['ck-list__item'],
				style: bind.to('style')
			},

			children: [{
				text: bind.to('label')
			}],

			on: {
				click: bind.to('click')
			}
		});

		/**
   * The label of the list item.
   *
   * @observable
   * @member {String} ui.list.ListItemView#label
   */

		/**
   * (Optional) The DOM style attribute of the list item.
   *
   * @observable
   * @member {String} ui.list.ListItemView#style
   */

		/**
   * Fired when the list item has been clicked.
   *
   * @event ui.list.ListItemView#click
   */
		return _this;
	}

	return ListItemView;
}(View);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The list controller class.
 *
 *		const itemsCollection = new Collection();
 *
 *		itemsCollection.add( new Model( { label: 'foo' } ) );
 *		itemsCollection.add( new Model( { label: 'bar' } ) );
 *
 *		const model = new Model( {
 *			items: itemsCollection
 *		} );
 *
 *		// An instance of List filled up with the `itemsCollection`.
 *		// Any change to `itemsCollection` will be reflected in DOM.
 *		new List( model, new ListView() );
 *
 * See {@link ui.list.ListView}, {@link ui.list.ListItem}.
 *
 * @memberOf ui.list
 * @extends ui.Controller
 */

var List = function (_Controller) {
  inherits(List, _Controller);

  /**
   * Creates an instance of {@link ui.list.List} class.
   *
   * @param {ui.list.ListModel} model Model of this list.
   * @param {ui.View} view View of this list.
   */
  function List(model, view) {
    classCallCheck(this, List);

    var _this = possibleConstructorReturn(this, Object.getPrototypeOf(List).call(this, model, view));

    var list = _this.addCollection('list');

    list.bind(model.items).as(ListItem, ListItemView);
    list.delegate('execute').to(model);
    return _this;
  }

  return List;
}(Controller);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The list view class.
 *
 * See {@link ui.list.List}.
 *
 * @memberOf ui.list
 * @extends ui.View
 */

var ListView = function (_View) {
	inherits(ListView, _View);

	/**
  * @inheritDoc
  */
	function ListView() {
		classCallCheck(this, ListView);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ListView).call(this));

		_this.template = new Template({
			tag: 'ul',

			attributes: {
				class: ['ck-reset', 'ck-list']
			}
		});

		_this.register('list', function (el) {
			return el;
		});
		return _this;
	}

	return ListView;
}(View);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The list dropdown controller class. It represents a dropdown
 * with a {@link ui.list.List} component.
 *
 *		const model = new Model( {
 *			label: 'List Dropdown',
 *			isEnabled: true,
 *			isOn: false,
 *			content: {@link ui.dropdown.list.ListDropdownModel#content}
 *		} );
 *
 *		// An instance of Dropdown.
 *		new ListDropdown( model, new ListDropdownView() );
 *
 * See {@link ui.dropdown.list.ListDropdownView}.
 *
 * @memberOf ui.dropdown.list
 * @extends ui.dropdown.Dropdown
 */

var ListDropdown = function (_Dropdown) {
  inherits(ListDropdown, _Dropdown);

  /**
   * Creates an instance of {@link ui.dropdown.list.ListDropdown} class.
   *
   * @param {ui.dropdown.list.ListDropdownModel} model Model of this list dropdown.
   * @param {ui.View} view View of this list dropdown.
   */
  function ListDropdown(model, view) {
    classCallCheck(this, ListDropdown);

    /**
     * List of this list dropdown.
     *
     * @readonly
     * @member {ui.list.List} ui.dropdown.list.ListDropdown#list
     */
    var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ListDropdown).call(this, model, view));

    _this.list = new List(_this.model.content, new ListView());

    // Delegate ui.list.ListModel#execute to the model.
    _this.model.content.delegate('execute').to(model);

    // Collapse the dropdown when an item in the panel is clicked.
    _this.listenTo(model, 'execute', function () {
      view.isOpen = false;
    });

    _this.panel.add('content', _this.list);
    return _this;
  }

  return ListDropdown;
}(Dropdown);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The dropdown view class.
 *
 * See {@link ui.dropdown.Dropdown}.
 *
 * @memberOf ui.dropdown
 * @extends ui.View
 */

var DropdownView = function (_View) {
	inherits(DropdownView, _View);

	/**
  * @inheritDoc
  */
	function DropdownView() {
		classCallCheck(this, DropdownView);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(DropdownView).call(this));

		_this.set('isOpen', false);

		_this.template = new Template({
			tag: 'div',

			attributes: {
				class: ['ck-dropdown']
			}
		});

		_this.register('main', function (el) {
			return el;
		});

		/**
   * Controls whether the dropdown view is open, which also means its
   * {@link ui.dropdown.Dropdown#panel} is visible.
   *
   * @observable
   * @member {Boolean} ui.dropdown.DropdownViewl#isOpen
   */
		return _this;
	}

	return DropdownView;
}(View);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* globals document */

/**
 * The list dropdown view class.
 *
 * See {@link ui.dropdown.list.ListDropdown}.
 *
 * @memberOf ui.dropdown.list
 * @extends ui.dropdown.DropdownView
 */

var ListDropdownView = function (_DropdownView) {
	inherits(ListDropdownView, _DropdownView);

	/**
  * @inheritDoc
  */
	function ListDropdownView() {
		classCallCheck(this, ListDropdownView);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ListDropdownView).call(this));

		_this.listenTo(_this, 'change:isOpen', function (evt, name, value) {
			if (value) {
				// TODO: It will probably be focus/blur-based rather than click. It should be bound
				// to focusmanager of some sort.
				_this.listenTo(document, 'click', function (evtInfo, _ref) {
					var domEvtTarget = _ref.target;

					// Collapse the dropdown when the webpage outside of the component is clicked.
					if (_this.element != domEvtTarget && !_this.element.contains(domEvtTarget)) {
						_this.isOpen = false;
					}
				});
			} else {
				_this.stopListening(document);
			}
		});
		return _this;
	}

	return ListDropdownView;
}(DropdownView);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The headings feature. It introduces the `headings` drop-down list and the `heading` command which allow
 * to convert paragraphs into headings.
 *
 * @memberOf heading
 * @extends core.Feature
 */

var Heading = function (_Feature) {
	inherits(Heading, _Feature);

	function Heading() {
		classCallCheck(this, Heading);
		return possibleConstructorReturn(this, Object.getPrototypeOf(Heading).apply(this, arguments));
	}

	createClass(Heading, [{
		key: 'init',


		/**
   * @inheritDoc
   */
		value: function init() {
			var editor = this.editor;
			var command = editor.commands.get('heading');
			var formats = command.formats;
			var collection = new Collection();

			// Add formats to collection.
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = formats[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var format = _step.value;

					collection.add(new Model({
						id: format.id,
						label: format.label
					}));
				}

				// Create dropdown model.
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			var dropdownModel = new Model({
				isEnabled: true,
				isOn: false,
				label: 'Heading',
				withText: true,

				// Create item list model.
				content: new Model({
					items: collection
				})
			});

			// Bind dropdown model to command.
			dropdownModel.bind('isEnabled').to(command, 'isEnabled');
			dropdownModel.bind('label').to(command, 'value', function (format) {
				return format.label;
			});

			// Execute command when an item from the dropdown is selected.
			this.listenTo(dropdownModel, 'execute', function (evt) {
				editor.execute('heading', { formatId: evt.source.id });
				editor.editing.view.focus();
			});

			// Register UI component.
			editor.ui.featureComponents.add('headings', ListDropdown, ListDropdownView, dropdownModel);
		}
	}], [{
		key: 'requires',

		/**
   * @inheritDoc
   */
		get: function get() {
			return [HeadingEngine];
		}
	}]);
	return Heading;
}(Feature);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * {@link engine.view.Document#click Click} event observer.
 *
 * Note that this observer is not available by default. To make it available it needs to be added to {@link engine.view.Document}
 * by a {@link engine.view.Document#addObserver} method.
 *
 * @memberOf engine.view.observer
 * @extends engine.view.observer.DomEventObserver
 */

var ClickObserver = function (_DomEventObserver) {
  inherits(ClickObserver, _DomEventObserver);

  function ClickObserver(document) {
    classCallCheck(this, ClickObserver);

    var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ClickObserver).call(this, document));

    _this.domEventType = 'click';
    return _this;
  }

  createClass(ClickObserver, [{
    key: 'onDomEvent',
    value: function onDomEvent(domEvent) {
      this.fire(domEvent.type, domEvent);
    }
  }]);
  return ClickObserver;
}(DomEventObserver);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * This class is to mark specific {@link engine.view.Node} as {@link link.LinkElement}.
 * E.g. There could be a situation when different features will create nodes with the same names,
 * and hence they must be identified somehow.
 *
 * @memberOf link
 * @extends engine.view.AttributeElement
 */

var LinkElement = function (_AttributeElement) {
  inherits(LinkElement, _AttributeElement);

  function LinkElement() {
    classCallCheck(this, LinkElement);
    return possibleConstructorReturn(this, Object.getPrototypeOf(LinkElement).apply(this, arguments));
  }

  return LinkElement;
}(AttributeElement);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Walk backward and forward from start position, node by node as long as they have the same `linkHref` attribute value and return
 * {@link engine.model.Range Range} with found link.
 *
 * @param {engine.model.Position} position Start position.
 * @param {String} value `linkHref` attribute value.
 * @returns {engine.model.Range} Link range.
 */
function findLinkRange(position, value) {
  return new Range$1(_findBound(position, value, true), _findBound(position, value, false));
}

// Walk forward or backward (depends on `lookBack` flag), node by node as long as they have the same `linkHref` attribute value
// and return position just before or after (depends on `lookBack` flag) last matched node.
//
// @param {engine.model.Position} position Start position.
// @param {String} value `linkHref` attribute value.
// @param {Boolean} lookBack Whether walk direction is forward `false` or backward `true`.
// @returns {engine.model.Position} Position just before last matched node.
function _findBound(position, value, lookBack) {
  // Get node before or after position (depends on `lookBack` flag).
  // When position is inside text node then start searching from text node.
  var node = position.textNode || (lookBack ? position.nodeBefore : position.nodeAfter);

  var lastNode = null;

  while (node && node.getAttribute('linkHref') == value) {
    lastNode = node;
    node = lookBack ? node.previousSibling : node.nextSibling;
  }

  return lastNode ? Position.createAt(lastNode, lookBack ? 'before' : 'after') : position;
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The link command. It is used by the {@link Link.Link link feature}.
 *
 * @memberOf link
 * @extends core.command.Command
 */

var LinkCommand = function (_Command) {
	inherits(LinkCommand, _Command);

	/**
  * @see core.command.Command
  * @param {core.editor.Editor} editor
  */
	function LinkCommand(editor) {
		classCallCheck(this, LinkCommand);

		/**
   * Currently selected `linkHref` attribute value.
   *
   * @observable
   * @member {Boolean} core.command.ToggleAttributeCommand#value
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(LinkCommand).call(this, editor));

		_this.set('value', undefined);

		_this.listenTo(_this.editor.document.selection, 'change:attribute', function () {
			_this.value = _this.editor.document.selection.getAttribute('linkHref');
		});
		return _this;
	}

	/**
  * Checks if {@link engine.model.Document#schema} allows to create attribute in {@link engine.model.Document#selection}
  *
  * @protected
  * @returns {Boolean}
  */


	createClass(LinkCommand, [{
		key: '_checkEnabled',
		value: function _checkEnabled() {
			var document = this.editor.document;

			return isAttributeAllowedInSelection('linkHref', document.selection, document.schema);
		}

		/**
   * Executes the command.
   *
   * When selection is non-collapsed, then `linkHref` attribute will be applied to nodes inside selection, but only to
   * those nodes where `linkHref` attribute is allowed (disallowed nodes will be omitted).
   *
   * When selection is collapsed and is not inside text with `linkHref` attribute, then new {@link engine.model.Text Text node} with
   * `linkHref` attribute will be inserted in place of caret, but only if such an element is allowed in this place. `_data` of
   * the inserted text will equal `href` parameter. Selection will be updated to wrap just inserted text node.
   *
   * When selection is collapsed and inside text with `linkHref` attribute, the attribute value will be updated.
   *
   * @protected
   * @param {String} href Link destination.
   */

	}, {
		key: '_doExecute',
		value: function _doExecute(href) {
			var document = this.editor.document;
			var selection = document.selection;

			document.enqueueChanges(function () {
				// Keep it as one undo step.
				var batch = document.batch();

				// If selection is collapsed then update selected link or insert new one at the place of caret.
				if (selection.isCollapsed) {
					var position = selection.getFirstPosition();
					var parent = position.parent;

					// When selection is inside text with `linkHref` attribute.
					if (selection.hasAttribute('linkHref')) {
						// Then update `linkHref` value.
						var linkRange = findLinkRange(selection.getFirstPosition(), selection.getAttribute('linkHref'));

						batch.setAttribute(linkRange, 'linkHref', href);

						// Create new range wrapping changed link.
						selection.setRanges([linkRange]);
					}
					// If not then insert text node with `linkHref` attribute in place of caret.
					else if (document.schema.check({ name: '$text', attributes: 'linkHref', inside: parent.name })) {
							var node = new Text$1(href, { linkHref: href });

							batch.insert(position, node);

							// Create new range wrapping created node.
							selection.setRanges([Range$1.createOn(node)]);
						}
				} else {
					// If selection has non-collapsed ranges, we change attribute on nodes inside those ranges
					// omitting nodes where `linkHref` attribute is disallowed.
					var ranges = getSchemaValidRanges('linkHref', selection.getRanges(), document.schema);

					var _iteratorNormalCompletion = true;
					var _didIteratorError = false;
					var _iteratorError = undefined;

					try {
						for (var _iterator = ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
							var range = _step.value;

							batch.setAttribute(range, 'linkHref', href);
						}
					} catch (err) {
						_didIteratorError = true;
						_iteratorError = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion && _iterator.return) {
								_iterator.return();
							}
						} finally {
							if (_didIteratorError) {
								throw _iteratorError;
							}
						}
					}
				}
			});
		}
	}]);
	return LinkCommand;
}(Command);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The unlink command. It is used by the {@link Link.Link link feature}.
 *
 * @memberOf link
 * @extends core.command.Command
 */

var UnlinkCommand = function (_Command) {
	inherits(UnlinkCommand, _Command);

	/**
  * @see core.command.Command
  * @param {core.editor.Editor} editor
  */
	function UnlinkCommand(editor) {
		classCallCheck(this, UnlinkCommand);

		// Checks when command should be enabled or disabled.
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(UnlinkCommand).call(this, editor));

		_this.listenTo(editor.document.selection, 'change:attribute', function () {
			return _this.refreshState();
		});
		return _this;
	}

	/**
  * Executes the command.
  *
  * When the selection is collapsed, removes `linkHref` attribute from each node with the same `linkHref` attribute value.
  * When the selection is non-collapsed, removes `linkHref` from each node in selected ranges.
  *
  * @protected
  */


	createClass(UnlinkCommand, [{
		key: '_doExecute',
		value: function _doExecute() {
			var document = this.editor.document;
			var selection = document.selection;

			document.enqueueChanges(function () {
				// Get ranges to unlink.
				var rangesToUnlink = selection.isCollapsed ? [findLinkRange(selection.getFirstPosition(), selection.getAttribute('linkHref'))] : selection.getRanges();

				// Keep it as one undo step.
				var batch = document.batch();

				// Remove `linkHref` attribute from specified ranges.
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = rangesToUnlink[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var range = _step.value;

						batch.removeAttribute(range, 'linkHref');
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
			});
		}

		/**
   * Checks if selection has `linkHref` attribute.
   *
   * @protected
   * @returns {Boolean}
   */

	}, {
		key: '_checkEnabled',
		value: function _checkEnabled() {
			return this.editor.document.selection.hasAttribute('linkHref');
		}
	}]);
	return UnlinkCommand;
}(Command);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The link engine feature.
 *
 * It introduces the `linkHref="url"` attribute in the model which renders to the view as a `<a href="url">` element.
 *
 * @memberOf link
 * @extends core.Feature
 */

var LinkEngine = function (_Feature) {
	inherits(LinkEngine, _Feature);

	function LinkEngine() {
		classCallCheck(this, LinkEngine);
		return possibleConstructorReturn(this, Object.getPrototypeOf(LinkEngine).apply(this, arguments));
	}

	createClass(LinkEngine, [{
		key: 'init',

		/**
   * @inheritDoc
   */
		value: function init() {
			var editor = this.editor;
			var data = editor.data;
			var editing = editor.editing;

			// Allow link attribute on all inline nodes.
			editor.document.schema.allow({ name: '$inline', attributes: 'linkHref' });

			// Build converter from model to view for data and editing pipelines.
			buildModelConverter().for(data.modelToView, editing.modelToView).fromAttribute('linkHref').toElement(function (linkHref) {
				return new LinkElement('a', { href: linkHref });
			});

			// Build converter from view to model for data pipeline.
			buildViewConverter().for(data.viewToModel).fromElement('a').toAttribute(function (viewElement) {
				return {
					key: 'linkHref',
					value: viewElement.getAttribute('href')
				};
			});

			// Create linking commands.
			editor.commands.set('link', new LinkCommand(editor));
			editor.commands.set('unlink', new UnlinkCommand(editor));
		}
	}]);
	return LinkEngine;
}(Feature);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* global document */

/**
 * Handles click outside of specified element and fires action.
 *
 * Note that it is not handled by a `click` event, this is to avoid situation when click on some trigger
 * opens and closes element at the same time.
 *
 * @param {Object} [options] Configuration options.
 * @param {ui.Controller} [options.controller] The controller to which this behavior should be added.
 * @param {utils.Observable} [options.model] Used together with `options.activeIf` to know when to listen for clicks.
 * @param {String} [options.activeIf] Used together with `options.model` to know when to listen for clicks.
 * @param {HTMLElement} [options.contextElement] Target element, click on it will not fire callback.
 * @param {Function} [options.callback] Function fired after clicking outside of specified element.
 */
function clickOutsideHandler(options) {
	var controller = options.controller;
	var clickHandler = function clickHandler(evt, domEvt) {
		return handleClickOutside(domEvt.target, options.contextElement, options.callback);
	};

	controller.listenTo(options.model, 'change:' + options.activeIf, function (evt, name, value) {
		if (value) {
			controller.listenTo(document, 'mouseup', clickHandler);
		} else {
			controller.stopListening(document, 'mouseup', clickHandler);
		}
	});

	// When `activeIf` property is `true` on init.
	if (options.model[options.activeIf]) {
		controller.listenTo(document, 'mouseup', clickHandler);
	}
}

// Fires callback when clicked element is outside of context element.
//
// @private
// @param {HTMLElement} clickedElement Clicked element.
// @param {HTMLElement} contextElement Click on this element will not fire callback.
// @param {Function} callback Action fired after clicking outside of context element.
function handleClickOutside(clickedElement, contextElement, callback) {
	if (!contextElement.contains(clickedElement)) {
		callback();
	}
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* global document */

/**
 * Handles <kbd>Esc</kbd> keydown and fires action.
 *
 * @param {Object} [options] Configuration options.
 * @param {ui.Controller} [options.controller] The controller to which this behavior should be added.
 * @param {utils.Observable} [options.model] Used together with `options.activeIf` to know when to listen for keydown.
 * @param {String} [options.activeIf] Used together with `options.model` to know when to listen for keydown.
 * @param {Function} [options.callback] Function fired after <kbd>Esc</kbd> is pressed.
 * @returns {Function} Click handler
 */
function escPressHandler(options) {
	var controller = options.controller;
	var keypressHandler = function keypressHandler(evt, domEvt) {
		return handleEscPress(domEvt.keyCode, options.callback);
	};

	controller.listenTo(options.model, 'change:' + options.activeIf, function (evt, name, value) {
		if (value) {
			controller.listenTo(document, 'keydown', keypressHandler);
		} else {
			controller.stopListening(document, 'keydown', keypressHandler);
		}
	});

	// When `activeIf` property is `true` on init.
	if (options.model[options.activeIf]) {
		controller.listenTo(document, 'keydown', keypressHandler);
	}
}

// Fires callback when ESC key was pressed.
//
// @private
// @param {HTMLElement} keyCode Code of pressed key.
// @param {Function} callback Action fired after ESC press.
function handleEscPress(keyCode, callback) {
	if (keyCode == keyCodes.esc) {
		callback();
	}
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The balloon panel controller class.
 *
 *		new BalloonPanel( new Model(), new BalloonPanelView() );
 *
 * See {@link ui.balloonPanel.BalloonPanelView}.
 *
 * @memberOf ui.balloonPanel
 * @extends ui.Controller
 */

var BalloonPanel = function (_Controller) {
  inherits(BalloonPanel, _Controller);

  /**
   * Creates an instance of {@link ui.balloonPanel.BalloonPanel} class.
   *
   * @param {ui.balloonPanel.BalloonPanelModel} model Model of this balloon panel.
   * @param {ui.View} view View of this balloon panel.
   */
  function BalloonPanel(model, view) {
    classCallCheck(this, BalloonPanel);

    var _this = possibleConstructorReturn(this, Object.getPrototypeOf(BalloonPanel).call(this, model, view));

    view.set({
      top: 0,
      left: 0,
      arrow: 'se',
      isVisible: false
    });

    view.bind('maxWidth').to(model);

    _this.addCollection('content');
    return _this;
  }

  return BalloonPanel;
}(Controller);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/* globals window, document, Range, HTMLElement */

var toPx$1 = toUnit('px');
var arrowLeftOffset = 30;
var arrowTopOffset = 15;

/**
 * The balloon panel view class.
 *
 * See {@link ui.balloonPanel.BalloonPanel}.
 *
 * @memberOf ui.balloonPanel
 * @extends ui.View
 */

var BalloonPanelView = function (_View) {
	inherits(BalloonPanelView, _View);

	/**
  * @inheritDoc
  */
	function BalloonPanelView(locale) {
		classCallCheck(this, BalloonPanelView);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(BalloonPanelView).call(this, locale));

		var bind = _this.bindTemplate;

		_this.template = new Template({
			tag: 'div',
			attributes: {
				class: ['ck-balloon-panel', bind.to('arrow', function (value) {
					return 'ck-balloon-panel_arrow_' + value;
				}), bind.if('isVisible', 'ck-balloon-panel_visible')],

				style: {
					top: bind.to('top', toPx$1),
					left: bind.to('left', toPx$1),
					maxWidth: bind.to('maxWidth', toPx$1)
				},

				// Make this element `focusable` to be available for adding to FocusTracker.
				tabindex: -1
			}
		});

		_this.register('content', function (el) {
			return el;
		});

		/**
   * The absolute top position of the balloon panel in pixels.
   *
   * @observable
   * @member {Number} ui.balloonPanel.BalloonPanelView#top
   */

		/**
   * The absolute left position of the balloon panel in pixels.
   *
   * @observable
   * @member {Number} ui.balloonPanel.BalloonPanelView#left
   */

		/**
   * The maximum width of the balloon panel, as in CSS.
   *
   * @observable
   * @member {Number} ui.balloonPanel.BalloonPanelView#maxWidth
   */

		/**
   * Balloon panel arrow direction.
   *
   * @observable
   * @member {'se'|'sw'|'ne'|'nw'} ui.balloonPanel.BalloonPanelView#arrow
   */

		/**
   * Controls whether the balloon panel is visible or not.
   *
   * @observable
   * @member {Boolean} ui.balloonPanel.BalloonPanelView#isVisible
   */
		return _this;
	}

	/**
  * Shows the balloon panel.
  *
  * See {@link ui.balloonPanel.BalloonPanelView#isVisible}.
  */


	createClass(BalloonPanelView, [{
		key: 'show',
		value: function show() {
			this.isVisible = true;
		}

		/**
   * Hides the balloon panel.
   *
   * See {@link ui.balloonPanel.BalloonPanelView#isVisible}.
   */

	}, {
		key: 'hide',
		value: function hide() {
			this.isVisible = false;
		}

		/**
   * Attaches the balloon panel to a specified DOM element or range with a smart heuristics.
   *
   * **Notes**:
   *
   * * The algorithm takes the geometry of the "limiter element" into consideration so,
   * if possible, the balloon is positioned within the rect of that element.
   * * If possible, the balloon is positioned within the area of the "limiter element"
   * fitting into the browser viewport visible to the user. It prevents the panel from
   * appearing off screen.
   *
   * The heuristics chooses from among 4 available positions relative to the target DOM element or range:
   *
   * * South east:
   *
   *		[ Target ]
   *		    ^
   *		+-----------------+
   *		|                 |
   *		+-----------------+
   *
   *
   * * South west:
   *
   *		         [ Target ]
   *		              ^
   *		+-----------------+
   *		|                 |
   *		+-----------------+
   *
   *
   * * North east:
   *
   *		+-----------------+
   *		|                 |
   *		+-----------------+
   *		    V
   *		[ Target ]
   *
   *
   * * North west:
   *
   *		+-----------------+
   *		|                 |
   *		+-----------------+
   *		              V
   *		         [ Target ]
   *
   * See {@ link ui.balloonPanel.BalloonPanelView#arrow}.
   *
   * @param {HTMLElement|Range} elementOrRange Target DOM element or range to which the balloon will be attached.
   * @param {HTMLElement|Object} limiterElementOrRect The DOM element or element rect beyond which area the balloon panel should not be
   * positioned, if possible.
   */

	}, {
		key: 'attachTo',
		value: function attachTo(elementOrRange, limiterElementOrRect) {
			this.show();

			var elementOrRangeRect = new AbsoluteDomRect(elementOrRange);
			var panelRect = new AbsoluteDomRect(this.element);
			var limiterVisibleRect = getAbsoluteRectVisibleInTheViewport(limiterElementOrRect);

			// Create a rect for each of the possible balloon positions and feed them to _smartAttachTo,
			// which will use whichever is the optimal. Position are ordered from most to less desired.
			var possiblePanelRects = {
				// The absolute rect for "South east" position.
				se: panelRect.clone().moveTo({
					top: elementOrRangeRect.bottom + arrowTopOffset,
					left: elementOrRangeRect.left + elementOrRangeRect.width / 2 - arrowLeftOffset
				}),

				// The absolute rect for "South west" position.
				sw: panelRect.clone().moveTo({
					top: elementOrRangeRect.bottom + arrowTopOffset,
					left: elementOrRangeRect.left + elementOrRangeRect.width / 2 - panelRect.width + arrowLeftOffset
				}),

				// The absolute rect for "North east" position.
				ne: panelRect.clone().moveTo({
					top: elementOrRangeRect.top - panelRect.height - arrowTopOffset,
					left: elementOrRangeRect.left + elementOrRangeRect.width / 2 - arrowLeftOffset
				}),

				// The absolute rect for "North west" position.
				nw: panelRect.clone().moveTo({
					top: elementOrRangeRect.top - panelRect.height - arrowTopOffset,
					left: elementOrRangeRect.left + elementOrRangeRect.width / 2 - panelRect.width + arrowLeftOffset
				})
			};

			this._smartAttachTo(possiblePanelRects, limiterVisibleRect, panelRect.width * panelRect.height);
		}

		/**
   * For the given set of possible rects, chooses the one which fits the best into both - browser viewport and
   * `visibleContainerRect`, which is when their intersection has the biggest area. Note that priority is a possible
   * highest intersection area with browser viewport.
   *
   * @private
   * @param {Object} rects Set of positions where balloon can be placed.
   * @param {AbsoluteDomRect} visibleContainerRect The absolute rect of the visible part of container element.
   * @param {Number} panelSurfaceArea Panel surface area.
   */

	}, {
		key: '_smartAttachTo',
		value: function _smartAttachTo(rects, visibleContainerRect, panelSurfaceArea) {
			var viewportRect = new AbsoluteDomRect(getAbsoluteViewportRect());
			var maxIntersectRectPos = void 0;
			var maxContainerIntersectArea = -1;
			var maxViewportIntersectArea = -1;

			// Find the best place. Stop searching when the position with fully visible panel has been found.
			Object.keys(rects).some(function (rectPos) {
				var containerIntersectArea = rects[rectPos].getIntersectArea(visibleContainerRect);
				var viewportIntersectArea = rects[rectPos].getIntersectArea(viewportRect);

				if (viewportIntersectArea >= maxViewportIntersectArea && containerIntersectArea > maxContainerIntersectArea) {
					maxIntersectRectPos = rectPos;
					maxContainerIntersectArea = containerIntersectArea;
					maxViewportIntersectArea = viewportIntersectArea;
				}

				return maxContainerIntersectArea === panelSurfaceArea;
			});

			// Move the balloon panel.
			this.arrow = maxIntersectRectPos;
			this.top = rects[maxIntersectRectPos].top;
			this.left = rects[maxIntersectRectPos].left;
		}
	}]);
	return BalloonPanelView;
}(View);

var AbsoluteDomRect = function () {
	// Create instance of AbsoluteDomRect class.
	//
	// @param {HTMLElement|Range|Object} elementOrRangeOrRect Source object to create the rect.
	function AbsoluteDomRect(elementOrRangeOrRect) {
		classCallCheck(this, AbsoluteDomRect);

		Object.assign(this, getAbsoluteRect(elementOrRangeOrRect));
	}

	// Clone instance of this class.
	//
	// @returns {AbsoluteDomRect}


	createClass(AbsoluteDomRect, [{
		key: 'clone',
		value: function clone() {
			return new AbsoluteDomRect(this);
		}

		// Move current box to specified position.
		//
		// @param {Number} top New to position.
		// @param {Number} left New left position.
		// @returns {AbsoluteDomRect}

	}, {
		key: 'moveTo',
		value: function moveTo(_ref) {
			var top = _ref.top;
			var left = _ref.left;

			this.top = top;
			this.right = left + this.width;
			this.bottom = top + this.height;
			this.left = left;

			return this;
		}

		// Get intersect surface area of this AbsoluteDomRect and other AbsoluteDomRect.
		//
		// @param {AbsoluteDomRect} rect
		// @returns {Number} Overlap surface area.

	}, {
		key: 'getIntersectArea',
		value: function getIntersectArea(rect) {
			var hOverlap = Math.max(0, Math.min(this.right, rect.right) - Math.max(this.left, rect.left));
			var vOverlap = Math.max(0, Math.min(this.bottom, rect.bottom) - Math.max(this.top, rect.top));

			return hOverlap * vOverlap;
		}
	}]);
	return AbsoluteDomRect;
}();

// Returns the client rect of an HTMLElement, Range, or rect. The obtained geometry of the rect
// corresponds with `position: absolute` relative to the `<body>` (`document.body`).
//
// @private
// @param {HTMLElement|Range|Object} elementOrRangeOrRect Target object witch rect is to be determined.
// @returns {Object} Client rect object.


function getAbsoluteRect(elementOrRangeOrRect) {
	var bodyRect = document.body.getBoundingClientRect();

	if (elementOrRangeOrRect instanceof HTMLElement || elementOrRangeOrRect instanceof Range) {
		var elementRect = elementOrRangeOrRect.getBoundingClientRect();

		return {
			top: elementRect.top - bodyRect.top,
			right: elementRect.right - bodyRect.left,
			bottom: elementRect.bottom - bodyRect.top,
			left: elementRect.left - bodyRect.left,
			width: elementRect.width,
			height: elementRect.height
		};
	}

	// The rect has been passed.
	var absoluteRect = Object.assign({}, elementOrRangeOrRect);

	if (absoluteRect.width === undefined) {
		absoluteRect.width = absoluteRect.right - absoluteRect.left;
	}

	if (absoluteRect.height === undefined) {
		absoluteRect.height = absoluteRect.bottom - absoluteRect.top;
	}

	return absoluteRect;
}

// Returns the client rect of the element limited by the visible (to the user)
// viewport of the browser window.
//
//		[Browser viewport]
//		+---------------------------------------+
//		|                        [Element]      |
//		|                        +----------------------+
//		|                        |##############|       |
//		|                        |##############|       |
//		|                        |#######^######|       |
//		|                        +-------|--------------+
//		|                                |      |
//		+--------------------------------|------+
//		                                 |
//		                                  \- [Element rect visible in the viewport]
//
// @private
// @param {HTMLElement|Object} element Object which visible area rect is to be determined.
// @returns {AbsoluteDomRect} An absolute rect of the area visible in the viewport.
function getAbsoluteRectVisibleInTheViewport(element) {
	var elementRect = getAbsoluteRect(element);
	var viewportRect = getAbsoluteViewportRect();

	return new AbsoluteDomRect({
		top: Math.max(elementRect.top, viewportRect.top),
		left: Math.max(elementRect.left, viewportRect.left),
		right: Math.min(elementRect.right, viewportRect.right),
		bottom: Math.min(elementRect.bottom, viewportRect.bottom)
	});
}

// Get browser viewport rect.
//
// @private
// @returns {Object} Viewport rect.
function getAbsoluteViewportRect() {
	var windowScrollX = window.scrollX;
	var windowScrollY = window.scrollY;
	var windowWidth = window.innerWidth;
	var windowHeight = window.innerHeight;

	return {
		top: windowScrollY,
		right: windowWidth + windowScrollX,
		bottom: windowHeight + windowScrollY,
		left: windowScrollX
	};
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The label controller class.
 *
 *		const model = new Model( {
 *			text: 'Label of some input.',
 *			for: 'id-of-related-input'
 *		} );
 *
 *		new Label( model, new LabelView() );
 *
 * See {@link ui.input.LabelView}.
 *
 * @memberOf ui.label
 * @extends ui.Controller
 */

var Label = function (_Controller) {
  inherits(Label, _Controller);

  /**
   * Creates an instance of {@link ui.label.Label} class.
   *
   * @param {ui.label.LabelModel} model Model of this label.
   * @param {ui.View} view View of this label.
   */
  function Label(model, view) {
    classCallCheck(this, Label);

    var _this = possibleConstructorReturn(this, Object.getPrototypeOf(Label).call(this, model, view));

    view.bind('text', 'for').to(model);
    return _this;
  }

  return Label;
}(Controller);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The labeled input controller class. It contains two components, {@link ui.input.Label Label}
 * and `InputComponent` instance, connected by an unique id.
 *
 *		const input = new InputText( new Model(), new InputTextView() );
 *
 *		const model = new Model( {
 *			label: 'Label text'
 *			value: 'init value',
 *		} );
 *
 *		new LabeledInput( model, new LabeledInputView(), input );
 *
 * See {@link ui.input.labeled.LabeledInputView}.
 *
 * @memberOf ui.input.labeled
 * @extends ui.Controller
 */

var LabeledInput = function (_Controller) {
	inherits(LabeledInput, _Controller);

	/**
  * Creates an instance of {@link ui.input.labeled.LabeledInput} class.
  *
  * @param {ui.input.labeled.LabeledInputModel} model Model of this input.
  * @param {ui.View} view View of this input.
  * @param {Function} InputClass Constructor of the input component.
  * @param {ui.Model} model Model of the input component.
  */
	function LabeledInput(model, view, InputClass, inputModel) {
		classCallCheck(this, LabeledInput);

		/**
   * An unique `id` to pair the input with its label.
   *
   * @protected
   * @member {ui.input.Label}
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(LabeledInput).call(this, model, view));

		_this._uid = 'ck-input-' + uid();

		/**
   * The `Label` controller instance.
   *
   * @member {ui.input.Label}
   */
		_this.label = _this._createLabel();

		/**
   * The input controller instance.
   *
   * @member {ui.input.InputText}
   */
		_this.input = _this._spawnInput(InputClass, inputModel);
		return _this;
	}

	/**
  * Returns the input value.
  *
  * @returns {String} Input value.
  */


	createClass(LabeledInput, [{
		key: '_createLabel',


		/**
   * Initializes the {@link ui.input.Label Label} instance.
   *
   * @private
   * @returns {Label}
   */
		value: function _createLabel() {
			var model = new Model();

			model.bind('text').to(this.model, 'label');
			model.set('for', this._uid);

			return new Label(model, this.view.labelView);
		}

		/**
   * Creates the new input using given constructor and model.
   * Binds basic attributes of the newly created input's model to {ui.input.labeled.LabeledInputModel}.
   *
   * @private
   * @param {Function} InputClass A constructor of the input component.
   * @param {ui.Model} inputModel Model of the input component.
   * @returns {ui.Controller} An instance of the input component.
   */

	}, {
		key: '_spawnInput',
		value: function _spawnInput(InputClass, inputModel) {
			inputModel.bind('value').to(this.model, 'value');
			inputModel.set('id', this._uid);

			return new InputClass(inputModel, this.view.inputView);
		}
	}, {
		key: 'value',
		get: function get() {
			return this.input.value;
		}
	}]);
	return LabeledInput;
}(Controller);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The text input controller class.
 *
 *		const model = new Model( {
 *			value: 'Initial value.',
 *			id: 'id-of-this-input'
 *		} );
 *
 *		new InputText( model, new InputTextView() );
 *
 * See {@link ui.input.InputTextView}.
 *
 * @memberOf ui.input
 * @extends ui.Controller
 */

var InputText = function (_Controller) {
  inherits(InputText, _Controller);

  /**
   * Creates an instance of {@link ui.input.InputText} class.
   *
   * @param {ui.input.InputTextModel} model Model of this input.
   * @param {ui.View} view View of this input.
   */
  function InputText(model, view) {
    classCallCheck(this, InputText);

    var _this = possibleConstructorReturn(this, Object.getPrototypeOf(InputText).call(this, model, view));

    view.bind('value', 'id').to(model);
    return _this;
  }

  /**
   * Returns the input value.
   *
   * @returns {String} input value.
   */


  createClass(InputText, [{
    key: 'value',
    get: function get() {
      return this.view.element.value;
    }
  }]);
  return InputText;
}(Controller);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The link form class.
 *
 *		new LinkForm( new Model(), new LinkFormView() );
 *
 * See {@link link.ui.LinkFormView}.
 *
 * @memberOf link.ui
 * @extends ui.Controller
 */

var LinkForm = function (_Controller) {
	inherits(LinkForm, _Controller);

	/**
  * Creates an instance of {@link link.ui.LinkForm} class.
  *
  * @param {link.ui.LinkFormModel} model Model of this link form.
  * @param {ui.View} view View of this link form.
  */
	function LinkForm(model, view) {
		classCallCheck(this, LinkForm);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(LinkForm).call(this, model, view));

		var t = _this.view.t;
		var urlInputModel = new Model({
			label: t('Link URL')
		});

		// Bind LabeledInputModel#value to LinkFormModel#url.
		urlInputModel.bind('value').to(model, 'url');

		/**
   * The URL input inside {@link link.ui.LinkForm}.
   *
   * @member {ui.input.labeled.LabeledInput} link.ui.LinkForm#urlInput
   */
		_this.urlInput = new LabeledInput(urlInputModel, view.urlInputView, InputText, new Model());

		/**
   * The save button inside {@link link.ui.LinkForm}.
   *
   * @member {ui.button.Button} link.ui.LinkForm#saveButton
   */
		_this.saveButton = new Button(new Model({
			isEnabled: true,
			isOn: false,
			label: t('Save'),
			withText: true,
			type: 'submit'
		}), view.saveButtonView);

		/**
   * The cancel button inside {@link link.ui.LinkForm}.
   *
   * @member {ui.button.Button} link.ui.LinkForm#cancelButton
   */
		_this.cancelButton = new Button(new Model({
			isEnabled: true,
			isOn: false,
			label: t('Cancel'),
			withText: true
		}), view.cancelButtonView);

		/**
   * The unlink button inside {@link link.ui.LinkForm}.
   *
   * @member {ui.button.Button} link.ui.LinkForm#unlinkButton
   */
		_this.unlinkButton = new Button(new Model({
			isEnabled: true,
			isOn: false,
			label: t('Unlink'),
			icon: 'unlink'
		}), view.unlinkButtonView);

		view.delegate('submit').to(model);

		// TODO: Delegate event with changed name.
		_this.listenTo(_this.cancelButton.model, 'execute', function () {
			_this.model.fire('cancel');
		});

		_this.listenTo(_this.unlinkButton.model, 'execute', function () {
			_this.model.fire('unlink');
		});

		// TODO: add() should accept multiple items.
		_this.add(_this.urlInput);
		_this.add(_this.saveButton);
		_this.add(_this.cancelButton);
		_this.add(_this.unlinkButton);
		return _this;
	}

	return LinkForm;
}(Controller);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The label view class.
 *
 * See {@link ui.label.Label}.
 *
 * @memberOf ui.label
 * @extends ui.View
 */

var LabelView = function (_View) {
	inherits(LabelView, _View);

	/**
  * @inheritDoc
  */
	function LabelView(locale) {
		classCallCheck(this, LabelView);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(LabelView).call(this, locale));

		var bind = _this.bindTemplate;

		_this.template = new Template({
			tag: 'label',
			attributes: {
				class: ['ck-label'],
				for: bind.to('for')
			},
			children: [{
				text: bind.to('text')
			}]
		});

		/**
   * The text of the label.
   *
   * @observable
   * @member {String} ui.label.LabelView#text
   */

		/**
   * The `for` attribute of the label (i.e. to pair with an `<input>` element).
   *
   * @observable
   * @member {String} ui.label.LabelView#for
   */
		return _this;
	}

	return LabelView;
}(View);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The labeled input view class.
 *
 * See {@link ui.input.labeled.LabeledInput}.
 *
 * @memberOf ui.input.labeled
 * @extends ui.View
 */

var LabeledInputView = function (_View) {
	inherits(LabeledInputView, _View);

	/**
  * Creates an instance of the labeled input view class.
  *
  * @param {Function} InputViewClass Constructor of the input view.
  * @param {utils.Locale} [locale] The {@link core.editor.Editor#locale editor's locale} instance.
  */
	function LabeledInputView(InputViewClass, locale) {
		classCallCheck(this, LabeledInputView);

		/**
   * The label view.
   *
   * @member {ui.label.LabelView} ui.input.labeled.LabeledInput#labelView
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(LabeledInputView).call(this, locale));

		_this.labelView = new LabelView(_this.locale);

		/**
   * The input view.
   *
   * @member {ui.View} ui.input.labeled.LabeledInput#inputView
   */
		_this.inputView = new InputViewClass(_this.locale);

		_this.template = new Template({
			tag: 'div',

			children: [_this.labelView, _this.inputView]
		});
		return _this;
	}

	/**
  * Moves the focus to the input and selects the value.
  */


	createClass(LabeledInputView, [{
		key: 'select',
		value: function select() {
			this.inputView.select();
		}
	}]);
	return LabeledInputView;
}(View);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The text input view class.
 *
 * See {@link ui.input.InputText}.
 *
 * @memberOf ui.input
 * @extends ui.View
 */

var InputTextView = function (_View) {
	inherits(InputTextView, _View);

	/**
  * @inheritDoc
  */
	function InputTextView(locale) {
		classCallCheck(this, InputTextView);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(InputTextView).call(this, locale));

		var bind = _this.bindTemplate;

		_this.template = new Template({
			tag: 'input',
			attributes: {
				type: 'text',
				class: ['ck-input', 'ck-input-text'],
				id: bind.to('id')
			}
		});

		// Note: `value` cannot be an HTML attribute, because it doesn't change HTMLInputElement value once changed.
		_this.on('change:value', function (evt, propertyName, value) {
			return _this.element.value = value || '';
		});

		/**
   * The value of the input.
   *
   * @observable
   * @member {String} ui.input.InputTextView#value
   */

		/**
   * The `id` attribute of the input (i.e. to pair with a `<label>` element).
   *
   * @observable
   * @member {String} ui.input.InputTextView#id
   */
		return _this;
	}

	/**
  * Moves the focus to the input and selects the value.
  */


	createClass(InputTextView, [{
		key: 'select',
		value: function select() {
			this.element.select();
		}
	}]);
	return InputTextView;
}(View);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Handles native DOM `submit` event by preventing it and firing
 * the {ui.View} `submit` event, which can be then handled by the
 * parent controller.
 *
 * @param {Object} [options] Configuration options.
 * @param {ui.View} options.view The view to which this behavior should be added.
 */
function submitHandler(_ref) {
  var view = _ref.view;

  view.listenTo(view.element, 'submit', function (evt, domEvt) {
    domEvt.preventDefault();
    view.fire('submit');
  }, { useCapture: true });
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The link form view controller class.
 *
 * See {@link link.ui.LinkForm}.
 *
 * @memberOf link.ui
 * @extends ui.View
 */

var LinkFormView = function (_View) {
	inherits(LinkFormView, _View);

	/**
  * @inheritDoc
  */
	function LinkFormView(locale) {
		classCallCheck(this, LinkFormView);

		/**
   * The url input view.
   *
   * @member {ui.input.labeled.LabeledInputView} link.ui.LinkFormView#urlInputView
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(LinkFormView).call(this, locale));

		_this.urlInputView = new LabeledInputView(InputTextView, locale);

		/**
   * The save button view.
   *
   * @member {ui.button.ButtonView} link.ui.LinkFormView#saveButtonView
   */
		_this.saveButtonView = new ButtonView(locale);

		/**
   * The cancel button view.
   *
   * @member {ui.button.ButtonView} link.ui.LinkFormView#cancelButtonView
   */
		_this.cancelButtonView = new ButtonView(locale);

		/**
   * The unlink button view.
   *
   * @member {ui.button.ButtonView} link.ui.LinkFormView#unlinkButtonView
   */
		_this.unlinkButtonView = new ButtonView(locale);

		Template.extend(_this.saveButtonView.template, {
			attributes: {
				class: ['ck-button-action']
			}
		});

		_this.template = new Template({
			tag: 'form',

			attributes: {
				class: ['ck-link-form']
			},

			children: [_this.urlInputView, {
				tag: 'div',

				attributes: {
					class: ['ck-link-form__actions']
				},

				children: [_this.saveButtonView, _this.cancelButtonView, _this.unlinkButtonView]
			}]
		});

		submitHandler({
			view: _this
		});
		return _this;
	}

	return LinkFormView;
}(View);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The link feature. It introduces the Link and Unlink buttons and the <kbd>Ctrl+K</kbd> keystroke.
 *
 * It uses the {@link link.LinkEngine link engine feature}.
 *
 * @memberOf link
 * @extends core.Feature
 */

var Link = function (_Feature) {
	inherits(Link, _Feature);

	function Link() {
		classCallCheck(this, Link);
		return possibleConstructorReturn(this, Object.getPrototypeOf(Link).apply(this, arguments));
	}

	createClass(Link, [{
		key: 'init',


		/**
   * @inheritDoc
   */
		value: function init() {
			this.editor.editing.view.addObserver(ClickObserver);

			/**
    * Balloon panel component to display the main UI.
    *
    * @member {link.ui.LinkBalloonPanel} link.Link#balloonPanel
    */
			this.balloonPanel = this._createBalloonPanel();

			/**
    * The form component inside {@link link.Link#balloonPanel}.
    *
    * @member {link.ui.LinkForm} link.Link#form
    */
			this.form = this._createForm();

			// Create toolbar buttons.
			this._createToolbarLinkButton();
			this._createToolbarUnlinkButton();
		}

		/**
   * Creates a toolbar link button. Clicking this button will show
   * {@link link.Link#balloonPanel} attached to the selection.
   *
   * @private
   */

	}, {
		key: '_createToolbarLinkButton',
		value: function _createToolbarLinkButton() {
			var _this2 = this;

			var editor = this.editor;
			var linkCommand = editor.commands.get('link');
			var t = editor.t;

			// Create button model.
			var linkButtonModel = new Model({
				isEnabled: true,
				isOn: false,
				label: t('Link'),
				icon: 'link',
				keystroke: 'CTRL+K'
			});

			// Bind button model to the command.
			linkButtonModel.bind('isEnabled').to(linkCommand, 'isEnabled');

			// Show the panel on button click only when editor is focused.
			this.listenTo(linkButtonModel, 'execute', function () {
				return _this2._showPanel();
			});

			// Add link button to feature components.
			editor.ui.featureComponents.add('link', Button, ButtonView, linkButtonModel);

			// Handle `Ctrl+K` keystroke and show panel.
			editor.keystrokes.set('CTRL+K', function () {
				return _this2._showPanel();
			});
		}

		/**
   * Creates a toolbar unlink button. Clicking this button will unlink
   * the selected link.
   *
   * @private
   */

	}, {
		key: '_createToolbarUnlinkButton',
		value: function _createToolbarUnlinkButton() {
			var editor = this.editor;
			var t = editor.t;
			var unlinkCommand = editor.commands.get('unlink');

			// Create the button model.
			var unlinkButtonModel = new Model({
				isEnabled: false,
				isOn: false,
				label: t('Unlink'),
				icon: 'unlink'
			});

			// Bind button model to the command.
			unlinkButtonModel.bind('isEnabled').to(unlinkCommand, 'isEnabled');

			// Execute unlink command and hide panel, if open.
			this.listenTo(unlinkButtonModel, 'execute', function () {
				editor.execute('unlink');
			});

			// Add unlink button to feature components.
			editor.ui.featureComponents.add('unlink', Button, ButtonView, unlinkButtonModel);
		}

		/**
   * Creates the {@link link.ui.LinkBalloonPanel} instance.
   *
   * @private
   * @returns {link.ui.LinkBalloonPanel} Link balloon panel instance.
   */

	}, {
		key: '_createBalloonPanel',
		value: function _createBalloonPanel() {
			var _this3 = this;

			var editor = this.editor;
			var viewDocument = editor.editing.view;

			// Create the balloon panel instance.
			var balloonPanel = new BalloonPanel(new Model({
				maxWidth: 300
			}), new BalloonPanelView(editor.locale));

			// Add balloonPanel.view#element to FocusTracker.
			// @TODO: Do it automatically ckeditor5-core#23
			editor.focusTracker.add(balloonPanel.view.element);

			// Handle click on view document and show panel when selection is placed inside the link element.
			// Keep panel open until selection will be inside the same link element.
			this.listenTo(viewDocument, 'click', function () {
				var viewSelection = viewDocument.selection;
				var parentLink = getPositionParentLink(viewSelection.getFirstPosition());

				if (viewSelection.isCollapsed && parentLink) {
					_this3._attachPanelToElement();

					_this3.listenTo(viewDocument, 'render', function () {
						var currentParentLink = getPositionParentLink(viewSelection.getFirstPosition());

						if (!viewSelection.isCollapsed || parentLink !== currentParentLink) {
							_this3._hidePanel();
						} else {
							_this3._attachPanelToElement(parentLink);
						}
					});

					_this3.listenTo(balloonPanel.view, 'change:isVisible', function () {
						return _this3.stopListening(viewDocument, 'render');
					});
				}
			});

			// Close on `ESC` press.
			escPressHandler({
				controller: balloonPanel.view,
				model: balloonPanel.view,
				activeIf: 'isVisible',
				callback: function callback() {
					return _this3._hidePanel(true);
				}
			});

			// Close on click outside of balloon panel element.
			clickOutsideHandler({
				controller: balloonPanel.view,
				model: balloonPanel.view,
				activeIf: 'isVisible',
				contextElement: balloonPanel.view.element,
				callback: function callback() {
					return _this3._hidePanel();
				}
			});

			editor.ui.add('body', balloonPanel);

			return balloonPanel;
		}

		/**
   * Creates the {@link link.ui.LinkForm} instance.
   *
   * @private
   * @returns {link.ui.LinkForm} Link form instance.
   */

	}, {
		key: '_createForm',
		value: function _createForm() {
			var _this4 = this;

			var editor = this.editor;
			var formModel = new Model();

			formModel.bind('url').to(editor.commands.get('link'), 'value');

			var form = new LinkForm(formModel, new LinkFormView(editor.locale));

			// Execute link command after clicking on balloon panel `Link` button.
			this.listenTo(formModel, 'submit', function () {
				editor.execute('link', _this4.form.urlInput.value);
				_this4._hidePanel(true);
			});

			// Execute unlink command after clicking on balloon panel `Unlink` button.
			this.listenTo(formModel, 'unlink', function () {
				editor.execute('unlink');
				_this4._hidePanel(true);
			});

			// Hide balloon panel after clicking on balloon panel `Cancel` button.
			this.listenTo(formModel, 'cancel', function () {
				return _this4._hidePanel(true);
			});

			this.balloonPanel.add('content', form);

			return form;
		}

		/**
   * Shows {@link link.Link#balloonPanel LinkBalloonPanel} and attach to target element.
   * If selection is collapsed and is placed inside link element, then panel will be attached
   * to whole link element, otherwise will be attached to the selection.
   *
   * @private
   * @param {link.LinkElement} [parentLink] Target element.
   */

	}, {
		key: '_attachPanelToElement',
		value: function _attachPanelToElement(parentLink) {
			var viewDocument = this.editor.editing.view;
			var domEditableElement = viewDocument.domConverter.getCorrespondingDomElement(viewDocument.selection.editableElement);
			var targetLink = parentLink || getPositionParentLink(viewDocument.selection.getFirstPosition());

			// When selection is inside link element, then attach panel to this element.
			if (targetLink) {
				this.balloonPanel.view.attachTo(viewDocument.domConverter.getCorrespondingDomElement(targetLink), domEditableElement);
			}
			// Otherwise attach panel to the selection.
			else {
					this.balloonPanel.view.attachTo(viewDocument.domConverter.viewRangeToDom(viewDocument.selection.getFirstRange()), domEditableElement);
				}
		}

		/**
   * Hides {@link link.Link#balloonPanel LinkBalloonPanel}.
   *
   * @private
   * @param {Boolean} [focusEditable=false] When `true` then editable focus will be restored on panel hide.
   */

	}, {
		key: '_hidePanel',
		value: function _hidePanel(focusEditable) {
			this.balloonPanel.view.hide();

			if (focusEditable) {
				this.editor.editing.view.focus();
			}
		}

		/**
   * Shows {@link link.Link#balloonPanel LinkBalloonPanel}.
   *
   * @private
   */

	}, {
		key: '_showPanel',
		value: function _showPanel() {
			this._attachPanelToElement();
			this.form.urlInput.view.select();
		}
	}], [{
		key: 'requires',

		/**
   * @inheritDoc
   */
		get: function get() {
			return [LinkEngine];
		}
	}]);
	return Link;
}(Feature);

function getPositionParentLink(position) {
	return position.parent.getAncestors().find(function (ancestor) {
		return ancestor instanceof LinkElement;
	});
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Utilities used in modules from {@link list list} package.
 *
 * @memberOf list
 * @namespace list.utils
 */

/**
 * For given {@link engine.model.Position position}, returns the closest ancestor of that position which is a
 * `listItem` element.
 *
 * @function list.utils.getClosestListItem
 * @param {engine.model.Position} position Position which ancestor should be check looking for `listItem` element.
 * @returns {engine.model.Element|null} Element with `listItem` name that is a closest ancestor of given `position`, or
 * `null` if neither of `position` ancestors is a `listItem`.
 */
function getClosestListItem(position) {
  return Array.from(position.getAncestors()).find(function (parent) {
    return parent.name == 'listItem';
  }) || null;
}

/**
 * For given {@link engine.model.Selection selection} and {@link engine.model.Schema schema}, returns an array with
 * all elements that are in the selection and are extending `$block` schema item.
 *
 * @function list.utils.getSelectedBlocks
 * @param {engine.model.Selection} selection Selection from which blocks will be taken.
 * @param {engine.model.Schema} schema Schema which will be used to check if a model element extends `$block`.
 * @returns {Array.<engine.model.Element>} All blocks from the selection.
 */
function getSelectedBlocks(selection, schema) {
  var position = getPositionBeforeBlock(selection.getFirstPosition(), schema);

  var endPosition = selection.getLastPosition();
  var blocks = [];

  // Traverse model from the first position before a block to the end position of selection.
  // Store all elements that were after the correct positions.
  while (position !== null && position.isBefore(endPosition)) {
    blocks.push(position.nodeAfter);

    position.offset++;
    position = getPositionBeforeBlock(position, schema);
  }

  return blocks;
}

/**
 * For given {@link engine.model.Position position}, finds a model element extending `$block` schema item which is
 * closest element to that position. First node after the position is checked and then the position's ancestors. `null`
 * is returned if such element has not been found or found element is a root element.
 *
 * @param position
 * @param schema
 * @returns {*}
 */
function getPositionBeforeBlock(position, schema) {
  // Start from the element right after the position. Maybe it is already a `$block` element.
  var element = position.nodeAfter;

  // If the position is not before an element, check the parent.
  if (!element) {
    element = position.parent;
  }

  // If proper element is still not found, check the ancestors.
  while (element !== null && !schema.itemExtends(element.name || '$text', '$block')) {
    element = element.parent;
  }

  // If proper element has been found, return position before it, otherwise return null;
  return element !== null && element.parent !== null ? Position.createBefore(element) : null;
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The list command. It is used by the {@link list.List list feature}.
 *
 * @memberOf list
 * @extends core.command.Command
 */

var ListCommand = function (_Command) {
	inherits(ListCommand, _Command);

	/**
  * Creates an instance of the command.
  *
  * @param {core.editor.Editor} editor Editor instance.
  * @param {'numbered'|'bulleted'} type List type that will be handled by this command.
  */
	function ListCommand(editor, type) {
		classCallCheck(this, ListCommand);

		/**
   * The type of list created by the command.
   *
   * @readonly
   * @member {'numbered'|'bulleted'} list.ListCommand#type
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ListCommand).call(this, editor));

		_this.type = type == 'bulleted' ? 'bulleted' : 'numbered';

		/**
   * Flag indicating whether the command is active, which means that selection starts in a list of the same type.
   *
   * @observable
   * @member {Boolean} list.ListCommand#value
   */
		_this.set('value', false);

		var changeCallback = function changeCallback() {
			_this.refreshValue();
			_this.refreshState();
		};

		// Listen on selection and document changes and set the current command's value.
		_this.listenTo(editor.document.selection, 'change:range', changeCallback);
		_this.listenTo(editor.document, 'changesDone', changeCallback);
		return _this;
	}

	/**
  * Sets command's value based on the document selection.
  */


	createClass(ListCommand, [{
		key: 'refreshValue',
		value: function refreshValue() {
			var position = this.editor.document.selection.getFirstPosition();

			// Check whether closest `listItem` ancestor of the position has a correct type.
			var listItem = getClosestListItem(position);
			this.value = listItem !== null && listItem.getAttribute('type') == this.type;
		}

		/**
   * Executes command.
   *
   * @protected
   * @param {Object} [options] Options for executed command.
   * @param {engine.model.Batch} [options.batch] Batch to collect all the change steps.
   * New batch will be created if this option is not set.
   */

	}, {
		key: '_doExecute',
		value: function _doExecute() {
			var _this2 = this;

			var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

			var document = this.editor.document;
			var blocks = getSelectedBlocks(document.selection, document.schema);

			// Whether we are turning off some items.
			var turnOff = this.value === true;
			// If we are turning off items, we are going to rename them to paragraphs.

			document.enqueueChanges(function () {
				var batch = options.batch || document.batch();

				// If part of a list got turned off, we need to handle (outdent) all of sub-items of the last turned-off item.
				// To be sure that model is all the time in a good state, we first fix items below turned-off item.
				if (turnOff) {
					// Start from the model item that is just after the last turned-off item.
					var next = blocks[blocks.length - 1].nextSibling;
					var currentIndent = Number.POSITIVE_INFINITY;
					var changes = [];

					// Correct indent of all items after the last turned off item.
					// Rules that should be followed:
					// 1. All direct sub-items of turned-off item should become indent 0, because the first item after it
					//    will be the first item of a new list. Other items are at the same level, so should have same 0 index.
					// 2. All items with indent lower than indent of turned-off item should become indent 0, because they
					//    should not end up as a child of any of list items that they were not children of before.
					// 3. All other items should have their indent changed relatively to it's parent.
					//
					// For example:
					// 1  * --------
					// 2     * --------
					// 3        * -------- <- this is turned off.
					// 4           * -------- <- this has to become indent = 0, because it will be first item on a new list.
					// 5              * -------- <- this should be still be a child of item above, so indent = 1.
					// 6        * -------- <- this also has to become indent = 0, because it shouldn't end up as a child of any of items above.
					// 7           * -------- <- this should be still be a child of item above, so indent = 1.
					// 8     * -------- <- this has to become indent = 0.
					// 9        * -------- <- this should still be a child of item above, so indent = 1.
					// 10          * -------- <- this should still be a child of item above, so indent = 2.
					// 11          * -------- <- this should still be at the same level as item above, so indent = 2.
					// 12 * -------- <- this and all below are left unchanged.
					// 13    * --------
					// 14       * --------
					//
					// After turning off 3 the list becomes:
					//
					// 1  * --------
					// 2     * --------
					//
					// 3  --------
					//
					// 4  * --------
					// 5     * --------
					// 6  * --------
					// 7     * --------
					// 8  * --------
					// 9     * --------
					// 10       * --------
					// 11       * --------
					// 12 * --------
					// 13    * --------
					// 14       * --------
					//
					// Thanks to this algorithm no lists are mismatched and no items get unexpected children/parent, while
					// those parent-child connection which are possible to maintain are still maintained. It's worth noting
					// that this is the same effect that we would be get by multiple use of outdent command. However doing
					// it like this is much more efficient because it's less operation (less memory usage, easier OT) and
					// less conversion (faster).
					while (next && next.name == 'listItem' && next.getAttribute('indent') !== 0) {
						// Check each next list item, as long as its indent is bigger than 0.
						// If the indent is 0 we are not going to change anything anyway.
						var indent = next.getAttribute('indent');

						// We check if that's item indent is lower as current relative indent.
						if (indent < currentIndent) {
							// If it is, current relative indent becomes that indent.
							currentIndent = indent;
						}

						// Fix indent relatively to current relative indent.
						// Note, that if we just changed the current relative indent, the newIndent will be equal to 0.
						var newIndent = indent - currentIndent;

						// Save the entry in changes array. We do not apply it at the moment, because we will need to
						// reverse the changes so the last item is changed first.
						// This is to keep model in correct state all the time.
						changes.push({ element: next, indent: newIndent });

						// Find next item.
						next = next.nextSibling;
					}

					changes = changes.reverse();

					var _iteratorNormalCompletion = true;
					var _didIteratorError = false;
					var _iteratorError = undefined;

					try {
						for (var _iterator = changes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
							var item = _step.value;

							batch.setAttribute(item.element, 'indent', item.indent);
						}
					} catch (err) {
						_didIteratorError = true;
						_iteratorError = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion && _iterator.return) {
								_iterator.return();
							}
						} finally {
							if (_didIteratorError) {
								throw _iteratorError;
							}
						}
					}
				}

				// Phew! Now it will be easier :).
				// For each block element that was in the selection, we will either: turn it to list item,
				// turn it to paragraph, or change it's type. Or leave it as it is.
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;

				try {
					for (var _iterator2 = blocks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var element = _step2.value;

						if (turnOff && element.name == 'listItem') {
							// We are turning off and the element is a `listItem` - it should be converted to `paragraph`.
							// The order is important to keep model in correct state.
							batch.rename(element, 'paragraph').removeAttribute(element, 'type').removeAttribute(element, 'indent');
						} else if (!turnOff && element.name != 'listItem') {
							// We are turning on and the element is not a `listItem` - it should be converted to `listItem`.
							// The order is important to keep model in correct state.
							batch.setAttribute(element, 'type', _this2.type).setAttribute(element, 'indent', 0).rename(element, 'listItem');
						} else if (!turnOff && element.name == 'listItem' && element.getAttribute('type') != _this2.type) {
							// We are turning on and the element is a `listItem` but has different type - change type.
							batch.setAttribute(element, 'type', _this2.type);
						}
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2.return) {
							_iterator2.return();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
			});
		}

		/**
   * @inheritDoc
   */

	}, {
		key: '_checkEnabled',
		value: function _checkEnabled() {
			// If command is enabled it means that we are in list item, so the command should be enabled.
			if (this.value) {
				return true;
			}

			var selection = this.editor.document.selection;
			var schema = this.editor.document.schema;
			var position = getPositionBeforeBlock(selection.getFirstPosition(), schema);

			// Otherwise, check if list item can be inserted at the position start.
			return schema.check({ name: 'listItem', inside: position, attributes: ['type', 'indent'] });
		}
	}]);
	return ListCommand;
}(Command);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The list indent command. It is used by the {@link list.List list feature}.
 *
 * @memberOf list
 * @extends core.command.Command
 */

var IndentCommand = function (_Command) {
	inherits(IndentCommand, _Command);

	/**
  * Creates an instance of the command.
  *
  * @param {core.editor.Editor} editor Editor instance.
  * @param {'forward'|'backward'} indentDirection Direction of indent. If it is equal to `backward`, the command
  * will outdent a list item.
  */
	function IndentCommand(editor, indentDirection) {
		classCallCheck(this, IndentCommand);

		/**
   * By how much the command will change list item's indent attribute.
   *
   * @readonly
   * @private
   * @member {Number} list.IndentCommand#_indentBy
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(IndentCommand).call(this, editor));

		_this._indentBy = indentDirection == 'forward' ? 1 : -1;

		// Refresh command state after selection is changed or changes has been done to the document.
		_this.listenTo(editor.document.selection, 'change:range', function () {
			_this.refreshState();
		});

		_this.listenTo(editor.document, 'changesDone', function () {
			_this.refreshState();
		});
		return _this;
	}

	/**
  * @inheritDoc
  */


	createClass(IndentCommand, [{
		key: '_doExecute',
		value: function _doExecute() {
			var _this2 = this;

			var doc = this.editor.document;
			var batch = doc.batch();
			var element = getClosestListItem(doc.selection.getFirstPosition());

			doc.enqueueChanges(function () {
				var oldIndent = element.getAttribute('indent');

				var itemsToChange = [element];

				// Indenting a list item should also indent all the items that are already sub-items of indented item.
				var next = element.nextSibling;

				// Check all items as long as their indent is bigger than indent of changed list item.
				while (next && next.name == 'listItem' && next.getAttribute('indent') > oldIndent) {
					itemsToChange.push(next);

					next = next.nextSibling;
				}

				// We need to be sure to keep model in correct state after each small change, because converters
				// bases on that state and assumes that model is correct.
				// Because of that, if the command outdented items, we will outdent them starting from the last item, as
				// it is safer.
				if (_this2._indentBy < 0) {
					itemsToChange = itemsToChange.reverse();
				}

				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = itemsToChange[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var item = _step.value;

						var indent = item.getAttribute('indent') + _this2._indentBy;

						// If indent is lower than 0, it means that the item got outdented when it was not indented.
						// This means that we need to convert that list item to paragraph.
						if (indent < 0) {
							// To keep the model as correct as possible, first rename listItem, then remove attributes,
							// as listItem without attributes is very incorrect and will cause problems in converters.
							batch.rename(item, 'paragraph').removeAttribute(item, 'indent').removeAttribute(item, 'type');
						} else {
							// If indent is >= 0, just change the attribute value.
							batch.setAttribute(item, 'indent', indent);
						}
					}
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}
			});
		}

		/**
   * @inheritDoc
   */

	}, {
		key: '_checkEnabled',
		value: function _checkEnabled() {
			// Check whether any of position's ancestor is a list item.
			var listItem = getClosestListItem(this.editor.document.selection.getFirstPosition());

			// If selection is not in a list item, the command is disabled.
			if (!listItem) {
				return false;
			}

			var prev = listItem.previousSibling;
			var oldIndent = listItem.getAttribute('indent');
			var newIndent = oldIndent + this._indentBy;

			if (this._indentBy > 0) {
				// If we are indenting, there are some conditions to meet.
				// Cannot indent first list item.
				if (!prev || prev.name != 'listItem') {
					return false;
				}

				// Indent can be at most greater by one than indent of previous item.
				if (prev.getAttribute('indent') + 1 < newIndent) {
					return false;
				}
			}

			// If we are outdenting it is enough to be in list item. Every list item can always be outdented.
			return true;
		}
	}]);
	return IndentCommand;
}(Command);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * View element class representing list item (`<li>`). It extends {@link engine.view.ContainerElement} and overwrites
 * {@link list.ViewListItemElement#getFillerOffset evaluating whether filler offset} is needed.
 *
 * @memberOf list
 * @extends engine.view.ContainerElement
 */

var ViewListItemElement = function (_ViewContainerElement) {
	inherits(ViewListItemElement, _ViewContainerElement);

	/**
  * Creates `<li>` view item.
  *
  * @param {Object|Iterable} [attrs] Collection of attributes.
  * @param {engine.view.Node|Iterable.<engine.view.Node>} [children] List of nodes to be inserted into created element.
  */
	function ViewListItemElement(attrs, children) {
		classCallCheck(this, ViewListItemElement);
		return possibleConstructorReturn(this, Object.getPrototypeOf(ViewListItemElement).call(this, 'li', attrs, children));
	}

	/**
  * @inheritDoc
  */


	createClass(ViewListItemElement, [{
		key: 'getFillerOffset',
		value: function getFillerOffset() {
			var hasOnlyLists = !this.isEmpty && (this.getChild(0).name == 'ul' || this.getChild(0).name == 'ol');

			return this.isEmpty || hasOnlyLists ? 0 : null;
		}
	}]);
	return ViewListItemElement;
}(ContainerElement);

/**
 * The list indent command. It is used by the {@link list.List list feature}.
 *
 * @memberOf list
 * @namespace list.converters
 */

// Helper function that creates a `<ul><li></li></ul>` structure out of given `modelItem` model `listItem` element.
// Then, it binds created view list item (LI) with model `listItem` element.
// The function then returns created view list item (LI).
function generateLiInUl(modelItem, mapper) {
	var listType = modelItem.getAttribute('type') == 'numbered' ? 'ol' : 'ul';
	var viewItem = new ViewListItemElement();

	var viewList = new ContainerElement(listType, null);
	viewList.appendChildren(viewItem);

	mapper.bindElements(modelItem, viewItem);

	return viewItem;
}

// Helper function that seeks for a sibling of given `modelItem` that is a `listItem` element and meets given criteria.
// `options` object may contain one or more of given values (by default they are `false`):
// `options.getNext` - whether next or previous siblings should be checked (default = previous)
// `options.checkAllSiblings` - whether all siblings or just the first one should be checked (default = only one),
// `options.sameIndent` - whether sought sibling should have same indent (default = no),
// `options.biggerIndent` - whether sought sibling should have bigger indent (default = no).
// Either `options.sameIndent` or `options.biggerIndent` should be set to `true`.
function getSiblingListItem(modelItem, options) {
	var direction = options.getNext ? 'nextSibling' : 'previousSibling';
	var checkAllSiblings = !!options.checkAllSiblings;
	var sameIndent = !!options.sameIndent;
	var biggerIndent = !!options.biggerIndent;

	var indent = modelItem.getAttribute('indent');

	var item = modelItem[direction];

	while (item && item.name == 'listItem') {
		var itemIndent = item.getAttribute('indent');

		if (sameIndent && indent == itemIndent || biggerIndent && indent < itemIndent) {
			return item;
		} else if (!checkAllSiblings || indent > itemIndent) {
			return null;
		}

		item = item[direction];
	}

	return null;
}

// Helper function that takes two parameters, that are expected to be view list elements, and merges them.
// The merge happen only if both parameters are UL or OL elements.
function mergeViewLists(firstList, secondList) {
	if (firstList && secondList && (firstList.name == 'ul' || firstList.name == 'ol') && firstList.name == secondList.name) {
		viewWriter.mergeContainers(Position$1.createAfter(firstList));
	}
}

// Helper function that takes model list item element `modelItem`, corresponding view list item element `injectedItem`
// that is not added to the view and is inside a view list element (`ul` or `ol`) and is that's list only child.
// The list is inserted at correct position (element breaking may be needed) and then merged with it's siblings.
// See comments below to better understand the algorithm.
function injectViewList(modelItem, injectedItem, mapper) {
	var injectedList = injectedItem.parent;

	// 1. Break after previous `listItem` if it has same or bigger indent.
	var prevModelItem = getSiblingListItem(modelItem, { sameIndent: true, biggerIndent: true });

	if (prevModelItem) {
		var viewItem = mapper.toViewElement(prevModelItem);
		var viewPosition = Position$1.createAfter(viewItem);
		viewWriter.breakContainer(viewPosition);
	}

	// 2. Break after closest previous `listItem` sibling with same indent.
	var sameIndentModelItem = getSiblingListItem(modelItem, { sameIndent: true, checkAllSiblings: true });
	// Position between broken lists will be a place where new list is inserted.
	// If there is nothing to break (`sameIndentModelItem` is falsy) it means that converted list item
	// is (will be) the first list item.
	var insertionPosition = void 0;

	if (sameIndentModelItem) {
		var _viewItem = mapper.toViewElement(sameIndentModelItem);
		var _viewPosition = Position$1.createAfter(_viewItem);
		insertionPosition = viewWriter.breakContainer(_viewPosition);
	} else {
		// If there is a list item before converted list item, it means that that list item has lower indent.
		// In such case the created view list should be appended as a child of that item.
		var prevSibling = modelItem.previousSibling;

		if (prevSibling && prevSibling.name == 'listItem') {
			insertionPosition = Position$1.createAt(mapper.toViewElement(prevSibling), 'end');
		} else {
			// This is the very first list item, use position mapping to get correct insertion position.
			insertionPosition = mapper.toViewPosition(Position.createBefore(modelItem));
		}
	}

	// 3. Append new UL/OL in position after breaking in step 2.
	viewWriter.insert(insertionPosition, injectedList);

	// 4. If next sibling is list item with bigger indent, append it's UL/OL to new LI.
	var nextModelItem = getSiblingListItem(modelItem, { getNext: true, biggerIndent: true });
	var nextViewItem = mapper.toViewElement(nextModelItem);

	/* istanbul ignore if */ // Part of code connected with indenting that is not yet complete.
	if (nextViewItem) {
		var sourceRange = Range$2.createOn(nextViewItem.parent);
		var targetPosition = Position$1.createAt(injectedItem, 'end');
		viewWriter.move(sourceRange, targetPosition);
	}

	// 5. Merge new UL/OL with above and below items (ULs/OLs or LIs).
	mergeViewLists(injectedList, injectedList.nextSibling);
	mergeViewLists(injectedList.previousSibling, injectedList);
}

/**
 * Model to view converter for `listItem` model element insertion.
 *
 * It creates `<ul><li></li><ul>` (or `<ol>`) view structure out of `listItem` model element, inserts it at correct
 * position, and merges the list with surrounding lists (if able).
 *
 * @see engine.conversion.ModelConversionDispatcher#event:insert
 * @param {utils.EventInfo} evt Object containing information about the fired event.
 * @param {Object} data Additional information about the change.
 * @param {engine.conversion.ModelConsumable} consumable Values to consume.
 * @param {Object} conversionApi Conversion interface.
 */
function modelViewInsertion(evt, data, consumable, conversionApi) {
	if (!consumable.test(data.item, 'insert') || !consumable.test(data.item, 'addAttribute:type') || !consumable.test(data.item, 'addAttribute:indent')) {
		return;
	}

	consumable.consume(data.item, 'insert');
	consumable.consume(data.item, 'addAttribute:type');
	consumable.consume(data.item, 'addAttribute:indent');

	var modelItem = data.item;
	var viewItem = generateLiInUl(modelItem, conversionApi.mapper);

	injectViewList(modelItem, viewItem, conversionApi.mapper);
}

/**
 * Model to view converter for `type` attribute change on `listItem` model element.
 *
 * This change means that `<li>`s parent changes from `<ul>` to `<ol>` (or vice versa). This is accomplished by breaking
 * view elements, changing their name and merging them.
 *
 * @see engine.conversion.ModelConversionDispatcher#event:changeAttribute
 * @param {utils.EventInfo} evt Object containing information about the fired event.
 * @param {Object} data Additional information about the change.
 * @param {engine.conversion.ModelConsumable} consumable Values to consume.
 * @param {Object} conversionApi Conversion interface.
 */
function modelViewChangeType(evt, data, consumable, conversionApi) {
	if (!consumable.consume(data.item, 'changeAttribute:type')) {
		return;
	}

	var viewItem = conversionApi.mapper.toViewElement(data.item);

	// 1. Break the container after and before the list item.
	// This will create a view list with one view list item -- the one that changed type.
	viewWriter.breakContainer(Position$1.createBefore(viewItem));
	viewWriter.breakContainer(Position$1.createAfter(viewItem));

	// 2. Change name of the view list that holds the changed view item.
	// We cannot just change name property, because that would not render properly.
	var viewList = viewItem.parent;
	var listName = data.attributeNewValue == 'numbered' ? 'ol' : 'ul';
	viewList = viewWriter.rename(viewList, listName);

	// 3. Merge the changed view list with other lists, if possible.
	mergeViewLists(viewList, viewList.nextSibling);
	mergeViewLists(viewList.previousSibling, viewList);
}

/**
 * Model to view converter for `listItem` model element remove.
 *
 * @see engine.conversion.ModelConversionDispatcher#event:remove
 * @param {utils.EventInfo} evt Object containing information about the fired event.
 * @param {Object} data Additional information about the change.
 * @param {engine.conversion.ModelConsumable} consumable Values to consume.
 * @param {Object} conversionApi Conversion interface.
 */
function modelViewRemove(evt, data, consumable, conversionApi) {
	if (!consumable.consume(data.item, 'remove')) {
		return;
	}

	var viewItem = conversionApi.mapper.toViewElement(data.item);

	// 1. Break the container after and before the list item.
	// This will create a view list with one view list item -- the one that changed type.
	viewWriter.breakContainer(Position$1.createBefore(viewItem));
	viewWriter.breakContainer(Position$1.createAfter(viewItem));

	// 2. Remove the UL that contains just the removed LI.
	var viewList = viewItem.parent;
	viewWriter.remove(Range$2.createOn(viewList));
}

/**
 * Model to view converter for `listItem` model element move.
 *
 * @see engine.conversion.ModelConversionDispatcher#event:move
 * @param {utils.EventInfo} evt Object containing information about the fired event.
 * @param {Object} data Additional information about the change.
 * @param {engine.conversion.ModelConsumable} consumable Values to consume.
 * @param {Object} conversionApi Conversion interface.
 */
function modelViewMove(evt, data, consumable, conversionApi) {
	if (!consumable.consume(data.item, 'move')) {
		return;
	}

	var viewItem = conversionApi.mapper.toViewElement(data.item);

	// 1. Break the container after and before the list item.
	// This will create a view list with one view list item -- the one that changed type.
	viewWriter.breakContainer(Position$1.createBefore(viewItem));
	viewWriter.breakContainer(Position$1.createAfter(viewItem));

	// 2. Extract view list with changed view list item and merge "hole" possibly created by breaking and removing elements.
	var viewList = viewItem.parent;
	var viewListPrev = viewList.previousSibling;
	var viewListNext = viewList.nextSibling;

	var insertionPosition = conversionApi.mapper.toViewPosition(data.targetPosition);

	if (insertionPosition.parent.name == 'ol' || insertionPosition.parent.name == 'ul') {
		insertionPosition = viewWriter.breakContainer(insertionPosition);
	}

	viewWriter.move(Range$2.createOn(viewList), insertionPosition);

	// No worries, merging will happen only if both elements exist and they are same type of lists.
	mergeViewLists(viewListPrev, viewListNext);
	mergeViewLists(viewList, viewList.nextSibling);
	mergeViewLists(viewList.previousSibling, viewList);
}

/**
 * Model to view converter for `indent` attribute change on `listItem` model element.
 *
 * @see engine.conversion.ModelConversionDispatcher#event:changeAttribute
 * @param {utils.EventInfo} evt Object containing information about the fired event.
 * @param {Object} data Additional information about the change.
 * @param {engine.conversion.ModelConsumable} consumable Values to consume.
 * @param {Object} conversionApi Conversion interface.
 */
function modelViewChangeIndent(evt, data, consumable, conversionApi) {
	/* istanbul ignore if */ // Part of code connected with indenting that is not yet complete.
	if (!consumable.consume(data.item, 'changeAttribute:indent')) {
		return;
	}

	var viewItem = conversionApi.mapper.toViewElement(data.item);

	// 1. Break the container after and before the list item.
	// This will create a view list with one view list item -- the one that changed type.
	viewWriter.breakContainer(Position$1.createBefore(viewItem));
	viewWriter.breakContainer(Position$1.createAfter(viewItem));

	// 2. Extract view list with changed view list item and merge "hole" possibly created by breaking and removing elements.
	var viewList = viewItem.parent;
	var viewListPrev = viewList.previousSibling;

	viewWriter.remove(Range$2.createOn(viewList));

	// If there is no `viewListPrev` it means that the first item was indented which is an error.
	mergeViewLists(viewListPrev, viewListPrev.nextSibling);

	// 3. Inject view list like it is newly inserted.
	injectViewList(data.item, viewItem, conversionApi.mapper);
}

/**
 * A special model to view converter introduced by {@link list.List List feature}. This converter is fired for
 * insert change of every model item, and should be fired before actual converter. The converter checks whether inserted
 * model item is a non-`listItem` element. If it is, and it is inserted inside a view list, the converter breaks the
 * list so the model element is inserted to the view parent element corresponding to its model parent element.
 *
 * The converter prevents such situations:
 *
 *		// Model:                        // View:
 *		<listItem>foo</listItem>         <ul>
 *		<listItem>bar</listItem>             <li>foo</li>
 *		                                     <li>bar</li>
 *		                                 </ul>
 *
 *		// After change:                 // Correct view guaranteed by this converter:
 *		<listItem>foo</listItem>         <ul><li>foo</li></ul><p>xxx</p><ul><li>bar</li></ul>
 *		<paragraph>xxx</paragraph>       // Instead of this wrong view state:
 *		<listItem>bar</listItem>         <ul><li>foo</li><p>xxx</p><li>bar</li></ul>
 *
 * @see engine.conversion.ModelConversionDispatcher#event:insert
 * @param {utils.EventInfo} evt Object containing information about the fired event.
 * @param {Object} data Additional information about the change.
 * @param {engine.conversion.ModelConsumable} consumable Values to consume.
 * @param {Object} conversionApi Conversion interface.
 */
function modelViewSplitOnInsert(evt, data, consumable, conversionApi) {
	if (data.item.name != 'listItem') {
		var viewPosition = conversionApi.mapper.toViewPosition(data.range.start);

		// Break multiple ULs/OLs if there are.
		while (viewPosition.parent.name == 'ul' || viewPosition.parent.name == 'ol') {
			viewPosition = viewWriter.breakContainer(viewPosition);

			/* istanbul ignore else */ // Part of code connected with indenting that is not yet complete.
			if (viewPosition.parent.parent === null) {
				break;
			}

			/* istanbul ignore next */ // Part of code connected with indenting that is not yet complete.
			viewPosition = Position$1.createBefore(viewPosition.parent);
		}
	}
}

/**
 * A special model to view converter introduced by {@link list.List List feature}. This converter takes care of
 * merging view lists after something is removed or moved from near them.
 *
 * Example:
 *
 *		// Model:                        // View:
 *		<listItem>foo</listItem>         <ul><li>foo</li></ul>
 *		<paragraph>xxx</paragraph>       <p>xxx</p>
 *		<listItem>bar</listItem>         <ul><li>bar</li></ul>
 *
 *		// After change:                 // Correct view guaranteed by this converter:
 *		<listItem>foo</listItem>         <ul>
 *		<listItem>bar</listItem>             <li>foo</li>
 *		                                     <li>bar</li>
 *		                                 </ul>
 *
 * @see engine.conversion.ModelConversionDispatcher#event:remove
 * @see engine.conversion.ModelConversionDispatcher#event:move
 * @param {utils.EventInfo} evt Object containing information about the fired event.
 * @param {Object} data Additional information about the change.
 * @param {engine.conversion.ModelConsumable} consumable Values to consume.
 * @param {Object} conversionApi Conversion interface.
 */
function modelViewMergeAfter(evt, data, consumable, conversionApi) {
	var viewPosition = conversionApi.mapper.toViewPosition(data.sourcePosition);
	var viewItemPrev = viewPosition.nodeBefore;
	var viewItemNext = viewPosition.nodeAfter;

	// Merge lists if something (remove, move) was done from inside of list.
	// Merging will be done only if both items are view lists of the same type.
	// The check is done inside the helper function.
	mergeViewLists(viewItemPrev, viewItemNext);
}

/**
 * View to model converter that converts view `<li>` elements into `listItem` model elements.
 *
 * To set correct values of `type` and `indent` attribute the converter:
 * * checks `<li>`'s parent,
 * * passes `data.indent` value when `<li>`'s sub-items are converted.
 *
 * @see engine.conversion.ViewConversionDispatcher#event:element
 * @param {utils.EventInfo} evt Object containing information about the fired event.
 * @param {Object} data Object containing conversion input and a placeholder for conversion output and possibly other values.
 * @param {engine.conversion.ViewConsumable} consumable Values to consume.
 * @param {Object} conversionApi Conversion interface to be used by callback.
 */
function viewModelConverter(evt, data, consumable, conversionApi) {
	if (consumable.consume(data.input, { name: true })) {
		// 1. Create `listItem` model element.
		var listItem = new Element('listItem');

		// 2. Handle `listItem` model element attributes.
		data.indent = data.indent ? data.indent : 0;

		var type = data.input.parent.name == 'ul' ? 'bulleted' : 'numbered';
		listItem.setAttribute('type', type);
		listItem.setAttribute('indent', data.indent);

		// 3. Handle `<li>` children.
		data.context.push(listItem);

		// `listItem`s created recursievly should have bigger indent.
		data.indent++;

		// `listItem`s will be kept in flat structure.
		var items = [listItem];

		// Check all children of the converted `<li>`.
		// At this point we assume there are no "whitespace" view text nodes in view list, between view list items.
		// This should be handled by `<ul>` and `<ol>` converters.
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = data.input.getChildren()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var child = _step.value;

				// Let's convert the child.
				var converted = conversionApi.convertItem(child, consumable, data);

				// If this is a view list element, we will convert it and concat the result (`listItem` model elements)
				// with already gathered results (in `items` array). `converted` should be a `ModelDocumentFragment`.
				if (child.name == 'ul' || child.name == 'ol') {
					items = items.concat(Array.from(converted.getChildren()));
				}
				// If it was not a list it was a "regular" list item content. Just append it to `listItem`.
				else {
						listItem.appendChildren(converted);
					}
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}

		data.indent--;
		data.context.pop();

		/* istanbul ignore next */ // Part of code connected with indenting that is not yet complete.
		data.output = data.output ? data.output.concat(items) : items;
	}
}

/**
 * View to model converter for `<ul>` and `<ol>` view elements, that cleans the input view out of garbage.
 * This is mostly to clean white spaces from between `<li>` view elements inside the view list element, however also
 * incorrect data can be cleared if the view was incorrect.
 *
 * @see engine.conversion.ViewConversionDispatcher#event:element
 * @param {utils.EventInfo} evt Object containing information about the fired event.
 * @param {Object} data Object containing conversion input and a placeholder for conversion output and possibly other values.
 * @param {engine.conversion.ViewConsumable} consumable Values to consume.
 */
function cleanList(evt, data, consumable) {
	if (consumable.test(data.input, { name: true })) {
		// Caching children because when we start removing them iterating fails.
		var children = Array.from(data.input.getChildren());

		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var child = _step2.value;

				if (!child.name || child.name != 'li') {
					child.remove();
				}
			}
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}
	}
}

/**
 * Callback for model position to view position mapping for {@link engine.conversion.Mapper}. The callback fixes positions
 * between `listItem` elements, that would be incorrectly mapped because of how list items are represented in model
 * and view.
 *
 * @see engine.conversion.Mapper#event:modelToViewPosition
 * @param {utils.EventInfo} evt Object containing information about the fired event.
 * @param {Object} data Object containing additional data and placeholder for mapping result.
 */
function modelToViewPosition(evt, data) {
	var modelPosition = data.modelPosition;
	var mapper = data.mapper;
	var nodeAfter = modelPosition.nodeAfter;

	// `listItem` elements are mapped with view, so positions inside them will be correctly mapped by default algorithm.
	// Problem are positions between `listItem`s because they are incorrectly mapped to inside `<li>`. This is
	// because of how view-to-model lengths work. What is important is that if a position is before a `listItem` and
	// it is not a first `listItem`, the position has to be placed before corresponding `<li>`. If this is the first
	// `listItem` position has to be before `<ul>` (this is default behavior).
	if (nodeAfter && nodeAfter.name == 'listItem') {
		var viewNode = mapper.toViewElement(nodeAfter);

		if (viewNode && viewNode.index !== 0) {
			data.viewPosition = Position$1.createBefore(viewNode);

			evt.stop();
		}
	}
}

/**
 * Callback for view position to model position mapping for {@link engine.conversion.Mapper}. The callback fixes positions
 * between `<li>` elements, that would be incorrectly mapped because of how list items are represented in model
 * and view.
 *
 * @see engine.conversion.Mapper#event:viewToModelPosition
 * @param {utils.EventInfo} evt Object containing information about the fired event.
 * @param {Object} data Object containing additional data and placeholder for mapping result.
 */
function viewToModelPosition(evt, data) {
	var viewPosition = data.viewPosition;
	var mapper = data.mapper;
	var nodeAfter = viewPosition.nodeAfter;
	var nodeBefore = viewPosition.nodeBefore;

	var modelNode = void 0;

	if (nodeAfter) {
		if (nodeAfter.name == 'ul' || nodeAfter.name == 'ol') {
			// If the position is before view list, model position should be placed before `listItem`
			// that is bound to the first `<li>` of that view list.
			// Default algorithm would work like this but only for top-level list.
			modelNode = mapper.toModelElement(nodeAfter.getChild(0));
		} else if (nodeAfter.name == 'li') {
			// If the position is before view list item, just place model position before bound `listItem` element.
			modelNode = mapper.toModelElement(nodeAfter);
		}

		if (modelNode) {
			data.modelPosition = Position.createBefore(modelNode);
		}
	} else if (nodeBefore) {
		var viewNode = void 0;

		// Find `<li>` after which we want to place position.
		// We want to find a `<li>` that will be mapped to model `listItem` element. That `listItem` will
		// be used as a reference point to evaluate model position.
		/* istanbul ignore if */ // Part of code connected with indenting that is not yet complete.
		if (nodeBefore.name == 'ul' || nodeBefore.name == 'ol') {
			// If the position is before view list, take the last `<li>` of that view list.
			viewNode = nodeBefore.getChild(nodeBefore.childCount - 1);
		} else if (nodeBefore.name == 'li') {
			// If the position is before view list item, take that `<li>`.
			viewNode = nodeBefore;
		}

		// Evaluate correct model position.
		// At this stage we have a `<li>`. This `<li>` may have nested `<li>`s inside. We will use `mapper`
		// to obtain this `<li>`'s model length. Placing model position after that `<li>` will be done
		// by placing it before the bound `listItem` and moving by offset equal to `<li>`s length.
		if (viewNode) {
			modelNode = mapper.toModelElement(viewNode);
			var offset = mapper.getModelLength(viewNode);

			data.modelPosition = Position.createBefore(modelNode).getShiftedBy(offset);
		}
	}

	// If we found a model position, stop the event.
	if (data.modelPosition !== null) {
		evt.stop();
	}
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The engine of the lists feature. It handles creating, editing and removing lists and list items.
 * It registers the `numberedList`, `bulletedList`, `indentList` and `outdentList` commands.
 *
 * @memberOf list
 * @extends core.Feature
 */

var ListEngine = function (_Feature) {
	inherits(ListEngine, _Feature);

	function ListEngine() {
		classCallCheck(this, ListEngine);
		return possibleConstructorReturn(this, Object.getPrototypeOf(ListEngine).apply(this, arguments));
	}

	createClass(ListEngine, [{
		key: 'init',

		/**
   * @inheritDoc
   */
		value: function init() {
			var editor = this.editor;

			// Schema.
			var schema = editor.document.schema;
			schema.registerItem('listItem', '$block');
			schema.allow({
				name: 'listItem',
				inside: '$root',
				attributes: ['type', 'indent']
			});
			schema.requireAttributes('listItem', ['type', 'indent']);

			// Converters.
			var data = editor.data;
			var editing = editor.editing;

			editing.mapper.on('modelToViewPosition', modelToViewPosition);
			editing.mapper.on('viewToModelPosition', viewToModelPosition);
			data.mapper.on('modelToViewPosition', modelToViewPosition);

			editing.modelToView.on('insert', modelViewSplitOnInsert, { priority: 'high' });
			editing.modelToView.on('insert:listItem', modelViewInsertion);
			data.modelToView.on('insert', modelViewSplitOnInsert, { priority: 'high' });
			data.modelToView.on('insert:listItem', modelViewInsertion);

			// Only change converter is needed. List item's type attribute is required, so it's adding is handled when
			// list item is added and you cannot remove it.
			editing.modelToView.on('changeAttribute:type:listItem', modelViewChangeType);
			data.modelToView.on('changeAttribute:type:listItem', modelViewChangeType);

			editing.modelToView.on('remove:listItem', modelViewRemove);
			editing.modelToView.on('remove', modelViewMergeAfter, { priority: 'low' });
			data.modelToView.on('remove:listItem', modelViewRemove);
			data.modelToView.on('remove', modelViewMergeAfter, { priority: 'low' });

			editing.modelToView.on('move:listItem', modelViewMove);
			editing.modelToView.on('move', modelViewMergeAfter, { priority: 'low' });
			data.modelToView.on('move:listItem', modelViewMove);
			data.modelToView.on('move', modelViewMergeAfter, { priority: 'low' });

			editing.modelToView.on('changeAttribute:indent:listItem', modelViewChangeIndent);
			data.modelToView.on('changeAttribute:indent:listItem', modelViewChangeIndent);

			data.viewToModel.on('element:li', viewModelConverter);
			data.viewToModel.on('element:ul', cleanList, { priority: 'high' });
			data.viewToModel.on('element:ol', cleanList, { priority: 'high' });

			// Register commands for numbered and bulleted list.
			editor.commands.set('numberedList', new ListCommand(editor, 'numbered'));
			editor.commands.set('bulletedList', new ListCommand(editor, 'bulleted'));

			// Register commands for indenting.
			editor.commands.set('indentList', new IndentCommand(editor, 'forward'));
			editor.commands.set('outdentList', new IndentCommand(editor, 'backward'));
		}
	}]);
	return ListEngine;
}(Feature);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The lists feature. It introduces the `numberedList` and `bulletedList` buttons which
 * allows to convert paragraphs to/from list items and indent/outdent them.
 *
 * See also {@link list.ListEngine}.
 *
 * @memberOf list
 * @extends core.Feature
 */

var List$1 = function (_Feature) {
	inherits(List, _Feature);

	function List() {
		classCallCheck(this, List);
		return possibleConstructorReturn(this, Object.getPrototypeOf(List).apply(this, arguments));
	}

	createClass(List, [{
		key: 'init',


		/**
   * @inheritDoc
   */
		value: function init() {
			var _this2 = this;

			// Create two buttons and link them with numberedList and bulletedList commands.
			var t = this.editor.t;
			this._addButton('numberedList', t('Numbered List'));
			this._addButton('bulletedList', t('Bulleted List'));

			// Overwrite default enter key behavior.
			// If enter key is pressed with selection collapsed in empty list item, outdent it instead of breaking it.
			this.listenTo(this.editor.editing.view, 'enter', function (evt, data) {
				var doc = _this2.editor.document;
				var positionParent = doc.selection.getLastPosition().parent;

				if (doc.selection.isCollapsed && positionParent.name == 'listItem' && positionParent.isEmpty) {
					_this2.editor.execute('outdentList');

					data.preventDefault();
					evt.stop();
				}
			});

			// Add tab key support.
			// When in list item, pressing tab should indent list item, if possible.
			// Pressing shift + tab shout outdent list item.
			this.listenTo(this.editor.editing.view, 'keydown', function (evt, data) {
				var commandName = null;

				if (data.keystroke == parseKeystroke('tab')) {
					commandName = 'indentList';
				} else if (data.keystroke == parseKeystroke('Shift+tab')) {
					commandName = 'outdentList';
				}

				if (commandName) {
					var command = _this2.editor.commands.get(commandName);

					if (command.isEnabled) {
						_this2.editor.execute(commandName);

						data.preventDefault();
						evt.stop();
					}
				}
			});
		}

		/**
   * Helper method for initializing a button and linking it with an appropriate command.
   *
   * @private
   * @param {String} commandName Name of the command.
   * @param {Object} label Button label.
   */

	}, {
		key: '_addButton',
		value: function _addButton(commandName, label) {
			var editor = this.editor;
			var command = editor.commands.get(commandName);

			// Create button model.
			var buttonModel = new Model({
				isEnabled: true,
				isOn: false,
				label: label,
				icon: commandName.toLowerCase()
			});

			// Bind button model to command.
			buttonModel.bind('isOn', 'isEnabled').to(command, 'value', 'isEnabled');

			// Execute command.
			this.listenTo(buttonModel, 'execute', function () {
				return editor.execute(commandName);
			});

			// Add button to feature components.
			editor.ui.featureComponents.add(commandName, Button, ButtonView, buttonModel);
		}
	}], [{
		key: 'requires',

		/**
   * @inheritDoc
   */
		get: function get() {
			return [ListEngine];
		}
	}]);
	return List;
}(Feature);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Returns the number of items return by the iterator.
 *
 *		count( [ 1, 2, 3, 4, 5 ] ); // 5;
 *
 * @memberOf utils
 * @param {Iterable.<*>} iterator Any iterator.
 * @returns {Number} Number of items returned by that iterator.
 */
function count(iterator) {
  var count = 0;

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = iterator[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _ = _step.value;
      // jshint ignore:line
      count++;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return count;
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Change buffer allows to group atomic changes (like characters that have been typed) into
 * {@link engine.treeModel.batch.Batch batches}.
 *
 * Batches represent single undo steps, hence changes added to one single batch are undone together.
 *
 * The buffer has a configurable limit of atomic changes that it can accommodate. After the limit was
 * exceeded (see {@link typing.ChangeBuffer#input}), a new batch is created in {@link typing.ChangeBuffer#batch}.
 *
 * To use the change buffer you need to let it know about the number of changes that were added to the batch:
 *
 *		const buffer = new ChangeBuffer( document, LIMIT );
 *
 *		// Later on in your feature:
 *		buffer.batch.insert( pos, insertedCharacters );
 *		buffer.input( insertedCharacters.length );
 *
 * @memberOf typing
 */

var ChangeBuffer = function () {
	/**
  * Creates a new instance of the change buffer.
  *
  * @param {engine.treeModel.Document} document
  * @param {Number} [limit=20] The maximum number of atomic changes which can be contained in one batch.
  */
	function ChangeBuffer(doc) {
		var _this = this;

		var limit = arguments.length <= 1 || arguments[1] === undefined ? 20 : arguments[1];
		classCallCheck(this, ChangeBuffer);

		/**
   * The document instance.
   *
   * @readonly
   * @property {engine.treeModel.Document} typing.ChangeBuffer#document
   */
		this.document = doc;

		/**
   * The number of atomic changes in the buffer. Once it exceeds the {@link typing.ChangeBuffer#limit},
   * the {@link typing.ChangeBuffer#batch batch} is set to a new one.
   *
   * @readonly
   * @property {Number} typing.ChangeBuffer#size
   */
		this.size = 0;

		/**
   * The maximum number of atomic changes which can be contained in one batch.
   *
   * @readonly
   * @property {Number} typing.ChangeBuffer#limit
   */
		this.limit = limit;

		this._changeCallback = function (evt, type, changes, batch) {
			_this._onBatch(batch);
		};

		doc.on('change', this._changeCallback);

		/**
   * The current batch instance.
   *
   * @private
   * @property typing.ChangeBuffer#_batch
   */

		/**
   * The callback to document the change event which later needs to be removed.
   *
   * @private
   * @property typing.ChangeBuffer#_changeCallback
   */
	}

	/**
  * The current batch to which a feature should add its deltas. Once the {@link typing.ChangeBuffer#size}
  * is reached or exceeds the {@link typing.ChangeBuffer#limit}, the batch is set to a new instance and the size is reset.
  *
  * @type {engine.treeModel.batch.Batch}
  */


	createClass(ChangeBuffer, [{
		key: 'input',


		/**
   * The input number of changes into the buffer. Once the {@link typing.ChangeBuffer#size} is
   * reached or exceeds the {@link typing.ChangeBuffer#limit}, the batch is set to a new instance and the size is reset.
   *
   * @param {Number} changeCount The number of atomic changes to input.
   */
		value: function input(changeCount) {
			this.size += changeCount;

			if (this.size >= this.limit) {
				this._reset();
			}
		}

		/**
   * Destroys the buffer.
   */

	}, {
		key: 'destroy',
		value: function destroy() {
			this.document.off('change', this._changeCallback);
		}

		/**
   * The method to be called in order to notify the buffer about batches which appeared in the document.
   * The method will check whether it is a new batch and in that case the buffer will be flushed.
   *
   * The reason why the buffer needs to be flushed whenever a new batch appears is that the changes added afterwards
   * should be added to a new batch. For instance, when the  user types, then inserts an image, and then types again,
   * the characters typed after inserting the image should be added to a different batch than the characters typed before.
   *
   * @private
   * @param {engine.treeModel.batch.Batch} batch The batch which appears in the document.
   */

	}, {
		key: '_onBatch',
		value: function _onBatch(batch) {
			// One operation means a newly created batch.
			if (batch.type != 'transparent' && batch !== this._batch && count(batch.getOperations()) <= 1) {
				this._reset();
			}
		}

		/**
   * Resets the change buffer.
   *
   * @private
   */

	}, {
		key: '_reset',
		value: function _reset() {
			this._batch = null;
			this.size = 0;
		}
	}, {
		key: 'batch',
		get: function get() {
			if (!this._batch) {
				this._batch = this.document.batch();
			}

			return this._batch;
		}
	}]);
	return ChangeBuffer;
}();

/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Creates a set of changes which need to be applied to the input in order to transform
 * it into the output. This function can be used with strings or arrays.
 *
 *		const input = Array.from( 'abc' );
 *		const output = Array.from( 'xaby' );
 *		const changes = diffToChanges( diff( input, output ), output );
 *
 *		changes.forEach( change => {
 *			if ( change.type == 'insert' ) {
 *				input.splice( change.index, 0, ...change.values );
 *			} else if ( change.type == 'delete' ) {
 *				input.splice( change.index, change.howMany );
 *			}
 *		} );
 *
 *		input.join( '' ) == output.join( '' ); // -> true
 *
 * @method utils.diffToChanges
 * @param {Array.<'equal'|'insert'|'delete'>} diff Result of {@link utils.diff}.
 * @param {String|Array} output The string or array which was passed as diff's output.
 * @returns {Array.<Object>} Set of changes (insert or delete) which need to be applied to the input
 * in order to transform it into the output.
 */
function diffToChanges(diff, output) {
	var changes = [];
	var index = 0;
	var lastOperation = void 0;

	diff.forEach(function (change) {
		if (change == 'equal') {
			pushLast();

			index++;
		} else if (change == 'insert') {
			if (isContinuationOf('insert')) {
				lastOperation.values.push(output[index]);
			} else {
				pushLast();

				lastOperation = {
					type: 'insert',
					index: index,
					values: [output[index]]
				};
			}

			index++;
		} else /* if ( change == 'delete' ) */{
				if (isContinuationOf('delete')) {
					lastOperation.howMany++;
				} else {
					pushLast();

					lastOperation = {
						type: 'delete',
						index: index,
						howMany: 1
					};
				}
			}
	});

	pushLast();

	return changes;

	function pushLast() {
		if (lastOperation) {
			changes.push(lastOperation);
			lastOperation = null;
		}
	}

	function isContinuationOf(expected) {
		return lastOperation && lastOperation.type == expected;
	}
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Handles text input coming from the keyboard or other input methods.
 *
 * @memberOf typing
 * @extends core.Feature
 */

var Input = function (_Feature) {
	inherits(Input, _Feature);

	function Input() {
		classCallCheck(this, Input);
		return possibleConstructorReturn(this, Object.getPrototypeOf(Input).apply(this, arguments));
	}

	createClass(Input, [{
		key: 'init',

		/**
   * @inheritDoc
   */
		value: function init() {
			var _this2 = this;

			var editor = this.editor;
			var editingView = editor.editing.view;

			/**
    * Typing's change buffer used to group subsequent changes into batches.
    *
    * @protected
    * @member {typing.ChangeBuffer} typing.Input#_buffer
    */
			this._buffer = new ChangeBuffer(editor.document, editor.config.get('typing.undoStep') || 20);

			// TODO The above default configuration value should be defined using editor.config.define() once it's fixed.

			this.listenTo(editingView, 'keydown', function (evt, data) {
				_this2._handleKeydown(data);
			}, { priority: 'lowest' });

			this.listenTo(editingView, 'mutations', function (evt, mutations, viewSelection) {
				_this2._handleMutations(mutations, viewSelection);
			});
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'destroy',
		value: function destroy() {
			get(Object.getPrototypeOf(Input.prototype), 'destroy', this).call(this);

			this._buffer.destroy();
			this._buffer = null;
		}

		/**
   * Handles the keydown event. We need to guess whether such keystroke is going to result
   * in typing. If so, then before character insertion happens, any selected content needs
   * to be deleted. Otherwise the default browser deletion mechanism would be
   * triggered, resulting in:
   *
   * * Hundreds of mutations which could not be handled.
   * * But most importantly, loss of control over how the content is being deleted.
   *
   * The method is used in a low-priority listener, hence allowing other listeners (e.g. delete or enter features)
   * to handle the event.
   *
   * @private
   * @param {engine.view.observer.keyObserver.KeyEventData} evtData
   */

	}, {
		key: '_handleKeydown',
		value: function _handleKeydown(evtData) {
			var _this3 = this;

			var doc = this.editor.document;

			if (isSafeKeystroke(evtData) || doc.selection.isCollapsed) {
				return;
			}

			doc.enqueueChanges(function () {
				doc.composer.deleteContents(_this3._buffer.batch, doc.selection);
			});
		}

		/**
   * Handles DOM mutations.
   *
   * @param {Array.<engine.view.Document~MutatatedText|engine.view.Document~MutatatedChildren>} mutations
   */

	}, {
		key: '_handleMutations',
		value: function _handleMutations(mutations, viewSelection) {
			var doc = this.editor.document;
			var handler = new MutationHandler(this.editor.editing, this._buffer);

			doc.enqueueChanges(function () {
				return handler.handle(mutations, viewSelection);
			});
		}
	}]);
	return Input;
}(Feature);

var MutationHandler = function () {
	/**
  * Creates an instance of the mutation handler.
  *
  * @param {engine.controller.EditingController} editing
  * @param {typing.ChangeBuffer} buffer
  */
	function MutationHandler(editing, buffer) {
		classCallCheck(this, MutationHandler);

		/**
   * The editing controller.
   *
   * @member {engine.controller.EditingController} typing.Input.MutationHandler#editing
   */
		this.editing = editing;

		/**
   * The change buffer.
   *
   * @member {engine.controller.EditingController} typing.Input.MutationHandler#buffer
   */
		this.buffer = buffer;

		/**
   * The number of inserted characters which need to be fed to the {@link #buffer change buffer}
   * on {@link #commit}.
   *
   * @member {Number} typing.Input.MutationHandler#insertedCharacterCount
   */
		this.insertedCharacterCount = 0;
	}

	/**
  * Handles given mutations.
  *
  * @param {Array.<engine.view.Document~MutatatedText|engine.view.Document~MutatatedChildren>} mutations
  */


	createClass(MutationHandler, [{
		key: 'handle',
		value: function handle(mutations, viewSelection) {
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = mutations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var mutation = _step.value;

					// Fortunately it will never be both.
					this._handleTextMutation(mutation, viewSelection);
					this._handleTextNodeInsertion(mutation);
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			this.buffer.input(Math.max(this.insertedCharacterCount, 0));
		}
	}, {
		key: '_handleTextMutation',
		value: function _handleTextMutation(mutation, viewSelection) {
			if (mutation.type != 'text') {
				return;
			}

			// Replace &nbsp; inserted by the browser with normal space.
			// We want only normal spaces in the model and in the view. Renderer and DOM Converter will be then responsible
			// for rendering consecutive spaces using &nbsp;, but the model and the view has to be clear.
			// Other feature may introduce inserting non-breakable space on specific key stroke (for example shift + space).
			// However then it will be handled outside of mutations, like enter key is.
			// The replacing is here because it has to be done before `diff` and `diffToChanges` functions, as they
			// take `newText` and compare it to (cleaned up) view.
			// It could also be done in mutation observer too, however if any outside plugin would like to
			// introduce additional events for mutations, they would get already cleaned up version (this may be good or not).
			var newText = mutation.newText.replace(/\u00A0/g, ' ');
			// To have correct `diffResult`, we also compare view node text data with &nbsp; replaced by space.
			var oldText = mutation.oldText.replace(/\u00A0/g, ' ');

			var diffResult = diff(oldText, newText);

			// Index where the first change happens. Used to set the position from which nodes will be removed and where will be inserted.
			var firstChangeAt = null;
			// Index where the last change happens. Used to properly count how many characters have to be removed and inserted.
			var lastChangeAt = null;

			// Get `firstChangeAt` and `lastChangeAt`.
			for (var i = 0; i < diffResult.length; i++) {
				var change = diffResult[i];

				if (change != 'equal') {
					firstChangeAt = firstChangeAt === null ? i : firstChangeAt;
					lastChangeAt = i;
				}
			}

			// How many characters, starting from `firstChangeAt`, should be removed.
			var deletions = 0;
			// How many characters, starting from `firstChangeAt`, should be inserted (basing on mutation.newText).
			var insertions = 0;

			for (var _i = firstChangeAt; _i <= lastChangeAt; _i++) {
				// If there is no change (equal) or delete, the character is existing in `oldText`. We count it for removing.
				if (diffResult[_i] != 'insert') {
					deletions++;
				}

				// If there is no change (equal) or insert, the character is existing in `newText`. We count it for inserting.
				if (diffResult[_i] != 'delete') {
					insertions++;
				}
			}

			// Try setting new model selection according to passed view selection.
			var modelSelectionPosition = null;

			if (viewSelection) {
				modelSelectionPosition = this.editing.mapper.toModelPosition(viewSelection.anchor);
			}

			// Get the position in view and model where the changes will happen.
			var viewPos = new Position$1(mutation.node, firstChangeAt);
			var modelPos = this.editing.mapper.toModelPosition(viewPos);

			// Remove appropriate number of characters from the model text node.
			if (deletions > 0) {
				var removeRange = Range$1.createFromPositionAndShift(modelPos, deletions);
				this._remove(removeRange, deletions);
			}

			// Insert appropriate characters basing on `mutation.text`.
			var insertedText = mutation.newText.substr(firstChangeAt, insertions);
			this._insert(modelPos, insertedText);

			// If there was `viewSelection` and it got correctly mapped, collapse selection at found model position.
			if (modelSelectionPosition) {
				this.editing.model.selection.collapse(modelSelectionPosition);
			}
		}
	}, {
		key: '_handleTextNodeInsertion',
		value: function _handleTextNodeInsertion(mutation) {
			if (mutation.type != 'children') {
				return;
			}

			// One new node.
			if (mutation.newChildren.length - mutation.oldChildren.length != 1) {
				return;
			}

			// Which is text.
			var diffResult = diff(mutation.oldChildren, mutation.newChildren, compareChildNodes);
			var changes = diffToChanges(diffResult, mutation.newChildren);

			// In case of [ delete, insert, insert ] the previous check will not exit.
			if (changes.length > 1) {
				return;
			}

			var change = changes[0];

			// Which is text.
			if (!(change.values[0] instanceof Text$2)) {
				return;
			}

			var viewPos = new Position$1(mutation.node, change.index);
			var modelPos = this.editing.mapper.toModelPosition(viewPos);
			var insertedText = change.values[0].data;

			// Replace &nbsp; inserted by the browser with normal space.
			// See comment in `_handleTextMutation`.
			// In this case we don't need to do this before `diff` because we diff whole nodes.
			// Just change &nbsp; in case there are some.
			insertedText = insertedText.replace(/\u00A0/g, ' ');

			this._insert(modelPos, insertedText);

			this.editing.model.selection.collapse(modelPos.parent, 'end');
		}
	}, {
		key: '_insert',
		value: function _insert(position, text) {
			this.buffer.batch.weakInsert(position, text);

			this.insertedCharacterCount += text.length;
		}
	}, {
		key: '_remove',
		value: function _remove(range, length) {
			this.buffer.batch.remove(range);

			this.insertedCharacterCount -= length;
		}
	}]);
	return MutationHandler;
}();

var safeKeycodes = [getCode('arrowUp'), getCode('arrowRight'), getCode('arrowDown'), getCode('arrowLeft'), 16, // Shift
17, // Ctrl
18, // Alt
20, // CapsLock
27, // Escape
33, // PageUp
34, // PageDown
35, // Home
36];

// Function keys.
for (var code = 112; code <= 135; code++) {
	safeKeycodes.push(code);
}

// Returns `true` if a keystroke should not cause any content change caused by "typing".
//
// Note: This implementation is very simple and will need to be refined with time.
//
// @param {engine.view.observer.keyObserver.KeyEventData} keyData
// @returns {Boolean}
function isSafeKeystroke(keyData) {
	// Keystrokes which contain Ctrl don't represent typing.
	if (keyData.ctrlKey) {
		return true;
	}

	return safeKeycodes.includes(keyData.keyCode);
}

// Helper function that compares whether two given view nodes are same. It is used in `diff` when it's passed an array
// with child nodes.
function compareChildNodes(oldChild, newChild) {
	if (oldChild instanceof Text$2 && newChild instanceof Text$2) {
		return oldChild.data === newChild.data;
	} else {
		return oldChild === newChild;
	}
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The delete command. Used by the {@link typing.Delete delete feature} to handle the <kbd>Delete</kbd> and
 * <kbd>Backspace</kbd> keys.
 *
 * @member typing
 * @extends core.command.Command
 */

var DeleteCommand = function (_Command) {
	inherits(DeleteCommand, _Command);

	/**
  * Creates an instance of the command.
  *
  * @param {core.editor.Editor} editor
  * @param {'forward'|'backward'} direction The directionality of the delete describing in what direction it
  * should consume the content when the selection is collapsed.
  */
	function DeleteCommand(editor, direction) {
		classCallCheck(this, DeleteCommand);

		/**
   * The directionality of the delete describing in what direction it should
   * consume the content when the selection is collapsed.
   *
   * @readonly
   * @member {'forward'|'backward'} typing.DeleteCommand#direction
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(DeleteCommand).call(this, editor));

		_this.direction = direction;

		/**
   * Delete's change buffer used to group subsequent changes into batches.
   *
   * @readonly
   * @private
   * @member {typing.ChangeBuffer} typing.DeleteCommand#buffer
   */
		_this._buffer = new ChangeBuffer(editor.document, editor.config.get('undo.step'));
		return _this;
	}

	/**
  * Executes the delete command. Depending on whether the selection is collapsed or not, deletes its content
  * or a piece of content in the {@link typing.DeleteCommand#direction defined direction}.
  *
  * @param {Object} [options] The command options.
  * @param {'character'} [options.unit='character'] See {@link engine.model.composer.modifySelection}'s options.
  */


	createClass(DeleteCommand, [{
		key: '_doExecute',
		value: function _doExecute() {
			var _this2 = this;

			var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

			var doc = this.editor.document;

			doc.enqueueChanges(function () {
				var selection = Selection.createFromSelection(doc.selection);

				// Try to extend the selection in the specified direction.
				if (selection.isCollapsed) {
					doc.composer.modifySelection(selection, { direction: _this2.direction, unit: options.unit });
				}

				// If selection is still collapsed, then there's nothing to delete.
				if (selection.isCollapsed) {
					return;
				}

				var changeCount = 0;

				selection.getFirstRange().getMinimalFlatRanges().forEach(function (range) {
					changeCount += count(range.getWalker({ singleCharacters: true, ignoreElementEnd: true, shallow: true }));
				});

				doc.composer.deleteContents(_this2._buffer.batch, selection, { merge: true });
				_this2._buffer.input(changeCount);

				doc.selection.setRanges(selection.getRanges(), selection.isBackward);
			});
		}
	}]);
	return DeleteCommand;
}(Command);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Delete observer introduces the {@link engine.view.Document#delete} event.
 *
 * @memberOf typing
 * @extends engine.view.observer.Observer
 */

var DeleteObserver = function (_Observer) {
	inherits(DeleteObserver, _Observer);

	function DeleteObserver(document) {
		classCallCheck(this, DeleteObserver);

		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(DeleteObserver).call(this, document));

		document.on('keydown', function (evt, data) {
			var deleteData = {};

			if (data.keyCode == keyCodes.delete) {
				deleteData.direction = 'forward';
				deleteData.unit = 'character';
			} else if (data.keyCode == keyCodes.backspace) {
				deleteData.direction = 'backward';
				deleteData.unit = 'codePoint';
			} else {
				return;
			}

			deleteData.unit = data.altKey ? 'word' : deleteData.unit;

			document.fire('delete', new DomEventData(document, data.domEvent, deleteData));
		});
		return _this;
	}

	/**
  * @inheritDoc
  */


	createClass(DeleteObserver, [{
		key: 'observe',
		value: function observe() {}
	}]);
	return DeleteObserver;
}(Observer);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The delete and backspace feature. Handles the <kbd>Delete</kbd> and <kbd>Backspace</kbd> keys in the editor.
 *
 * @memberOf typing
 * @extends core.Feature
 */

var Delete = function (_Feature) {
	inherits(Delete, _Feature);

	function Delete() {
		classCallCheck(this, Delete);
		return possibleConstructorReturn(this, Object.getPrototypeOf(Delete).apply(this, arguments));
	}

	createClass(Delete, [{
		key: 'init',
		value: function init() {
			var editor = this.editor;
			var editingView = editor.editing.view;

			editingView.addObserver(DeleteObserver);

			editor.commands.set('forwardDelete', new DeleteCommand(editor, 'forward'));
			editor.commands.set('delete', new DeleteCommand(editor, 'backward'));

			this.listenTo(editingView, 'delete', function (evt, data) {
				editor.execute(data.direction == 'forward' ? 'forwardDelete' : 'delete', { unit: data.unit });
				data.preventDefault();
			});
		}
	}]);
	return Delete;
}(Feature);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The typing feature. Handles typing.
 *
 * @memberOf typing
 * @extends core.Feature
 */

var Typing = function (_Feature) {
  inherits(Typing, _Feature);

  function Typing() {
    classCallCheck(this, Typing);
    return possibleConstructorReturn(this, Object.getPrototypeOf(Typing).apply(this, arguments));
  }

  createClass(Typing, null, [{
    key: 'requires',
    get: function get() {
      return [Input, Delete];
    }
  }]);
  return Typing;
}(Feature);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Base class for undo feature commands: {@link undo.UndoCommand} and {@link undo.RedoCommand}.
 *
 * @protected
 * @memberOf undo
 */

var BaseCommand = function (_Command) {
	inherits(BaseCommand, _Command);

	function BaseCommand(editor) {
		classCallCheck(this, BaseCommand);

		/**
   * Stack of items stored by the command. These are pairs of:
   *
   * * {@link engine.model.Batch batch} saved by the command,
   * * {@link engine.model.Selection selection} state at the moment of saving the batch.
   *
   * @protected
   * @member {Array} undo.BaseCommand#_stack
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(BaseCommand).call(this, editor));

		_this._stack = [];

		/**
   * Stores all batches that were created by this command.
   *
   * @protected
   * @member {WeakSet.<engine.model.Batch>} undo.BaseCommand#_createdBatches
   */
		_this._createdBatches = new WeakSet();

		// Refresh state, so command is inactive just after initialization.
		_this.refreshState();
		return _this;
	}

	/**
  * Stores a batch in the command, together with the selection state of the {@link engine.model.Document document}
  * created by the editor which this command is registered to.
  *
  * @param {engine.model.Batch} batch The batch to add.
  */


	createClass(BaseCommand, [{
		key: 'addBatch',
		value: function addBatch(batch) {
			var selection = {
				ranges: Array.from(this.editor.document.selection.getRanges()),
				isBackward: this.editor.document.selection.isBackward
			};

			this._stack.push({ batch: batch, selection: selection });
			this.refreshState();
		}

		/**
   * Removes all items from the stack.
   */

	}, {
		key: 'clearStack',
		value: function clearStack() {
			this._stack = [];
			this.refreshState();
		}

		/**
   * @inheritDoc
   */

	}, {
		key: '_checkEnabled',
		value: function _checkEnabled() {
			return this._stack.length > 0;
		}

		/**
   * Restores the {@link engine.model.Document#selection document selection} state after a batch was undone.
   *
   * @protected
   * @param {Array.<engine.model.Range>} ranges Ranges to be restored.
   * @param {Boolean} isBackward A flag describing whether the restored range was selected forward or backward.
   */

	}, {
		key: '_restoreSelection',
		value: function _restoreSelection(ranges, isBackward, deltas) {
			var document = this.editor.document;

			// This will keep the transformed selection ranges.
			var selectionRanges = [];

			// Transform all ranges from the restored selection.
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var range = _step.value;

					var transformedRanges = transformSelectionRange(range, deltas);

					// For each `range` from `ranges`, we take only one transformed range.
					// This is because we want to prevent situation where single-range selection
					// got transformed to multi-range selection. We will take the first range that
					// is not in the graveyard.
					var transformedRange = transformedRanges.find(function (range) {
						return range.start.root != document.graveyard;
					});

					// `transformedRange` might be `undefined` if transformed range ended up in graveyard.
					if (transformedRange) {
						selectionRanges.push(transformedRange);
					}
				}

				// `selectionRanges` may be empty if all ranges ended up in graveyard. If that is the case, do not restore selection.
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			if (selectionRanges.length) {
				document.selection.setRanges(selectionRanges, isBackward);
			}
		}
	}]);
	return BaseCommand;
}(Command);

function transformDelta(setToTransform, setToTransformBy) {
	var isStrong = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

	var results = [];

	var _iteratorNormalCompletion2 = true;
	var _didIteratorError2 = false;
	var _iteratorError2 = undefined;

	try {
		for (var _iterator2 = setToTransform[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
			var toTransform = _step2.value;

			var to = [toTransform];

			for (var t = 0; t < to.length; t++) {
				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = undefined;

				try {
					for (var _iterator3 = setToTransformBy[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						var transformBy = _step3.value;

						var transformed = transform$1(to[t], transformBy, isStrong);
						to.splice.apply(to, [t, 1].concat(toConsumableArray(transformed)));
						t = t - 1 + transformed.length;
					}
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 && _iterator3.return) {
							_iterator3.return();
						}
					} finally {
						if (_didIteratorError3) {
							throw _iteratorError3;
						}
					}
				}
			}

			results = results.concat(to);
		}
	} catch (err) {
		_didIteratorError2 = true;
		_iteratorError2 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion2 && _iterator2.return) {
				_iterator2.return();
			}
		} finally {
			if (_didIteratorError2) {
				throw _iteratorError2;
			}
		}
	}

	return results;
}

// Transforms given range `range` by deltas from `document` history, starting from a delta with given `baseVersion`.
// Returns an array containing one or more ranges, which are result of the transformation.
function transformSelectionRange(range, deltas) {
	// The range will be transformed by history deltas that happened after the selection got stored.
	// Note, that at this point, the document history is already updated by undo command execution. We will
	// not transform the range by deltas that got undone or their reversing counterparts.
	var transformed = transformRangesByDeltas([range], deltas);

	// After `range` got transformed, we have an array of ranges. Some of those
	// ranges may be "touching" -- they can be next to each other and could be merged.
	// First, we have to sort those ranges because they don't have to be in an order.
	transformed.sort(function (a, b) {
		return a.start.isBefore(b.start) ? -1 : 1;
	});

	// Then, we check if two consecutive ranges are touching.
	for (var i = 1; i < transformed.length; i++) {
		var a = transformed[i - 1];
		var b = transformed[i];

		if (a.end.isTouching(b.start)) {
			a.end = b.end;
			transformed.splice(i, 1);
			i--;
		}
	}

	return transformed;
}

// Transforms given set of `ranges` by given set of `deltas`. Returns transformed `ranges`.
function transformRangesByDeltas(ranges, deltas) {
	var _iteratorNormalCompletion4 = true;
	var _didIteratorError4 = false;
	var _iteratorError4 = undefined;

	try {
		for (var _iterator4 = deltas[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
			var delta = _step4.value;
			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = delta.operations[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var operation = _step5.value;

					// We look through all operations from all deltas.

					for (var i = 0; i < ranges.length; i++) {
						// We transform every range by every operation.
						var result = void 0;

						switch (operation.type) {
							case 'insert':
								result = ranges[i]._getTransformedByInsertion(operation.position, operation.nodes.maxOffset, true);
								break;

							case 'move':
							case 'remove':
							case 'reinsert':
								result = ranges[i]._getTransformedByMove(operation.sourcePosition, operation.targetPosition, operation.howMany, true);
								break;
						}

						// If we have a transformation result, we substitute transformed range with it in `transformed` array.
						// Keep in mind that the result is an array and may contain multiple ranges.
						if (result) {
							ranges.splice.apply(ranges, [i, 1].concat(toConsumableArray(result)));

							// Fix iterator.
							i = i + result.length - 1;
						}
					}
				}
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5.return) {
						_iterator5.return();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}
		}
	} catch (err) {
		_didIteratorError4 = true;
		_iteratorError4 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion4 && _iterator4.return) {
				_iterator4.return();
			}
		} finally {
			if (_didIteratorError4) {
				throw _iteratorError4;
			}
		}
	}

	return ranges;
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The undo command stores {@link engine.model.Batch batches} applied to the {@link engine.model.Document document}
 * and is able to undo a batch by reversing it and transforming by other batches from {@link engine.model.Document#history history}
 * that happened after the reversed batch.
 *
 * The undo command also takes care of restoring the {@link engine.model.Document#selection document selection} to the state before
 * the undone batch was applied.
 *
 * @memberOf undo
 * @extends undo.BaseCommand
 */

var UndoCommand = function (_BaseCommand) {
	inherits(UndoCommand, _BaseCommand);

	function UndoCommand() {
		classCallCheck(this, UndoCommand);
		return possibleConstructorReturn(this, Object.getPrototypeOf(UndoCommand).apply(this, arguments));
	}

	createClass(UndoCommand, [{
		key: '_doExecute',

		/**
   * Executes the command. This method reverts a {@link engine.model.Batch batch} added to the command's stack, transforms
   * and applies the reverted version on the {@link engine.model.Document document} and removes the batch from the stack.
   * Then, it restores the {@link engine.model.Document#selection document selection}.
   *
   * @protected
   * @fires undo.UndoCommand#event:revert
   * @param {engine.model.Batch} [batch] A batch that should be undone. If not set, the last added batch will be undone.
   */
		value: function _doExecute() {
			var _this2 = this;

			var batch = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

			// If batch is not given, set `batchIndex` to the last index in command stack.
			var batchIndex = batch ? this._stack.findIndex(function (a) {
				return a.batch == batch;
			}) : this._stack.length - 1;

			var item = this._stack.splice(batchIndex, 1)[0];

			// All changes has to be done in one `enqueueChanges` callback so other listeners will not
			// step between consecutive deltas, or won't do changes to the document before selection is properly restored.
			this.editor.document.enqueueChanges(function () {
				var undoingBatch = _this2._undo(item.batch);

				var deltas = _this2.editor.document.history.getDeltas(item.batch.baseVersion);
				_this2._restoreSelection(item.selection.ranges, item.selection.isBackward, deltas);

				_this2.fire('revert', item.batch, undoingBatch);
			});

			this.refreshState();
		}

		/**
   * Returns an index in {@link undo.BaseCommand#_stack} pointing to the item that is storing a batch that has a given
   * {@link engine.model.Batch#baseVersion}.
   *
   * @private
   * @param {Number} baseVersion The base version of the batch to find.
   * @returns {Number|null}
   */

	}, {
		key: '_getItemIndexFromBaseVersion',
		value: function _getItemIndexFromBaseVersion(baseVersion) {
			for (var i = 0; i < this._stack.length; i++) {
				if (this._stack[i].batch.baseVersion == baseVersion) {
					return i;
				}
			}

			return null;
		}

		/**
   * Undoes a batch by reversing a batch from history, transforming that reversed batch and applying it. This is
   * a helper method for {@link undo.UndoCommand#_doExecute}.
   *
   * @private
   * @param {engine.model.Batch} batchToUndo A batch whose deltas will be reversed, transformed and applied.
   */

	}, {
		key: '_undo',
		value: function _undo(batchToUndo) {
			var document = this.editor.document;

			// All changes done by the command execution will be saved as one batch.
			var undoingBatch = document.batch();
			this._createdBatches.add(undoingBatch);

			var history = document.history;
			var deltasToUndo = batchToUndo.deltas.slice();
			deltasToUndo.reverse();

			// We will process each delta from `batchToUndo`, in reverse order. If there was deltas A, B and C in undone batch,
			// we need to revert them in reverse order, so first reverse C, then B, then A.
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = deltasToUndo[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var deltaToUndo = _step.value;

					// Keep in mind that all algorithms return arrays. That's because the transformation might result in multiple
					// deltas, so we need arrays to handle them anyway. To simplify algorithms, it is better to always have arrays
					// in mind. For simplicity reasons, we will use singular form in descriptions and names.
					var baseVersion = deltaToUndo.baseVersion;
					var nextBaseVersion = baseVersion + deltaToUndo.operations.length;

					// 1. Get updated version of the delta from the history.
					// Batch stored in the undo command might have an outdated version of the delta that should be undone.
					// To prevent errors, we will take an updated version of it from the history, basing on delta's `baseVersion`.
					var updatedDeltaToUndo = history.getDelta(baseVersion);

					// This is a safe valve in case of not finding delta to undo in history. This may come up if that delta
					// got updated into no deltas, or removed from history.
					if (updatedDeltaToUndo === null) {
						continue;
					}

					// 2. Reverse delta from the history.
					updatedDeltaToUndo.reverse();
					var reversedDelta = [];

					var _iteratorNormalCompletion2 = true;
					var _didIteratorError2 = false;
					var _iteratorError2 = undefined;

					try {
						for (var _iterator2 = updatedDeltaToUndo[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
							var delta = _step2.value;

							reversedDelta.push(delta.getReversed());
						}

						// Stores history deltas transformed by `deltaToUndo`. Will be used later for updating document history.
					} catch (err) {
						_didIteratorError2 = true;
						_iteratorError2 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion2 && _iterator2.return) {
								_iterator2.return();
							}
						} finally {
							if (_didIteratorError2) {
								throw _iteratorError2;
							}
						}
					}

					var updatedHistoryDeltas = {};

					// 3. Transform reversed delta by history deltas that happened after delta to undo. We have to bring
					// reversed delta to the current state of document. While doing this, we will also update history deltas
					// to the state which "does not remember" delta that we undo.
					var _iteratorNormalCompletion3 = true;
					var _didIteratorError3 = false;
					var _iteratorError3 = undefined;

					try {
						for (var _iterator3 = history.getDeltas(nextBaseVersion)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
							var historyDelta = _step3.value;

							// 3.1. Transform selection range stored with history batch by reversed delta.
							// It is important to keep stored selection ranges updated. As we are removing and updating deltas in the history,
							// selection ranges would base on outdated history state.
							var itemIndex = this._getItemIndexFromBaseVersion(historyDelta.baseVersion);

							// `itemIndex` will be `null` for `historyDelta` if it is not the first delta in it's batch.
							// This is fine, because we want to transform each selection only once, before transforming reversed delta
							// by the first delta of the batch connected with the ranges.
							if (itemIndex !== null) {
								this._stack[itemIndex].selection.ranges = transformRangesByDeltas(this._stack[itemIndex].selection.ranges, reversedDelta);
							}

							// 3.2. Transform history delta by reversed delta. We need this to update document history.
							var updatedHistoryDelta = transformDelta([historyDelta], reversedDelta, false);

							// 3.3. Transform reversed delta by history delta (in state before transformation above).
							reversedDelta = transformDelta(reversedDelta, [historyDelta], true);

							// 3.4. Store updated history delta. Later, it will be updated in `history`.
							if (!updatedHistoryDeltas[historyDelta.baseVersion]) {
								updatedHistoryDeltas[historyDelta.baseVersion] = [];
							}

							updatedHistoryDeltas[historyDelta.baseVersion] = updatedHistoryDeltas[historyDelta.baseVersion].concat(updatedHistoryDelta);
						}

						// 4. After reversed delta has been transformed by all history deltas, apply it.
					} catch (err) {
						_didIteratorError3 = true;
						_iteratorError3 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion3 && _iterator3.return) {
								_iterator3.return();
							}
						} finally {
							if (_didIteratorError3) {
								throw _iteratorError3;
							}
						}
					}

					var _iteratorNormalCompletion4 = true;
					var _didIteratorError4 = false;
					var _iteratorError4 = undefined;

					try {
						for (var _iterator4 = reversedDelta[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
							var _delta = _step4.value;

							// Fix base version.
							_delta.baseVersion = document.version;

							// Before applying, add the delta to the `undoingBatch`.
							undoingBatch.addDelta(_delta);

							// Now, apply all operations of the delta.
							var _iteratorNormalCompletion6 = true;
							var _didIteratorError6 = false;
							var _iteratorError6 = undefined;

							try {
								for (var _iterator6 = _delta.operations[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
									var operation = _step6.value;

									document.applyOperation(operation);
								}
							} catch (err) {
								_didIteratorError6 = true;
								_iteratorError6 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion6 && _iterator6.return) {
										_iterator6.return();
									}
								} finally {
									if (_didIteratorError6) {
										throw _iteratorError6;
									}
								}
							}
						}

						// 5. Remove reversed delta from the history.
					} catch (err) {
						_didIteratorError4 = true;
						_iteratorError4 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion4 && _iterator4.return) {
								_iterator4.return();
							}
						} finally {
							if (_didIteratorError4) {
								throw _iteratorError4;
							}
						}
					}

					history.removeDelta(baseVersion);

					// And all deltas that are reversing it.
					// So the history looks like both original and reversing deltas never happened.
					// That's why we have to update history deltas - some of them might have been basing on deltas that we are now removing.
					var _iteratorNormalCompletion5 = true;
					var _didIteratorError5 = false;
					var _iteratorError5 = undefined;

					try {
						for (var _iterator5 = reversedDelta[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
							var _delta2 = _step5.value;

							history.removeDelta(_delta2.baseVersion);
						}

						// 6. Update history deltas in history.
					} catch (err) {
						_didIteratorError5 = true;
						_iteratorError5 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion5 && _iterator5.return) {
								_iterator5.return();
							}
						} finally {
							if (_didIteratorError5) {
								throw _iteratorError5;
							}
						}
					}

					for (var historyBaseVersion in updatedHistoryDeltas) {
						history.updateDelta(Number(historyBaseVersion), updatedHistoryDeltas[historyBaseVersion]);
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			return undoingBatch;
		}
	}]);
	return UndoCommand;
}(BaseCommand);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The redo command stores {@link engine.model.Batch batches} that were used to undo a batch by {@link undo.UndoCommand UndoCommand}.
 * It is able to redo a previously undone batch by reversing the undoing batches created by `UndoCommand`. The reversed batch is
 * also transformed by batches from {@link engine.model.Document#history history} that happened after it and are not other redo batches.
 *
 * The redo command also takes care of restoring the {@link engine.model.Document#selection document selection} to the state before
 * an undone batch was applied.
 *
 * @memberOf undo
 * @extends undo.BaseCommand
 */

var RedoCommand = function (_BaseCommand) {
	inherits(RedoCommand, _BaseCommand);

	function RedoCommand() {
		classCallCheck(this, RedoCommand);
		return possibleConstructorReturn(this, Object.getPrototypeOf(RedoCommand).apply(this, arguments));
	}

	createClass(RedoCommand, [{
		key: '_doExecute',

		/**
   * Executes the command. This method reverts the last {@link engine.model.Batch batch} added to the command's stack, applies
   * the reverted and transformed version on the {@link engine.model.Document document} and removes the batch from the stack.
   * Then, it restores the {@link engine.model.Document#selection document selection}.
   *
   * @protected
   */
		value: function _doExecute() {
			var _this2 = this;

			var item = this._stack.pop();

			// All changes have to be done in one `enqueueChanges` callback so other listeners will not
			// step between consecutive deltas, or won't do changes to the document before selection is properly restored.
			this.editor.document.enqueueChanges(function () {
				var lastDelta = item.batch.deltas[item.batch.deltas.length - 1];
				var nextBaseVersion = lastDelta.baseVersion + lastDelta.operations.length;

				// Selection state is from the moment after undo happened. It needs to be transformed by all the deltas
				// that happened after the selection state got saved. Unfortunately it is tricky, because those deltas
				// are already compressed in the history (they are removed).
				// Because of that we will transform the selection only by non-redo deltas
				var deltas = Array.from(_this2.editor.document.history.getDeltas(nextBaseVersion)).filter(function (delta) {
					return !_this2._createdBatches.has(delta.batch);
				});

				_this2._restoreSelection(item.selection.ranges, item.selection.isBackward, deltas);
				_this2._redo(item.batch);
			});

			this.refreshState();
		}

		/**
   * Redoes a batch by reversing the batch that has undone it, transforming that batch and applying it. This is
   * a helper method for {@link undo.RedoCommand#_doExecute}.
   *
   * @private
   * @param {engine.model.Batch} storedBatch The batch whose deltas will be reversed, transformed and applied.
   */

	}, {
		key: '_redo',
		value: function _redo(storedBatch) {
			var document = this.editor.document;

			// All changes done by the command execution will be saved as one batch.
			var redoingBatch = document.batch();
			this._createdBatches.add(redoingBatch);

			var deltasToRedo = storedBatch.deltas.slice();
			deltasToRedo.reverse();

			// We will process each delta from `storedBatch`, in reverse order. If there was deltas A, B and C in stored batch,
			// we need to revert them in reverse order, so first reverse C, then B, then A.
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = deltasToRedo[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var deltaToRedo = _step.value;

					// Keep in mind that all algorithms return arrays. That's because the transformation might result in multiple
					// deltas, so we need arrays to handle them anyway. To simplify algorithms, it is better to always have arrays
					// in mind. For simplicity reasons, we will use singular form in descriptions and names.

					var nextBaseVersion = deltaToRedo.baseVersion + deltaToRedo.operations.length;

					// As stated above, convert delta to array of deltas.
					var reversedDelta = [deltaToRedo.getReversed()];

					// 1. Transform that delta by deltas from history that happened after it.
					// Omit deltas from "redo" batches, because reversed delta already bases on them. Transforming by them
					// again will result in incorrect deltas.
					var _iteratorNormalCompletion2 = true;
					var _didIteratorError2 = false;
					var _iteratorError2 = undefined;

					try {
						for (var _iterator2 = document.history.getDeltas(nextBaseVersion)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
							var historyDelta = _step2.value;

							if (!this._createdBatches.has(historyDelta.batch)) {
								reversedDelta = transformDelta(reversedDelta, [historyDelta], true);
							}
						}

						// 2. After reversed delta has been transformed by all history deltas, apply it.
					} catch (err) {
						_didIteratorError2 = true;
						_iteratorError2 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion2 && _iterator2.return) {
								_iterator2.return();
							}
						} finally {
							if (_didIteratorError2) {
								throw _iteratorError2;
							}
						}
					}

					var _iteratorNormalCompletion3 = true;
					var _didIteratorError3 = false;
					var _iteratorError3 = undefined;

					try {
						for (var _iterator3 = reversedDelta[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
							var delta = _step3.value;

							// Fix base version.
							delta.baseVersion = document.version;

							// Before applying, add the delta to the `redoingBatch`.
							redoingBatch.addDelta(delta);

							// Now, apply all operations of the delta.
							var _iteratorNormalCompletion4 = true;
							var _didIteratorError4 = false;
							var _iteratorError4 = undefined;

							try {
								for (var _iterator4 = delta.operations[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
									var operation = _step4.value;

									document.applyOperation(operation);
								}
							} catch (err) {
								_didIteratorError4 = true;
								_iteratorError4 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion4 && _iterator4.return) {
										_iterator4.return();
									}
								} finally {
									if (_didIteratorError4) {
										throw _iteratorError4;
									}
								}
							}
						}
					} catch (err) {
						_didIteratorError3 = true;
						_iteratorError3 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion3 && _iterator3.return) {
								_iterator3.return();
							}
						} finally {
							if (_didIteratorError3) {
								throw _iteratorError3;
							}
						}
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		}
	}]);
	return RedoCommand;
}(BaseCommand);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The undo engine feature.
 *
 * Undo brings in possibility to undo and redo changes done in the model by deltas through
 * the {@link engine.model.Document#batch Batch API}.
 *
 * @memberOf undo
 * @extends core.Feature
 */

var UndoEngine = function (_Feature) {
	inherits(UndoEngine, _Feature);

	/**
  * @inheritDoc
  */
	function UndoEngine(editor) {
		classCallCheck(this, UndoEngine);

		/**
   * The command that manages undo {@link engine.model.Batch batches} stack (history).
   * Created and registered during the {@link undo.UndoEngine#init feature initialization}.
   *
   * @private
   * @member {undo.UndoEngineCommand} undo.UndoEngine#_undoCommand
   */

		/**
   * The command that manages redo {@link engine.model.Batch batches} stack (history).
   * Created and registered during the {@link undo.UndoEngine#init feature initialization}.
   *
   * @private
   * @member {undo.UndoEngineCommand} undo.UndoEngine#_redoCommand
   */

		/**
   * Keeps track of which batches were registered in undo.
   *
   * @private
   * @member {WeakSet.<engine.model.Batch>} undo.UndoEngine#_batchRegistry
   */
		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(UndoEngine).call(this, editor));

		_this._batchRegistry = new WeakSet();
		return _this;
	}

	/**
  * @inheritDoc
  */


	createClass(UndoEngine, [{
		key: 'init',
		value: function init() {
			var _this2 = this;

			// Create commands.
			this._undoCommand = new UndoCommand(this.editor);
			this._redoCommand = new RedoCommand(this.editor);

			// Register command to the editor.
			this.editor.commands.set('undo', this._undoCommand);
			this.editor.commands.set('redo', this._redoCommand);

			this.listenTo(this.editor.document, 'change', function (evt, type, changes, batch) {
				// If changes are not a part of a batch or this is not a new batch, omit those changes.
				if (_this2._batchRegistry.has(batch) || batch.type == 'transparent') {
					return;
				} else {
					if (_this2._redoCommand._createdBatches.has(batch)) {
						// If this batch comes from `redoCommand`, add it to `undoCommand` stack.
						_this2._undoCommand.addBatch(batch);
					} else if (!_this2._undoCommand._createdBatches.has(batch)) {
						// A default batch - these are new changes in the document, not introduced by undo feature.
						// Add them to `undoCommand` stack and clear `redoCommand` stack.
						_this2._undoCommand.addBatch(batch);
						_this2._redoCommand.clearStack();
					}
				}

				// Add the batch to the registry so it will not be processed again.
				_this2._batchRegistry.add(batch);
			}, { priority: 'highest' });

			this.listenTo(this._undoCommand, 'revert', function (evt, undoneBatch, undoingBatch) {
				_this2._redoCommand.addBatch(undoingBatch);
			});
		}
	}]);
	return UndoEngine;
}(Feature);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The undo feature. It introduces the Undo and Redo buttons to the editor.
 *
 * Below is the explanation of the undo mechanism working together with {@link engine.model.History History}:
 *
 * Whenever a {@link engine.model.Delta delta} is applied to the {@link engine.model.Document document}, it is saved to
 * `History` as is. The {@link engine.model.Batch batch} that owns that delta is also saved, in {@link undo.UndoCommand},
 * together with the selection that was present in the document before the delta was applied. A batch is saved instead of the delta
 * because changes are undone batch-by-batch, not delta-by-delta and a batch is seen as one undo step.
 *
 * After some changes happen to the document, the `History` and `UndoCommand` stack can be represented as follows:
 *
 *		  History                           Undo stack
 *		===========             ==================================
 *		[delta A1]              [batch A with selection before A1]
 *		[delta B1]              [batch B with selection before B1]
 *		[delta B2]              [batch C with selection before C1]
 *		[delta C1]
 *		[delta C2]
 *		[delta B3]
 *		[delta C3]
 *
 * Where deltas starting with the same letter are from same batch.
 *
 * Undoing a batch means that a set of deltas which will reverse the effects of that batch needs to be generated. For example, if a batch
 * added several letters, undoing the batch should remove them. It is important to apply undoing deltas in the reversed order,
 * so if a batch has delta `X`, `Y`, `Z`, reversed deltas `Zr`, `Yr` and `Xr` need to be applied. Otherwise reversed delta
 * `Xr` would operate on a wrong document state, because delta `X` does not know that deltas `Y` and `Z` happened.
 *
 * After deltas from an undone batch got {@link engine.model.Delta#getReversed reversed}, one needs to make sure if they are
 * ready to be applied. In the scenario above, delta `C3` is the last delta and `C3r` bases on up-to-date document state, so
 * it can be applied to the document.
 *
 *		  History                           Undo stack
 *		===========             ==================================
 *		[delta A1 ]             [batch A with selection before A1]
 *		[delta B1 ]             [batch B with selection before B1]
 *		[delta B2 ]             [   processing undoing batch C   ]
 *		[delta C1 ]
 *		[delta C2 ]
 *		[delta B3 ]
 *		[delta C3 ]
 *		[delta C3r]
 *
 * Next is delta `C2`, reversed to `C2r`. `C2r` bases on `C2`, so it bases on the wrong document state. It needs to be
 * transformed by deltas from history that happened after it, so it "knows" about them. Let us assume that `C2' = C2r * B3 * C3 * C3r`,
 * where `*` means "transformed by". As can be seen, `C2r` is transformed by a delta which is undone afterwards anyway.
 * This brings two problems: lower effectiveness (obvious) and incorrect results. Bad results come from the fact that
 * operational transformation algorithms assume there is no connection between two transformed operations when resolving
 * conflicts, which is true for example for collaborative editing, but is not true for the undo algorithm.
 *
 * To prevent both problems, `History` introduces an API to {@link engine.model.History#removeDelta remove}
 * deltas from history. It is used to remove undone and undoing deltas after they are applied. It feels right &mdash; since when a
 * delta is undone or reversed, it is "removed" and there should be no sign of it in the history (fig. 1).
 *
 * Notes:
 *
 * * `---` symbolizes a removed delta.
 * * `'` symbolizes a reversed delta that was later transformed.
 *
 *		History (fig. 1)            History (fig. 2)            History (fig. 3)
 *		================            ================            ================
 *		   [delta A1]                  [delta A1]                  [delta A1]
 *		   [delta B1]                  [delta B1]                  [delta B1]
 *		   [delta B2]                  [delta B2]                  [delta B2]
 *		   [delta C1]                  [delta C1]                  [---C1---]
 *		   [delta C2]                  [---C2---]                  [---C2---]
 *		   [delta B3]                  [delta B3]                  [delta B3]
 *		   [---C3---]                  [---C3---]                  [---C3---]
 *		   [---C3r--]                  [---C3r--]                  [---C3r--]
 *		                               [---C2'--]                  [---C2'--]
 *		                                                           [---C1'--]
 *
 * `C2r` can now be transformed only by `B3` and both `C2'` and `C2` can be removed (fig. 2). Same with `C1` (fig. 3).
 *
 * But what about that selection? For batch `C`, undo feature remembers the selection just before `C1` was applied. It can be
 * visualized between delta `B2` and `B3` (see fig. 3). As can be seen, some operations were applied to the document since the selection
 * state was remembered. Setting the document selection as it was remembered would be incorrect. It feels natural that
 * the selection state should also be transformed by deltas from history. The same pattern applies as with transforming deltas &mdash;
 * ranges should not be transformed by undone and undoing deltas. Thankfully, those deltas are already removed from history.
 *
 * Unfortunately, a problem appears with delta `B3`. It still remembers the context of deltas `C2` and `C1` on which it bases.
 * It is an obvious error &mdash; transforming by that delta would lead to incorrect results or "repeating" history would
 * produce a different document than the actual one.
 *
 * To prevent this situation, `B3` needs to also be {@link engine.model.History#updateDelta updated} in history.
 * It should be kept in a state that "does not remember" deltas that were removed from history. It is easily
 * achieved while transforming the reversed delta. For example, when `C2r` is transformed by `B3`, at the same time `B3` is
 * transformed by `C2r`. Transforming `B3` that remembers `C2` by a delta reversing `C2` effectively makes `B3` "forget" about `C2`.
 * By doing these transformations you effectively make `B3` base on `B2` which is the correct state of history (fig. 4).
 *
 *		     History (fig. 4)                         History (fig. 5)
 *		===========================            ===============================
 *		        [delta A1]                               [---A1---]
 *		        [delta B1]                         [delta B1 "without A1"]
 *		        [delta B2]                         [delta B2 "without A1"]
 *		        [---C1---]                               [---C1---]
 *		        [---C2---]                               [---C2---]
 *		[delta B3 "without C2, C1"]            [delta B3 "without C2, C1, A1"]
 *		        [---C3---]                               [---C3---]
 *		        [---C3r--]                               [---C3r--]
 *		        [---C2'--]                               [---C2'--]
 *		        [---C1'--]                               [---C1'--]
 *		                                                 [---A1'--]
 *
 * Selective undo works on the same basis, however, instead of undoing the last batch in the undo stack, any batch can be undone.
 * The same algorithm applies: deltas from a batch (i.e. `A1`) are reversed and then transformed by deltas stored in history,
 * simultaneously updating them. Then deltas are applied to the document and removed from history (fig. 5).
 *
 * @memberOf undo
 * @extends core.Feature
 */

var Undo = function (_Feature) {
  inherits(Undo, _Feature);

  function Undo() {
    classCallCheck(this, Undo);
    return possibleConstructorReturn(this, Object.getPrototypeOf(Undo).apply(this, arguments));
  }

  createClass(Undo, [{
    key: 'init',


    /**
     * @inheritDoc
     */
    value: function init() {
      var editor = this.editor;
      var t = editor.t;

      this._addButton('undo', t('Undo'), 'CTRL+Z');
      this._addButton('redo', t('Redo'), 'CTRL+Y');

      editor.keystrokes.set('CTRL+Z', 'undo');
      editor.keystrokes.set('CTRL+Y', 'redo');
      editor.keystrokes.set('CTRL+SHIFT+Z', 'redo');
    }

    /**
     * Creates a button for the specified command.
     *
     * @private
     * @param {String} name Command name.
     * @param {String} label Button label.
     * @param {String} keystroke Command keystroke.
     */

  }, {
    key: '_addButton',
    value: function _addButton(name, label, keystroke) {
      var editor = this.editor;

      var command = editor.commands.get(name);

      var model = new Model({
        isOn: false,
        label: label,
        icon: name,
        keystroke: keystroke
      });

      model.bind('isEnabled').to(command, 'isEnabled');

      this.listenTo(model, 'execute', function () {
        return editor.execute(name);
      });

      editor.ui.featureComponents.add(name, Button, ButtonView, model);
    }
  }], [{
    key: 'requires',

    /**
     * @inheritDoc
     */
    get: function get() {
      return [UndoEngine];
    }
  }]);
  return Undo;
}(Feature);

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The block autoformatting engine. Allows to format various block patterns. For example,
 * it can be configured to make a paragraph starting with "* " a list item.
 *
 * The autoformatting operation is integrated with the undo manager,
 * so the autoformatting step can be undone, if the user's intention wasn't to format the text.
 *
 * See the constructors documentation to learn how to create custom inline autoformatters. You can also use
 * the {@link autoformat.Autoformat} feature which enables a set of default autoformatters (lists, headings, bold and italic).
 *
 * @memberOf autoformat
 */

var BlockAutoformatEngine =
/**
 * Creates listener triggered on `change` event in document.
 * Calls callback when inserted text matches regular expression or command name
 * if provided instead of callback.
 *
 * Examples of usage:
 *
 * To convert paragraph to heading1 when `- ` is typed, using just commmand name:
 *
 *		new BlockAutoformatEngine( editor, /^\- $/, 'heading1' );
 *
 * To convert paragraph to heading1 when `- ` is typed, using just callback:
 *
 *		new BlockAutoformatEngine( editor, /^\- $/, ( context ) => {
 *			const { batch, match } = context;
 *			const headingLevel = match[ 1 ].length;
 *
 *			editor.execute( 'heading', {
 *				batch,
 *				formatId: `heading${ headingLevel }`
 *			} );
 * 		} );
 *
 * @param {core.editor.Editor} editor Editor instance.
 * @param {RegExp} pattern Regular expression to exec on just inserted text.
 * @param {Function|String} callbackOrCommand Callback to execute or command to run when text is matched.
 * In case of providing callback it receives following parameters:
 * * {engine.model.Batch} batch Newly created batch for autoformat changes.
 * * {Object} match RegExp.exec() result of matching pattern to inserted text.
 */
function BlockAutoformatEngine(editor, pattern, callbackOrCommand) {
	classCallCheck(this, BlockAutoformatEngine);

	var callback = void 0;

	if (typeof callbackOrCommand == 'function') {
		callback = callbackOrCommand;
	} else {
		(function () {
			// We assume that the actual command name was provided.
			var command = callbackOrCommand;

			callback = function callback(context) {
				var batch = context.batch;

				// Create new batch for removal and command execution.

				editor.execute(command, { batch: batch });
			};
		})();
	}

	editor.document.on('change', function (event, type, changes) {
		if (type != 'insert') {
			return;
		}

		// Take the first element. Typing shouldn't add more than one element at once.
		// And if it is not typing (e.g. paste), Autoformat should not be fired.
		var value = changes.range.getItems().next().value;

		if (!(value instanceof TextProxy)) {
			return;
		}

		var textNode = value.textNode;
		var text = textNode.data;

		// Run matching only on non-empty paragraphs.
		if (textNode.parent.name !== 'paragraph' || !text) {
			return;
		}

		var match = pattern.exec(text);

		if (!match) {
			return;
		}

		editor.document.enqueueChanges(function () {
			// Create new batch to separate typing batch from the Autoformat changes.
			var batch = editor.document.batch();

			// Matched range.
			var range = Range$1.createFromParentsAndOffsets(textNode.parent, 0, textNode.parent, match[0].length);

			// Remove matched text.
			batch.remove(range);

			callback({ batch: batch, match: match });
		});
	});
};

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * The inline autoformatting engine. Allows to format various inline patterns. For example,
 * it can be configured to make "foo" bold when typed `**foo**` (the `**` markers will be removed).
 *
 * The autoformatting operation is integrated with the undo manager,
 * so the autoformatting step can be undone, if the user's intention wasn't to format the text.
 *
 * See the constructors documentation to learn how to create custom inline autoformatters. You can also use
 * the {@link autoformat.Autoformat} feature which enables a set of default autoformatters (lists, headings, bold and italic).
 *
 * @memberOf autoformat
 */

var InlineAutoformatEngine =
/**
 * Enables autoformatting mechanism on a given {@link core.editor.Editor}.
 *
 * It formats the matched text by applying given model attribute or by running the provided formatting callback.
 * Each time data model changes text from given node (from the beginning of the current node to the collapsed
 * selection location) will be tested.
 *
 * @param {core.editor.Editor} editor Editor instance.
 * @param {Function|RegExp} testRegexpOrCallback RegExp or callback to execute on text.
 * Provided RegExp *must* have three capture groups. First and third capture groups
 * should match opening/closing delimiters. Second capture group should match text to format.
 *
 *		// Matches `**bold text**` pattern.
 *		// There are three capturing groups:
 *		// - first to match starting `**` delimiter,
 *		// - second to match text to format,
 *		// - third to match ending `**` delimiter.
 *		new InlineAutoformatEngine( this.editor, /(\*\*)([^\*]+?)(\*\*)$/g, 'bold' );
 *
 * When function is provided instead of RegExp, it will be executed with text to match as a parameter. Function
 * should return proper "ranges" to delete and format.
 *
 *		{
 *			remove: [
 *				[ 0, 1 ],	// Remove first letter from the given text.
 *				[ 5, 6 ]	// Remove 6th letter from the given text.
 *			],
 *			format: [
 *				[ 1, 5 ]	// Format all letters from 2nd to 5th.
 *			]
 *		}
 *
 * @param {Function|String} attributeOrCallback Name of attribute to apply on matching text or callback for manual
 * formatting.
 *
 *		// Use attribute name:
 *		new InlineAutoformatEngine( this.editor, /(\*\*)([^\*]+?)(\*\*)$/g, 'bold' );
 *
 *		// Use formatting callback:
 *		new InlineAutoformatEngine( this.editor, /(\*\*)([^\*]+?)(\*\*)$/g, ( batch, validRanges ) => {
 *			for ( let range of validRanges ) {
 *				batch.setAttribute( range, command, true );
 *			}
 *		} );
 */
function InlineAutoformatEngine(editor, testRegexpOrCallback, attributeOrCallback) {
	var _this = this;

	classCallCheck(this, InlineAutoformatEngine);

	this.editor = editor;

	var regExp = void 0;
	var command = void 0;
	var testCallback = void 0;
	var formatCallback = void 0;

	if (testRegexpOrCallback instanceof RegExp) {
		regExp = testRegexpOrCallback;
	} else {
		testCallback = testRegexpOrCallback;
	}

	if (typeof attributeOrCallback == 'string') {
		command = attributeOrCallback;
	} else {
		formatCallback = attributeOrCallback;
	}

	// A test callback run on changed text.
	testCallback = testCallback || function (text) {
		var result = void 0;
		var remove = [];
		var format = [];

		while ((result = regExp.exec(text)) !== null) {
			// There should be full match and 3 capture groups.
			if (result && result.length < 4) {
				break;
			}

			var _result = result;
			var index = _result.index;
			var leftDel = _result['1'];
			var content = _result['2'];
			var rightDel = _result['3'];

			// Real matched string - there might be some non-capturing groups so we need to recalculate starting index.

			var found = leftDel + content + rightDel;
			index += result[0].length - found.length;

			// Start and End offsets of delimiters to remove.
			var delStart = [index, index + leftDel.length];
			var delEnd = [index + leftDel.length + content.length, index + leftDel.length + content.length + rightDel.length];

			remove.push(delStart);
			remove.push(delEnd);

			format.push([index + leftDel.length, index + leftDel.length + content.length]);
		}

		return {
			remove: remove,
			format: format
		};
	};

	// A format callback run on matched text.
	formatCallback = formatCallback || function (batch, validRanges) {
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = validRanges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var range = _step.value;

				batch.setAttribute(range, command, true);
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}
	};

	editor.document.on('change', function (evt, type) {
		if (type !== 'insert') {
			return;
		}

		var selection = _this.editor.document.selection;

		if (!selection.isCollapsed || !selection.focus || !selection.focus.parent) {
			return;
		}

		var block = selection.focus.parent;
		var text = getText(block).slice(0, selection.focus.offset + 1);
		var ranges = testCallback(text);
		var rangesToFormat = [];

		// Apply format before deleting text.
		ranges.format.forEach(function (range) {
			if (range[0] === undefined || range[1] === undefined) {
				return;
			}

			rangesToFormat.push(LiveRange.createFromParentsAndOffsets(block, range[0], block, range[1]));
		});

		var rangesToRemove = [];

		// Reverse order to not mix the offsets while removing.
		ranges.remove.slice().reverse().forEach(function (range) {
			if (range[0] === undefined || range[1] === undefined) {
				return;
			}

			rangesToRemove.push(LiveRange.createFromParentsAndOffsets(block, range[0], block, range[1]));
		});

		if (!(rangesToFormat.length && rangesToRemove.length)) {
			return;
		}

		var batch = editor.document.batch();

		editor.document.enqueueChanges(function () {
			var validRanges = getSchemaValidRanges(command, rangesToFormat, editor.document.schema);

			// Apply format.
			formatCallback(batch, validRanges);

			// Remove delimiters.
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = rangesToRemove[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var range = _step2.value;

					batch.remove(range);
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}
		});
	});
};

function getText(element) {
	return Array.from(element.getChildren()).reduce(function (a, b) {
		return a + b.data;
	}, '');
}

/**
 * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * Includes a set of predefined autoformatting actions.
 *
 * ## Bulleted list
 *
 * You can create a bulleted list by staring a line with:
 *
 * * `* `
 * * `- `
 *
 * ## Numbered list
 *
 * You can create a numbered list by staring a line with:
 *
 * * `1. `
 * * `1) `
 *
 * ## Headings
 *
 * You can create a heading by starting a line with:
 *
 * `# ` – will create Heading 1,
 * `## ` – will create Heading 2,
 * `### ` – will create Heading 3.
 *
 * ## Bold and italic
 *
 * You can apply bold or italic to a text by typing Markdown formatting:
 *
 * * `**foo bar**` or `__foo bar__` – will bold the text,
 * * `*foo bar*` or `_foo bar_` – will italicize the text,
 *
 * @memberOf autoformat
 * @extends core.Feature
 */

var Autoformat = function (_Feature) {
	inherits(Autoformat, _Feature);

	function Autoformat() {
		classCallCheck(this, Autoformat);
		return possibleConstructorReturn(this, Object.getPrototypeOf(Autoformat).apply(this, arguments));
	}

	createClass(Autoformat, [{
		key: 'init',


		/**
   * @inheritDoc
   */
		value: function init() {
			this._addListAutoformats();
			this._addHeadingAutoformats();
			this._addInlineAutoformats();
		}

		/**
   * Adds autoformatting related to ListEngine commands.
   *
   * When typed:
   * - `* ` or `- ` - paragraph will be changed to a bulleted list,
   * - `1. ` or `1) ` - paragraph will be changed to a numbered list (1 can be any digit or list of digits).
   *
   * @private
   */

	}, {
		key: '_addListAutoformats',
		value: function _addListAutoformats() {
			new BlockAutoformatEngine(this.editor, /^[\*\-]\s$/, 'bulletedList');
			new BlockAutoformatEngine(this.editor, /^\d+[\.|)]?\s$/, 'numberedList');
		}

		/**
   * Adds autoformatting related to HeadingEngine commands.
   * When typed `# ` or `## ` or `### ` paragraph will be changed to a corresponding heading level.
   *
   * @private
   */

	}, {
		key: '_addHeadingAutoformats',
		value: function _addHeadingAutoformats() {
			var _this2 = this;

			new BlockAutoformatEngine(this.editor, /^(#{1,3})\s$/, function (context) {
				var batch = context.batch;
				var match = context.match;

				var headingLevel = match[1].length;

				_this2.editor.execute('heading', {
					batch: batch,
					formatId: 'heading' + headingLevel
				});
			});
		}

		/**
   * Adds inline autoformatting capabilities to the editor.
   *
   * When typed:
   * - `**foobar**`: `**` characters are removed, and `foobar` is set to bold,
   * - `__foobar__`: `__` characters are removed, and `foobar` is set to bold,
   * - `*foobar*`: `*` characters are removed, and `foobar` is set to italic,
   * - `_foobar_`: `_` characters are removed, and `foobar` is set to italic.
   *
   * @private
   */

	}, {
		key: '_addInlineAutoformats',
		value: function _addInlineAutoformats() {
			new InlineAutoformatEngine(this.editor, /(\*\*)([^\*]+)(\*\*)$/g, 'bold');
			new InlineAutoformatEngine(this.editor, /(__)([^_]+)(__)$/g, 'bold');

			// The italic autoformatter cannot be triggered by the bold markers, so we need to check the
			// text before the pattern (e.g. `(?:^|[^\*])`).
			new InlineAutoformatEngine(this.editor, /(?:^|[^\*])(\*)([^\*_]+)(\*)$/g, 'italic');
			new InlineAutoformatEngine(this.editor, /(?:^|[^_])(_)([^_]+)(_)$/g, 'italic');
		}
	}], [{
		key: 'requires',

		/**
   * @inheritDoc
   */
		get: function get() {
			return [HeadingEngine, ListEngine, BoldEngine, ItalicEngine];
		}
	}]);
	return Autoformat;
}(Feature);

// Babel helpers.

var ClassicEditor = function (_Classic) {
	inherits(ClassicEditor, _Classic);

	function ClassicEditor() {
		classCallCheck(this, ClassicEditor);
		return possibleConstructorReturn(this, Object.getPrototypeOf(ClassicEditor).apply(this, arguments));
	}

	createClass(ClassicEditor, null, [{
		key: 'create',
		value: function create(element) {
			var config = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

			if (!config.features) {
				config.features = [];
			}

			config.features = [].concat(toConsumableArray(config.features), [Bold, Italic, Clipboard, Enter, Heading, Link, List$1, Paragraph, Typing, Undo, Autoformat]);

			return ClassicEditor$1.create(element, config);
		}
	}]);
	return ClassicEditor;
}(ClassicEditor$1);

return ClassicEditor;

}());