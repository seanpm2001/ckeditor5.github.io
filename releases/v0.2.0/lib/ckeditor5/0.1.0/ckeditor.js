var ClassicEditor = (function () {
    'use strict';

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };

    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };

    var createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();

    var get = function get(object, property, receiver) {
      if (object === null) object = Function.prototype;
      var desc = Object.getOwnPropertyDescriptor(object, property);

      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);

        if (parent === null) {
          return undefined;
        } else {
          return get(parent, property, receiver);
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;

        if (getter === undefined) {
          return undefined;
        }

        return getter.call(receiver);
      }
    };

    var inherits = function (subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    };

    var possibleConstructorReturn = function (self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return call && (typeof call === "object" || typeof call === "function") ? call : self;
    };

    var slicedToArray = function () {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = undefined;

        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);

            if (i && _arr.length === i) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"]) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }

        return _arr;
      }

      return function (arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();

    var toConsumableArray = function (arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

        return arr2;
      } else {
        return Array.from(arr);
      }
    };

    /**
     * Copyright (c) 2014, Facebook, Inc.
     * All rights reserved.
     *
     * This source code is licensed under the BSD-style license found in the
     * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
     * additional grant of patent rights can be found in the PATENTS file in
     * the same directory.
     */

    !function (global) {
      "use strict";

      var hasOwn = Object.prototype.hasOwnProperty;
      var undefined; // More compressible than void 0.
      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

      var inModule = (typeof module === "undefined" ? "undefined" : _typeof(module)) === "object";
      var runtime = global.regeneratorRuntime;
      if (runtime) {
        if (inModule) {
          // If regeneratorRuntime is defined globally and we're in a module,
          // make the exports object identical to regeneratorRuntime.
          module.exports = runtime;
        }
        // Don't bother evaluating the rest of this file if the runtime was
        // already defined globally.
        return;
      }

      // Define the runtime globally (as expected by generated code) as either
      // module.exports (if we're in a module) or a new, empty object.
      runtime = global.regeneratorRuntime = inModule ? module.exports : {};

      function wrap(innerFn, outerFn, self, tryLocsList) {
        // If outerFn provided, then outerFn.prototype instanceof Generator.
        var generator = Object.create((outerFn || Generator).prototype);
        var context = new Context(tryLocsList || []);

        // The ._invoke method unifies the implementations of the .next,
        // .throw, and .return methods.
        generator._invoke = makeInvokeMethod(innerFn, self, context);

        return generator;
      }
      runtime.wrap = wrap;

      // Try/catch helper to minimize deoptimizations. Returns a completion
      // record like context.tryEntries[i].completion. This interface could
      // have been (and was previously) designed to take a closure to be
      // invoked without arguments, but in all the cases we care about we
      // already have an existing method we want to call, so there's no need
      // to create a new function object. We can even get away with assuming
      // the method takes exactly one argument, since that happens to be true
      // in every case, so we don't have to touch the arguments object. The
      // only additional allocation required is the completion record, which
      // has a stable shape and so hopefully should be cheap to allocate.
      function tryCatch(fn, obj, arg) {
        try {
          return { type: "normal", arg: fn.call(obj, arg) };
        } catch (err) {
          return { type: "throw", arg: err };
        }
      }

      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";

      // Returning this object from the innerFn has the same effect as
      // breaking out of the dispatch switch statement.
      var ContinueSentinel = {};

      // Dummy constructor functions that we use as the .constructor and
      // .constructor.prototype properties for functions that return Generator
      // objects. For full spec compliance, you may wish to configure your
      // minifier not to mangle the names of these two functions.
      function Generator() {}
      function GeneratorFunction() {}
      function GeneratorFunctionPrototype() {}

      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
      GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
      GeneratorFunctionPrototype.constructor = GeneratorFunction;
      GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

      // Helper for defining the .next, .throw, and .return methods of the
      // Iterator interface in terms of a single ._invoke method.
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          prototype[method] = function (arg) {
            return this._invoke(method, arg);
          };
        });
      }

      runtime.isGeneratorFunction = function (genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };

      runtime.mark = function (genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          if (!(toStringTagSymbol in genFun)) {
            genFun[toStringTagSymbol] = "GeneratorFunction";
          }
        }
        genFun.prototype = Object.create(Gp);
        return genFun;
      };

      // Within the body of any async function, `await x` is transformed to
      // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
      // `value instanceof AwaitArgument` to determine if the yielded value is
      // meant to be awaited. Some may consider the name of this method too
      // cutesy, but they are curmudgeons.
      runtime.awrap = function (arg) {
        return new AwaitArgument(arg);
      };

      function AwaitArgument(arg) {
        this.arg = arg;
      }

      function AsyncIterator(generator) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;
            if (value instanceof AwaitArgument) {
              return Promise.resolve(value.arg).then(function (value) {
                invoke("next", value, resolve, reject);
              }, function (err) {
                invoke("throw", err, resolve, reject);
              });
            }

            return Promise.resolve(value).then(function (unwrapped) {
              // When a yielded Promise is resolved, its final value becomes
              // the .value of the Promise<{value,done}> result for the
              // current iteration. If the Promise is rejected, however, the
              // result for this iteration will be rejected with the same
              // reason. Note that rejections of yielded Promises are not
              // thrown back into the generator function, as is the case
              // when an awaited Promise is rejected. This difference in
              // behavior between yield and await is important, because it
              // allows the consumer to decide what to do with the yielded
              // rejection (swallow it and continue, manually .throw it back
              // into the generator, abandon iteration, whatever). With
              // await, by contrast, there is no opportunity to examine the
              // rejection reason outside the generator function, so the
              // only option is to throw it from the await expression, and
              // let the generator function handle the exception.
              result.value = unwrapped;
              resolve(result);
            }, reject);
          }
        }

        if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process.domain) {
          invoke = process.domain.bind(invoke);
        }

        var previousPromise;

        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new Promise(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }

          return previousPromise =
          // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }

        // Define the unified helper method that is used to implement .next,
        // .throw, and .return (see defineIteratorMethods).
        this._invoke = enqueue;
      }

      defineIteratorMethods(AsyncIterator.prototype);

      // Note that simple async functions are implemented on top of
      // AsyncIterator objects; they just return a Promise for the value of
      // the final result produced by the iterator.
      runtime.async = function (innerFn, outerFn, self, tryLocsList) {
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

        return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      };

      function makeInvokeMethod(innerFn, self, context) {
        var state = GenStateSuspendedStart;

        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }

          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }

            // Be forgiving, per 25.3.3.3.3 of the spec:
            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
            return doneResult();
          }

          while (true) {
            var delegate = context.delegate;
            if (delegate) {
              if (method === "return" || method === "throw" && delegate.iterator[method] === undefined) {
                // A return or throw (when the delegate iterator has no throw
                // method) always terminates the yield* loop.
                context.delegate = null;

                // If the delegate iterator has a return method, give it a
                // chance to clean up.
                var returnMethod = delegate.iterator["return"];
                if (returnMethod) {
                  var record = tryCatch(returnMethod, delegate.iterator, arg);
                  if (record.type === "throw") {
                    // If the return method threw an exception, let that
                    // exception prevail over the original return or throw.
                    method = "throw";
                    arg = record.arg;
                    continue;
                  }
                }

                if (method === "return") {
                  // Continue with the outer return, now that the delegate
                  // iterator has been terminated.
                  continue;
                }
              }

              var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);

              if (record.type === "throw") {
                context.delegate = null;

                // Like returning generator.throw(uncaught), but without the
                // overhead of an extra function call.
                method = "throw";
                arg = record.arg;
                continue;
              }

              // Delegate generator ran and handled its own exceptions so
              // regardless of what the method was, we continue as if it is
              // "next" with an undefined arg.
              method = "next";
              arg = undefined;

              var info = record.arg;
              if (info.done) {
                context[delegate.resultName] = info.value;
                context.next = delegate.nextLoc;
              } else {
                state = GenStateSuspendedYield;
                return info;
              }

              context.delegate = null;
            }

            if (method === "next") {
              // Setting context._sent for legacy support of Babel's
              // function.sent implementation.
              context.sent = context._sent = arg;
            } else if (method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw arg;
              }

              if (context.dispatchException(arg)) {
                // If the dispatched exception was caught by a catch block,
                // then let that catch block handle the exception normally.
                method = "next";
                arg = undefined;
              }
            } else if (method === "return") {
              context.abrupt("return", arg);
            }

            state = GenStateExecuting;

            var record = tryCatch(innerFn, self, context);
            if (record.type === "normal") {
              // If an exception is thrown from innerFn, we leave state ===
              // GenStateExecuting and loop back for another invocation.
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;

              var info = {
                value: record.arg,
                done: context.done
              };

              if (record.arg === ContinueSentinel) {
                if (context.delegate && method === "next") {
                  // Deliberately forget the last sent value so that we don't
                  // accidentally pass it on to the delegate.
                  arg = undefined;
                }
              } else {
                return info;
              }
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              // Dispatch the exception by looping back around to the
              // context.dispatchException(arg) call above.
              method = "throw";
              arg = record.arg;
            }
          }
        };
      }

      // Define Generator.prototype.{next,throw,return} in terms of the
      // unified ._invoke helper method.
      defineIteratorMethods(Gp);

      Gp[iteratorSymbol] = function () {
        return this;
      };

      Gp[toStringTagSymbol] = "Generator";

      Gp.toString = function () {
        return "[object Generator]";
      };

      function pushTryEntry(locs) {
        var entry = { tryLoc: locs[0] };

        if (1 in locs) {
          entry.catchLoc = locs[1];
        }

        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }

        this.tryEntries.push(entry);
      }

      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }

      function Context(tryLocsList) {
        // The root entry object (effectively a try statement without a catch
        // or a finally block) gives us a place to store values thrown from
        // locations where there is no enclosing try statement.
        this.tryEntries = [{ tryLoc: "root" }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }

      runtime.keys = function (object) {
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        keys.reverse();

        // Rather than returning an object with a next method, we keep
        // things simple and return the next function itself.
        return function next() {
          while (keys.length) {
            var key = keys.pop();
            if (key in object) {
              next.value = key;
              next.done = false;
              return next;
            }
          }

          // To avoid creating an additional object, we just hang the .value
          // and .done properties off the next function object itself. This
          // also ensures that the minifier will not anonymize the function.
          next.done = true;
          return next;
        };
      };

      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }

          if (typeof iterable.next === "function") {
            return iterable;
          }

          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next.value = iterable[i];
                  next.done = false;
                  return next;
                }
              }

              next.value = undefined;
              next.done = true;

              return next;
            };

            return next.next = next;
          }
        }

        // Return an iterator with no values.
        return { next: doneResult };
      }
      runtime.values = values;

      function doneResult() {
        return { value: undefined, done: true };
      }

      Context.prototype = {
        constructor: Context,

        reset: function reset(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          // Resetting context._sent for legacy support of Babel's
          // function.sent implementation.
          this.sent = this._sent = undefined;
          this.done = false;
          this.delegate = null;

          this.tryEntries.forEach(resetTryEntry);

          if (!skipTempReset) {
            for (var name in this) {
              // Not sure about the optimal order of these conditions:
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined;
              }
            }
          }
        },

        stop: function stop() {
          this.done = true;

          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }

          return this.rval;
        },

        dispatchException: function dispatchException(exception) {
          if (this.done) {
            throw exception;
          }

          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            return !!caught;
          }

          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;

            if (entry.tryLoc === "root") {
              // Exception thrown outside of any try block that could handle
              // it, so set the completion value of the entire function to
              // throw the exception.
              return handle("end");
            }

            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");

              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },

        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }

          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            // Ignore the finally entry if control is not jumping to a
            // location outside the try/catch block.
            finallyEntry = null;
          }

          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;

          if (finallyEntry) {
            this.next = finallyEntry.finallyLoc;
          } else {
            this.complete(record);
          }

          return ContinueSentinel;
        },

        complete: function complete(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }

          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = record.arg;
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
        },

        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },

        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }

          // The context.catch method must only be called with a location
          // argument that corresponds to a known catch block.
          throw new Error("illegal catch attempt");
        },

        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          };

          return ContinueSentinel;
        }
      };
    }(
    // Among the various tricks for obtaining a reference to the global
    // object, this seems to be the most reliable technique that does not
    // use indirect eval (which violates Content Security Policy).
    (typeof global === "undefined" ? "undefined" : _typeof(global)) === "object" ? global : (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" ? window : (typeof self === "undefined" ? "undefined" : _typeof(self)) === "object" ? self : undefined);

    /**
     * Creates a spy function (ala Sinon.js) that can be used to inspect call to it.
     *
     * The following are the present features:
     *
     * * spy.called: property set to `true` if the function has been called at least once.
     *
     * @memberOf utils
     * @returns {Function} The spy function.
     */

    function spy() {
      return function spy() {
        spy.called = true;
      };
    }

    /**
     * The event object passed to event callbacks. It is used to provide information about the event as well as a tool to
     * manipulate it.
     *
     * @memberOf utils
     */

    var EventInfo = function EventInfo(source, name) {
    	classCallCheck(this, EventInfo);

    	/**
      * The object that fired the event.
      *
      * @member utils.EventInfo#source
      */
    	this.source = source;

    	/**
      * The event name.
      *
      * @member utils.EventInfo#name
      */
    	this.name = name;

    	// The following methods are defined in the constructor because they must be re-created per instance.

    	/**
      * Stops the event emitter to call further callbacks for this event interaction.
      *
      * @method utils.EventInfo#stop
      */
    	this.stop = spy();

    	/**
      * Removes the current callback from future interactions of this event.
      *
      * @method utils.EventInfo#off
      */
    	this.off = spy();
    };

    /**
     * Returns a unique id. This id is a number (starting from 1) which will never get repeated on successive calls
     * to this method.
     *
     * @function
     * @memberOf utils
     * @returns {Number} A number representing the id.
     */

    var uid = (function () {
      var next = 1;

      return function () {
        return next++;
      };
    })();

    // Saves how many callbacks has been already added. Does not decrement when callback is removed.
    // Used internally as a unique id for a callback.
    var eventsCounter = 0;

    /**
     * Mixin that injects the events API into its host.
     *
     * @mixin utils.EmitterMixin
     * @implements utils.Emitter
     */
    var EmitterMixin = {
    	/**
      * Registers a callback function to be executed when an event is fired. Events can be grouped in namespaces using `:`.
      * When namespaced event is fired, it additionaly fires all callbacks for that namespace.
      *
      *		myEmitter.on( 'myGroup', genericCallback );
      *		myEmitter.on( 'myGroup:myEvent', specificCallback );
      *		myEmitter.fire( 'myGroup' ); // genericCallback is fired.
      *		myEmitter.fire( 'myGroup:myEvent' ); // both genericCallback and specificCallback are fired.
      *		myEmitter.fire( 'myGroup:foo' ); // genericCallback is fired even though there are no callbacks for "foo".
      *
      * @param {String} event The name of the event.
      * @param {Function} callback The function to be called on event.
      * @param {Object} [ctx] The object that represents `this` in the callback. Defaults to the object firing the
      * event.
      * @param {Number} [priority=10] The priority of this callback in relation to other callbacks to that same event.
      * Lower values are called first.
      * @method utils.EmitterMixin#on
      */

    	on: function on(event, callback, ctx, priority) {
    		createEventNamespace(this, event);
    		var lists = getCallbacksListsForNamespace(this, event);

    		// Set the priority defaults.
    		if (typeof priority != 'number') {
    			priority = 10;
    		}

    		callback = {
    			callback: callback,
    			ctx: ctx || this,
    			priority: priority
    		};

    		// Add the callback to all callbacks list.
    		var _iteratorNormalCompletion = true;
    		var _didIteratorError = false;
    		var _iteratorError = undefined;

    		try {
    			for (var _iterator = lists[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    				var callbacks = _step.value;

    				// Save counter value as unique id.
    				callback.counter = ++eventsCounter;

    				// Add the callback to the list in the right priority position.
    				var added = false;

    				for (var i = callbacks.length - 1; i >= 0; i--) {
    					if (callbacks[i].priority <= priority) {
    						callbacks.splice(i + 1, 0, callback);
    						added = true;

    						break;
    					}
    				}

    				// Add to the beginning if right place was not found.
    				if (!added) {
    					callbacks.unshift(callback);
    				}
    			}
    		} catch (err) {
    			_didIteratorError = true;
    			_iteratorError = err;
    		} finally {
    			try {
    				if (!_iteratorNormalCompletion && _iterator.return) {
    					_iterator.return();
    				}
    			} finally {
    				if (_didIteratorError) {
    					throw _iteratorError;
    				}
    			}
    		}
    	},


    	/**
      * Registers a callback function to be executed on the next time the event is fired only. This is similar to
      * calling {@link #on} followed by {@link #off} in the callback.
      *
      * @param {String} event The name of the event.
      * @param {Function} callback The function to be called on event.
      * @param {Object} [ctx] The object that represents `this` in the callback. Defaults to the object firing the
      * event.
      * @param {Number} [priority=10] The priority of this callback in relation to other callbacks to that same event.
      * Lower values are called first.
      * @method utils.EmitterMixin#once
      */
    	once: function once(event, callback, ctx, priority) {
    		var onceCallback = function onceCallback(event) {
    			// Go off() at the first call.
    			event.off();

    			// Go with the original callback.
    			callback.apply(this, arguments);
    		};

    		// Make a similar on() call, simply replacing the callback.
    		this.on(event, onceCallback, ctx, priority);
    	},


    	/**
      * Stops executing the callback on the given event.
      *
      * @param {String} event The name of the event.
      * @param {Function} callback The function to stop being called.
      * @param {Object} [ctx] The context object to be removed, pared with the given callback. To handle cases where
      * the same callback is used several times with different contexts.
      * @method utils.EmitterMixin#off
      */
    	off: function off(event, callback, ctx) {
    		var lists = getCallbacksListsForNamespace(this, event);

    		var _iteratorNormalCompletion2 = true;
    		var _didIteratorError2 = false;
    		var _iteratorError2 = undefined;

    		try {
    			for (var _iterator2 = lists[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    				var callbacks = _step2.value;

    				for (var i = 0; i < callbacks.length; i++) {
    					if (callbacks[i].callback == callback) {
    						if (!ctx || ctx == callbacks[i].ctx) {
    							// Remove the callback from the list (fixing the next index).
    							callbacks.splice(i, 1);
    							i--;
    						}
    					}
    				}
    			}
    		} catch (err) {
    			_didIteratorError2 = true;
    			_iteratorError2 = err;
    		} finally {
    			try {
    				if (!_iteratorNormalCompletion2 && _iterator2.return) {
    					_iterator2.return();
    				}
    			} finally {
    				if (_didIteratorError2) {
    					throw _iteratorError2;
    				}
    			}
    		}
    	},


    	/**
      * Registers a callback function to be executed when an event is fired in a specific (emitter) object.
      *
      * @param {utils.Emitter} emitter The object that fires the event.
      * @param {String} event The name of the event.
      * @param {Function} callback The function to be called on event.
      * @param {Object} [ctx] The object that represents `this` in the callback. Defaults to `emitter`.
      * @param {Number} [priority=10] The priority of this callback in relation to other callbacks to that same event.
      * Lower values are called first.
      * @method utils.EmitterMixin#listenTo
      */
    	listenTo: function listenTo(emitter, event, callback, ctx, priority) {
    		var emitters = void 0,
    		    emitterId = void 0,
    		    emitterInfo = void 0,
    		    eventCallbacks = void 0;

    		// _listeningTo contains a list of emitters that this object is listening to.
    		// This list has the following format:
    		//
    		// _listeningTo: {
    		//     emitterId: {
    		//         emitter: emitter,
    		//         callbacks: {
    		//             event1: [ callback1, callback2, ... ]
    		//             ....
    		//         }
    		//     },
    		//     ...
    		// }

    		if (!(emitters = this._listeningTo)) {
    			emitters = this._listeningTo = {};
    		}

    		if (!(emitterId = emitter._emitterId)) {
    			emitterId = emitter._emitterId = uid();
    		}

    		if (!(emitterInfo = emitters[emitterId])) {
    			emitterInfo = emitters[emitterId] = {
    				emitter: emitter,
    				callbacks: {}
    			};
    		}

    		if (!(eventCallbacks = emitterInfo.callbacks[event])) {
    			eventCallbacks = emitterInfo.callbacks[event] = [];
    		}

    		eventCallbacks.push(callback);

    		// Finally register the callback to the event.
    		emitter.on(event, callback, ctx, priority);
    	},


    	/**
      * Stops listening for events. It can be used at different levels:
      *
      * * To stop listening to a specific callback.
      * * To stop listening to a specific event.
      * * To stop listening to all events fired by a specific object.
      * * To stop listening to all events fired by all object.
      *
      * @param {utils.Emitter} [emitter] The object to stop listening to. If omitted, stops it for all objects.
      * @param {String} [event] (Requires the `emitter`) The name of the event to stop listening to. If omitted, stops it
      * for all events from `emitter`.
      * @param {Function} [callback] (Requires the `event`) The function to be removed from the call list for the given
      * `event`.
      * @method utils.EmitterMixin#stopListening
      */
    	stopListening: function stopListening(emitter, event, callback) {
    		var emitters = this._listeningTo;
    		var emitterId = emitter && emitter._emitterId;
    		var emitterInfo = emitters && emitterId && emitters[emitterId];
    		var eventCallbacks = emitterInfo && event && emitterInfo.callbacks[event];

    		// Stop if nothing has been listened.
    		if (!emitters || emitter && !emitterInfo || event && !eventCallbacks) {
    			return;
    		}

    		// All params provided. off() that single callback.
    		if (callback) {
    			emitter.off(event, callback);
    		}
    		// Only `emitter` and `event` provided. off() all callbacks for that event.
    		else if (eventCallbacks) {
    				while (callback = eventCallbacks.pop()) {
    					emitter.off(event, callback);
    				}
    				delete emitterInfo.callbacks[event];
    			}
    			// Only `emitter` provided. off() all events for that emitter.
    			else if (emitterInfo) {
    					for (event in emitterInfo.callbacks) {
    						this.stopListening(emitter, event);
    					}
    					delete emitters[emitterId];
    				}
    				// No params provided. off() all emitters.
    				else {
    						for (emitterId in emitters) {
    							this.stopListening(emitters[emitterId].emitter);
    						}
    						delete this._listeningTo;
    					}
    	},


    	/**
      * Fires an event, executing all callbacks registered for it.
      *
      * The first parameter passed to callbacks is an {@link EventInfo} object, followed by the optional `args` provided in
      * the `fire()` method call.
      *
      * @param {String} event The name of the event.
      * @param {...*} [args] Additional arguments to be passed to the callbacks.
      * @method utils.EmitterMixin#fire
      */
    	fire: function fire(event, args) {
    		var callbacks = getCallbacksForEvent(this, event);

    		if (!callbacks) {
    			return;
    		}

    		var eventInfo = new EventInfo(this, event);

    		// Take the list of arguments to pass to the callbacks.
    		args = Array.prototype.slice.call(arguments, 1);
    		args.unshift(eventInfo);

    		// Save how many callbacks were added at the moment when the event has been fired.
    		var counter = eventsCounter;

    		for (var i = 0; i < callbacks.length; i++) {
    			// Filter out callbacks that have been added after event has been fired.
    			if (callbacks[i].counter > counter) {
    				continue;
    			}

    			callbacks[i].callback.apply(callbacks[i].ctx, args);

    			// Remove the callback from future requests if off() has been called.
    			if (eventInfo.off.called) {
    				// Remove the called mark for the next calls.
    				delete eventInfo.off.called;

    				// Remove the callback from the list (fixing the next index).
    				callbacks.splice(i, 1);
    				i--;
    			}

    			// Do not execute next callbacks if stop() was called.
    			if (eventInfo.stop.called) {
    				break;
    			}
    		}
    	}
    };

    // Gets the internal `_events` property of the given object.
    // `_events` property store all lists with callbacks for registered event names.
    // If there were no events registered on the object, empty `_events` object is created.
    function getEvents(source) {
    	if (!source._events) {
    		Object.defineProperty(source, '_events', {
    			value: {}
    		});
    	}

    	return source._events;
    }

    // Creates event node for generic-specific events relation architecture.
    function makeEventNode() {
    	return {
    		callbacks: [],
    		childEvents: []
    	};
    }

    // Creates an architecture for generic-specific events relation.
    // If needed, creates all events for given eventName, i.e. if the first registered event
    // is foo:bar:abc, it will create foo:bar:abc, foo:bar and foo event and tie them together.
    // It also copies callbacks from more generic events to more specific events when
    // specific events are created.
    function createEventNamespace(source, eventName) {
    	var events = getEvents(source);

    	// First, check if the event we want to add to the structure already exists.
    	if (events[eventName]) {
    		// If it exists, we don't have to do anything.
    		return;
    	}

    	// In other case, we have to create the structure for the event.
    	// Note, that we might need to create intermediate events too.
    	// I.e. if foo:bar:abc is being registered and we only have foo in the structure,
    	// we need to also register foo:bar.

    	// Currently processed event name.
    	var name = eventName;
    	// Name of the event that is a child event for currently processed event.
    	var childEventName = null;

    	// Array containing all newly created specific events.
    	var newEventNodes = [];

    	// While loop can't check for ':' index because we have to handle generic events too.
    	// In each loop, we truncate event name, going from the most specific name to the generic one.
    	// I.e. foo:bar:abc -> foo:bar -> foo.
    	while (name !== '') {
    		if (events[name]) {
    			// If the currently processed event name is already registered, we can be sure
    			// that it already has all the structure created, so we can break the loop here
    			// as no more events need to be registered.
    			break;
    		}

    		// If this event is not yet registered, create a new object for it.
    		events[name] = makeEventNode();
    		// Add it to the array with newly created events.
    		newEventNodes.push(events[name]);

    		// Add previously processed event name as a child of this event.
    		if (childEventName) {
    			events[name].childEvents.push(childEventName);
    		}

    		childEventName = name;
    		// If `.lastIndexOf()` returns -1, `.substr()` will return '' which will break the loop.
    		name = name.substr(0, name.lastIndexOf(':'));
    	}

    	if (name !== '') {
    		// If name is not empty, we found an already registered event that was a parent of the
    		// event we wanted to register.

    		// Copy that event's callbacks to newly registered events.
    		var _iteratorNormalCompletion3 = true;
    		var _didIteratorError3 = false;
    		var _iteratorError3 = undefined;

    		try {
    			for (var _iterator3 = newEventNodes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
    				var node = _step3.value;

    				node.callbacks = events[name].callbacks.slice();
    			}

    			// Add last newly created event to the already registered event.
    		} catch (err) {
    			_didIteratorError3 = true;
    			_iteratorError3 = err;
    		} finally {
    			try {
    				if (!_iteratorNormalCompletion3 && _iterator3.return) {
    					_iterator3.return();
    				}
    			} finally {
    				if (_didIteratorError3) {
    					throw _iteratorError3;
    				}
    			}
    		}

    		events[name].childEvents.push(childEventName);
    	}
    }

    // Gets an array containing callbacks list for a given event and it's more specific events.
    // I.e. if given event is foo:bar and there is also foo:bar:abc event registered, this will
    // return callback list of foo:bar and foo:bar:abc (but not foo).
    // Returns empty array if given event has not been yet registered.
    function getCallbacksListsForNamespace(source, eventName) {
    	var eventNode = getEvents(source)[eventName];

    	if (!eventNode) {
    		return [];
    	}

    	var callbacksLists = [eventNode.callbacks];

    	for (var i = 0; i < eventNode.childEvents.length; i++) {
    		var childCallbacksLists = getCallbacksListsForNamespace(source, eventNode.childEvents[i]);

    		callbacksLists = callbacksLists.concat(childCallbacksLists);
    	}

    	return callbacksLists;
    }

    // Get the list of callbacks for a given event, but only if there any callbacks have been registered.
    // If there are no callbacks registered for given event, it checks if this is a specific event and looks
    // for callbacks for it's more generic version.
    function getCallbacksForEvent(source, eventName) {
    	var event = void 0;

    	if (!source._events || !(event = source._events[eventName]) || !event.callbacks.length) {
    		// There are no callbacks registered for specified eventName.
    		// But this could be a specific-type event that is in a namespace.
    		if (eventName.indexOf(':') > -1) {
    			// If the eventName is specific, try to find callback lists for more generic event.
    			return getCallbacksForEvent(source, eventName.substr(0, eventName.lastIndexOf(':')));
    		} else {
    			// If this is a top-level generic event, return null;
    			return null;
    		}
    	}

    	return event.callbacks;
    }

    /**
     * Interface representing classes which mix in {@link utils.EmitterMixin}.
     *
     * @interface utils.Emitter
     */

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetPrototype = Object.getPrototypeOf;

    /**
     * Gets the `[[Prototype]]` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {null|Object} Returns the `[[Prototype]]`.
     */
    function getPrototype(value) {
      return nativeGetPrototype(Object(value));
    }

    /**
     * Checks if `value` is a host object in IE < 9.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
     */
    function isHostObject(value) {
      // Many host objects are `Object` objects that can coerce to strings
      // despite having improperly defined `toString` methods.
      var result = false;
      if (value != null && typeof value.toString != 'function') {
        try {
          result = !!(value + '');
        } catch (e) {}
      }
      return result;
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
    }

    /** `Object#toString` result references. */
    var objectTag = '[object Object]';

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString = Function.prototype.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object,
     *  else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Handles a configuration dictionary.
     *
     * @memberOf utils
     */

    var Config = function () {
    	/**
      * Creates an instance of the {@link Config} class.
      *
      * @param {Object} [configurations] The initial configurations to be set.
      */

    	function Config(configurations) {
    		classCallCheck(this, Config);

    		/**
       * Store for the whole configuration.
       *
       * @private
       * @member {Object} utils.config#_config
       */
    		this._config = {};

    		// Set initial configuration.
    		if (configurations) {
    			this._setObjectToTarget(this._config, configurations);
    		}
    	}

    	/**
      * Set configuration values.
      *
      * It accepts both a name/value pair or an object, which properties and values will be used to set
      * configurations.
      *
      * It also accepts setting a "deep configuration" by using dots in the name. For example, `'resize.width'` sets
      * the value for the `width` configuration in the `resize` subset.
      *
      *		config.set( 'width', 500 );
      *		config.set( 'toolbar.collapsed', true );
      *
      *		// Equivalent to:
      *		config.set( {
      *			width: 500
      *			toolbar: {
      *				collapsed: true
      *			}
      *		} );
      *
      * Passing an object as the value will amend the configuration, not replace it.
      *
      *		config.set( 'toolbar', {
      *			collapsed: true,
      *		} );
      *
      *		config.set( 'toolbar', {
      *			color: 'red',
      *		} );
      *
      *		config.get( 'toolbar.collapsed' ); // true
      *		config.get( 'toolbar.color' ); // 'red'
      *
      * @param {String|Object} name The configuration name or an object from which take properties as
      * configuration entries. Configuration names are case-sensitive.
      * @param {*} value The configuration value. Used if a name is passed.
      */


    	createClass(Config, [{
    		key: 'set',
    		value: function set(name, value) {
    			this._setToTarget(this._config, name, value);
    		}

    		/**
       * Does exactly the same as {@link #set} with one exception – passed configuration extends
       * existing one, but does not overwrite already defined values.
       *
       * This method is supposed to be called by plugin developers to setup plugin's configurations. It would be
       * rarely used for other needs.
       *
       * @param {String|Object} name The configuration name or an object from which take properties as
       * configuration entries. Configuration names are case-sensitive.
       * @param {*} value The configuration value. Used if a name is passed.
       */

    	}, {
    		key: 'define',
    		value: function define(name, value) {
    			var isDefine = true;

    			this._setToTarget(this._config, name, value, isDefine);
    		}

    		/**
       * Gets the value for a configuration entry.
       *
       *		config.get( 'name' );
       *
       * Deep configurations can be retrieved by separating each part with a dot.
       *
       *		config.get( 'toolbar.collapsed' );
       *
       * @param {String} name The configuration name. Configuration names are case-sensitive.
       * @returns {*} The configuration value or `undefined` if the configuration entry was not found.
       */

    	}, {
    		key: 'get',
    		value: function get(name) {
    			return this._getFromSource(this._config, name);
    		}

    		/**
       * Saves passed configuration to the specified target (nested object).
       *
       * @private
       * @param {Object} target Nested config object.
       * @param {String|Object} name The configuration name or an object from which take properties as
       * configuration entries. Configuration names are case-sensitive.
       * @param {*} value The configuration value. Used if a name is passed.
       * @param {Boolean} [isDefine=false] Define if passed configuration should overwrite existing one.
       */

    	}, {
    		key: '_setToTarget',
    		value: function _setToTarget(target, name, value) {
    			var isDefine = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

    			// In case of an object, iterate through it and call `_setToTarget` again for each property.
    			if (isPlainObject(name)) {
    				this._setObjectToTarget(target, name, isDefine);

    				return;
    			}

    			// The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].
    			var parts = name.split('.');

    			// Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.
    			name = parts.pop();

    			// Iterate over parts to check if currently stored configuration has proper structure.
    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var part = _step.value;

    					// If there is no object for specified part then create one.
    					if (!isPlainObject(target[part])) {
    						target[part] = {};
    					}

    					// Nested object becomes a target.
    					target = target[part];
    				}

    				// In case of value is an object.
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}

    			if (isPlainObject(value)) {
    				// We take care of proper config structure.
    				if (!isPlainObject(target[name])) {
    					target[name] = {};
    				}

    				target = target[name];

    				// And iterate through this object calling `_setToTarget` again for each property.
    				this._setObjectToTarget(target, value, isDefine);

    				return;
    			}

    			// Do nothing if we are defining configuration for non empty name.
    			if (isDefine && typeof target[name] != 'undefined') {
    				return;
    			}

    			target[name] = value;
    		}

    		/**
       * Get specified configuration from specified source (nested object).
       *
       * @private
       * @param {Object} source level of nested object.
       * @param {String} name The configuration name. Configuration names are case-sensitive.
       * @returns {*} The configuration value or `undefined` if the configuration entry was not found.
       */

    	}, {
    		key: '_getFromSource',
    		value: function _getFromSource(source, name) {
    			// The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].
    			var parts = name.split('.');

    			// Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.
    			name = parts.pop();

    			// Iterate over parts to check if currently stored configuration has proper structure.
    			var _iteratorNormalCompletion2 = true;
    			var _didIteratorError2 = false;
    			var _iteratorError2 = undefined;

    			try {
    				for (var _iterator2 = parts[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    					var part = _step2.value;

    					if (!isPlainObject(source[part])) {
    						source = null;
    						break;
    					}

    					// Nested object becomes a source.
    					source = source[part];
    				}

    				// Always returns undefined for non existing configuration
    			} catch (err) {
    				_didIteratorError2 = true;
    				_iteratorError2 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion2 && _iterator2.return) {
    						_iterator2.return();
    					}
    				} finally {
    					if (_didIteratorError2) {
    						throw _iteratorError2;
    					}
    				}
    			}

    			return source ? source[name] : undefined;
    		}

    		/**
       * Iterate through passed object and call {@link #_setToTarget} method with object key and value for each property.
       *
       * @private
       * @param {Object} target Nested config object.
       * @param {Object} configuration Configuration data set
       * @param {Boolean} [isDefine] Defines if passed configuration is default configuration or not.
       */

    	}, {
    		key: '_setObjectToTarget',
    		value: function _setObjectToTarget(target, configuration, isDefine) {
    			var _this = this;

    			Object.keys(configuration).forEach(function (key) {
    				_this._setToTarget(target, key, configuration[key], isDefine);
    			});
    		}
    	}]);
    	return Config;
    }();

    /**
     * The CKEditor error class.
     *
     * All errors will be shortened during the minification process in order to reduce the code size.
     * Therefore, all error messages should be documented in the same way as those in {@link utils.log}.
     *
     * Read more in the {@link utils.log} module.
     *
     * @memberOf utils
     * @extends Error
     */

    var CKEditorError = function (_Error) {
    	inherits(CKEditorError, _Error);

    	/**
      * Creates an instance of the CKEditorError class.
      *
      * Read more about error logging in the {@link utils.log} module.
      *
      * @param {String} message The error message in an `error-name: Error message.` format.
      * During the minification process the "Error message" part will be removed to limit the code size
      * and a link to this error documentation will be added to the `message`.
      * @param {Object} [data] Additional data describing the error. A stringified version of this object
      * will be appended to the error {@link #message}, so the data are quickly visible in the console. The original
      * data object will also be later available under the {@link #data} property.
      */

    	function CKEditorError(message, data) {
    		classCallCheck(this, CKEditorError);

    		if (data) {
    			message += ' ' + JSON.stringify(data);
    		}

    		/**
       * @member {String} utils.CKEditorError#name
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(CKEditorError).call(this, message));

    		_this.name = 'CKEditorError';

    		/**
       * The additional error data passed to the constructor.
       *
       * @member {Object} utils.CKEditorError#data
       */
    		_this.data = data;
    		return _this;
    	}

    	return CKEditorError;
    }(Error);

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }

    /** Used for built-in method references. */
    var objectProto$2 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty$1.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
        object[key] = value;
      }
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : source[key];

        assignValue(object, key, newValue);
      }
      return object;
    }

    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function baseProperty(key) {
      return function (object) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * Gets the "length" property value of `object`.
     *
     * **Note:** This function is used to avoid a
     * [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) that affects
     * Safari on at least iOS 8.1-8.3 ARM64.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {*} Returns the "length" value.
     */
    var getLength = baseProperty('length');

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
      return !!value && (type == 'object' || type == 'function');
    }

    var funcTag = '[object Function]';
    var genTag = '[object GeneratorFunction]';
    /** Used for built-in method references. */
    var objectProto$3 = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString$1 = objectProto$3.toString;

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified,
     *  else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8 which returns 'object' for typed array and weak map constructors,
      // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
      var tag = isObject(value) ? objectToString$1.call(value) : '';
      return tag == funcTag || tag == genTag;
    }

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length,
     *  else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(getLength(value)) && !isFunction(value);
    }

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$1 = 9007199254740991;

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index === 'undefined' ? 'undefined' : _typeof(index);
      if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * A faster alternative to `Function#apply`, this function invokes `func`
     * with the `this` binding of `thisArg` and the arguments of `args`.
     *
     * @private
     * @param {Function} func The function to invoke.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} args The arguments to invoke `func` with.
     * @returns {*} Returns the result of `func`.
     */
    function apply(func, thisArg, args) {
      var length = args.length;
      switch (length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }

    /** `Object#toString` result references. */
    var symbolTag = '[object Symbol]';

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString$2 = objectProto$4.toString;

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified,
     *  else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && objectToString$2.call(value) == symbolTag;
    }

    /** Used as references for various `Number` constants. */
    var NAN = 0 / 0;

    /** Used to match leading and trailing whitespace. */
    var reTrim = /^\s+|\s+$/g;

    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;

    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;

    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = isFunction(value.valueOf) ? value.valueOf() : value;
        value = isObject(other) ? other + '' : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }

    var INFINITY = 1 / 0;
    var MAX_INTEGER = 1.7976931348623157e+308;
    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This function is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? remainder ? result - remainder : result : 0;
    }

    /** Used as the `TypeError` message for "Functions" methods. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max;

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = nativeMax(start === undefined ? func.length - 1 : toInteger(start), 0);
      return function () {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        switch (start) {
          case 0:
            return func.call(this, array);
          case 1:
            return func.call(this, args[0], array);
          case 2:
            return func.call(this, args[0], args[1], array);
        }
        var otherArgs = Array(start + 1);
        index = -1;
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return rest(function (object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /** Used for built-in method references. */
    var objectProto$5 = Object.prototype;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$5;

      return value === proto;
    }

    /**
     * Checks if `value` is a global object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {null|Object} Returns `value` if it's a global object, else `null`.
     */
    function checkGlobal(value) {
      return value && value.Object === Object ? value : null;
    }

    /** Used to determine if values are of the language type `Object`. */
    var objectTypes = {
      'function': true,
      'object': true
    };

    /** Detect free variable `exports`. */
    var freeExports = objectTypes[typeof exports === 'undefined' ? 'undefined' : _typeof(exports)] && exports && !exports.nodeType ? exports : undefined;

    /** Detect free variable `module`. */
    var freeModule = objectTypes[typeof module === 'undefined' ? 'undefined' : _typeof(module)] && module && !module.nodeType ? module : undefined;

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = checkGlobal(freeExports && freeModule && (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global);

    /** Detect free variable `self`. */
    var freeSelf = checkGlobal(objectTypes[typeof self === 'undefined' ? 'undefined' : _typeof(self)] && self);

    /** Detect free variable `window`. */
    var freeWindow = checkGlobal(objectTypes[typeof window === 'undefined' ? 'undefined' : _typeof(window)] && window);

    /** Detect `this` as the global object. */
    var thisGlobal = checkGlobal(objectTypes[_typeof(undefined)] && undefined);

    /**
     * Used as a reference to the global object.
     *
     * The `this` value is used if it's the global object to avoid Greasemonkey's
     * restricted `window` object, otherwise the `window` object is used.
     */
    var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function('return this')();

    /** Built-in value references. */
    var Reflect = root.Reflect;

    /**
     * Converts `iterator` to an array.
     *
     * @private
     * @param {Object} iterator The iterator to convert.
     * @returns {Array} Returns the converted array.
     */
    function iteratorToArray(iterator) {
      var data,
          result = [];

      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$7 = Object.prototype;

    /** Built-in value references. */
    var enumerate = Reflect ? Reflect.enumerate : undefined;
var     propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;
    /**
     * The base implementation of `_.keysIn` which doesn't skip the constructor
     * property of prototypes or treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      object = object == null ? object : Object(object);

      var result = [];
      for (var key in object) {
        result.push(key);
      }
      return result;
    }

    // Fallback for IE < 9 with es6-shim.
    if (enumerate && !propertyIsEnumerable$1.call({ 'valueOf': 1 }, 'valueOf')) {
      baseKeysIn = function baseKeysIn(object) {
        return iteratorToArray(enumerate(object));
      };
    }

    var baseKeysIn$1 = baseKeysIn;

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]';

    /** Used for built-in method references. */
    var objectProto$8 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$3 = objectProto$8.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString$3 = objectProto$8.toString;

    /** Built-in value references. */
    var propertyIsEnumerable$2 = objectProto$8.propertyIsEnumerable;

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
      return isArrayLikeObject(value) && hasOwnProperty$3.call(value, 'callee') && (!propertyIsEnumerable$2.call(value, 'callee') || objectToString$3.call(value) == argsTag);
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @type {Function}
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified,
     *  else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /** `Object#toString` result references. */
    var stringTag = '[object String]';

    /** Used for built-in method references. */
    var objectProto$9 = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString$4 = objectProto$9.toString;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified,
     *  else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' || !isArray(value) && isObjectLike(value) && objectToString$4.call(value) == stringTag;
    }

    /**
     * Creates an array of index keys for `object` values of arrays,
     * `arguments` objects, and strings, otherwise `null` is returned.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array|null} Returns index keys, else `null`.
     */
    function indexKeys(object) {
      var length = object ? object.length : undefined;
      if (isLength(length) && (isArray(object) || isString(object) || isArguments(object))) {
        return baseTimes(length, String);
      }
      return null;
    }

    /** Used for built-in method references. */
    var objectProto$6 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$2 = objectProto$6.hasOwnProperty;

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      var index = -1,
          isProto = isPrototype(object),
          props = baseKeysIn$1(object),
          propsLength = props.length,
          indexes = indexKeys(object),
          skipIndexes = !!indexes,
          result = indexes || [],
          length = result.length;

      while (++index < propsLength) {
        var key = props[index];
        if (!(skipIndexes && (key == 'length' || isIndex(key, length))) && !(key == 'constructor' && (isProto || !hasOwnProperty$2.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;

    /** Built-in value references. */
    var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;

    /** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
    var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * function Bar() {
     *   this.d = 4;
     * }
     *
     * Foo.prototype.c = 3;
     * Bar.prototype.e = 5;
     *
     * _.assignIn({ 'a': 1 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5 }
     */
    var assignIn = createAssigner(function (object, source) {
      if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keysIn(source), object);
        return;
      }
      for (var key in source) {
        assignValue(object, key, source[key]);
      }
    });

    var attributesSymbol = Symbol('attributes');
    var boundObservablesSymbol = Symbol('boundObservables');
    var boundAttributesSymbol = Symbol('boundAttributes');

    /**
     * Mixin that injects the "observable attributes" and data binding functionality.
     * Used mainly in the {@link ui.Model} class.
     *
     * @mixin utils.ObservableMixin
     * @mixes utils.EmitterMixin
     * @implements utils.Observable
     */
    var ObservableMixin = {
    	/**
      * Creates and sets the value of an observable attribute of this object. Such an attribute becomes a part
      * of the state and is be observable.
      *
      * It accepts also a single object literal containing key/value pairs with attributes to be set.
      *
      * This method throws the {@link observable-set-cannot-override} error if the observable instance already
      * have a property with a given attribute name. This prevents from mistakenly overriding existing
      * properties and methods, but means that `foo.set( 'bar', 1 )` may be slightly slower than `foo.bar = 1`.
      *
      * @method utils.ObservableMixin#set
      * @param {String} name The attributes name.
      * @param {*} value The attributes value.
      */

    	set: function set(name, value) {
    		var _this = this;

    		// If the first parameter is an Object, iterate over its properties.
    		if (isObject(name)) {
    			Object.keys(name).forEach(function (attr) {
    				_this.set(attr, name[attr]);
    			}, this);

    			return;
    		}

    		initObservable(this);

    		var attributes = this[attributesSymbol];

    		if (name in this && !attributes.has(name)) {
    			/**
        * Cannot override an existing property.
        *
        * This error is thrown when trying to {@link utils.Observable#set set} an attribute with
        * a name of an already existing property. For example:
        *
        *		let observable = new Model();
        *		observable.property = 1;
        *		observable.set( 'property', 2 );		// throws
        *
        *		observable.set( 'attr', 1 );
        *		observable.set( 'attr', 2 );			// ok, because this is an existing attribute.
        *
        * @error observable-set-cannot-override
        */
    			throw new CKEditorError('observable-set-cannot-override: Cannot override an existing property.');
    		}

    		Object.defineProperty(this, name, {
    			enumerable: true,
    			configurable: true,

    			get: function get() {
    				return attributes.get(name);
    			},
    			set: function set(value) {
    				var oldValue = attributes.get(name);

    				// Allow undefined as an initial value like A.define( 'x', undefined ) (#132).
    				// Note: When attributes map has no such own property, then its value is undefined.
    				if (oldValue !== value || !attributes.has(name)) {
    					attributes.set(name, value);
    					this.fire('change:' + name, name, value, oldValue);
    				}
    			}
    		});

    		this[name] = value;
    	},


    	/**
      * Binds observable attributes to another objects implementing {@link ObservableMixin}
      * interface (like {@link ui.Model}).
      *
      * Once bound, the observable will immediately share the current state of attributes
      * of the observable it is bound to and react to the changes to these attributes
      * in the future.
      *
      * **Note**: To release the binding use {@link utils.ObservableMixin#unbind}.
      *
      *		A.bind( 'a' ).to( B );
      *		A.bind( 'a' ).to( B, 'b' );
      *		A.bind( 'a', 'b' ).to( B, 'c', 'd' );
      *		A.bind( 'a' ).to( B, 'b', C, 'd', ( b, d ) => b + d );
      *
      * @method utils.ObservableMixin#bind
      * @param {String...} bindAttrs Observable attributes that will be bound to another observable(s).
      * @returns {utils.BindChain}
      */
    	bind: function bind() {
    		for (var _len = arguments.length, bindAttrs = Array(_len), _key = 0; _key < _len; _key++) {
    			bindAttrs[_key] = arguments[_key];
    		}

    		if (!bindAttrs.length || !isStringArray(bindAttrs)) {
    			/**
        * All attributes must be strings.
        *
        * @error observable-bind-wrong-attrs
        */
    			throw new CKEditorError('observable-bind-wrong-attrs: All attributes must be strings.');
    		}

    		if (new Set(bindAttrs).size !== bindAttrs.length) {
    			/**
        * Attributes must be unique.
        *
        * @error observable-bind-duplicate-attrs
        */
    			throw new CKEditorError('observable-bind-duplicate-attrs: Attributes must be unique.');
    		}

    		initObservable(this);

    		var boundAttributes = this[boundAttributesSymbol];

    		bindAttrs.forEach(function (attrName) {
    			if (boundAttributes.has(attrName)) {
    				/**
         * Cannot bind the same attribute more that once.
         *
         * @error observable-bind-rebind
         */
    				throw new CKEditorError('observable-bind-rebind: Cannot bind the same attribute more that once.');
    			}
    		});

    		var bindings = new Map();

    		/**
       * @typedef utils.Binding
       * @type Object
       * @property {Array} attr Attribute which is bound.
       * @property {Array} to Array of observable–attribute components of the binding (`{ observable: ..., attr: .. }`).
       * @property {Array} callback A function which processes `to` components.
       */
    		bindAttrs.forEach(function (a) {
    			var binding = { attr: a, to: [] };

    			boundAttributes.set(a, binding);
    			bindings.set(a, binding);
    		});

    		/**
       * @typedef utils.BindChain
       * @type Object
       * @property {Function} to See {@link utils.ObservableMixin#_bindTo}.
       * @property {Observable} _observable The observable which initializes the binding.
       * @property {Array} _bindAttrs Array of `_observable` attributes to be bound.
       * @property {Array} _to Array of `to()` observable–attributes (`{ observable: toObservable, attrs: ...toAttrs }`).
       * @property {Map} _bindings Stores bindings to be kept in
       *  {@link utils.ObservableMixin#_boundAttributes}/{@link utils.ObservableMixin#_boundObservables}
       * initiated in this binding chain.
       */
    		return {
    			to: bindTo,

    			_observable: this,
    			_bindAttrs: bindAttrs,
    			_to: [],
    			_bindings: bindings
    		};
    	},


    	/**
      * Removes the binding created with {@link utils.ObservableMixin#bind}.
      *
      *		A.unbind( 'a' );
      *		A.unbind();
      *
      * @method utils.ObservableMixin#unbind
      * @param {String} [unbindAttrs] Observable attributes to be unbound. All the bindings will
      * be released if no attributes provided.
      */
    	unbind: function unbind() {
    		var _this2 = this;

    		// Nothing to do here if not inited yet.
    		if (!(attributesSymbol in this)) {
    			return;
    		}

    		var boundAttributes = this[boundAttributesSymbol];
    		var boundObservables = this[boundObservablesSymbol];

    		for (var _len2 = arguments.length, unbindAttrs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    			unbindAttrs[_key2] = arguments[_key2];
    		}

    		if (unbindAttrs.length) {
    			if (!isStringArray(unbindAttrs)) {
    				/**
         * Attributes must be strings.
         *
         * @error observable-unbind-wrong-attrs
         */
    				throw new CKEditorError('observable-unbind-wrong-attrs: Attributes must be strings.');
    			}

    			unbindAttrs.forEach(function (attrName) {
    				var binding = boundAttributes.get(attrName);
    				var toObservable = void 0,
    				    toAttr = void 0,
    				    toAttrs = void 0,
    				    toAttrBindings = void 0;

    				binding.to.forEach(function (to) {
    					// TODO: ES6 destructuring.
    					toObservable = to[0];
    					toAttr = to[1];
    					toAttrs = boundObservables.get(toObservable);
    					toAttrBindings = toAttrs[toAttr];

    					toAttrBindings.delete(binding);

    					if (!toAttrBindings.size) {
    						delete toAttrs[toAttr];
    					}

    					if (!Object.keys(toAttrs).length) {
    						boundObservables.delete(toObservable);
    						_this2.stopListening(toObservable, 'change');
    					}
    				});

    				boundAttributes.delete(attrName);
    			});
    		} else {
    			boundObservables.forEach(function (bindings, boundObservable) {
    				_this2.stopListening(boundObservable, 'change');
    			});

    			boundObservables.clear();
    			boundAttributes.clear();
    		}
    	}
    };

    // Init symbol properties needed to for the observable mechanism to work.
    //
    // @private
    // @param {ObservableMixin} observable
    function initObservable(observable) {
    	// Do nothing if already inited.
    	if (attributesSymbol in observable) {
    		return;
    	}

    	// The internal hash containing the observable's state.
    	//
    	// @private
    	// @type {Map}
    	Object.defineProperty(observable, attributesSymbol, {
    		value: new Map()
    	});

    	// Map containing bindings to external observables. It shares the binding objects
    	// (`{ observable: A, attr: 'a', to: ... }`) with {@link utils.ObservableMixin#_boundAttributes} and
    	// it is used to observe external observables to update own attributes accordingly.
    	// See {@link utils.ObservableMixin#bind}.
    	//
    	//		A.bind( 'a', 'b', 'c' ).to( B, 'x', 'y', 'x' );
    	//		console.log( A._boundObservables );
    	//
    	//			Map( {
    	//				B: {
    	//					x: Set( [
    	//						{ observable: A, attr: 'a', to: [ [ B, 'x' ] ] },
    	//						{ observable: A, attr: 'c', to: [ [ B, 'x' ] ] }
    	//					] ),
    	//					y: Set( [
    	//						{ observable: A, attr: 'b', to: [ [ B, 'y' ] ] },
    	//					] )
    	//				}
    	//			} )
    	//
    	//		A.bind( 'd' ).to( B, 'z' ).to( C, 'w' ).as( callback );
    	//		console.log( A._boundObservables );
    	//
    	//			Map( {
    	//				B: {
    	//					x: Set( [
    	//						{ observable: A, attr: 'a', to: [ [ B, 'x' ] ] },
    	//						{ observable: A, attr: 'c', to: [ [ B, 'x' ] ] }
    	//					] ),
    	//					y: Set( [
    	//						{ observable: A, attr: 'b', to: [ [ B, 'y' ] ] },
    	//					] ),
    	//					z: Set( [
    	//						{ observable: A, attr: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }
    	//					] )
    	//				},
    	//				C: {
    	//					w: Set( [
    	//						{ observable: A, attr: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }
    	//					] )
    	//				}
    	//			} )
    	//
    	// @private
    	// @type {Map}
    	Object.defineProperty(observable, boundObservablesSymbol, {
    		value: new Map()
    	});

    	// Object that stores which attributes of this observable are bound and how. It shares
    	// the binding objects (`{ observable: A, attr: 'a', to: ... }`) with {@link utils.ObservableMixin#_boundObservables}.
    	// This data structure is a reverse of {@link utils.ObservableMixin#_boundObservables} and it is helpful for
    	// {@link utils.ObservableMixin#unbind}.
    	//
    	// See {@link utils.ObservableMixin#bind}.
    	//
    	//		A.bind( 'a', 'b', 'c' ).to( B, 'x', 'y', 'x' );
    	//		console.log( A._boundAttributes );
    	//
    	//			Map( {
    	//				a: { observable: A, attr: 'a', to: [ [ B, 'x' ] ] },
    	//				b: { observable: A, attr: 'b', to: [ [ B, 'y' ] ] },
    	//				c: { observable: A, attr: 'c', to: [ [ B, 'x' ] ] }
    	//			} )
    	//
    	//		A.bind( 'd' ).to( B, 'z' ).to( C, 'w' ).as( callback );
    	//		console.log( A._boundAttributes );
    	//
    	//			Map( {
    	//				a: { observable: A, attr: 'a', to: [ [ B, 'x' ] ] },
    	//				b: { observable: A, attr: 'b', to: [ [ B, 'y' ] ] },
    	//				c: { observable: A, attr: 'c', to: [ [ B, 'x' ] ] },
    	//				d: { observable: A, attr: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }
    	//			} )
    	//
    	// @private
    	// @type {Map}
    	Object.defineProperty(observable, boundAttributesSymbol, {
    		value: new Map()
    	});
    }

    // A chaining for {@link utils.ObservableMixin#bind} providing `.to()` interface.
    //
    // @private
    // @param {...[Observable|String|Function]} args Arguments of the `.to( args )` binding.
    function bindTo() {
    	var _this3 = this;

    	/* jshint validthis: true */
    	var parsedArgs = parseBindToArgs.apply(undefined, arguments);
    	var bindingsKeys = Array.from(this._bindings.keys());
    	var numberOfBindings = bindingsKeys.length;

    	// Eliminate A.bind( 'x' ).to( B, C )
    	if (!parsedArgs.callback && parsedArgs.to.length > 1) {
    		/**
       * Binding multiple observables only possible with callback.
       *
       * @error observable-bind-no-callback
       */
    		throw new CKEditorError('observable-bind-to-no-callback: Binding multiple observables only possible with callback.');
    	}

    	// Eliminate A.bind( 'x', 'y' ).to( B, callback )
    	if (numberOfBindings > 1 && parsedArgs.callback) {
    		/**
       * Cannot bind multiple attributes and use a callback in one binding.
       *
       * @error observable-bind-to-extra-callback
       */
    		throw new CKEditorError('observable-bind-to-extra-callback: Cannot bind multiple attributes and use a callback in one binding.');
    	}

    	parsedArgs.to.forEach(function (to) {
    		// Eliminate A.bind( 'x', 'y' ).to( B, 'a' )
    		if (to.attrs.length && to.attrs.length !== numberOfBindings) {
    			/**
        * The number of attributes must match.
        *
        * @error observable-bind-to-attrs-length
        */
    			throw new CKEditorError('observable-bind-to-attrs-length: The number of attributes must match.');
    		}

    		// When no to.attrs specified, observing source attributes instead i.e.
    		// A.bind( 'x', 'y' ).to( B ) -> Observe B.x and B.y
    		if (!to.attrs.length) {
    			to.attrs = _this3._bindAttrs;
    		}
    	});

    	this._to = parsedArgs.to;

    	// Fill {@link BindChain#_bindings} with callback. When the callback is set there's only one binding.
    	if (parsedArgs.callback) {
    		this._bindings.get(bindingsKeys[0]).callback = parsedArgs.callback;
    	}

    	attachBindToListeners(this._observable, this._to);

    	// Update observable._boundAttributes and observable._boundObservables.
    	updateBindToBound(this);

    	// Set initial values of bound attributes.
    	this._bindAttrs.forEach(function (attrName) {
    		updateBoundObservableAttr(_this3._observable, attrName);
    	});
    }

    // Check if all entries of the array are of `String` type.
    //
    // @private
    // @param {Array} arr An array to be checked.
    // @returns {Boolean}
    function isStringArray(arr) {
    	return arr.every(function (a) {
    		return typeof a == 'string';
    	});
    }

    // Parses and validates {@link Observable#bind}`.to( args )` arguments and returns
    // an object with a parsed structure. For example
    //
    //		A.bind( 'x' ).to( B, 'a', C, 'b', call );
    //
    // becomes
    //
    //		{
    //			to: [
    //				{ observable: B, attrs: [ 'a' ] },
    //				{ observable: C, attrs: [ 'b' ] },
    //			],
    //			callback: call
    // 		}
    //
    // @private
    // @param {...*} args Arguments of {@link Observable#bind}`.to( args )`.
    // @returns {Object}
    function parseBindToArgs() {
    	for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    		args[_key3] = arguments[_key3];
    	}

    	// Eliminate A.bind( 'x' ).to()
    	if (!args.length) {
    		/**
       * Invalid argument syntax in `to()`.
       *
       * @error observable-bind-to-parse-error
       */
    		throw new CKEditorError('observable-bind-to-parse-error: Invalid argument syntax in `to()`.');
    	}

    	var parsed = { to: [] };
    	var lastObservable = void 0;

    	if (typeof args[args.length - 1] == 'function') {
    		parsed.callback = args.pop();
    	}

    	args.forEach(function (a) {
    		if (typeof a == 'string') {
    			lastObservable.attrs.push(a);
    		} else if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) == 'object') {
    			lastObservable = { observable: a, attrs: [] };
    			parsed.to.push(lastObservable);
    		} else {
    			throw new CKEditorError('observable-bind-to-parse-error: Invalid argument syntax in `to()`.');
    		}
    	});

    	return parsed;
    }

    // Synchronizes {@link Observable#_boundObservables} with {@link Binding}.
    //
    // @private
    // @param {Binding} binding A binding to store in {@link Observable#_boundObservables}.
    // @param {Observable} toObservable A observable, which is a new component of `binding`.
    // @param {String} toAttrName A name of `toObservable`'s attribute, a new component of the `binding`.
    function updateBoundObservables(observable, binding, toObservable, toAttrName) {
    	var boundObservables = observable[boundObservablesSymbol];
    	var bindingsToObservable = boundObservables.get(toObservable);
    	var bindings = bindingsToObservable || {};

    	if (!bindings[toAttrName]) {
    		bindings[toAttrName] = new Set();
    	}

    	// Pass the binding to a corresponding Set in `observable._boundObservables`.
    	bindings[toAttrName].add(binding);

    	if (!bindingsToObservable) {
    		boundObservables.set(toObservable, bindings);
    	}
    }

    // Synchronizes {@link Observable#_boundAttributes} and {@link Observable#_boundObservables}
    // with {@link BindChain}.
    //
    // Assuming the following binding being created
    //
    // 		A.bind( 'a', 'b' ).to( B, 'x', 'y' );
    //
    // the following bindings were initialized by {@link Observable#bind} in {@link BindChain#_bindings}:
    //
    // 		{
    // 			a: { observable: A, attr: 'a', to: [] },
    // 			b: { observable: A, attr: 'b', to: [] },
    // 		}
    //
    // Iterate over all bindings in this chain and fill their `to` properties with
    // corresponding to( ... ) arguments (components of the binding), so
    //
    // 		{
    // 			a: { observable: A, attr: 'a', to: [ B, 'x' ] },
    // 			b: { observable: A, attr: 'b', to: [ B, 'y' ] },
    // 		}
    //
    // Then update the structure of {@link Observable#_boundObservables} with updated
    // binding, so it becomes:
    //
    // 		Map( {
    // 			B: {
    // 				x: Set( [
    // 					{ observable: A, attr: 'a', to: [ [ B, 'x' ] ] }
    // 				] ),
    // 				y: Set( [
    // 					{ observable: A, attr: 'b', to: [ [ B, 'y' ] ] },
    // 				] )
    //			}
    // 		} )
    //
    // @private
    // @param {BindChain} chain The binding initialized by {@link Observable#bind}.
    function updateBindToBound(chain) {
    	var toAttr = void 0;

    	chain._bindings.forEach(function (binding, attrName) {
    		// Note: For a binding without a callback, this will run only once
    		// like in A.bind( 'x', 'y' ).to( B, 'a', 'b' )
    		// TODO: ES6 destructuring.
    		chain._to.forEach(function (to) {
    			toAttr = to.attrs[binding.callback ? 0 : chain._bindAttrs.indexOf(attrName)];

    			binding.to.push([to.observable, toAttr]);
    			updateBoundObservables(chain._observable, binding, to.observable, toAttr);
    		});
    	});
    }

    // Updates an attribute of a {@link Observable} with a value
    // determined by an entry in {@link Observable#_boundAttributes}.
    //
    // @private
    // @param {Observable} observable A observable which attribute is to be updated.
    // @param {String} attrName An attribute to be updated.
    function updateBoundObservableAttr(observable, attrName) {
    	var boundAttributes = observable[boundAttributesSymbol];
    	var binding = boundAttributes.get(attrName);
    	var attrValue = void 0;

    	// When a binding with callback is created like
    	//
    	// 		A.bind( 'a' ).to( B, 'b', C, 'c', callback );
    	//
    	// collect B.b and C.c, then pass them to callback to set A.a.
    	if (binding.callback) {
    		attrValue = binding.callback.apply(observable, binding.to.map(function (to) {
    			return to[0][to[1]];
    		}));
    	} else {
    		attrValue = binding.to[0];
    		attrValue = attrValue[0][attrValue[1]];
    	}

    	if (observable.hasOwnProperty(attrName)) {
    		observable[attrName] = attrValue;
    	} else {
    		observable.set(attrName, attrValue);
    	}
    }

    // Starts listening to changes in {@link BindChain._to} observables to update
    // {@link BindChain._observable} {@link BindChain._bindAttrs}. Also sets the
    // initial state of {@link BindChain._observable}.
    //
    // @private
    // @param {BindChain} chain The chain initialized by {@link Observable#bind}.
    function attachBindToListeners(observable, toBindings) {
    	toBindings.forEach(function (to) {
    		var boundObservables = observable[boundObservablesSymbol];
    		var bindings = void 0;

    		// If there's already a chain between the observables (`observable` listens to
    		// `to.observable`), there's no need to create another `change` event listener.
    		if (!boundObservables.get(to.observable)) {
    			observable.listenTo(to.observable, 'change', function (evt, attrName) {
    				bindings = boundObservables.get(to.observable)[attrName];

    				// Note: to.observable will fire for any attribute change, react
    				// to changes of attributes which are bound only.
    				if (bindings) {
    					bindings.forEach(function (binding) {
    						updateBoundObservableAttr(observable, binding.attr);
    					});
    				}
    			});
    		}
    	});
    }

    assignIn(ObservableMixin, EmitterMixin);

    /**
     * Copies enumerable properties and symbols from the objects given as 2nd+ parameters to the
     * prototype of first object (a constructor).
     *
     *		class Editor {
     *			...
     *		}
     *
     *		const SomeMixin = {
     *			a() {
     *				return 'a';
     *			}
     *		};
     *
     *		mix( Editor, SomeMixin, ... );
     *
     *		new Editor().a(); // -> 'a'
     *
     * Note: Properties which already exist in the base class will not be overriden.
     *
     * @memberOf utils
     * @param {Function} [baseClass] Class which prototype will be extended.
     * @param {Object} [...mixins] Objects from which to get properties.
     */

    function mix(baseClass) {
      for (var _len = arguments.length, mixins = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        mixins[_key - 1] = arguments[_key];
      }

      mixins.forEach(function (mixin) {
        Object.getOwnPropertyNames(mixin).concat(Object.getOwnPropertySymbols(mixin)).forEach(function (key) {
          if (key in baseClass.prototype) {
            return;
          }

          var sourceDescriptor = Object.getOwnPropertyDescriptor(mixin, key);
          sourceDescriptor.enumerable = false;

          Object.defineProperty(baseClass.prototype, key, sourceDescriptor);
        });
      });
    }

    /**
     * The base class for CKEditor plugin classes.
     *
     * @memberOf ckeditor5
     * @mixes utils.ObservaleMixin
     */

    var Plugin = function () {
    	/**
      * Creates a new Plugin instance.
      *
      * @param {ckeditor5.Editor} editor
      */

    	function Plugin(editor) {
    		classCallCheck(this, Plugin);

    		/**
       * @readonly
       * @member {ckeditor5.Editor} ckeditor5.Plugin#editor
       */
    		this.editor = editor;
    	}

    	/**
      * An array of plugins required by this plugin.
      *
      * To keep a plugin class definition tight it's recommended to define this property as a static getter:
      *
      *		import Image from './image.js';
      *
      *		export default class ImageCaption extends Feature {
         *			static get requires() {
         *				return [ Image ];
         *			}
      *		}
      *
      * @static
      * @member {Function[]} ckeditor5.Plugin.requires
      */

    	/**
      * @returns {null|Promise}
      */


    	createClass(Plugin, [{
    		key: 'init',
    		value: function init() {}

    		/**
       * Destroys the plugin.
       *
       * @returns {null|Promise}
       */

    	}, {
    		key: 'destroy',
    		value: function destroy() {}
    	}]);
    	return Plugin;
    }();

    mix(Plugin, ObservableMixin);

    /**
     * The logging module.
     *
     * This object features two functions that should be used across CKEditor code base to log errors and warnings.
     * Despite being an overridable interface for native `console.*` this module serves also the goal to limit the
     * code size of a minified CKEditor package. During minification process the messages will be shortened and
     * links to their documentation will be logged to the console.
     *
     * All errors and warning should be documented in the following way:
     *
     *		/**
     *		 * Error thrown when a plugin cannot be loaded due to JavaScript errors, lack of plugins with a given name, etc.
     *		 *
     *		 * @error plugin-load
     *		 * @param pluginName The name of the plugin that could not be loaded.
     *		 * @param moduleName The name of the module which tried to load this plugin.
     *		 * /
     *		log.error( 'plugin-load: It was not possible to load the "{$pluginName}" plugin in module "{$moduleName}', {
     *			pluginName: 'foo',
     *			moduleName: 'bar'
     *		} );
     *
     * ### Warning vs Error vs Throw
     *
     * * Whenever a potentially incorrect situation occurs, which does not directly lead to an incorrect behavior,
     * log a warning.
     * * Whenever an incorrect situation occurs, but the app may continue working (although perhaps incorrectly),
     * log an error.
     * * Whenever it's really bad and it does not make sense to continue working, throw a {@link utils.CKEditorError}.
     *
     * @namespace utils.log
     */

    var log = {
      /**
       * Logs an error to the console.
       *
       * Read more about error logging in the {@link utils.log} module.
       *
       * @param {String} message The error message in an `error-name: Error message.` format.
       * During the minification process the "Error message" part will be removed to limit the code size
       * and a link to this error documentation will be logged to the console.
       * @param {Object} [data] Additional data describing the error.
       * @method utils.log.error
       */

      error: function error(message, data) {
        console.error(message, data);
      },


      /**
       * Logs a warning to the console.
       *
       * Read more about error logging in the {@link utils.log} module.
       *
       * @param {String} message The warning message in a `warning-name: Warning message.` format.
       * During the minification process the "Warning message" part will be removed to limit the code size
       * and a link to this error documentation will be logged to the console.
       * @param {Object} [data] Additional data describing the warning.
       * @method utils.log.warn
       */
      warn: function warn(message, data) {
        console.warn(message, data);
      }
    };

    /* global System */

    function load(modulePath) {
    	modulePath = '../' + modulePath;

    	return System.import(modulePath).then(function (module) {
    		return module;
    	});
    }

    /**
     * Manages a list of CKEditor plugins, including loading, resolving dependencies and initialization.
     *
     * @memberOf ckeditor5
     */

    var PluginCollection = function () {
    	/**
      * Creates an instance of the PluginCollection class, initializing it with a set of plugins.
      *
      * @param {ckeditor5.Editor} editor
      */

    	function PluginCollection(editor) {
    		classCallCheck(this, PluginCollection);

    		/**
       * @protected
       * @member {ckeditor5.Editor} ckeditor5.PluginCollection#_editor
       */
    		this._editor = editor;

    		/**
       * @protected
       * @member {Map} ckeditor5.PluginCollection#_plugins
       */
    		this._plugins = new Map();
    	}

    	/**
      * Collection iterator. Returns `[ key, plugin ]` pairs. Plugins which are
      * kept in the collection twice (under their name and class) will be returned twice.
      */


    	createClass(PluginCollection, [{
    		key: Symbol.iterator,
    		value: function value() {
    			return this._plugins[Symbol.iterator]();
    		}

    		/**
       * Gets the plugin instance by its name or class.
       *
       * @param {String/Function} key The name of the plugin or the class.
       * @returns {ckeditor5.Plugin}
       */

    	}, {
    		key: 'get',
    		value: function get(key) {
    			return this._plugins.get(key);
    		}

    		/**
       * Loads a set of plugins and add them to the collection.
       *
       * @param {String[]} plugins An array of plugins to load.
       * @returns {Promise} A promise which gets resolved once all plugins are loaded and available into the
       * collection.
       * @param {ckeditor5.Plugin[]} returns.loadedPlugins The array of loaded plugins.
       */

    	}, {
    		key: 'load',
    		value: function load$$(plugins) {
    			var that = this;
    			var editor = this._editor;
    			var loading = new Set();
    			var loaded = [];

    			return Promise.all(plugins.map(loadPlugin)).then(function () {
    				return loaded;
    			});

    			function loadPlugin(pluginClassOrName) {
    				// The plugin is already loaded or being loaded - do nothing.
    				if (that.get(pluginClassOrName) || loading.has(pluginClassOrName)) {
    					return;
    				}

    				var promise = typeof pluginClassOrName == 'string' ? loadPluginByName(pluginClassOrName) : loadPluginByClass(pluginClassOrName);

    				return promise.catch(function (err) {
    					/**
          * It was not possible to load the plugin.
          *
          * @error plugincollection-load
          * @param {String} plugin The name of the plugin that could not be loaded.
          */
    					log.error('plugincollection-load: It was not possible to load the plugin.', { plugin: pluginClassOrName });

    					throw err;
    				});
    			}

    			function loadPluginByName(pluginName) {
    				return load(PluginCollection.getPluginPath(pluginName)).then(function (PluginModule) {
    					return loadPluginByClass(PluginModule.default, pluginName);
    				});
    			}

    			function loadPluginByClass(PluginClass, pluginName) {
    				return new Promise(function (resolve) {
    					loading.add(PluginClass);

    					assertIsPlugin(PluginClass);

    					if (PluginClass.requires) {
    						PluginClass.requires.forEach(loadPlugin);
    					}

    					var plugin = new PluginClass(editor);
    					that._add(PluginClass, plugin);
    					loaded.push(plugin);

    					// Expose the plugin also by its name if loaded through load() by name.
    					if (pluginName) {
    						that._add(pluginName, plugin);
    					}

    					resolve();
    				});
    			}

    			function assertIsPlugin(LoadedPlugin) {
    				if (!(LoadedPlugin.prototype instanceof Plugin)) {
    					/**
          * The loaded plugin module is not an instance of Plugin.
          *
          * @error plugincollection-instance
          * @param {LoadedPlugin} plugin The class which is meant to be loaded as a plugin.
          */
    					throw new CKEditorError('plugincollection-instance: The loaded plugin module is not an instance of Plugin.', { plugin: LoadedPlugin });
    				}
    			}
    		}

    		/**
       * Resolves a simplified plugin name to a real path. The returned
       * paths are relative to the main `ckeditor.js` file, but they do not start with `./`.
       *
       * For instance:
       *
       * * `foo` will be transformed to `ckeditor5/foo/foo.js`,
       * * `ui/controller` to `ckeditor5/ui/controller.js` and
       * * `foo/bar/bom` to `ckeditor5/foo/bar/bom.js`.
       *
       * @param {String} name
       * @returns {String} Path to the module.
       */

    	}, {
    		key: '_add',


    		/**
       * Adds the plugin to the collection. Exposed mainly for testing purposes.
       *
       * @protected
       * @param {String/Function} key The name or the plugin class.
       * @param {ckeditor5.Plugin} plugin The instance of the plugin.
       */
    		value: function _add(key, plugin) {
    			this._plugins.set(key, plugin);
    		}
    	}], [{
    		key: 'getPluginPath',
    		value: function getPluginPath(name) {
    			// Resolve shortened feature names to `featureName/featureName`.
    			if (name.indexOf('/') < 0) {
    				name = name + '/' + name;
    			}

    			return 'ckeditor5/' + name + '.js';
    		}
    	}]);
    	return PluginCollection;
    }();

    /**
     * Represents the localization services.
     *
     * @memberOf utils
     */

    var Locale = function () {
    	/**
      * Creates a new instance of the Locale class. {@link Foo#bar}
      *
      * @param {String} [lang='en'] The language code in [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.
      */

    	function Locale(lang) {
    		var _this = this;

    		classCallCheck(this, Locale);

    		/**
       * The language code in [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.
       *
       * @readonly
       * @member {String} utils.Locale#lang
       */
    		this.lang = lang || 'en';

    		/**
       * Translates the given string to the {@link #lang}. This method is also availble in {@link Editor#t} and
       * {@link ui.View#t}.
       *
       * The strings may contain placeholders (`%<index>`) for values which are passed as the second argument.
       * `<index>` is the index in the `values` array.
       *
       *		editor.t( 'Created file "%0" in %1ms.', [ fileName, timeTaken ] );
       *
       * This method's context is statically bound to Locale instance,
       * so it can be called as a function:
       *
       *		const t = this.t;
       *		t( 'Label' );
       *
       * @method utils.Locale#t
       * @param {String} str The string to translate.
       * @param {String[]} values Values that should be used to interpolate the string.
       */
    		this.t = function () {
    			return _this._t.apply(_this, arguments);
    		};
    	}

    	/**
      * Base for the {@link #t} method.
      *
      * @private
      */


    	createClass(Locale, [{
    		key: '_t',
    		value: function _t(str, values) {
    			if (values) {
    				str = str.replace(/\%(\d+)/g, function (match, index) {
    					return index < values.length ? values[index] : match;
    				});
    			}

    			return str;
    		}
    	}]);
    	return Locale;
    }();

    /**
     * Transforms object to map.
     *
     *		const map = objectToMap( { 'foo': 1, 'bar': 2 } );
     *		map.get( 'foo' ); // 1
     *
     * @memberOf utils
     * @param {Object} obj Object to transform.
     * @returns {Map} Map created from object.
     */

    function objectToMap(obj) {
      var map = new Map();

      for (var key in obj) {
        map.set(key, obj[key]);
      }

      return map;
    }

    /**
     * Transforms object or iterable to map. Iterable needs to be in the format acceptable by the `Map` constructor.
     *
     *		map = toMap( { 'foo': 1, 'bar': 2 } );
     *		map = toMap( [ [ 'foo', 1 ], [ 'bar', 2 ] ] );
     *		map = toMap( anotherMap );
     *
     * @memberOf utils
     * @param {Object|Iterable} data Object or iterable to transform.
     * @returns {Map} Map created from data.
     */
    function toMap(data) {
      if (isPlainObject(data)) {
        return objectToMap(data);
      } else {
        return new Map(data);
      }
    }

    /**
     * Tree model node. This is an abstract class for other classes representing different nodes in Tree Model.
     *
     * @memberOf engine.model
     */

    var Node$1 = function () {
    	/**
      * Creates a tree node.
      *
      * This is an abstract class, so this constructor should not be used directly.
      *
      * @abstract
      * @param {Iterable|Object} [attrs] Iterable collection of attributes.
      */

    	function Node(attrs) {
    		classCallCheck(this, Node);

    		/**
       * Element or DocumentFragment that is a parent of this node.
       *
       * @readonly
       * @member {engine.model.Element|engine.model.DocumentFragment|null} engine.model.Node#parent
       */
    		this.parent = null;

    		/**
       * List of attributes set on this node.
       *
       * **Note:** It is **important** that attributes of nodes already attached to the document must be changed
       * only by an {@link engine.model.operation.AttributeOperation}. Do not set attributes of such nodes
       * using {@link engine.model.Node} methods.
       *
       * @protected
       * @member {Map} engine.model.Node#_attrs
       */
    		this._attrs = toMap(attrs);
    	}

    	/**
      * Depth of the node, which equals to total number of its parents.
      *
      * @readonly
      * @type {Number}
      */


    	createClass(Node, [{
    		key: 'getIndex',


    		/**
       * Index of the node in the parent element or null if the node has no parent.
       *
       * Throws error if the parent element does not contain this node.
       *
       * @returns {Number|Null} Index of the node in the parent element or null if the node has not parent.
       */
    		value: function getIndex() {
    			var pos = void 0;

    			if (!this.parent) {
    				return null;
    			}

    			if ((pos = this.parent.getChildIndex(this)) == -1) {
    				/**
         * The node's parent does not contain this node.
         *
         * @error node-not-found-in-parent
         */
    				throw new CKEditorError('node-not-found-in-parent: The node\'s parent does not contain this node.');
    			}

    			return pos;
    		}

    		/**
       * Gets path to the node. For example if the node is the second child of the first child of the root then the path
       * will be `[ 1, 2 ]`. This path can be used as a parameter of {@link engine.model.Position}.
       *
       * @returns {Number[]} The path.
       */

    	}, {
    		key: 'getPath',
    		value: function getPath() {
    			var path = [];
    			var node = this;

    			while (node.parent) {
    				path.unshift(node.getIndex());
    				node = node.parent;
    			}

    			return path;
    		}

    		/**
       * Checks if the node has an attribute for given key.
       *
       * @param {String} key Key of attribute to check.
       * @returns {Boolean} `true` if attribute with given key is set on node, `false` otherwise.
       */

    	}, {
    		key: 'hasAttribute',
    		value: function hasAttribute(key) {
    			return this._attrs.has(key);
    		}

    		/**
       * Gets an attribute value for given key or undefined if that attribute is not set on node.
       *
       * @param {String} key Key of attribute to look for.
       * @returns {*} Attribute value or null.
       */

    	}, {
    		key: 'getAttribute',
    		value: function getAttribute(key) {
    			return this._attrs.get(key);
    		}

    		/**
       * Returns iterator that iterates over this node attributes.
       *
       * @returns {Iterable.<*>}
       */

    	}, {
    		key: 'getAttributes',
    		value: function getAttributes() {
    			return this._attrs[Symbol.iterator]();
    		}

    		/**
       * Custom toJSON method to solve child-parent circular dependencies.
       *
       * @returns {Object} Clone of this object with the parent property replaced with its name.
       */

    	}, {
    		key: 'toJSON',
    		value: function toJSON() {
    			var json = {};

    			if (this._attrs.size) {
    				json.attributes = [].concat(toConsumableArray(this._attrs));
    			}

    			return json;
    		}
    	}, {
    		key: 'depth',
    		get: function get() {
    			var depth = 0;
    			var parent = this.parent;

    			while (parent) {
    				depth++;

    				parent = parent.parent;
    			}

    			return depth;
    		}

    		/**
       * Nodes next sibling or `null` if it is the last child.
       *
       * @readonly
       * @type {engine.model.Node|null}
       */

    	}, {
    		key: 'nextSibling',
    		get: function get() {
    			var index = this.getIndex();

    			return index !== null && this.parent.getChild(index + 1) || null;
    		}

    		/**
       * Nodes previous sibling or null if it is the last child.
       *
       * @readonly
       * @type {engine.model.Node|null}
       */

    	}, {
    		key: 'previousSibling',
    		get: function get() {
    			var index = this.getIndex();

    			return index !== null && this.parent.getChild(index - 1) || null;
    		}

    		/**
       * The top parent for the node. If node has no parent it is the root itself.
       *
       * @readonly
       * @type {engine.model.Element}
       */

    	}, {
    		key: 'root',
    		get: function get() {
    			var root = this;

    			while (root.parent) {
    				root = root.parent;
    			}

    			return root;
    		}
    	}]);
    	return Node;
    }();

    /**
     * A proxy object representing one character stored in the tree data model. It looks and behaves like
     * normal node, but is a read-only structure. This is a representation of the data. Manipulating it won't affect
     * the actual nodes in tree model.
     *
     * Keep in mind that CharacterProxy is static, meaning that it won't change when tree model changes. For example, if you
     * have a {engine.model.Element element} `myEl` containing text `foobar` and then assign `let b = myEl.getChild( 3 )`
     * and then remove all nodes from `myEl`, `b` will still have character `b`, parent `myEl` and offset `3`.
     *
     * CharacterProxy is created on the fly basing on tree model. It is not an explicit node in a tree model but
     * rather represents it. Because of this, it is not advised to store or compare instances of CharacterProxy class.
     * If you want to keep live reference to a point in a text, you should use {@link engine.model.LivePosition}.
     *
     * You should never create an instance of this class by your own. When passing parameters to constructors,
     * use string literals or {@link engine.model.Text} instead.
     *
     * @memberOf engine.model
     * @extends engine.model.Node
     */

    var CharacterProxy = function (_Node) {
    	inherits(CharacterProxy, _Node);

    	/**
      * Creates character node proxy.
      *
      * @protected
      * @param {engine.model.NodeListText} nodeListText Reference to a text object in a node list containing this character.
      * @param {Number} index Index of the character in `nodeListText`.
      */

    	function CharacterProxy(nodeListText, index) {
    		classCallCheck(this, CharacterProxy);


    		/**
       * Character represented by this proxy.
       *
       * @readonly
       * @member {String} engine.model.CharacterProxy#character
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(CharacterProxy).call(this, nodeListText._attrs));

    		_this.character = nodeListText.text.substr(index, 1);

    		/**
       * @inheritdoc
       */
    		_this.parent = nodeListText.parent;

    		/**
       * Reference to a text object in a node list containing this character.
       *
       * @protected
       * @readonly
       * @member {engine.model.NodeListText} engine.model.CharacterProxy#_nodeListText
       */
    		_this._nodeListText = nodeListText;

    		/**
       * Index of the character in `nodeListText`.
       *
       * @protected
       * @readonly
       * @member {Number} engine.model.CharacterProxy#_index
       */
    		_this._index = index;
    		return _this;
    	}

    	/**
      * Sets attribute on the text fragment. If attribute with the same key already is set, it overwrites its values.
      *
      * **Note:** Changing attributes of text fragment affects document state. This TextProxy instance properties
      * will be refreshed, but other may get invalidated. It is highly unrecommended to store references to TextProxy instances.
      *
      * @param {String} key Key of attribute to set.
      * @param {*} value Attribute value.
      */


    	createClass(CharacterProxy, [{
    		key: 'setAttribute',
    		value: function setAttribute(key, value) {
    			var index = this.getIndex();

    			this.parent._children.setAttribute(index, 1, key, value);
    			this._attrs.set(key, value);
    		}

    		/**
       * Removes all attributes from the character proxy and sets given attributes.
       *
       * **Note:** Changing attributes of character proxy affects document state. This `CharacterProxy` instance properties
       * will be refreshed, but other instances of `CharacterProxy` and `TextProxy` may get invalidated.
       * It is highly unrecommended to store references to `CharacterProxy` instances.
       *
       * @param {Iterable|Object} attrs Iterable object containing attributes to be set. See
       * {@link engine.model.CharacterProxy#getAttributes}.
       */

    	}, {
    		key: 'setAttributesTo',
    		value: function setAttributesTo(attrs) {
    			var attrsMap = toMap(attrs);

    			this.clearAttributes();

    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = attrsMap[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var attr = _step.value;

    					this.setAttribute(attr[0], attr[1]);
    				}
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}
    		}

    		/**
       * Removes an attribute with given key from the character proxy.
       *
       * **Note:** Changing attributes of character proxy affects document state. This `CharacterProxy` instance properties
       * will be refreshed, but other instances of `CharacterProxy` and `TextProxy` may get invalidated.
       * It is highly unrecommended to store references to `CharacterProxy` instances.
       *
       * @param {String} key Key of attribute to remove.
       */

    	}, {
    		key: 'removeAttribute',
    		value: function removeAttribute(key) {
    			this.setAttribute(key, null);
    		}

    		/**
       * Removes all attributes from the character proxy.
       *
       * **Note:** Changing attributes of character proxy affects document state. This `CharacterProxy` instance properties
       * will be refreshed, but other instances of `CharacterProxy` and `TextProxy` may get invalidated.
       * It is highly unrecommended to store references to `CharacterProxy` instances.
       */

    	}, {
    		key: 'clearAttributes',
    		value: function clearAttributes() {
    			var _iteratorNormalCompletion2 = true;
    			var _didIteratorError2 = false;
    			var _iteratorError2 = undefined;

    			try {
    				for (var _iterator2 = this.getAttributes()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    					var attr = _step2.value;

    					this.removeAttribute(attr[0]);
    				}
    			} catch (err) {
    				_didIteratorError2 = true;
    				_iteratorError2 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion2 && _iterator2.return) {
    						_iterator2.return();
    					}
    				} finally {
    					if (_didIteratorError2) {
    						throw _iteratorError2;
    					}
    				}
    			}
    		}
    	}]);
    	return CharacterProxy;
    }(Node$1);

    /**
     * Data structure for text with attributes. Note that `Text` is not a {@link engine.model.Node}. This class is used
     * as an aggregator for multiple characters that have same attributes. Example usage:
     *
     *        let myElem = new Element( 'li', [], new Text( 'text with attributes', { foo: true, bar: true } ) );
     *
     * @memberOf engine.model
     */

    var Text$1 = function () {
    	/**
      * Creates a text with attributes.
      *
      * @param {String} text Described text.
      * @param {Iterable|Object} [attrs] Iterable collection of attributes.
      */

    	function Text(text, attrs) {
    		classCallCheck(this, Text);

    		/**
       * Text.
       *
       * @readonly
       * @member {String} engine.model.Text#text
       */
    		this.text = text || '';

    		/**
       * List of attributes bound with the text.
       *
       * @protected
       * @member {Map} engine.model.Text#_attrs
       */
    		this._attrs = toMap(attrs);
    	}

    	/**
      * Checks if the text has an attribute for given key.
      *
      * @param {String} key Key of attribute to check.
      * @returns {Boolean} `true` if attribute with given key is set on text, `false` otherwise.
      */


    	createClass(Text, [{
    		key: 'hasAttribute',
    		value: function hasAttribute(key) {
    			return this._attrs.has(key);
    		}

    		/**
       * Gets an attribute value for given key or undefined if that attribute is not set on text.
       *
       * @param {String} key Key of attribute to look for.
       * @returns {*} Attribute value or null.
       */

    	}, {
    		key: 'getAttribute',
    		value: function getAttribute(key) {
    			return this._attrs.get(key);
    		}

    		/**
       * Returns iterator that iterates over this text attributes.
       *
       * @returns {Iterable.<*>}
       */

    	}, {
    		key: 'getAttributes',
    		value: function getAttributes() {
    			return this._attrs[Symbol.iterator]();
    		}

    		/**
       * Sets attribute on text. If attribute with the same key already is set, it overwrites its value.
       *
       * @param {String} key Key of attribute to set.
       * @param {*} value Attribute value.
       */

    	}, {
    		key: 'setAttribute',
    		value: function setAttribute(key, value) {
    			this._attrs.set(key, value);
    		}

    		/**
       * Removes all attributes from text and sets given attributes.
       *
       * @param {Iterable|Object} attrs Iterable object containing attributes to be set. See {@link engine.model.Text#getAttributes}.
       */

    	}, {
    		key: 'setAttributesTo',
    		value: function setAttributesTo(attrs) {
    			this._attrs = toMap(attrs);
    		}

    		/**
       * Removes an attribute with given key from text.
       *
       * @param {String} key Key of attribute to remove.
       * @returns {Boolean} `true` if the attribute was set on text, `false` otherwise.
       */

    	}, {
    		key: 'removeAttribute',
    		value: function removeAttribute(key) {
    			return this._attrs.delete(key);
    		}

    		/**
       * Removes all attributes from text.
       */

    	}, {
    		key: 'clearAttributes',
    		value: function clearAttributes() {
    			this._attrs.clear();
    		}

    		/**
       * Custom toJSON method to solve child-parent circular dependencies.
       *
       * @returns {Object} Clone of this object with the parent property replaced with its name.
       */

    	}, {
    		key: 'toJSON',
    		value: function toJSON() {
    			var json = {
    				text: this.text
    			};

    			if (this._attrs.size) {
    				json.attributes = [].concat(toConsumableArray(this._attrs));
    			}

    			return json;
    		}
    	}]);
    	return Text;
    }();

    /**
     * TextProxy is an aggregator for multiple CharacterProxy instances that are placed next to each other in
     * tree model, in the same parent, and all have same attributes set. Instances of this class are created and returned
     * in various algorithms that "merge characters" (see {@link engine.model.TreeWalker}, {@link engine.model.Range}).
     *
     * **Note:** TextProxy instances are created on the fly basing on the current state of tree model and attributes
     * set on characters. Because of this it is highly unrecommended to store references to TextProxy instances
     * because they might get invalidated due to operations on Document. This is especially true when you change
     * attributes of TextProxy.
     *
     * Difference between {@link engine.model.TextProxy} and {@link engine.model.Text} is that the former is a set of
     * nodes taken from tree model, while {@link engine.model.Text} is simply a string with attributes set.
     *
     * You should never create an instance of this class by your own. Instead, use string literals or {@link engine.model.Text}.
     *
     * @memberOf engine.model
     */

    var TextProxy = function () {
    	/**
      * Creates a text fragment.
      *
      * @protected
      * @param {engine.model.CharacterProxy} firstCharacter First character node contained in {@link engine.model.TextProxy}.
      * @param {Number} length Whole text contained in {@link engine.model.TextProxy}.
      * @constructor
      */

    	function TextProxy(firstCharacter, length) {
    		classCallCheck(this, TextProxy);

    		/**
       * First character node contained in {@link engine.model.TextProxy}.
       *
       * @readonly
       * @member {engine.model.CharacterProxy} engine.model.TextProxy#first
       */
    		this.first = firstCharacter;

    		/**
       * Characters contained in {@link engine.model.TextProxy}.
       *
       * @readonly
       * @member {String} engine.model.TextProxy#text
       */
    		this.text = firstCharacter._nodeListText.text.substr(this.first._index, length);

    		/**
       * Last {@link engine.model.CharacterProxy character node} contained in {@link engine.model.TextProxy}.
       *
       * @readonly
       * @member {engine.model.CharacterProxy} engine.model.TextProxy#last
       */
    		this.last = this.getCharAt(this.text.length - 1);
    	}

    	/**
      * A common parent of all character nodes contained in {@link engine.model.TextProxy}.
      *
      * @type {engine.model.Element}
      */


    	createClass(TextProxy, [{
    		key: 'getCharAt',


    		/**
       * Gets a character at given index and creates a {@link engine.model.CharacterProxy} out of it.
       *
       * @param {Number} index Character index.
       * @returns {engine.model.CharacterProxy}
       */
    		value: function getCharAt(index) {
    			if (index < 0 || index >= this.text.length) {
    				return null;
    			}

    			return new CharacterProxy(this.first._nodeListText, this.first._index + index);
    		}

    		/**
       * Checks if the text fragment has an attribute for given key.
       *
       * @param {String} key Key of attribute to check.
       * @returns {Boolean} `true` if attribute with given key is set on text fragment, `false` otherwise.
       */

    	}, {
    		key: 'hasAttribute',
    		value: function hasAttribute(key) {
    			return this.first.hasAttribute(key);
    		}

    		/**
       * Gets an attribute value for given key or undefined it that attribute is not set on text fragment.
       *
       * @param {String} key Key of attribute to look for.
       * @returns {*} Attribute value or null.
       */

    	}, {
    		key: 'getAttribute',
    		value: function getAttribute(key) {
    			return this.first.getAttribute(key);
    		}

    		/**
       * Returns iterator that iterates over this text fragment attributes.
       *
       * @returns {Iterable.<*>}
       */

    	}, {
    		key: 'getAttributes',
    		value: function getAttributes() {
    			return this.first.getAttributes();
    		}

    		/**
       * Sets attribute on the text fragment. If attribute with the same key already is set, it overwrites its values.
       *
       * **Note:** Changing attributes of text fragment affects document state. This TextProxy instance properties
       * will be refreshed, but other may get invalidated. It is highly unrecommended to store references to TextProxy instances.
       *
       * @param {String} key Key of attribute to set.
       * @param {*} value Attribute value.
       */

    	}, {
    		key: 'setAttribute',
    		value: function setAttribute(key, value) {
    			var index = this.first.getIndex();

    			this.commonParent._children.setAttribute(this.first.getIndex(), this.text.length, key, value);

    			this.first = this.commonParent.getChild(index);
    			this.last = this.getCharAt(this.text.length - 1);
    		}

    		/**
       * Removes all attributes from the text fragment and sets given attributes.
       *
       * **Note:** Changing attributes of text fragment affects document state. This `TextProxy` instance properties
       * will be refreshed, but other may get invalidated. It is highly unrecommended to store references to TextProxy instances.
       *
       * @param {Iterable|Object} attrs Iterable object containing attributes to be set.
       * See {@link engine.model.TextProxy#getAttributes}.
       */

    	}, {
    		key: 'setAttributesTo',
    		value: function setAttributesTo(attrs) {
    			var attrsMap = toMap(attrs);

    			this.clearAttributes();

    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = attrsMap[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var attr = _step.value;

    					this.setAttribute(attr[0], attr[1]);
    				}
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}
    		}

    		/**
       * Removes an attribute with given key from the text fragment.
       *
       * **Note:** Changing attributes of text fragment affects document state. This `TextProxy` instance properties
       * will be refreshed, but other may get invalidated. It is highly unrecommended to store references to TextProxy instances.
       *
       * @param {String} key Key of attribute to remove.
       */

    	}, {
    		key: 'removeAttribute',
    		value: function removeAttribute(key) {
    			this.setAttribute(key, null);
    		}

    		/**
       * Removes all attributes from the text fragment.
       *
       * **Note:** Changing attributes of text fragment affects document state. This `TextProxy` instance properties
       * will be refreshed, but other may get invalidated. It is highly unrecommended to store references to TextProxy instances.
       */

    	}, {
    		key: 'clearAttributes',
    		value: function clearAttributes() {
    			var _iteratorNormalCompletion2 = true;
    			var _didIteratorError2 = false;
    			var _iteratorError2 = undefined;

    			try {
    				for (var _iterator2 = this.getAttributes()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    					var attr = _step2.value;

    					this.removeAttribute(attr[0]);
    				}
    			} catch (err) {
    				_didIteratorError2 = true;
    				_iteratorError2 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion2 && _iterator2.return) {
    						_iterator2.return();
    					}
    				} finally {
    					if (_didIteratorError2) {
    						throw _iteratorError2;
    					}
    				}
    			}
    		}
    	}, {
    		key: 'commonParent',
    		get: function get() {
    			return this.first.parent;
    		}
    	}]);
    	return TextProxy;
    }();

    /**
     * Position iterator class. It allows to iterate forward and backward over the document.
     *
     * @memberOf engine.model
     */

    var TreeWalker = function () {
    	/**
      * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
      *
      * @constructor
      * @param {Object} [options={}] Object with configuration.
      * @param {'FORWARD'|'BACKWARD'} [options.direction='FORWARD'] Walking direction.
      * @param {engine.model.Range} [options.boundaries=null] Range to define boundaries of the iterator.
      * @param {engine.model.Position} [options.startPosition] Starting position.
      * @param {Boolean} [options.singleCharacters=false] Flag indicating whether all consecutive characters with the same attributes
      * should be returned one by one as multiple {@link engine.model.CharacterProxy} (`true`) objects or as one
      * {@link engine.model.TextProxy} (`false`).
      * @param {Boolean} [options.shallow=false] Flag indicating whether iterator should enter elements or not. If the
      * iterator is shallow child nodes of any iterated node will not be returned along with `ELEMENT_END` tag.
      * @param {Boolean} [options.ignoreElementEnd=false] Flag indicating whether iterator should ignore `ELEMENT_END`
      * tags. If the option is true walker will not return a parent node of start position. If this option is `true`
      * each {@link engine.model.Element} will be returned once, while if the option is `false` they might be returned
      * twice: for `'ELEMENT_START'` and `'ELEMENT_END'`.
      */

    	function TreeWalker() {
    		var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    		classCallCheck(this, TreeWalker);

    		if (!options.boundaries && !options.startPosition) {
    			/**
        * Neither boundaries nor starting position have been defined.
        *
        * @error tree-walker-no-start-position
        */
    			throw new CKEditorError('tree-walker-no-start-position: Neither boundaries nor starting position have been defined.');
    		}

    		var direction = options.direction || 'FORWARD';

    		if (direction != 'FORWARD' && direction != 'BACKWARD') {
    			throw new CKEditorError('tree-walker-unknown-direction: Only `BACKWARD` and `FORWARD` direction allowed.', { direction: direction });
    		}

    		/**
       * Walking direction. Defaults `FORWARD`.
       *
       * @readonly
       * @member {'BACKWARD'|'FORWARD'} engine.model.TreeWalker#direction
       */
    		this.direction = direction;

    		/**
       * Iterator boundaries.
       *
       * When the iterator is walking `FORWARD` on the end of boundary or is walking `BACKWARD`
       * on the start of boundary, then `{ done: true }` is returned.
       *
       * If boundaries are not defined they are set before first and after last child of the root node.
       *
       * @readonly
       * @member {engine.model.Range} engine.model.TreeWalker#boundaries
       */
    		this.boundaries = options.boundaries || null;

    		/**
       * Iterator position. This is always static position, even if the initial position was a
       * {@link engine.model.LivePosition live position}. If start position is not defined then position depends
       * on {@link #direction}. If direction is `FORWARD` position starts form the beginning, when direction
       * is `BACKWARD` position starts from the end.
       *
       * @readonly
       * @member {engine.model.Position} engine.model.TreeWalker#position
       */
    		if (options.startPosition) {
    			this.position = Position.createFromPosition(options.startPosition);
    		} else {
    			this.position = Position.createFromPosition(this.boundaries[this.direction == 'BACKWARD' ? 'end' : 'start']);
    		}

    		/**
       * Flag indicating whether all consecutive characters with the same attributes should be
       * returned as one {@link engine.model.CharacterProxy} (`true`) or one by one (`false`).
       *
       * @readonly
       * @member {Boolean} engine.model.TreeWalker#singleCharacters
       */
    		this.singleCharacters = !!options.singleCharacters;

    		/**
       * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any
       * iterated node will not be returned along with `ELEMENT_END` tag.
       *
       * @readonly
       * @member {Boolean} engine.model.TreeWalker#shallow
       */
    		this.shallow = !!options.shallow;

    		/**
       * Flag indicating whether iterator should ignore `ELEMENT_END` tags. If the option is true walker will not
       * return a parent node of the start position. If this option is `true` each {@link engine.model.Element} will
       * be returned once, while if the option is `false` they might be returned twice:
       * for `'ELEMENT_START'` and `'ELEMENT_END'`.
       *
       * @readonly
       * @member {Boolean} engine.model.TreeWalker#ignoreElementEnd
       */
    		this.ignoreElementEnd = !!options.ignoreElementEnd;

    		/**
       * Start boundary cached for optimization purposes.
       *
       * @private
       * @member {engine.model.Element} engine.model.TreeWalker#_boundaryStartParent
       */
    		this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;

    		/**
       * End boundary cached for optimization purposes.
       *
       * @private
       * @member {engine.model.Element} engine.model.TreeWalker#_boundaryEndParent
       */
    		this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;

    		/**
       * Parent of the most recently visited node. Cached for optimization purposes.
       *
       * @private
       * @member {engine.model.Element|engine.model.DocumentFragment} engine.model.TreeWalker#_visitedParent
       */
    		this._visitedParent = this.position.parent;
    	}

    	/**
      * Iterator interface.
      */


    	createClass(TreeWalker, [{
    		key: Symbol.iterator,
    		value: function value() {
    			return this;
    		}

    		/**
       * Iterator interface method.
       * Detects walking direction and makes step forward or backward.
       *
       * @returns {Object} Object implementing iterator interface, returning information about taken step.
       */

    	}, {
    		key: 'next',
    		value: function next() {
    			if (this.direction == 'FORWARD') {
    				return this._next();
    			} else {
    				return this._previous();
    			}
    		}

    		/**
       * Makes a step forward in model. Moves the {@link #position} to the next position and returns the encountered value.
       *
       * @private
       * @returns {Object}
       * @returns {Boolean} return.done True if iterator is done.
       * @returns {engine.model.TreeWalkerValue} return.value Information about taken step.
       */

    	}, {
    		key: '_next',
    		value: function _next() {
    			var previousPosition = this.position;
    			var position = Position.createFromPosition(this.position);
    			var parent = this._visitedParent;

    			// We are at the end of the root.
    			if (parent.parent === null && position.offset === parent.getChildCount()) {
    				return { done: true };
    			}

    			// We reached the walker boundary.
    			if (parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {
    				return { done: true };
    			}

    			var node = parent.getChild(position.offset);

    			if (node instanceof Element) {
    				if (!this.shallow) {
    					// Manual operations on path internals for optimization purposes. Here and in the rest of the method.
    					position.path.push(0);
    					this._visitedParent = node;
    				} else {
    					position.offset++;
    				}

    				this.position = position;

    				return formatReturnValue('ELEMENT_START', node, previousPosition, position, 1);
    			} else if (node instanceof CharacterProxy) {
    				if (this.singleCharacters) {
    					position.offset++;
    					this.position = position;

    					return formatReturnValue('CHARACTER', node, previousPosition, position, 1);
    				} else {
    					var charactersCount = node._nodeListText.text.length - node._index;
    					var offset = position.offset + charactersCount;

    					if (this._boundaryEndParent == parent && this.boundaries.end.offset < offset) {
    						offset = this.boundaries.end.offset;
    						charactersCount = offset - position.offset;
    					}

    					var textProxy = new TextProxy(node, charactersCount);

    					position.offset = offset;
    					this.position = position;

    					return formatReturnValue('TEXT', textProxy, previousPosition, position, charactersCount);
    				}
    			} else {
    				// `node` is not set, we reached the end of current `parent`.
    				position.path.pop();
    				position.offset++;
    				this.position = position;
    				this._visitedParent = parent.parent;

    				if (this.ignoreElementEnd) {
    					return this._next();
    				} else {
    					return formatReturnValue('ELEMENT_END', parent, previousPosition, position);
    				}
    			}
    		}

    		/**
       * Makes a step backward in model. Moves the {@link #position} to the previous position and returns the encountered value.
       *
       * @private
       * @returns {Object}
       * @returns {Boolean} return.done True if iterator is done.
       * @returns {engine.model.TreeWalkerValue} return.value Information about taken step.
       */

    	}, {
    		key: '_previous',
    		value: function _previous() {
    			var previousPosition = this.position;
    			var position = Position.createFromPosition(this.position);
    			var parent = this._visitedParent;

    			// We are at the beginning of the root.
    			if (parent.parent === null && position.offset === 0) {
    				return { done: true };
    			}

    			// We reached the walker boundary.
    			if (parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {
    				return { done: true };
    			}

    			// Get node just before current position
    			var node = parent.getChild(position.offset - 1);

    			if (node instanceof Element) {
    				position.offset--;

    				if (!this.shallow) {
    					position.path.push(node.getChildCount());
    					this.position = position;
    					this._visitedParent = node;

    					if (this.ignoreElementEnd) {
    						return this._previous();
    					} else {
    						return formatReturnValue('ELEMENT_END', node, previousPosition, position);
    					}
    				} else {
    					this.position = position;

    					return formatReturnValue('ELEMENT_START', node, previousPosition, position, 1);
    				}
    			} else if (node instanceof CharacterProxy) {
    				if (this.singleCharacters) {
    					position.offset--;
    					this.position = position;

    					return formatReturnValue('CHARACTER', node, previousPosition, position, 1);
    				} else {
    					var charactersCount = node._index + 1;
    					var offset = position.offset - charactersCount;

    					if (this._boundaryStartParent == parent && this.boundaries.start.offset > offset) {
    						offset = this.boundaries.start.offset;
    						charactersCount = position.offset - offset;
    					}

    					var textFragment = new TextProxy(parent.getChild(offset), charactersCount);

    					position.offset = offset;
    					this.position = position;

    					return formatReturnValue('TEXT', textFragment, previousPosition, position, charactersCount);
    				}
    			} else {
    				// `node` is not set, we reached the beginning of current `parent`.
    				position.path.pop();
    				this.position = position;
    				this._visitedParent = parent.parent;

    				return formatReturnValue('ELEMENT_START', parent, previousPosition, position, 1);
    			}
    		}
    	}]);
    	return TreeWalker;
    }();

    function formatReturnValue(type, item, previousPosition, nextPosition, length) {
    	return {
    		done: false,
    		value: {
    			type: type,
    			item: item,
    			previousPosition: previousPosition,
    			nextPosition: nextPosition,
    			length: length
    		}
    	};
    }

    /**
     * Compares how given arrays relate to each other. One array can be: same as another array, prefix of another array
     * or completely different. If arrays are different, first index at which they differ is returned. Otherwise,
     * a flag specifying the relation is returned. Flags are negative numbers, so whenever a number >= 0 is returned
     * it means that arrays differ.
     *
     *		compareArrays( [ 0, 2 ], [ 0, 2 ] );		// 'SAME'
     *		compareArrays( [ 0, 2 ], [ 0, 2, 1 ] );		// 'PREFIX'
     *		compareArrays( [ 0, 2 ], [ 0 ] );			// 'EXTENSION'
     *		compareArrays( [ 0, 2 ], [ 1, 2 ] );		// 0
     *		compareArrays( [ 0, 2 ], [ 0, 1 ] );		// 1
     *
     * @memberOf utils
     * @param {Array} a Array that is compared.
     * @param {Array} b Array to compare with.
     * @returns {utils.ArrayRelation} How array `a` is related to `b`.
     */

    function compareArrays(a, b) {
      var minLen = Math.min(a.length, b.length);

      for (var i = 0; i < minLen; i++) {
        if (a[i] != b[i]) {
          // The arrays are different.
          return i;
        }
      }

      // Both arrays were same at all points.
      if (a.length == b.length) {
        // If their length is also same, they are the same.
        return 'SAME';
      } else if (a.length < b.length) {
        // Compared array is shorter so it is a prefix of the other array.
        return 'PREFIX';
      } else {
        // Compared array is longer so it is an extension of the other array.
        return 'EXTENSION';
      }
    }

    /**
     * Range class. Range is iterable.
     *
     * @memberOf engine.model
     */

    var Range$1 = function () {
    	/**
      * Creates a range spanning from `start` position to `end` position.
      * **Note:** Constructor creates it's own {@link engine.model.Position} instances basing on passed values.
      *
      * @param {engine.model.Position} start Start position.
      * @param {engine.model.Position} end End position.
      */

    	function Range(start, end) {
    		classCallCheck(this, Range);

    		/**
       * Start position.
       *
       * @readonly
       * @member {engine.model.Position} engine.model.Range#start
       */
    		this.start = Position.createFromPosition(start);

    		/**
       * End position.
       *
       * @readonly
       * @member {engine.model.Position} engine.model.Range#end
       */
    		this.end = Position.createFromPosition(end);
    	}

    	/**
      * Returns an iterator that iterates over all {@link engine.model.Item items} that are in this range and returns
      * them together with additional information like length or {@link engine.model.Position positions},
      * grouped as {@link engine.model.TreeWalkerValue}. It iterates over all {@link engine.model.TextProxy texts}
      * that are inside the range and all the {@link engine.model.Element}s we enter into when iterating over this
      * range.
      *
      * **Note:** iterator will not return a parent node of start position. This is in contrary to
      * {@link engine.model.TreeWalker} which will return that node with `'ELEMENT_END'` type. Iterator also
      * returns each {@link engine.model.Element} once, while simply used {@link engine.model.TreeWalker} might
      * return it twice: for `'ELEMENT_START'` and `'ELEMENT_END'`.
      *
      * **Note:** because iterator does not return {@link engine.model.TreeWalkerValue values} with the type of
      * `'ELEMENT_END'`, you can use {@link engine.model.TreeWalkerValue.previousPosition} as a position before the
      * item.
      *
      * @see engine.model.TreeWalker
      * @returns {Iterable.<engine.model.TreeWalkerValue>}
      */


    	createClass(Range, [{
    		key: Symbol.iterator,
    		value: regeneratorRuntime.mark(function value() {
    			return regeneratorRuntime.wrap(function value$(_context) {
    				while (1) {
    					switch (_context.prev = _context.next) {
    						case 0:
    							return _context.delegateYield(new TreeWalker({ boundaries: this, ignoreElementEnd: true }), 't0', 1);

    						case 1:
    						case 'end':
    							return _context.stop();
    					}
    				}
    			}, value, this);
    		})

    		/**
       * Returns whether the range is collapsed, that is it start and end positions are equal.
       *
       * @type {Boolean}
       */

    	}, {
    		key: 'containsPosition',


    		/**
       * Checks whether this contains given {@link engine.model.Position position}.
       *
       * @param {engine.model.Position} position Position to check.
       * @returns {Boolean} True if given {@link engine.model.Position position} is contained.
       */
    		value: function containsPosition(position) {
    			return position.isAfter(this.start) && position.isBefore(this.end);
    		}

    		/**
       * Checks whether this range contains given {@link engine.model.Range range}.
       *
       * @param {engine.model.Range} otherRange Range to check.
       * @returns {Boolean} True if given {@link engine.model.Range range} boundaries are contained by this range.
       */

    	}, {
    		key: 'containsRange',
    		value: function containsRange(otherRange) {
    			return this.containsPosition(otherRange.start) && this.containsPosition(otherRange.end);
    		}

    		/**
       * Gets a part of this {@link engine.model.Range range} which is not a part of given {@link engine.model.Range range}. Returned
       * array contains zero, one or two {@link engine.model.Range ranges}.
       *
       * Examples:
       *
       *		let range = new Range( new Position( root, [ 2, 7 ] ), new Position( root, [ 4, 0, 1 ] ) );
       *		let otherRange = new Range( new Position( root, [ 1 ] ), new Position( root, [ 5 ] ) );
       *		let transformed = range.getDifference( otherRange );
       *		// transformed array has no ranges because `otherRange` contains `range`
       *
       *		otherRange = new Range( new Position( root, [ 1 ] ), new Position( root, [ 3 ] ) );
       *		transformed = range.getDifference( otherRange );
       *		// transformed array has one range: from [ 3 ] to [ 4, 0, 1 ]
       *
       *		otherRange = new Range( new Position( root, [ 3 ] ), new Position( root, [ 4 ] ) );
       *		transformed = range.getDifference( otherRange );
       *		// transformed array has two ranges: from [ 2, 7 ] to [ 3 ] and from [ 4 ] to [ 4, 0, 1 ]
       *
       * @param {engine.model.Range} otherRange Range to differentiate against.
       * @returns {Array.<engine.model.Range>} The difference between ranges.
       */

    	}, {
    		key: 'getDifference',
    		value: function getDifference(otherRange) {
    			var ranges = [];

    			if (this.isIntersecting(otherRange)) {
    				// Ranges intersect.

    				if (this.containsPosition(otherRange.start)) {
    					// Given range start is inside this range. This means that we have to
    					// add shrunken range - from the start to the middle of this range.
    					ranges.push(new Range(this.start, otherRange.start));
    				}

    				if (this.containsPosition(otherRange.end)) {
    					// Given range end is inside this range. This means that we have to
    					// add shrunken range - from the middle of this range to the end.
    					ranges.push(new Range(otherRange.end, this.end));
    				}
    			} else {
    				// Ranges do not intersect, return the original range.
    				ranges.push(Range.createFromRange(this));
    			}

    			return ranges;
    		}

    		/**
       * Returns an intersection of this {@link engine.model.Range range} and given {@link engine.model.Range range}. Intersection
       * is a common part of both of those ranges. If ranges has no common part, returns `null`.
       *
       * Examples:
       *
       *		let range = new Range( new Position( root, [ 2, 7 ] ), new Position( root, [ 4, 0, 1 ] ) );
       *		let otherRange = new Range( new Position( root, [ 1 ] ), new Position( root, [ 2 ] ) );
       *		let transformed = range.getIntersection( otherRange ); // null - ranges have no common part
       *
       *		otherRange = new Range( new Position( root, [ 3 ] ), new Position( root, [ 5 ] ) );
       *		transformed = range.getIntersection( otherRange ); // range from [ 3 ] to [ 4, 0, 1 ]
       *
       * @param {engine.model.Range} otherRange Range to check for intersection.
       * @returns {engine.model.Range|null} A common part of given ranges or null if ranges have no common part.
       */

    	}, {
    		key: 'getIntersection',
    		value: function getIntersection(otherRange) {
    			if (this.isIntersecting(otherRange)) {
    				// Ranges intersect, so a common range will be returned.
    				// At most, it will be same as this range.
    				var commonRangeStart = this.start;
    				var commonRangeEnd = this.end;

    				if (this.containsPosition(otherRange.start)) {
    					// Given range start is inside this range. This means thaNt we have to
    					// shrink common range to the given range start.
    					commonRangeStart = otherRange.start;
    				}

    				if (this.containsPosition(otherRange.end)) {
    					// Given range end is inside this range. This means that we have to
    					// shrink common range to the given range end.
    					commonRangeEnd = otherRange.end;
    				}

    				return new Range(commonRangeStart, commonRangeEnd);
    			}

    			// Ranges do not intersect, so they do not have common part.
    			return null;
    		}

    		/**
       * Computes and returns the smallest set of {@link #isFlat flat} ranges, that covers this range in whole.
       * Assuming that tree model model structure is ("[" and "]" are range boundaries):
       *
       *		root                                                            root
       *		 |- element DIV                         DIV             P2              P3             DIV
       *		 |   |- element H                   H        P1        f o o           b a r       H         P4
       *		 |   |   |- "fir[st"             fir[st     lorem                               se]cond     ipsum
       *		 |   |- element P1
       *		 |   |   |- "lorem"                                              ||
       *		 |- element P2                                                   ||
       *		 |   |- "foo"                                                    VV
       *		 |- element P3
       *		 |   |- "bar"                                                   root
       *		 |- element DIV                         DIV             [P2             P3]             DIV
       *		 |   |- element H                   H       [P1]       f o o           b a r        H         P4
       *		 |   |   |- "se]cond"            fir[st]    lorem                               [se]cond     ipsum
       *		 |   |- element P4
       *		 |   |   |- "ipsum"
       *
       * As it can be seen, letters contained in the range are stloremfoobarse, spread across different parents.
       * We are looking for minimal set of {@link #isFlat flat} ranges that contains the same nodes.
       *
       * Minimal flat ranges for above range `( [ 0, 0, 3 ], [ 3, 0, 2 ] )` will be:
       *
       *		( [ 0, 0, 3 ], [ 0, 0, 5 ] ) = "st"
       *		( [ 0, 1 ], [ 0, 2 ] ) = element P1 ("lorem")
       *		( [ 1 ], [ 3 ] ) = element P2, element P3 ("foobar")
       *		( [ 3, 0, 0 ], [ 3, 0, 2 ] ) = "se"
       *
       * **Note:** this method is not returning flat ranges that contain no nodes. It may also happen that not-collapsed
       * range will return an empty array of flat ranges.
       *
       * @returns {Array.<engine.model.Range>} Array of flat ranges.
       */

    	}, {
    		key: 'getMinimalFlatRanges',
    		value: function getMinimalFlatRanges() {
    			var ranges = [];

    			// We find on which tree-level start and end have the lowest common ancestor
    			var cmp = compareArrays(this.start.path, this.end.path);
    			// If comparison returned string it means that arrays are same.
    			var diffAt = typeof cmp == 'string' ? Math.min(this.start.path.length, this.end.path.length) : cmp;

    			var pos = Position.createFromPosition(this.start);
    			var posParent = pos.parent;

    			// Go up.
    			while (pos.path.length > diffAt + 1) {
    				var howMany = posParent.getChildCount() - pos.offset;

    				if (howMany !== 0) {
    					ranges.push(new Range(pos, pos.getShiftedBy(howMany)));
    				}

    				pos.path = pos.path.slice(0, -1);
    				pos.offset++;
    				posParent = posParent.parent;
    			}

    			// Go down.
    			while (pos.path.length <= this.end.path.length) {
    				var offset = this.end.path[pos.path.length - 1];
    				var _howMany = offset - pos.offset;

    				if (_howMany !== 0) {
    					ranges.push(new Range(pos, pos.getShiftedBy(_howMany)));
    				}

    				pos.offset = offset;
    				pos.path.push(0);
    			}

    			return ranges;
    		}

    		/**
       * Creates a {@link engine.model.TreeWalker} instance with this range as a boundary.
       *
       * @param {Object} options Object with configuration options. See {@link engine.model.TreeWalker}.
       * @param {engine.model.Position} [options.startPosition]
       * @param {Boolean} [options.singleCharacters=false]
       * @param {Boolean} [options.shallow=false]
       * @param {Boolean} [options.ignoreElementEnd=false]
       */

    	}, {
    		key: 'getWalker',
    		value: function getWalker() {
    			var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    			options.boundaries = this;

    			return new TreeWalker(options);
    		}

    		/**
       * Returns an iterator that iterates over all {@link engine.model.Item items} that are in this range and returns
       * them. It iterates over all {@link engine.model.CharacterProxy characters} or
       * {@link engine.model.TextProxy texts} that are inside the range and all the {@link engine.model.Element}s
       * we enter into when iterating over this range. Note that it use {@link engine.model.TreeWalker} with the
       * {@link engine.model.TreeWalker#ignoreElementEnd ignoreElementEnd} option set to true.
       *
       * @param {Object} options Object with configuration options. See {@link engine.model.TreeWalker}.
       * @param {engine.model.Position} [options.startPosition]
       * @param {Boolean} [options.singleCharacters=false]
       * @param {Boolean} [options.shallow=false]
       * @returns {Iterable.<engine.model.Item>}
       */

    	}, {
    		key: 'getItems',
    		value: regeneratorRuntime.mark(function getItems() {
    			var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    			var treeWalker, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value;

    			return regeneratorRuntime.wrap(function getItems$(_context2) {
    				while (1) {
    					switch (_context2.prev = _context2.next) {
    						case 0:
    							options.boundaries = this;
    							options.ignoreElementEnd = true;

    							treeWalker = new TreeWalker(options);
    							_iteratorNormalCompletion = true;
    							_didIteratorError = false;
    							_iteratorError = undefined;
    							_context2.prev = 6;
    							_iterator = treeWalker[Symbol.iterator]();

    						case 8:
    							if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
    								_context2.next = 15;
    								break;
    							}

    							_value = _step.value;
    							_context2.next = 12;
    							return _value.item;

    						case 12:
    							_iteratorNormalCompletion = true;
    							_context2.next = 8;
    							break;

    						case 15:
    							_context2.next = 21;
    							break;

    						case 17:
    							_context2.prev = 17;
    							_context2.t0 = _context2['catch'](6);
    							_didIteratorError = true;
    							_iteratorError = _context2.t0;

    						case 21:
    							_context2.prev = 21;
    							_context2.prev = 22;

    							if (!_iteratorNormalCompletion && _iterator.return) {
    								_iterator.return();
    							}

    						case 24:
    							_context2.prev = 24;

    							if (!_didIteratorError) {
    								_context2.next = 27;
    								break;
    							}

    							throw _iteratorError;

    						case 27:
    							return _context2.finish(24);

    						case 28:
    							return _context2.finish(21);

    						case 29:
    						case 'end':
    							return _context2.stop();
    					}
    				}
    			}, getItems, this, [[6, 17, 21, 29], [22,, 24, 28]]);
    		})

    		/**
       * Returns an iterator that iterates over all {@link engine.model.Position positions} that are boundaries or
       * contained in this range.
       *
       * @param {Object} options Object with configuration options. See {@link engine.model.TreeWalker}.
       * @param {Boolean} [options.singleCharacters=false]
       * @param {Boolean} [options.shallow=false]
       * @returns {Iterable.<engine.model.Position>}
       */

    	}, {
    		key: 'getPositions',
    		value: regeneratorRuntime.mark(function getPositions() {
    			var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    			var treeWalker, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2;

    			return regeneratorRuntime.wrap(function getPositions$(_context3) {
    				while (1) {
    					switch (_context3.prev = _context3.next) {
    						case 0:
    							options.boundaries = this;

    							treeWalker = new TreeWalker(options);
    							_context3.next = 4;
    							return treeWalker.position;

    						case 4:
    							_iteratorNormalCompletion2 = true;
    							_didIteratorError2 = false;
    							_iteratorError2 = undefined;
    							_context3.prev = 7;
    							_iterator2 = treeWalker[Symbol.iterator]();

    						case 9:
    							if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
    								_context3.next = 16;
    								break;
    							}

    							_value2 = _step2.value;
    							_context3.next = 13;
    							return _value2.nextPosition;

    						case 13:
    							_iteratorNormalCompletion2 = true;
    							_context3.next = 9;
    							break;

    						case 16:
    							_context3.next = 22;
    							break;

    						case 18:
    							_context3.prev = 18;
    							_context3.t0 = _context3['catch'](7);
    							_didIteratorError2 = true;
    							_iteratorError2 = _context3.t0;

    						case 22:
    							_context3.prev = 22;
    							_context3.prev = 23;

    							if (!_iteratorNormalCompletion2 && _iterator2.return) {
    								_iterator2.return();
    							}

    						case 25:
    							_context3.prev = 25;

    							if (!_didIteratorError2) {
    								_context3.next = 28;
    								break;
    							}

    							throw _iteratorError2;

    						case 28:
    							return _context3.finish(25);

    						case 29:
    							return _context3.finish(22);

    						case 30:
    						case 'end':
    							return _context3.stop();
    					}
    				}
    			}, getPositions, this, [[7, 18, 22, 30], [23,, 25, 29]]);
    		})

    		/**
       * Returns an array containing one or two {engine.model.Range ranges} that are a result of transforming this
       * {@link engine.model.Range range} by inserting `howMany` nodes at `insertPosition`. Two {@link engine.model.Range ranges} are
       * returned if the insertion was inside this {@link engine.model.Range range} and `spread` is set to `true`.
       *
       * Examples:
       *
       *		let range = new Range( new Position( root, [ 2, 7 ] ), new Position( root, [ 4, 0, 1 ] ) );
       *		let transformed = range.getTransformedByInsertion( new Position( root, [ 1 ] ), 2 );
       *		// transformed array has one range from [ 4, 7 ] to [ 6, 0, 1 ]
       *
       *		transformed = range.getTransformedByInsertion( new Position( root, [ 4, 0, 0 ] ), 4 );
       *		// transformed array has one range from [ 2, 7 ] to [ 4, 0, 5 ]
       *
       *		transformed = range.getTransformedByInsertion( new Position( root, [ 3, 2 ] ), 4 );
       *		// transformed array has one range, which is equal to original range
       *
       *		transformed = range.getTransformedByInsertion( new Position( root, [ 3, 2 ] ), 4, true );
       *		// transformed array has two ranges: from [ 2, 7 ] to [ 3, 2 ] and from [ 3, 6 ] to [ 4, 0, 1 ]
       *
       *		transformed = range.getTransformedByInsertion( new Position( root, [ 4, 0, 1 ] ), 4, false, false );
       *		// transformed array has one range which is equal to original range because insertion is after the range boundary
       *
       *		transformed = range.getTransformedByInsertion( new Position( root, [ 4, 0, 1 ] ), 4, false, true );
       *		// transformed array has one range: from [ 2, 7 ] to [ 4, 0, 5 ] because range was expanded
       *
       * @protected
       * @param {engine.model.Position} insertPosition Position where nodes are inserted.
       * @param {Number} howMany How many nodes are inserted.
       * @param {Boolean} [spread] Flag indicating whether this {engine.model.Range range} should be spread if insertion
       * was inside the range. Defaults to `false`.
       * @param {Boolean} [isSticky] Flag indicating whether insertion should expand a range if it is in a place of
       * range boundary. Defaults to `false`.
       * @returns {Array.<engine.model.Range>} Result of the transformation.
       */

    	}, {
    		key: 'getTransformedByInsertion',
    		value: function getTransformedByInsertion(insertPosition, howMany) {
    			var spread = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
    			var isSticky = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

    			if (spread && this.containsPosition(insertPosition)) {
    				// Range has to be spread. The first part is from original start to the spread point.
    				// The other part is from spread point to the original end, but transformed by
    				// insertion to reflect insertion changes.

    				return [new Range(this.start, insertPosition), new Range(insertPosition.getTransformedByInsertion(insertPosition, howMany, true), this.end.getTransformedByInsertion(insertPosition, howMany, this.isCollapsed))];
    			} else {
    				var range = Range.createFromRange(this);

    				var insertBeforeStart = range.isCollapsed ? isSticky : !isSticky;
    				var insertBeforeEnd = isSticky;

    				range.start = range.start.getTransformedByInsertion(insertPosition, howMany, insertBeforeStart);
    				range.end = range.end.getTransformedByInsertion(insertPosition, howMany, insertBeforeEnd);

    				return [range];
    			}
    		}

    		/**
       * Returns an array containing {engine.model.Range ranges} that are a result of transforming this
       * {@link engine.model.Range range} by moving `howMany` nodes from `sourcePosition` to `targetPosition`.
       *
       * @param {engine.model.Position} sourcePosition Position from which nodes are moved.
       * @param {engine.model.Position} targetPosition Position to where nodes are moved.
       * @param {Number} howMany How many nodes are moved.
       * @param {Boolean} [spread] Flag indicating whether this {engine.model.Range range} should be spread if insertion
       * was inside the range. Defaults to `false`.
       * @returns {Array.<engine.model.Range>} Result of the transformation.
       */

    	}, {
    		key: 'getTransformedByMove',
    		value: function getTransformedByMove(sourcePosition, targetPosition, howMany, spread) {
    			var isSticky = arguments.length <= 4 || arguments[4] === undefined ? false : arguments[4];

    			var result = void 0;

    			var moveRange = new Range(sourcePosition, sourcePosition.getShiftedBy(howMany));

    			var differenceSet = this.getDifference(moveRange);
    			var difference = void 0;

    			if (differenceSet.length == 1) {
    				difference = new Range(differenceSet[0].start.getTransformedByDeletion(sourcePosition, howMany), differenceSet[0].end.getTransformedByDeletion(sourcePosition, howMany));
    			} else if (differenceSet.length == 2) {
    				// This means that ranges were moved from the inside of this range.
    				// So we can operate on this range positions and we don't have to transform starting position.
    				difference = new Range(this.start, this.end.getTransformedByDeletion(sourcePosition, howMany));
    			} else {
    				// 0.
    				difference = null;
    			}

    			var insertPosition = targetPosition.getTransformedByDeletion(sourcePosition, howMany);

    			if (difference) {
    				result = difference.getTransformedByInsertion(insertPosition, howMany, spread, isSticky);
    			} else {
    				result = [];
    			}

    			var common = this.getIntersection(moveRange);

    			// Add common part of the range only if there is any and only if it is not
    			// already included in `difference` part.
    			if (common && (spread || difference === null || !difference.containsPosition(insertPosition))) {
    				result.push(new Range(common.start._getCombined(moveRange.start, insertPosition), common.end._getCombined(moveRange.start, insertPosition)));
    			}

    			return result;
    		}

    		/**
       * Two ranges equal if their start and end positions equal.
       *
       * @param {engine.model.Range} otherRange Range to compare with.
       * @returns {Boolean} True if ranges equal.
       */

    	}, {
    		key: 'isEqual',
    		value: function isEqual(otherRange) {
    			return this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);
    		}

    		/**
       * Checks and returns whether this range intersects with given range.
       *
       * @param {engine.model.Range} otherRange Range to compare with.
       * @returns {Boolean} True if ranges intersect.
       */

    	}, {
    		key: 'isIntersecting',
    		value: function isIntersecting(otherRange) {
    			return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);
    		}

    		/**
       * Creates a range inside an element which starts before the first child and ends after the last child.
       *
       * @param {engine.model.Element} element Element which is a parent for the range.
       * @returns {engine.model.Range} Created range.
       */

    	}, {
    		key: 'isCollapsed',
    		get: function get() {
    			return this.start.isEqual(this.end);
    		}

    		/**
       * Returns whether this range is flat, that is if start position and end position are in the same parent.
       *
       * @type {Boolean}
       */

    	}, {
    		key: 'isFlat',
    		get: function get() {
    			return this.start.parent === this.end.parent;
    		}

    		/**
       * Returns whether this range has any nodes in it.
       *
       * @type {Boolean}
       */

    	}, {
    		key: 'isEmpty',
    		get: function get() {
    			return this.start.isTouching(this.end);
    		}

    		/**
       * Range root element.
       *
       * Equals to the root of start position (which should be same as root of end position).
       *
       * @type {engine.model.RootElement|engine.model.DocumentFragment}
       */

    	}, {
    		key: 'root',
    		get: function get() {
    			return this.start.root;
    		}
    	}], [{
    		key: 'createFromElement',
    		value: function createFromElement(element) {
    			return this.createFromParentsAndOffsets(element, 0, element, element.getChildCount());
    		}

    		/**
       * Creates a range on given element only. The range starts just before the element and ends before the first child of the element.
       *
       * @param {engine.model.Element} element Element on which range should be created.
       * @returns {engine.model.Range} Created range.
       */

    	}, {
    		key: 'createOnElement',
    		value: function createOnElement(element) {
    			return this.createFromParentsAndOffsets(element.parent, element.getIndex(), element, 0);
    		}

    		/**
       * Creates a new range spreading from specified position to the same position moved by given shift.
       *
       * @param {engine.model.Position} position Beginning of the range.
       * @param {Number} shift How long the range should be.
       * @returns {engine.model.Range}
       */

    	}, {
    		key: 'createFromPositionAndShift',
    		value: function createFromPositionAndShift(position, shift) {
    			return new this(position, position.getShiftedBy(shift));
    		}

    		/**
       * Creates a range from given parents and offsets.
       *
       * @param {engine.model.Element} startElement Start position parent element.
       * @param {Number} startOffset Start position offset.
       * @param {engine.model.Element} endElement End position parent element.
       * @param {Number} endOffset End position offset.
       * @returns {engine.model.Range} Created range.
       */

    	}, {
    		key: 'createFromParentsAndOffsets',
    		value: function createFromParentsAndOffsets(startElement, startOffset, endElement, endOffset) {
    			return new this(Position.createFromParentAndOffset(startElement, startOffset), Position.createFromParentAndOffset(endElement, endOffset));
    		}

    		/**
       * Creates and returns a new instance of Range which is equal to passed range.
       *
       * @param {engine.model.Range} range Range to clone.
       * @returns {engine.model.Range}
       */

    	}, {
    		key: 'createFromRange',
    		value: function createFromRange(range) {
    			return new this(range.start, range.end);
    		}

    		/**
       * Creates Range from deserilized object, ie. from parsed JSON string.
       *
       * @param {Object} json Deserialized JSON object.
       * @param {engine.model.Document} doc Document on which this operation will be applied.
       * @returns {engine.model.Range}
       */

    	}, {
    		key: 'fromJSON',
    		value: function fromJSON(json, doc) {
    			return new this(Position.fromJSON(json.start, doc), Position.fromJSON(json.end, doc));
    		}
    	}]);
    	return Range;
    }();

    /**
     * Tree data model element.
     *
     * @memberOf engine.model
     */

    var Element = function (_Node) {
    	inherits(Element, _Node);

    	/**
      * Creates a tree data model element.
      *
      * @param {String} name Node name.
      * @param {Iterable} [attrs] Iterable collection of attributes.
      * @param {engine.model.NodeSet} [children] List of nodes to be inserted.
      * into created element. List of nodes can be of any type accepted by the {@link engine.model.NodeList} constructor.
      */

    	function Element(name, attrs, children) {
    		classCallCheck(this, Element);


    		/**
       * Element name.
       *
       * @readonly
       * @member {String} engine.model.Element#name
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(Element).call(this, attrs));

    		_this.name = name;

    		/**
       * List of children nodes.
       *
       * @protected
       * @member {engine.model.NodeList} engine.model.Element#_children
       */
    		_this._children = new NodeList();

    		if (children) {
    			_this.insertChildren(0, children);
    		}
    		return _this;
    	}

    	/**
      * Gets child at the given index.
      *
      * @param {Number} index Index of child.
      * @returns {engine.model.Node} Child node.
      */


    	createClass(Element, [{
    		key: 'getChild',
    		value: function getChild(index) {
    			return this._children.get(index);
    		}

    		/**
       * Gets the number of element's children.
       *
       * @returns {Number} The number of element's children.
       */

    	}, {
    		key: 'getChildCount',
    		value: function getChildCount() {
    			return this._children.length;
    		}

    		/**
       * Gets index of the given child node.
       *
       * @param {engine.model.Node} node Child node.
       * @returns {Number} Index of the child node.
       */

    	}, {
    		key: 'getChildIndex',
    		value: function getChildIndex(node) {
    			return this._children.indexOf(node);
    		}

    		/**
       * {@link engine.model.Element#insert Inserts} a child node or a list of child nodes at the end of this node and sets
       * the parent of these nodes to this element.
       *
       * Note that the list of children can be modified only in elements not yet attached to the document.
       * All attached nodes should be modified using the {@link engine.model.operation.InsertOperation}.
       *
       * @param {engine.model.NodeSet} nodes The list of nodes to be inserted.
       */

    	}, {
    		key: 'appendChildren',
    		value: function appendChildren(nodes) {
    			this.insertChildren(this.getChildCount(), nodes);
    		}

    		/**
       * Inserts a list of child nodes on the given index and sets the parent of these nodes to this element.
       *
       * Note that the list of children can be modified only in elements not yet attached to the document.
       * All attached nodes should be modified using the {@link engine.model.operation.InsertOperation}.
       *
       * @param {Number} index Position where nodes should be inserted.
       * @param {engine.model.NodeSet} nodes The list of nodes to be inserted.
       */

    	}, {
    		key: 'insertChildren',
    		value: function insertChildren(index, nodes) {
    			var nodeList = new NodeList(nodes);

    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = nodeList._nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var node = _step.value;

    					node.parent = this;
    				}

    				// Clean original DocumentFragment so it won't contain nodes that were added somewhere else.
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}

    			if (nodes instanceof DocumentFragment) {
    				nodes._children = new NodeList();
    			}

    			this._children.insert(index, nodeList);
    		}

    		/**
       * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
       *
       * Note that the list of children can be modified only in elements not yet attached to the document.
       * All attached nodes should be modified using the {@link engine.model.operation.RemoveOperation}.
       *
       * @param {Number} index Position of the first node to remove.
       * @param {Number} [howMany=1] Number of nodes to remove.
       * @returns {engine.model.NodeList} The list of removed nodes.
       */

    	}, {
    		key: 'removeChildren',
    		value: function removeChildren(index) {
    			var howMany = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

    			var nodeList = this._children.remove(index, howMany);

    			var _iteratorNormalCompletion2 = true;
    			var _didIteratorError2 = false;
    			var _iteratorError2 = undefined;

    			try {
    				for (var _iterator2 = nodeList._nodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    					var node = _step2.value;

    					node.parent = null;
    				}
    			} catch (err) {
    				_didIteratorError2 = true;
    				_iteratorError2 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion2 && _iterator2.return) {
    						_iterator2.return();
    					}
    				} finally {
    					if (_didIteratorError2) {
    						throw _iteratorError2;
    					}
    				}
    			}

    			return nodeList;
    		}

    		/**
       * Sets attribute on the element. If attribute with the same key already is set, it overwrites its value.
       *
       * @param {String} key Key of attribute to set.
       * @param {*} value Attribute value.
       */

    	}, {
    		key: 'setAttribute',
    		value: function setAttribute(key, value) {
    			this._attrs.set(key, value);
    		}

    		/**
       * Removes all attributes from the element and sets given attributes.
       *
       * @param {Iterable|Object} attrs Iterable object containing attributes to be set. See {@link engine.model.Node#getAttributes}.
       */

    	}, {
    		key: 'setAttributesTo',
    		value: function setAttributesTo(attrs) {
    			this._attrs = toMap(attrs);
    		}

    		/**
       * Removes an attribute with given key from the element.
       *
       * @param {String} key Key of attribute to remove.
       * @returns {Boolean} `true` if the attribute was set on the element, `false` otherwise.
       */

    	}, {
    		key: 'removeAttribute',
    		value: function removeAttribute(key) {
    			return this._attrs.delete(key);
    		}

    		/**
       * Removes all attributes from the element.
       */

    	}, {
    		key: 'clearAttributes',
    		value: function clearAttributes() {
    			this._attrs.clear();
    		}

    		/**
       * Checks whether element is empty (has no children).
       *
       * @returns {Boolean}
       */

    	}, {
    		key: 'isEmpty',
    		value: function isEmpty() {
    			return this.getChildCount() === 0;
    		}

    		/**
       * Gets the text content of the element. The return value is created by concatenating all
       * text nodes in this element and its descendants.
       *
       * @returns {String}
       */

    	}, {
    		key: 'getText',
    		value: function getText() {
    			var text = '';

    			var _iteratorNormalCompletion3 = true;
    			var _didIteratorError3 = false;
    			var _iteratorError3 = undefined;

    			try {
    				for (var _iterator3 = Range$1.createFromElement(this)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
    					var value = _step3.value;

    					if (value.type == 'TEXT') {
    						text += value.item.text;
    					}
    				}
    			} catch (err) {
    				_didIteratorError3 = true;
    				_iteratorError3 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion3 && _iterator3.return) {
    						_iterator3.return();
    					}
    				} finally {
    					if (_didIteratorError3) {
    						throw _iteratorError3;
    					}
    				}
    			}

    			return text;
    		}

    		/**
       * Custom toJSON method to solve child-parent circular dependencies.
       *
       * @returns {Object} Clone of this object with the parent property replaced with its name.
       */

    	}, {
    		key: 'toJSON',
    		value: function toJSON() {
    			var json = get(Object.getPrototypeOf(Element.prototype), 'toJSON', this).call(this);

    			if (this._children.length) {
    				json.children = this._children.toJSON();
    			}

    			json.name = this.name;

    			return json;
    		}

    		/**
       * Creates Element object from deserilized object, ie. from parsed JSON string.
       *
       *		let deserialized = JSON.parse( JSON.stringify( someElementObject ) );
       *		let element = NodeList.fromJSON( deserialized );
       *
       * @param {Object} json
       * @returns {engine.model.Element}
       */

    	}], [{
    		key: 'fromJSON',
    		value: function fromJSON(json) {
    			if (json.children) {
    				return new Element(json.name, json.attributes, NodeList.fromJSON(json.children));
    			}

    			return new Element(json.name, json.attributes);
    		}
    	}]);
    	return Element;
    }(Node$1);

    /**
     * Checks whether given {Map}s are equal, that is has same size and same key-value pairs.
     *
     * @memberOf utils
     * @returns {Boolean} `true` if given maps are equal, `false` otherwise.
     */

    function mapsEqual(mapA, mapB) {
    	if (mapA.size != mapB.size) {
    		return false;
    	}

    	var _iteratorNormalCompletion = true;
    	var _didIteratorError = false;
    	var _iteratorError = undefined;

    	try {
    		for (var _iterator = mapA.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    			var attr = _step.value;

    			var valA = JSON.stringify(attr[1]);
    			var valB = JSON.stringify(mapB.get(attr[0]));

    			if (valA !== valB) {
    				return false;
    			}
    		}
    	} catch (err) {
    		_didIteratorError = true;
    		_iteratorError = err;
    	} finally {
    		try {
    			if (!_iteratorNormalCompletion && _iterator.return) {
    				_iterator.return();
    			}
    		} finally {
    			if (_didIteratorError) {
    				throw _iteratorError;
    			}
    		}
    	}

    	return true;
    }

    /**
     * Checks if value implements iterator interface.
     *
     * @memberOf utils
     * @param {*} value The value to check.
     * @returns {Boolean} True if value implements iterator interface.
     */

    function isIterable(value) {
      return !!(value && value[Symbol.iterator]);
    }

    var _marked = [getNodes].map(regeneratorRuntime.mark);

    /**
     * This is a private helper-class for {@link engine.model.NodeList} text compression utility.
     *
     * @protected
     * @memberOf engine.model
     * @extends engine.model.Text
     */

    var NodeListText = function (_Text) {
    	inherits(NodeListText, _Text);

    	/**
      * @see engine.model.Text#constructor
      * @protected
      * @constructor
      */

    	function NodeListText(text, attrs) {
    		classCallCheck(this, NodeListText);


    		/**
       * Element that contains character nodes represented by this NodeListText.
       *
       * @type {engine.model.Element|engine.model.DocumentFragment|null}
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(NodeListText).call(this, text, attrs));

    		_this.parent = null;
    		return _this;
    	}

    	/**
      * Gets a character at given index and creates a {@link engine.model.CharacterProxy} out of it.
      *
      * @param {Number} index Character index.
      * @returns {engine.model.CharacterProxy}
      */


    	createClass(NodeListText, [{
    		key: 'getCharAt',
    		value: function getCharAt(index) {
    			index = index && index >= 0 ? index : 0;

    			return new CharacterProxy(this, index);
    		}
    	}]);
    	return NodeListText;
    }(Text$1);

    /**
     * List of nodes. It is used to represent multiple nodes with a given order, for example children of
     * {@link engine.model.Element} object or nodes inserted using {@link engine.model.operation.InsertOperation}.
     *
     * Thanks to the constructor, which accepts various arguments, this class lets you easily create desired list of nodes.
     *
     * Parameters passed to constructor are converted and internally kept as an array of {@link engine.model.Node}
     * and {@link engine.model.Text} instances.
     *
     * @memberOf engine.model
     */


    var NodeList = function () {
    	/**
      * Constructor lets you create a list of nodes in many ways. See examples:
      *
      *		let nodeList = new NodeList( [ new Element( p1 ), new Element( p1 ) ] );
      *		nodeList.length; // 2
      *
      *		let nodeList = new NodeList( new Element( p ) );
      *		nodeList.length; // 1
      *
      *		let nodeList = new NodeList( [ 'foo', new Element( p ), 'bar' ] );
      *		nodeList.length; // 7
      *
      *		let nodeList = new NodeList( 'foo' );
      *		nodeList.length; // 3
      *
      *		let nodeList = new NodeList( new Text( 'foo', { bar: 'bom' } ) );
      *		nodeList.length; // 3
      *		nodeList.get( 0 ).getAttribute( 'bar' ); // 'bom'
      *		nodeList.get( 1 ).getAttribute( 'bar' ); // 'bom'
      *		nodeList.get( 2 ).getAttribute( 'bar' ); // 'bom'
      *
      *		let nodeListA = new NodeList( 'foo' );
      *		let nodeListB = new NodeList( nodeListA );
      *		nodeListA === nodeListB // true
      *		nodeListB.length // 3
      *
      * @see engine.model.NodeSet
      *
      * @param {engine.model.NodeSet} nodes List of nodes.
      * @constructor
      */

    	function NodeList(nodes) {
    		classCallCheck(this, NodeList);

    		if (nodes instanceof NodeList) {
    			// We do not clone anything.
    			return nodes;
    		} else if (nodes instanceof DocumentFragment) {
    			return nodes._children;
    		}

    		/**
       * Internal array to store nodes.
       *
       * @protected
       * @member {Array} engine.model.NodeList#_nodes
       */
    		this._nodes = [];

    		/**
       * Internal array where each index is mapped to correct node from `_nodes` array. This is introduced
       * to easily refer `_nodes` by index, since some of elements in `_nodes` may contain multiple characters,
       * which occupy multiple slots in `_indexMap`.
       *
       * @private
       * @member {Array} engine.model.NodeList#_indexMap
       */
    		this._indexMap = [];

    		if (nodes) {
    			if (typeof nodes == 'string' || !isIterable(nodes)) {
    				nodes = [nodes];
    			}

    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = getNodes(nodes)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var node = _step.value;

    					var indexInNodes = this._nodes.length;
    					var mergedWithPrev = false;
    					var length = 1;

    					if (node instanceof CharacterProxy) {
    						node = new NodeListText(node.character, node._attrs);
    					} else if (node instanceof Text$1) {
    						node = new NodeListText(node.text, node._attrs);
    					} else if (typeof node == 'string') {
    						node = new NodeListText(node, []);
    					}

    					if (node instanceof NodeListText) {
    						length = node.text.length;

    						var prev = this._nodes[this._nodes.length - 1];

    						if (prev instanceof NodeListText && mapsEqual(prev._attrs, node._attrs)) {
    							// If previously added text has same attributes, merge this text with it.
    							prev.text += node.text;
    							mergedWithPrev = true;
    							indexInNodes--;
    						} else if (node.text.length === 0) {
    							// If this is an empty text just omit it.
    							continue;
    						}
    					}

    					if (!mergedWithPrev) {
    						this._nodes.push(node);
    					}

    					for (var i = 0; i < length; i++) {
    						this._indexMap.push(indexInNodes);
    					}
    				}
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}
    		}
    	}

    	/**
      * Number of nodes in the node list.
      *
      * @readonly
      * @type {Number}
      */


    	createClass(NodeList, [{
    		key: Symbol.iterator,


    		/**
       * Node list iterator.
       */
    		value: regeneratorRuntime.mark(function value() {
    			var i;
    			return regeneratorRuntime.wrap(function value$(_context) {
    				while (1) {
    					switch (_context.prev = _context.next) {
    						case 0:
    							i = 0;

    						case 1:
    							if (!(i < this.length)) {
    								_context.next = 7;
    								break;
    							}

    							_context.next = 4;
    							return this.get(i);

    						case 4:
    							i++;
    							_context.next = 1;
    							break;

    						case 7:
    						case 'end':
    							return _context.stop();
    					}
    				}
    			}, value, this);
    		})

    		/**
       * Returns node at the given index.
       *
       * @param {Number} index Node index.
       * @returns {engine.model.Node} Node at given index.
       */

    	}, {
    		key: 'get',
    		value: function get(index) {
    			var realIndex = this._indexMap[index];
    			var node = this._nodes[realIndex];

    			if (node instanceof NodeListText) {
    				return node.getCharAt(this._getCharIndex(index));
    			} else {
    				return node;
    			}
    		}

    		/**
       * Search for the element in the node list.
       *
       * @param {engine.model.Node} node Node to find.
       * @returns {Number} Position of the element in the list or -1 if not found.
       */

    	}, {
    		key: 'indexOf',
    		value: function indexOf(node) {
    			if (node instanceof CharacterProxy) {
    				var baseIndex = this.indexOf(node._nodeListText);

    				return baseIndex == -1 ? -1 : baseIndex + node._index;
    			}

    			var realIndex = this._nodes.indexOf(node);

    			return this._indexMap.indexOf(realIndex);
    		}

    		/**
       * Inserts nodes from the given node list into this node list at the given index.
       *
       * @param {Number} index Position where nodes should be inserted.
       * @param {engine.model.NodeList} nodeList List of nodes to insert.
       */

    	}, {
    		key: 'insert',
    		value: function insert(index, nodeList) {
    			if (this._nodes.length === 0) {
    				this._nodes = nodeList._nodes.slice();
    				this._indexMap = nodeList._indexMap.slice();

    				return;
    			}

    			// If we are inserting into a text, splitting may be needed.
    			this._splitNodeAt(index);

    			// If `index` is too high to be found in `_indexMap` it means that we insert at the end of node list.
    			var realIndex = index >= this._indexMap.length ? this._nodes.length : this._indexMap[index];

    			// Splice arrays from inserted nodeList into this nodeList.
    			this._indexMap.splice.apply(this._indexMap, [index, 0].concat(nodeList._indexMap));
    			this._nodes.splice.apply(this._nodes, [realIndex, 0].concat(nodeList._nodes));

    			// Fix indexes in index map.
    			// From the beginning of spliced-in array to the end of spliced-in array.
    			for (var i = index; i < index + nodeList._indexMap.length; i++) {
    				this._indexMap[i] += realIndex;
    			}

    			// From the end of spliced-in array to the end of original array.
    			for (var _i = index + nodeList._indexMap.length; _i < this._indexMap.length; _i++) {
    				this._indexMap[_i] += nodeList._nodes.length;
    			}

    			this._mergeNodeAt(index);
    			this._mergeNodeAt(index + nodeList.length);
    		}

    		/**
       * Removes number of nodes starting at the given index.
       *
       * @param {Number} index Position of the first node to remove.
       * @param {Number} number Number of nodes to remove.
       * @returns {engine.model.NodeList} List of removed nodes.
       */

    	}, {
    		key: 'remove',
    		value: function remove(index, number) {
    			if (this._nodes.length === 0) {
    				return new NodeList();
    			}

    			// Removed "range" may start in NodeListText or end in NodeListText. Some splitting may be needed.
    			this._splitNodeAt(index);
    			this._splitNodeAt(index + number);

    			// If given index is too high to be found in `_indexMap` it means that we remove to the end of node list.
    			var realIndexEnd = index + number >= this._indexMap.length ? this._nodes.length : this._indexMap[index + number];
    			var realIndexStart = this._indexMap[index];
    			var removed = this._nodes.splice(realIndexStart, realIndexEnd - realIndexStart);

    			this._indexMap.splice(index, number);

    			for (var i = index; i < this._indexMap.length; i++) {
    				this._indexMap[i] -= removed.length;
    			}

    			this._mergeNodeAt(index);

    			return new NodeList(removed);
    		}

    		/**
       * Sets or removes given attribute on a range of nodes in the node list.
       *
       * @param {Number} index Position of the first node to change.
       * @param {Number} number Number of nodes to change.
       * @param {String} key Attribute key to change.
       * @param {*} [attribute] Attribute value or null if attribute with given key should be removed.
       */

    	}, {
    		key: 'setAttribute',
    		value: function setAttribute(index, number, key, value) {
    			if (index < 0 || index + number > this.length) {
    				/**
         * Trying to set attribute on non-existing node list items.
         *
         * @error nodelist-setattribute-out-of-bounds
         * @param root
         */
    				throw new CKEditorError('nodelist-setattribute-out-of-bounds: Trying to set attribute on non-existing node list items.');
    			}

    			// "Range" of nodes to remove attributes may start in NodeListText or end in NodeListText. Some splitting may be needed.
    			this._splitNodeAt(index);
    			this._splitNodeAt(index + number);

    			var i = index;

    			while (i < index + number) {
    				var node = this._nodes[this._indexMap[i]];

    				if (node instanceof NodeListText) {
    					if (value !== null) {
    						node._attrs.set(key, value);
    					} else {
    						node._attrs.delete(key);
    					}

    					this._mergeNodeAt(i);
    					i += node.text.length;
    				} else {
    					if (value !== null) {
    						node.setAttribute(key, value);
    					} else {
    						node.removeAttribute(key);
    					}

    					i++;
    				}
    			}

    			this._mergeNodeAt(index + number);
    		}

    		/**
       * Custom toJSON method to solve child-parent circular dependencies.
       *
       * @returns {Object} Clone of this object with the parent property replaced with its name.
       */

    	}, {
    		key: 'toJSON',
    		value: function toJSON() {
    			if (!this._nodes.length) {
    				return {};
    			}

    			var json = { nodes: [] };

    			var _iteratorNormalCompletion2 = true;
    			var _didIteratorError2 = false;
    			var _iteratorError2 = undefined;

    			try {
    				for (var _iterator2 = this._nodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    					var node = _step2.value;

    					json.nodes.push(node.toJSON());
    				}
    			} catch (err) {
    				_didIteratorError2 = true;
    				_iteratorError2 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion2 && _iterator2.return) {
    						_iterator2.return();
    					}
    				} finally {
    					if (_didIteratorError2) {
    						throw _iteratorError2;
    					}
    				}
    			}

    			return json;
    		}

    		/**
       * Creates NodeList object from deserilized object, ie. from parsed JSON string.
       *
       *		let deserialized = JSON.parse( JSON.stringify( someNodeList ) );
       *		let nodeList = NodeList.fromJSON( deserialized );
       *
       * @param {Object} json Deserialized JSON object.
       * @returns {engine.model.NodeList}
       */

    	}, {
    		key: '_splitNodeAt',


    		/**
       * Checks whether given index is inside a text and if so, splits that text node. This method should be used
       * to split text objects whenever there are some changes made on a part of text object (i.e. removing part of text,
       * inserting between text object, changing attributes of part of a text object).
       *
       * @protected
       * @param {Number} index Index in the node list at which node should be broken.
       */
    		value: function _splitNodeAt(index) {
    			if (this._indexMap[index] != this._indexMap[index - 1] || this._indexMap.length === 0) {
    				// Node before and node after splitting point are already different.
    				// Or the node list is empty.
    				// No splitting is needed.
    				return;
    			}

    			var realIndex = this._indexMap[index];
    			var node = this._nodes[realIndex];

    			// Get position in the text node where the text should be split.
    			var charIndex = this._getCharIndex(index);

    			// Get text part before and after split point.
    			var textBefore = node.text.substr(0, charIndex);
    			var textAfter = node.text.substr(charIndex);

    			// "Remove" part after split point from current text node.
    			node.text = textBefore;

    			// Create a new text node with the "removed" part and splice it after original node.
    			var newText = new NodeListText(textAfter, node._attrs);
    			newText.parent = node.parent;
    			this._nodes.splice.call(this._nodes, realIndex + 1, 0, newText);

    			// We added new element in the middle of _nodes what invalidated _indexMap. We have to fix it.
    			for (var i = index; i < this._indexMap.length; i++) {
    				this._indexMap[i]++;
    			}
    		}

    		/**
       * Checks whether given index is between two text nodes that have same attributes and if so, merges them
       * together into one node. Used to compress characters into large text objects and use less memory. This method
       * should be used whenever there are some changed done to the node list to check whether it is possible to merge
       * text objects.
       *
       * @param {Number} index Index in the node list at which node should be merged.
       * @protected
       */

    	}, {
    		key: '_mergeNodeAt',
    		value: function _mergeNodeAt(index) {
    			if (this._indexMap[index] == this._indexMap[index - 1] || this._indexMap.length === 0) {
    				// Node before and node after splitting point are already same.
    				// Or the node list is empty.
    				// No splitting is needed.
    				return;
    			}

    			// Get the node before and after given index.
    			var realIndexBefore = this._indexMap[index - 1];
    			var realIndexAfter = this._indexMap[index];

    			var nodeBefore = this._nodes[realIndexBefore];
    			var nodeAfter = this._nodes[realIndexAfter];

    			// Check if both of those nodes are text objects with same attributes.
    			if (nodeBefore instanceof NodeListText && nodeAfter instanceof NodeListText && mapsEqual(nodeBefore._attrs, nodeAfter._attrs)) {
    				// Append text of text node after index to the before one.
    				nodeBefore.text += nodeAfter.text;

    				// Remove text node after index.
    				this._nodes.splice(realIndexAfter, 1);

    				for (var i = index; i < this._indexMap.length; i++) {
    					this._indexMap[i]--;
    				}
    			}
    		}

    		/**
       * Helper function that takes an index in a node list that is inside a text node and returns the offset of that
       * index from the beginning of that text node. If index
       *
       * @param index
       * @returns {Number} Offset of given index from the beginning of the text node.
       * @private
       */

    	}, {
    		key: '_getCharIndex',
    		value: function _getCharIndex(index) {
    			return index - this._indexMap.indexOf(this._indexMap[index]);
    		}
    	}, {
    		key: 'length',
    		get: function get() {
    			return this._indexMap.length;
    		}
    	}], [{
    		key: 'fromJSON',
    		value: function fromJSON(json) {
    			var nodes = [];

    			if (json.nodes) {
    				var _iteratorNormalCompletion3 = true;
    				var _didIteratorError3 = false;
    				var _iteratorError3 = undefined;

    				try {
    					for (var _iterator3 = json.nodes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
    						var node = _step3.value;

    						if (node.text) {
    							nodes.push(new Text$1(node.text, node.attributes));
    						} else {
    							nodes.push(Element.fromJSON(node));
    						}
    					}
    				} catch (err) {
    					_didIteratorError3 = true;
    					_iteratorError3 = err;
    				} finally {
    					try {
    						if (!_iteratorNormalCompletion3 && _iterator3.return) {
    							_iterator3.return();
    						}
    					} finally {
    						if (_didIteratorError3) {
    							throw _iteratorError3;
    						}
    					}
    				}
    			}

    			return new NodeList(nodes);
    		}
    	}]);
    	return NodeList;
    }();

    function getNodes(nodes) {
    	var _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, node;

    	return regeneratorRuntime.wrap(function getNodes$(_context2) {
    		while (1) {
    			switch (_context2.prev = _context2.next) {
    				case 0:
    					_iteratorNormalCompletion4 = true;
    					_didIteratorError4 = false;
    					_iteratorError4 = undefined;
    					_context2.prev = 3;
    					_iterator4 = nodes[Symbol.iterator]();

    				case 5:
    					if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
    						_context2.next = 16;
    						break;
    					}

    					node = _step4.value;

    					if (!(node instanceof DocumentFragment)) {
    						_context2.next = 11;
    						break;
    					}

    					return _context2.delegateYield(node, 't0', 9);

    				case 9:
    					_context2.next = 13;
    					break;

    				case 11:
    					_context2.next = 13;
    					return node;

    				case 13:
    					_iteratorNormalCompletion4 = true;
    					_context2.next = 5;
    					break;

    				case 16:
    					_context2.next = 22;
    					break;

    				case 18:
    					_context2.prev = 18;
    					_context2.t1 = _context2['catch'](3);
    					_didIteratorError4 = true;
    					_iteratorError4 = _context2.t1;

    				case 22:
    					_context2.prev = 22;
    					_context2.prev = 23;

    					if (!_iteratorNormalCompletion4 && _iterator4.return) {
    						_iterator4.return();
    					}

    				case 25:
    					_context2.prev = 25;

    					if (!_didIteratorError4) {
    						_context2.next = 28;
    						break;
    					}

    					throw _iteratorError4;

    				case 28:
    					return _context2.finish(25);

    				case 29:
    					return _context2.finish(22);

    				case 30:
    				case 'end':
    					return _context2.stop();
    			}
    		}
    	}, _marked[0], this, [[3, 18, 22, 30], [23,, 25, 29]]);
    }

    /**
     * DocumentFragment represents a part of Tree Model which does not have a common root but it's top level nodes
     * can be seen as siblings.
     *
     * @memberOf engine.model
     */

    var DocumentFragment = function () {
    	/**
      * Creates empty DocumentFragment.
      *
      * @param {engine.model.NodeSet} children List of nodes contained inside the DocumentFragment.
      */

    	function DocumentFragment(children) {
    		classCallCheck(this, DocumentFragment);

    		/**
       * List of nodes contained inside the DocumentFragment.
       *
       * @protected
       * @member {engine.model.NodeSet} engine.model.DocumentFragment#_children
       */
    		this._children = new NodeList();

    		if (children) {
    			this.insertChildren(0, children);
    		}
    	}

    	/**
      * `DocumentFragment` iterator. Returns {@link engine.model.Node nodes} that are added to the `DocumentFragment`.
      */


    	createClass(DocumentFragment, [{
    		key: Symbol.iterator,
    		value: function value() {
    			return this._children[Symbol.iterator]();
    		}

    		/**
       * The root of `DocumentFragment`. Returns itself. Added for compatibility reasons with {@link engine.model.Element}.
       *
       * @readonly
       * @type {engine.model.DocumentFragment}
       */

    	}, {
    		key: 'getPath',


    		/**
       * Returns path to the `DocumentFragment` This is always equal to empty array and is added for compatibility reasons
       * with {@link engine.model.Element}.
       *
       * @returns {Array} The path.
       */
    		value: function getPath() {
    			return [];
    		}

    		/**
       * Gets child at the given index.
       *
       * @param {Number} index Index of child.
       * @returns {engine.model.Node} Child node.
       */

    	}, {
    		key: 'getChild',
    		value: function getChild(index) {
    			return this._children.get(index);
    		}

    		/**
       * Gets the number of top-level elements of DocumentFragment.
       *
       * @returns {Number} The number of top-level elements.
       */

    	}, {
    		key: 'getChildCount',
    		value: function getChildCount() {
    			return this._children.length;
    		}

    		/**
       * Gets index of the given child node.
       *
       * @param {engine.model.Node} node Child node.
       * @returns {Number} Index of the child node.
       */

    	}, {
    		key: 'getChildIndex',
    		value: function getChildIndex(node) {
    			return this._children.indexOf(node);
    		}

    		/**
       * Inserts a child node or a list of child nodes at the end of this DocumentFragment.
       *
       * @param {engine.model.NodeSet} nodes The list of nodes to be inserted.
       */

    	}, {
    		key: 'appendChildren',
    		value: function appendChildren(nodes) {
    			this.insertChildren(this.getChildCount(), nodes);
    		}

    		/**
       * Inserts a list of child nodes on the given index and sets the parent of these nodes to this DocumentFragment.
       *
       * @param {Number} index Position where nodes should be inserted.
       * @param {engine.model.NodeSet} nodes The list of nodes to be inserted.
       */

    	}, {
    		key: 'insertChildren',
    		value: function insertChildren(index, nodes) {
    			var nodeList = new NodeList(nodes);

    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = nodeList._nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var node = _step.value;

    					node.parent = this;
    				}

    				// Clean original DocumentFragment so it won't contain nodes that were added somewhere else.
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}

    			if (nodes instanceof DocumentFragment) {
    				nodes._children = new NodeList();
    			}

    			this._children.insert(index, nodeList);
    		}

    		/**
       * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
       *
       * @param {Number} index Position of the first node to remove.
       * @param {Number} [howMany=1] Number of nodes to remove.
       * @returns {engine.model.NodeList} The list of removed nodes.
       */

    	}, {
    		key: 'removeChildren',
    		value: function removeChildren(index) {
    			var howMany = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

    			var nodeList = this._children.remove(index, howMany);

    			var _iteratorNormalCompletion2 = true;
    			var _didIteratorError2 = false;
    			var _iteratorError2 = undefined;

    			try {
    				for (var _iterator2 = nodeList._nodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    					var node = _step2.value;

    					node.parent = null;
    				}
    			} catch (err) {
    				_didIteratorError2 = true;
    				_iteratorError2 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion2 && _iterator2.return) {
    						_iterator2.return();
    					}
    				} finally {
    					if (_didIteratorError2) {
    						throw _iteratorError2;
    					}
    				}
    			}

    			return nodeList;
    		}
    	}, {
    		key: 'root',
    		get: function get() {
    			return this;
    		}
    	}]);
    	return DocumentFragment;
    }();

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array ? array.length : 0;
      return length ? array[length - 1] : undefined;
    }

    /**
     * Position in the tree. Position is always located before or after a node.
     * See {@link #path} property for more information.
     *
     * @memberOf engine.model
     */

    var Position = function () {
    	/**
      * Creates a position.
      *
      * @param {engine.model.Element|engine.model.DocumentFragment} root
      * Root of the position path. Element (most often a {@link engine.model.RootElement}) or a document fragment.
      * @param {Array.<Number>} path Position path. See {@link engine.model.Position#path} property for more information.
      */

    	function Position(root, path) {
    		classCallCheck(this, Position);

    		if (!(root instanceof Element) && !(root instanceof DocumentFragment)) {
    			/**
        * Position root invalid.
        *
        * @error position-root-invalid.
        */
    			throw new CKEditorError('position-root-invalid: Position root invalid.');
    		}

    		if (!(path instanceof Array) || path.length === 0) {
    			/**
        * Position path must be an Array with at least one item.
        *
        * @error position-path-incorrect
        * @param path
        */
    			throw new CKEditorError('position-path-incorrect: Position path must be an Array with at least one item.', { path: path });
    		}

    		// Normalize the root and path (if element was passed).
    		path = root.getPath().concat(path);
    		root = root.root;

    		/**
       * Root of the position path.
       *
       * @readonly
       * @member {engine.model.Element|engine.model.DocumentFragment} engine.model.Position#root
       */
    		this.root = root;

    		/**
       * Position of the node it the tree. Must contain at least one item. For example:
       *
       *		 root
       *		  |- p         Before: [ 0 ]       After: [ 1 ]
       *		  |- ul        Before: [ 1 ]       After: [ 2 ]
       *		     |- li     Before: [ 1, 0 ]    After: [ 1, 1 ]
       *		     |  |- f   Before: [ 1, 0, 0 ] After: [ 1, 0, 1 ]
       *		     |  |- o   Before: [ 1, 0, 1 ] After: [ 1, 0, 2 ]
       *		     |  |- o   Before: [ 1, 0, 2 ] After: [ 1, 0, 3 ]
       *		     |- li     Before: [ 1, 1 ]    After: [ 1, 2 ]
       *		        |- b   Before: [ 1, 1, 0 ] After: [ 1, 1, 1 ]
       *		        |- a   Before: [ 1, 1, 1 ] After: [ 1, 1, 2 ]
       *		        |- r   Before: [ 1, 1, 2 ] After: [ 1, 1, 3 ]
       *
       * @member {Array.<Number>} engine.model.Position#path
       */
    		this.path = path;
    	}

    	/**
      * Node directly after the position.
      *
      * @readonly
      * @type {engine.model.Node}
      */


    	createClass(Position, [{
    		key: 'compareWith',


    		/**
       * Checks whether this position is before or after given position.
       *
       * @param {engine.model.Position} otherPosition Position to compare with.
       * @returns {engine.model.PositionRelation}
       */
    		value: function compareWith(otherPosition) {
    			if (this.root != otherPosition.root) {
    				return 'DIFFERENT';
    			}

    			var result = compareArrays(this.path, otherPosition.path);

    			switch (result) {
    				case 'SAME':
    					return 'SAME';

    				case 'PREFIX':
    					return 'BEFORE';

    				case 'EXTENSION':
    					return 'AFTER';

    				default:
    					if (this.path[result] < otherPosition.path[result]) {
    						return 'BEFORE';
    					} else {
    						return 'AFTER';
    					}
    			}
    		}

    		/**
       * Returns the path to the parent, which is the {@link engine.model.Position#path} without the last element.
       *
       * This method returns the parent path even if the parent does not exists.
       *
       * @returns {Number[]} Path to the parent.
       */

    	}, {
    		key: 'getParentPath',
    		value: function getParentPath() {
    			return this.path.slice(0, -1);
    		}

    		/**
       * Returns a new instance of Position with offset incremented by `shift` value.
       *
       * @param {Number} shift How position offset should get changed. Accepts negative values.
       * @returns {engine.model.Position} Shifted position.
       */

    	}, {
    		key: 'getShiftedBy',
    		value: function getShiftedBy(shift) {
    			var shifted = Position.createFromPosition(this);

    			var offset = shifted.offset + shift;
    			shifted.offset = offset < 0 ? 0 : offset;

    			return shifted;
    		}

    		/**
       * Returns this position after being updated by removing `howMany` nodes starting from `deletePosition`.
       * It may happen that this position is in a removed node. If that is the case, `null` is returned instead.
       *
       * @protected
       * @param {engine.model.Position} deletePosition Position before the first removed node.
       * @param {Number} howMany How many nodes are removed.
       * @returns {engine.model.Position|null} Transformed position or `null`.
       */

    	}, {
    		key: 'getTransformedByDeletion',
    		value: function getTransformedByDeletion(deletePosition, howMany) {
    			var transformed = Position.createFromPosition(this);

    			// This position can't be affected if deletion was in a different root.
    			if (this.root != deletePosition.root) {
    				return transformed;
    			}

    			if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == 'SAME') {
    				// If nodes are removed from the node that is pointed by this position...
    				if (deletePosition.offset < this.offset) {
    					// And are removed from before an offset of that position...
    					if (deletePosition.offset + howMany > this.offset) {
    						// Position is in removed range, it's no longer in the tree.
    						return null;
    					} else {
    						// Decrement the offset accordingly.
    						transformed.offset -= howMany;
    					}
    				}
    			} else if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == 'PREFIX') {
    				// If nodes are removed from a node that is on a path to this position...
    				var i = deletePosition.path.length - 1;

    				if (deletePosition.offset <= this.path[i]) {
    					// And are removed from before next node of that path...
    					if (deletePosition.offset + howMany > this.path[i]) {
    						// If the next node of that path is removed return null
    						// because the node containing this position got removed.
    						return null;
    					} else {
    						// Otherwise, decrement index on that path.
    						transformed.path[i] -= howMany;
    					}
    				}
    			}

    			return transformed;
    		}

    		/**
       * Returns this position after being updated by inserting `howMany` nodes at `insertPosition`.
       *
       * @protected
       * @param {engine.model.Position} insertPosition Position where nodes are inserted.
       * @param {Number} howMany How many nodes are inserted.
       * @param {Boolean} insertBefore Flag indicating whether nodes are inserted before or after `insertPosition`.
       * This is important only when `insertPosition` and this position are same. If that is the case and the flag is
       * set to `true`, this position will get transformed. If the flag is set to `false`, it won't.
       * @returns {engine.model.Position} Transformed position.
       */

    	}, {
    		key: 'getTransformedByInsertion',
    		value: function getTransformedByInsertion(insertPosition, howMany, insertBefore) {
    			var transformed = Position.createFromPosition(this);

    			// This position can't be affected if insertion was in a different root.
    			if (this.root != insertPosition.root) {
    				return transformed;
    			}

    			if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == 'SAME') {
    				// If nodes are inserted in the node that is pointed by this position...
    				if (insertPosition.offset < this.offset || insertPosition.offset == this.offset && insertBefore) {
    					// And are inserted before an offset of that position...
    					// "Push" this positions offset.
    					transformed.offset += howMany;
    				}
    			} else if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == 'PREFIX') {
    				// If nodes are inserted in a node that is on a path to this position...
    				var i = insertPosition.path.length - 1;

    				if (insertPosition.offset <= this.path[i]) {
    					// And are inserted before next node of that path...
    					// "Push" the index on that path.
    					transformed.path[i] += howMany;
    				}
    			}

    			return transformed;
    		}

    		/**
       * Returns this position after being updated by moving `howMany` nodes from `sourcePosition` to `targetPosition`.
       *
       * @protected
       * @param {engine.model.Position} sourcePosition Position before the first element to move.
       * @param {engine.model.Position} targetPosition Position where moved elements will be inserted.
       * @param {Number} howMany How many consecutive nodes to move, starting from `sourcePosition`.
       * @param {Boolean} insertBefore Flag indicating whether moved nodes are pasted before or after `insertPosition`.
       * This is important only when `targetPosition` and this position are same. If that is the case and the flag is
       * set to `true`, this position will get transformed by range insertion. If the flag is set to `false`, it won't.
       * @param {Boolean} [sticky] Flag indicating whether this position "sticks" to range, that is if it should be moved
       * with the moved range if it is equal to one of range's boundaries.
       * @returns {engine.model.Position} Transformed position.
       */

    	}, {
    		key: 'getTransformedByMove',
    		value: function getTransformedByMove(sourcePosition, targetPosition, howMany, insertBefore, sticky) {
    			// Moving a range removes nodes from their original position. We acknowledge this by proper transformation.
    			var transformed = this.getTransformedByDeletion(sourcePosition, howMany);

    			// Then we update target position, as it could be affected by nodes removal too.
    			targetPosition = targetPosition.getTransformedByDeletion(sourcePosition, howMany);

    			if (transformed === null || sticky && transformed.isEqual(sourcePosition)) {
    				// This position is inside moved range (or sticks to it).
    				// In this case, we calculate a combination of this position, move source position and target position.
    				transformed = this._getCombined(sourcePosition, targetPosition);
    			} else {
    				// This position is not inside a removed range.
    				// In next step, we simply reflect inserting `howMany` nodes, which might further affect the position.
    				transformed = transformed.getTransformedByInsertion(targetPosition, howMany, insertBefore);
    			}

    			return transformed;
    		}

    		/**
       * Checks whether this position is after given position.
       *
       * @see engine.model.Position#isBefore
       *
       * @param {engine.model.Position} otherPosition Position to compare with.
       * @returns {Boolean} True if this position is after given position.
       */

    	}, {
    		key: 'isAfter',
    		value: function isAfter(otherPosition) {
    			return this.compareWith(otherPosition) == 'AFTER';
    		}

    		/**
       * Checks whether this position is before given position.
       *
       * **Note:** watch out when using negation of the value returned by this method, because the negation will also
       * be `true` if positions are in different roots and you might not expect this. You should probably use
       * `a.isAfter( b ) || a.isEqual( b )` or `!a.isBefore( p ) && a.root == b.root` in most scenarios. If your
       * condition uses multiple `isAfter` and `isBefore` checks, build them so they do not use negated values, i.e.:
       *
       *		if ( a.isBefore( b ) && c.isAfter( d ) ) {
       *			// do A.
       *		} else {
       *			// do B.
       *		}
       *
       * or, if you have only one if-branch:
       *
       *		if ( !( a.isBefore( b ) && c.isAfter( d ) ) {
       *			// do B.
       *		}
       *
       * rather than:
       *
       *		if ( !a.isBefore( b ) || && !c.isAfter( d ) ) {
       *			// do B.
       *		} else {
       *			// do A.
       *		}
       *
       * @param {engine.model.Position} otherPosition Position to compare with.
       * @returns {Boolean} True if this position is before given position.
       */

    	}, {
    		key: 'isBefore',
    		value: function isBefore(otherPosition) {
    			return this.compareWith(otherPosition) == 'BEFORE';
    		}

    		/**
       * Checks whether this position equals given position.
       *
       * @param {engine.model.Position} otherPosition Position to compare with.
       * @returns {Boolean} True if positions are same.
       */

    	}, {
    		key: 'isEqual',
    		value: function isEqual(otherPosition) {
    			return this.compareWith(otherPosition) == 'SAME';
    		}

    		/**
       * Checks whether this position is touching given position. Positions touch when there are no characters
       * or empty nodes in a range between them. Technically, those positions are not equal but in many cases
       * they are very similar or even indistinguishable when they touch.
       *
       * @param {engine.model.Position} otherPosition Position to compare with.
       * @returns {Boolean} True if positions touch.
       */

    	}, {
    		key: 'isTouching',
    		value: function isTouching(otherPosition) {
    			var left = null;
    			var right = null;
    			var compare = this.compareWith(otherPosition);

    			switch (compare) {
    				case 'SAME':
    					return true;

    				case 'BEFORE':
    					left = Position.createFromPosition(this);
    					right = Position.createFromPosition(otherPosition);
    					break;

    				case 'AFTER':
    					left = Position.createFromPosition(otherPosition);
    					right = Position.createFromPosition(this);
    					break;

    				default:
    					return false;
    			}

    			while (left.path.length + right.path.length) {
    				if (left.isEqual(right)) {
    					return true;
    				}

    				if (left.path.length > right.path.length) {
    					if (left.nodeAfter !== null) {
    						return false;
    					}

    					left.path = left.path.slice(0, -1);
    					left.offset++;
    				} else {
    					if (right.nodeBefore !== null) {
    						return false;
    					}

    					right.path = right.path.slice(0, -1);
    				}
    			}
    		}

    		/**
       * Whether position is at the beginning of its {@link engine.model.Position#parent}.
       *
       * @returns {Boolean}
       */

    	}, {
    		key: 'isAtStart',
    		value: function isAtStart() {
    			return this.offset === 0;
    		}

    		/**
       * Whether position is at the end of its {@link engine.model.Position#parent}.
       *
       * @returns {Boolean}
       */

    	}, {
    		key: 'isAtEnd',
    		value: function isAtEnd() {
    			return this.offset == this.parent.getChildCount();
    		}

    		/**
       * Creates position at the given location. The location can be specified as:
       *
       * * a {@link engine.model.Position position},
       * * parent element and offset (offset defaults to `0`),
       * * parent element and `'END'` (sets selection at the end of that element),
       * * node and `'BEFORE'` or `'AFTER'` (sets selection before or after the given node).
       *
       * This method is a shortcut to other constructors such as:
       *
       * * {@link engine.model.Position.createBefore},
       * * {@link engine.model.Position.createAfter},
       * * {@link engine.model.Position.createFromParentAndOffset},
       * * {@link engine.model.Position.createFromPosition}.
       *
       * @param {engine.model.Node|engine.model.Position} nodeOrPosition
       * @param {Number|'END'|'BEFORE'|'AFTER'} [offset=0] Offset or one of the flags. Used only when
       * first parameter is a node.
       */

    	}, {
    		key: '_getCombined',


    		/**
       * Returns a new position that is a combination of this position and given positions. The combined
       * position is this position transformed by moving a range starting at `from` to `to` position.
       * It is expected that this position is inside the moved range.
       *
       * In other words, this method in a smart way "cuts out" `source` path from this position and
       * injects `target` path in it's place, while doing necessary fixes in order to get a correct path.
       *
       * Example:
       *
       * 	let original = new Position( root, [ 2, 3, 1 ] );
       * 	let source = new Position( root, [ 2, 2 ] );
       * 	let target = new Position( otherRoot, [ 1, 1, 3 ] );
       * 	let combined = original.getCombined( source, target );
       * 	// combined.path is [ 1, 1, 4, 1 ], combined.root is otherRoot
       *
       * Explanation:
       *
       * We have a position `[ 2, 3, 1 ]` and move some nodes from `[ 2, 2 ]` to `[ 1, 1, 3 ]`. The original position
       * was inside moved nodes and now should point to the new place. The moved nodes will be after
       * positions `[ 1, 1, 3 ]`, `[ 1, 1, 4 ]`, `[ 1, 1, 5 ]`. Since our position was in the second moved node,
       * the transformed position will be in a sub-tree of a node at `[ 1, 1, 4 ]`. Looking at original path, we
       * took care of `[ 2, 3 ]` part of it. Now we have to add the rest of the original path to the transformed path.
       * Finally, the transformed position will point to `[ 1, 1, 4, 1 ]`.
       *
       * @protected
       * @param {engine.model.Position} source Beginning of the moved range.
       * @param {engine.model.Position} target Position where the range is moved.
       * @returns {engine.model.Position} Combined position.
       */
    		value: function _getCombined(source, target) {
    			var i = source.path.length - 1;

    			// The first part of a path to combined position is a path to the place where nodes were moved.
    			var combined = Position.createFromPosition(target);

    			// Then we have to update the rest of the path.

    			// Fix the offset because this position might be after `from` position and we have to reflect that.
    			combined.offset = combined.offset + this.path[i] - source.offset;

    			// Then, add the rest of the path.
    			// If this position is at the same level as `from` position nothing will get added.
    			combined.path = combined.path.concat(this.path.slice(i + 1));

    			return combined;
    		}
    	}, {
    		key: 'nodeAfter',
    		get: function get() {
    			return this.parent.getChild(this.offset) || null;
    		}

    		/**
       * Node directly before the position.
       *
       * @readonly
       * @type {Node}
       */

    	}, {
    		key: 'nodeBefore',
    		get: function get() {
    			return this.parent.getChild(this.offset - 1) || null;
    		}

    		/**
       * Offset at which the position is located in the {@link #parent}.
       *
       * @readonly
       * @type {Number}
       */

    	}, {
    		key: 'offset',
    		get: function get() {
    			return last(this.path);
    		}

    		/**
       * Sets offset in the parent, which is the last element of the path.
       *
       * @param {Number} newOffset
       */
    		,
    		set: function set(newOffset) {
    			this.path[this.path.length - 1] = newOffset;
    		}

    		/**
       * Parent element of the position. The position is located at {@link #offset} in this element.
       *
       * @readonly
       * @type {engine.model.Element}
       */

    	}, {
    		key: 'parent',
    		get: function get() {
    			var parent = this.root;

    			var i = void 0,
    			    len = void 0;

    			for (i = 0, len = this.path.length - 1; i < len; i++) {
    				parent = parent.getChild(this.path[i]);
    			}

    			return parent;
    		}
    	}], [{
    		key: 'createAt',
    		value: function createAt(nodeOrPosition, offset) {
    			var node = void 0;

    			if (nodeOrPosition instanceof Position) {
    				return this.createFromPosition(nodeOrPosition);
    			} else {
    				node = nodeOrPosition;

    				if (offset == 'END') {
    					offset = node.getChildCount();
    				} else if (offset == 'BEFORE') {
    					return this.createBefore(node);
    				} else if (offset == 'AFTER') {
    					return this.createAfter(node);
    				} else if (!offset) {
    					offset = 0;
    				}

    				return this.createFromParentAndOffset(node, offset);
    			}
    		}

    		/**
       * Creates a new position after given node.
       *
       * @see {@link engine.model.TreeWalkerValue}
       *
       * @param {engine.model.Node} node Node the position should be directly after.
       * @returns {engine.model.Position}
       */

    	}, {
    		key: 'createAfter',
    		value: function createAfter(node) {
    			if (!node.parent) {
    				/**
         * You can not make position after root.
         *
         * @error position-after-root
         * @param {engine.model.Node} root
         */
    				throw new CKEditorError('position-after-root: You can not make position after root.', { root: node });
    			}

    			return this.createFromParentAndOffset(node.parent, node.getIndex() + 1);
    		}

    		/**
       * Creates a new position before the given node.
       *
       * @see {@link engine.model.TreeWalkerValue}
       *
       * @param {engine.model.node} node Node the position should be directly before.
       * @returns {engine.model.Position}
       */

    	}, {
    		key: 'createBefore',
    		value: function createBefore(node) {
    			if (!node.parent) {
    				/**
         * You can not make position before root.
         *
         * @error position-before-root
         * @param {engine.model.Node} root
         */
    				throw new CKEditorError('position-before-root: You can not make position before root.', { root: node });
    			}

    			return this.createFromParentAndOffset(node.parent, node.getIndex());
    		}

    		/**
       * Creates a new position from the parent element and the offset in that element.
       *
       * @param {engine.model.Element|engine.model.DocumentFragment} parent Position's parent element or
       * document fragment.
       * @param {Number} offset Position's offset.
       * @returns {engine.model.Position}
       */

    	}, {
    		key: 'createFromParentAndOffset',
    		value: function createFromParentAndOffset(parent, offset) {
    			if (!(parent instanceof Element || parent instanceof DocumentFragment)) {
    				/**
         * Position parent have to be a model element or model document fragment.
         *
         * @error position-parent-incorrect
         */
    				throw new CKEditorError('position-parent-incorrect: Position parent have to be a model element or model document fragment.');
    			}

    			var path = parent.getPath();

    			path.push(offset);

    			return new this(parent.root, path);
    		}

    		/**
       * Creates and returns a new instance of Position, which is equal to passed position.
       *
       * @param {engine.model.Position} position Position to be cloned.
       * @returns {engine.model.Position}
       */

    	}, {
    		key: 'createFromPosition',
    		value: function createFromPosition(position) {
    			return new this(position.root, position.path.slice());
    		}

    		/**
       * Creates Element object from deserilized object, ie. from parsed JSON string.
       *
       * @param {Object} json Deserialized JSON object.
       * @param {engine.model.Document} doc Document on which this operation will be applied.
       * @returns {engine.model.Position}
       */

    	}, {
    		key: 'fromJSON',
    		value: function fromJSON(json, doc) {
    			if (json.root === '$graveyard') {
    				return new Position(doc.graveyard, json.path);
    			}

    			if (!doc.hasRoot(json.root)) {
    				/**
         * Cannot create position for document. Root with specified name does not exist.
         *
         * @error position-fromjson-no-root
         * @param {String} rootName
         */
    				throw new CKEditorError('position-fromjson-no-root: Cannot create position for document. Root with specified name does not exist.', { rootName: json.root });
    			}

    			return new Position(doc.getRoot(json.root), json.path);
    		}
    	}]);
    	return Position;
    }();

    /**
     * Abstract tree view node class.
     *
     * @abstract
     * @memberOf engine.view
     */

    var Node$2 = function () {
    	/**
      * Creates a tree view node.
      *
      * This is an abstract class, so this constructor should not be used directly.
      */

    	function Node() {
    		classCallCheck(this, Node);

    		/**
       * Parent element. Null by default. Set by {@link engine.view.Element#insertChildren}.
       *
       * @readonly
       * @member {engine.view.Element|engine.view.DocumentFragment|null} engine.view.Node#parent
       */
    		this.parent = null;
    	}

    	/**
      * Returns index of the node in the parent element or null if the node has no parent.
      *
      * Throws error if the parent element does not contain this node.
      *
      * @returns {Number|null} Index of the node in the parent element or null if the node has not parent.
      */


    	createClass(Node, [{
    		key: 'getIndex',
    		value: function getIndex() {
    			var pos = void 0;

    			if (!this.parent) {
    				return null;
    			}

    			// No parent or child doesn't exist in parent's children.
    			if ((pos = this.parent.getChildIndex(this)) == -1) {
    				/**
         * The node's parent does not contain this node. It means that the document tree is corrupted.
         *
         * @error view-node-not-found-in-parent
         */
    				throw new CKEditorError('view-node-not-found-in-parent: The node\'s parent does not contain this node.');
    			}

    			return pos;
    		}

    		/**
       * Returns nodes next sibling or `null` if it is the last child.
       *
       * @returns {engine.view.Node|null} Nodes next sibling or `null` if it is the last child.
       */

    	}, {
    		key: 'getNextSibling',
    		value: function getNextSibling() {
    			var index = this.getIndex();

    			return index !== null && this.parent.getChild(index + 1) || null;
    		}

    		/**
       * Returns nodes previous sibling or `null` if it is the first child.
       *
       * @returns {engine.view.Node|null} Nodes previous sibling or `null` if it is the first child.
       */

    	}, {
    		key: 'getPreviousSibling',
    		value: function getPreviousSibling() {
    			var index = this.getIndex();

    			return index !== null && this.parent.getChild(index - 1) || null;
    		}

    		/**
       * Gets {@link engine.view.Document} reference, from the {@link engine.view.Node#getRoot root} or
       * returns null if the root has no reference to the {@link engine.view.Document}.
       *
       * @returns {engine.view.Document|null} View Document of the node or null.
       */

    	}, {
    		key: 'getDocument',
    		value: function getDocument() {
    			// Parent might be Node, null or DocumentFragment.
    			if (this.parent instanceof Node) {
    				return this.parent.getDocument();
    			} else {
    				return null;
    			}
    		}

    		/**
       * Gets the top parent for the node. If node has no parent it is the root itself.
       *
       * @returns {engine.view.Node}
       */

    	}, {
    		key: 'getRoot',
    		value: function getRoot() {
    			var root = this;

    			while (root.parent) {
    				root = root.parent;
    			}

    			return root;
    		}

    		/**
       * Returns ancestors array of this node.
       *
       * @param {Object} options Options object.
       * @param {Boolean} [options.includeNode=false] When set to `true` this node will be also included in parent's array.
       * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from node's parent to root element,
       * otherwise root element will be the first item in the array.
       * @returns {Array} Array with ancestors.
       */

    	}, {
    		key: 'getAncestors',
    		value: function getAncestors() {
    			var options = arguments.length <= 0 || arguments[0] === undefined ? { includeNode: false, parentFirst: false } : arguments[0];

    			var ancestors = [];
    			var parent = options.includeNode ? this : this.parent;

    			while (parent !== null) {
    				ancestors[options.parentFirst ? 'push' : 'unshift'](parent);
    				parent = parent.parent;
    			}

    			return ancestors;
    		}

    		/**
       * Removes node from parent.
       */

    	}, {
    		key: 'remove',
    		value: function remove() {
    			this.parent.removeChildren(this.getIndex());
    		}

    		/**
       * @param {engine.view.ChangeType} type Type of the change.
       * @param {engine.view.Node} node Changed node.
       * @fires engine.view.Node#change
       */

    	}, {
    		key: '_fireChange',
    		value: function _fireChange(type, node) {
    			this.fire('change:' + type, node);

    			if (this.parent) {
    				this.parent._fireChange(type, node);
    			}
    		}

    		/**
       * Clones this node.
       *
       * @method view.Node#clone
       * @returns {view.Node} Clone of this node.
       */

    		/**
       * Checks if provided node is similar to this node.
       *
       * @method view.Node#isSimilar
       * @returns {Boolean} True if nodes are similar.
       */

    		/**
       * Fired when list of {@link engine.view.Element elements} children changes.
       *
       * Change event is bubbled – it is fired on all ancestors.
       *
       * @event engine.view.Node#change:children
       * @param {engine.view.Node} Changed node.
       */

    		/**
       * Fired when list of {@link engine.view.Element elements} attributes changes.
       *
       * Change event is bubbled – it is fired on all ancestors.
       *
       * @event engine.view.Node#change:attributes
       * @param {engine.view.Node} Changed node.
       */

    		/**
       * Fired when {@link engine.view.Text text nodes} data changes.
       *
       * Change event is bubbled – it is fired on all ancestors.
       *
       * @event engine.view.Node#change:text
       * @param {engine.view.Node} Changed node.
       */

    	}]);
    	return Node;
    }();

    mix(Node$2, EmitterMixin);

    /**
     * Tree view text node.
     *
     * @memberOf engine.view
     * @extends engine.view.Node
     */

    var Text$2 = function (_Node) {
    	inherits(Text, _Node);

    	/**
      * Creates a tree view text node.
      *
      * @param {String} data Text.
      */

    	function Text(data) {
    		classCallCheck(this, Text);


    		/**
       * The text content.
       *
       * Setting the data fires the {@link engine.view.Node#event:change change event}.
       *
       * @private
       * @member {String} engine.view.Text#_data
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(Text).call(this));

    		_this._data = data;
    		return _this;
    	}

    	/**
      * Clones this node.
      *
      * @returns {engine.view.Text} Text node that is a clone of this node.
      */


    	createClass(Text, [{
    		key: 'clone',
    		value: function clone() {
    			return new Text(this.data);
    		}

    		/**
       * The text content.
       *
       * Setting the data fires the {@link view.Node#change change event}.
       */

    	}, {
    		key: 'isSimilar',


    		/**
       * Checks if this text node is similar to other text node.
       * Both nodes should have the same data to be considered as similar.
       *
       * @param {engine.view.Text} otherNode Node to check if it is same as this node.
       * @returns {Boolean}
       */
    		value: function isSimilar(otherNode) {
    			if (!(otherNode instanceof Text)) {
    				return false;
    			}

    			return this === otherNode || this.data === otherNode.data;
    		}
    	}, {
    		key: 'data',
    		get: function get() {
    			return this._data;
    		},
    		set: function set(data) {
    			this._fireChange('text', this);

    			this._data = data;
    		}
    	}]);
    	return Text;
    }(Node$2);

    /**
     * TextProxy is a wrapper for substring of {@link engine.view.Text}. Instance of this class is created by
     * {@link engine.view.TreeWalker} when only a part of {@link engine.view.Text} needs to be returned.
     *
     * **Note:** `TextProxy` instances are created on the fly basing on the current state of parent {@link engine.view.Text}.
     * Because of this it is highly unrecommended to store references to `TextProxy` instances because they might get
     * invalidated due to operations on the document. Also, `TextProxy` is not a {@link engine.view.Node} so it cannot be
     * inserted as a child of {@link engine.view.Element}.
     *
     * You should never create an instance of this class by your own.
     *
     * @memberOf engine.view
     */

    var TextProxy$1 = function () {
    	/**
      * Creates a tree view text proxy.
      *
      * @param {engine.view.Text} textNode Text node which text proxy is a substring.
      * @param {Number} startOffset Offset from beginning of {#textNode} and first character of {#data}.
      * @param {Number} [length] Length of substring. If is not set then the end offset is at the end of {#textNode}.
      */

    	function TextProxy(textNode, startOffset, length) {
    		classCallCheck(this, TextProxy);

    		/**
       * Element that is a parent of this text proxy.
       *
       * @readonly
       * @member {engine.view.Element|engine.view.DocumentFragment|null} engine.view.Node#parent
       */
    		this.parent = textNode.parent;

    		/**
       * Reference to the {@link engine.view.Text} element which TextProxy is a substring.
       *
       * @readonly
       * @member {engine.view.Text} engine.view.TextProxy#textNode
       */
    		this.textNode = textNode;

    		/**
       * Index of the substring in the `textParent`.
       *
       * @readonly
       * @member {Number} engine.view.TextProxy#index
       */
    		this.index = startOffset;

    		/**
       * The text content.
       *
       * @readonly
       * @member {String} engine.view.TextProxy#data
       */
    		this.data = textNode.data.substring(startOffset, startOffset + (length || textNode.data.length - startOffset));
    	}

    	/**
      * Gets {@link engine.view.Document} reference, from the {@link engine.view.Node#getRoot root} of
      * {#textNode} or returns null if the root has no reference to the {@link engine.view.Document}.
      *
      * @returns {engine.view.Document|null} View Document of the text proxy or null.
      */


    	createClass(TextProxy, [{
    		key: 'getDocument',
    		value: function getDocument() {
    			return this.textNode.getDocument();
    		}

    		/**
       * Gets the top parent for the {#textNode}. If there is no parent {#textNode} is the root.
       *
       * @returns {engine.view.Node}
       */

    	}, {
    		key: 'getRoot',
    		value: function getRoot() {
    			return this.textNode.getRoot();
    		}

    		/**
       * Returns ancestors array of this text proxy.
       *
       * @param {Object} options Options object.
       * @param {Boolean} [options.includeNode=false] When set to `true` {#textNode} will be also included in parent's array.
       * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from text proxy parent to
       * root element, otherwise root element will be the first item in the array.
       * @returns {Array} Array with ancestors.
       */

    	}, {
    		key: 'getAncestors',
    		value: function getAncestors() {
    			var options = arguments.length <= 0 || arguments[0] === undefined ? { includeNode: false, parentFirst: false } : arguments[0];

    			var ancestors = [];
    			var parent = options.includeNode ? this.textNode : this.parent;

    			while (parent !== null) {
    				ancestors[options.parentFirst ? 'push' : 'unshift'](parent);
    				parent = parent.parent;
    			}

    			return ancestors;
    		}
    	}]);
    	return TextProxy;
    }();

    /**
     * Tree view element.
     *
     * Editing engine does not define fixed HTML DTD. This is why the type of the {@link engine.view.Element} need to
     * be defined by the feature developer. Creating an element you should use {@link engine.view.ContainerElement}
     * class or {@link engine.view.AttributeElement}.
     *
     * Note that for view elements which are not created from model, like elements from mutations, paste or
     * {@link engine.DataController#set data.set} it is not possible to define the type of the element, so
     * these will be instances of the {@link engine.view.Element}.
     *
     * @memberOf engine.view
     * @extends engine.view.Node
     */

    var Element$1 = function (_Node) {
    	inherits(Element, _Node);

    	/**
      * Creates a tree view element.
      *
      * Attributes can be passed in various formats:
      *
      *		new Element( 'div', { 'class': 'editor', 'contentEditable': 'true' } ); // object
      *		new Element( 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator
      *		new Element( 'div', mapOfAttributes ); // map
      *
      * @param {String} name Node name.
      * @param {Object|Iterable} [attrs] Collection of attributes.
      * @param {engine.view.Node|Iterable.<engine.view.Node>} [children] List of nodes to be inserted into created element.
      */

    	function Element(name, attrs, children) {
    		classCallCheck(this, Element);


    		/**
       * Name of the element.
       *
       * @readonly
       * @member {String} engine.view.Element#name
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(Element).call(this));

    		_this.name = name;

    		/**
       * Map of attributes, where attributes names are keys and attributes values are values.
       *
       * @protected
       * @member {Map} engine.view.Element#_attrs
       */
    		if (isPlainObject(attrs)) {
    			_this._attrs = objectToMap(attrs);
    		} else {
    			_this._attrs = new Map(attrs);
    		}

    		/**
       * Array of child nodes.
       *
       * @protected
       * @member {Array.<engine.view.Node>} engine.view.Element#_children
       */
    		_this._children = [];

    		if (children) {
    			_this.insertChildren(0, children);
    		}

    		/**
       * Set of classes associated with element instance.
       *
       * @protected
       * @member {Set} engine.view.Element#_classes
       */
    		_this._classes = new Set();

    		if (_this._attrs.has('class')) {
    			// Remove class attribute and handle it by class set.
    			var classString = _this._attrs.get('class');
    			parseClasses(_this._classes, classString);
    			_this._attrs.delete('class');
    		}

    		/**
       * Map of styles.
       *
       * @protected
       * @member {Set} engine.view.Element#_styles
       */
    		_this._styles = new Map();

    		if (_this._attrs.has('style')) {
    			// Remove style attribute and handle it by styles map.
    			parseInlineStyles(_this._styles, _this._attrs.get('style'));
    			_this._attrs.delete('style');
    		}
    		return _this;
    	}

    	/**
      * Clones provided element.
      *
      * @param {Boolean} deep If set to `true` clones element and all its children recursively. When set to `false`,
      * element will be cloned without any children.
      * @returns {engine.view.Element} Clone of this element.
      */


    	createClass(Element, [{
    		key: 'clone',
    		value: function clone(deep) {
    			var childrenClone = [];

    			if (deep) {
    				var _iteratorNormalCompletion = true;
    				var _didIteratorError = false;
    				var _iteratorError = undefined;

    				try {
    					for (var _iterator = this.getChildren()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    						var child = _step.value;

    						childrenClone.push(child.clone(deep));
    					}
    				} catch (err) {
    					_didIteratorError = true;
    					_iteratorError = err;
    				} finally {
    					try {
    						if (!_iteratorNormalCompletion && _iterator.return) {
    							_iterator.return();
    						}
    					} finally {
    						if (_didIteratorError) {
    							throw _iteratorError;
    						}
    					}
    				}
    			}

    			// ContainerElement and AttributeElement should be also cloned properly.
    			var cloned = new this.constructor(this.name, this._attrs, childrenClone);

    			// Classes and styles are cloned separately - this solution is faster than adding them back to attributes and
    			// parse once again in constructor.
    			cloned._classes = new Set(this._classes);
    			cloned._styles = new Map(this._styles);

    			return cloned;
    		}

    		/**
       * {@link engine.view.Element#insert Insert} a child node or a list of child nodes at the end of this node and sets
       * the parent of these nodes to this element.
       *
       * @fires engine.view.Node#change
       * @param {engine.view.Node|Iterable.<engine.view.Node>} nodes Node or the list of nodes to be inserted.
       * @returns {Number} Number of appended nodes.
      	 */

    	}, {
    		key: 'appendChildren',
    		value: function appendChildren(nodes) {
    			return this.insertChildren(this.getChildCount(), nodes);
    		}

    		/**
       * Gets child at the given index.
       *
       * @param {Number} index Index of child.
       * @returns {engine.view.Node} Child node.
       */

    	}, {
    		key: 'getChild',
    		value: function getChild(index) {
    			return this._children[index];
    		}

    		/**
       * Gets the number of element's children.
       *
       * @returns {Number} The number of element's children.
       */

    	}, {
    		key: 'getChildCount',
    		value: function getChildCount() {
    			return this._children.length;
    		}

    		/**
       * Gets index of the given child node. Returns `-1` if child node is not found.
       *
       * @param {engine.view.Node} node Child node.
       * @returns {Number} Index of the child node.
       */

    	}, {
    		key: 'getChildIndex',
    		value: function getChildIndex(node) {
    			return this._children.indexOf(node);
    		}

    		/**
       * Gets child nodes iterator.
       *
       * @returns {Iterable.<engine.view.Node>} Child nodes iterator.
       */

    	}, {
    		key: 'getChildren',
    		value: function getChildren() {
    			return this._children[Symbol.iterator]();
    		}

    		/**
       * Returns an iterator that contains the keys for attributes.
       * Order of inserting attributes is not preserved.
       *
       * @returns {Iterator.<String>} Keys for attributes.
       */

    	}, {
    		key: 'getAttributeKeys',
    		value: regeneratorRuntime.mark(function getAttributeKeys() {
    			var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, key;

    			return regeneratorRuntime.wrap(function getAttributeKeys$(_context) {
    				while (1) {
    					switch (_context.prev = _context.next) {
    						case 0:
    							if (!(this._classes.size > 0)) {
    								_context.next = 3;
    								break;
    							}

    							_context.next = 3;
    							return 'class';

    						case 3:
    							if (!(this._styles.size > 0)) {
    								_context.next = 6;
    								break;
    							}

    							_context.next = 6;
    							return 'style';

    						case 6:

    							// This is not an optimal solution because of https://github.com/ckeditor/ckeditor5-engine/issues/454.
    							// It can be simplified to `yield* this._attrs.keys();`.
    							_iteratorNormalCompletion2 = true;
    							_didIteratorError2 = false;
    							_iteratorError2 = undefined;
    							_context.prev = 9;
    							_iterator2 = this._attrs.keys()[Symbol.iterator]();

    						case 11:
    							if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
    								_context.next = 18;
    								break;
    							}

    							key = _step2.value;
    							_context.next = 15;
    							return key;

    						case 15:
    							_iteratorNormalCompletion2 = true;
    							_context.next = 11;
    							break;

    						case 18:
    							_context.next = 24;
    							break;

    						case 20:
    							_context.prev = 20;
    							_context.t0 = _context['catch'](9);
    							_didIteratorError2 = true;
    							_iteratorError2 = _context.t0;

    						case 24:
    							_context.prev = 24;
    							_context.prev = 25;

    							if (!_iteratorNormalCompletion2 && _iterator2.return) {
    								_iterator2.return();
    							}

    						case 27:
    							_context.prev = 27;

    							if (!_didIteratorError2) {
    								_context.next = 30;
    								break;
    							}

    							throw _iteratorError2;

    						case 30:
    							return _context.finish(27);

    						case 31:
    							return _context.finish(24);

    						case 32:
    						case 'end':
    							return _context.stop();
    					}
    				}
    			}, getAttributeKeys, this, [[9, 20, 24, 32], [25,, 27, 31]]);
    		})

    		/**
       * Gets attribute by key. If attribute is not present - returns undefined.
       *
       * @param {String} key Attribute key.
       * @returns {String|undefined} Attribute value.
       */

    	}, {
    		key: 'getAttribute',
    		value: function getAttribute(key) {
    			if (key == 'class') {
    				if (this._classes.size > 0) {
    					return [].concat(toConsumableArray(this._classes)).join(' ');
    				}

    				return undefined;
    			}

    			if (key == 'style') {
    				if (this._styles.size > 0) {
    					var styleString = '';

    					var _iteratorNormalCompletion3 = true;
    					var _didIteratorError3 = false;
    					var _iteratorError3 = undefined;

    					try {
    						for (var _iterator3 = this._styles[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
    							var _step3$value = slicedToArray(_step3.value, 2);

    							var property = _step3$value[0];
    							var value = _step3$value[1];

    							styleString += property + ':' + value + ';';
    						}
    					} catch (err) {
    						_didIteratorError3 = true;
    						_iteratorError3 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion3 && _iterator3.return) {
    								_iterator3.return();
    							}
    						} finally {
    							if (_didIteratorError3) {
    								throw _iteratorError3;
    							}
    						}
    					}

    					return styleString;
    				}

    				return undefined;
    			}

    			return this._attrs.get(key);
    		}

    		/**
       * Returns a boolean indicating whether an attribute with the specified key exists in the element.
       *
       * @param {String} key Attribute key.
       * @returns {Boolean} `true` if attribute with the specified key exists in the element, false otherwise.
       */

    	}, {
    		key: 'hasAttribute',
    		value: function hasAttribute(key) {
    			if (key == 'class') {
    				return this._classes.size > 0;
    			}

    			if (key == 'style') {
    				return this._styles.size > 0;
    			}

    			return this._attrs.has(key);
    		}

    		/**
       * Adds or overwrite attribute with a specified key and value.
       *
       * @param {String} key Attribute key.
       * @param {String} value Attribute value.
       * @fires engine.view.Node#change
       */

    	}, {
    		key: 'setAttribute',
    		value: function setAttribute(key, value) {
    			this._fireChange('attributes', this);

    			if (key == 'class') {
    				parseClasses(this._classes, value);
    			} else if (key == 'style') {
    				parseInlineStyles(this._styles, value);
    			} else {
    				this._attrs.set(key, value);
    			}
    		}

    		/**
       * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
       * this element.
       *
       * @param {Number} index Position where nodes should be inserted.
       * @param {engine.view.Node|Iterable.<engine.view.Node>} nodes Node or the list of nodes to be inserted.
       * @fires engine.view.Node#change
       * @returns {Number} Number of inserted nodes.
       */

    	}, {
    		key: 'insertChildren',
    		value: function insertChildren(index, nodes) {
    			this._fireChange('children', this);
    			var count = 0;

    			if (!isIterable(nodes)) {
    				nodes = [nodes];
    			}

    			var _iteratorNormalCompletion4 = true;
    			var _didIteratorError4 = false;
    			var _iteratorError4 = undefined;

    			try {
    				for (var _iterator4 = nodes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
    					var node = _step4.value;

    					node.parent = this;

    					this._children.splice(index, 0, node);
    					index++;
    					count++;
    				}
    			} catch (err) {
    				_didIteratorError4 = true;
    				_iteratorError4 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion4 && _iterator4.return) {
    						_iterator4.return();
    					}
    				} finally {
    					if (_didIteratorError4) {
    						throw _iteratorError4;
    					}
    				}
    			}

    			return count;
    		}

    		/**
       * Removes attribute from the element.
       *
       * @param {String} key Attribute key.
       * @returns {Boolean} Returns true if an attribute existed and has been removed.
       * @fires engine.view.Node#change
       */

    	}, {
    		key: 'removeAttribute',
    		value: function removeAttribute(key) {
    			this._fireChange('attributes', this);

    			// Remove class attribute.
    			if (key == 'class') {
    				if (this._classes.size > 0) {
    					this._classes.clear();

    					return true;
    				}

    				return false;
    			}

    			// Remove style attribute.
    			if (key == 'style') {
    				if (this._styles.size > 0) {
    					this._styles.clear();

    					return true;
    				}

    				return false;
    			}

    			// Remove other attributes.
    			return this._attrs.delete(key);
    		}

    		/**
       * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
       *
       * @param {Number} index Number of the first node to remove.
       * @param {Number} [howMany=1] Number of nodes to remove.
       * @returns {Array.<engine.view.Node>} The array of removed nodes.
       * @fires engine.view.Node#change
       */

    	}, {
    		key: 'removeChildren',
    		value: function removeChildren(index) {
    			var howMany = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

    			this._fireChange('children', this);

    			for (var i = index; i < index + howMany; i++) {
    				this._children[i].parent = null;
    			}

    			return this._children.splice(index, howMany);
    		}

    		/**
       * Checks if this element is similar to other element.
       * Both elements should have the same name and attributes to be considered as similar. Two similar elements
       * can contain different set of children nodes.
       *
       * @param {engine.view.Element} otherElement
       * @returns {Boolean}
       */

    	}, {
    		key: 'isSimilar',
    		value: function isSimilar(otherElement) {
    			if (!(otherElement instanceof Element)) {
    				return false;
    			}

    			// If exactly the same Element is provided - return true immediately.
    			if (this === otherElement) {
    				return true;
    			}

    			// Check element name.
    			if (this.name != otherElement.name) {
    				return false;
    			}

    			// Check number of attributes, classes and styles.
    			if (this._attrs.size !== otherElement._attrs.size || this._classes.size !== otherElement._classes.size || this._styles.size !== otherElement._styles.size) {
    				return false;
    			}

    			// Check if attributes are the same.
    			var _iteratorNormalCompletion5 = true;
    			var _didIteratorError5 = false;
    			var _iteratorError5 = undefined;

    			try {
    				for (var _iterator5 = this._attrs[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
    					var _step5$value = slicedToArray(_step5.value, 2);

    					var key = _step5$value[0];
    					var value = _step5$value[1];

    					if (!otherElement._attrs.has(key) || otherElement._attrs.get(key) !== value) {
    						return false;
    					}
    				}

    				// Check if classes are the same.
    			} catch (err) {
    				_didIteratorError5 = true;
    				_iteratorError5 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion5 && _iterator5.return) {
    						_iterator5.return();
    					}
    				} finally {
    					if (_didIteratorError5) {
    						throw _iteratorError5;
    					}
    				}
    			}

    			var _iteratorNormalCompletion6 = true;
    			var _didIteratorError6 = false;
    			var _iteratorError6 = undefined;

    			try {
    				for (var _iterator6 = this._classes[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
    					var className = _step6.value;

    					if (!otherElement._classes.has(className)) {
    						return false;
    					}
    				}

    				// Check if styles are the same.
    			} catch (err) {
    				_didIteratorError6 = true;
    				_iteratorError6 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion6 && _iterator6.return) {
    						_iterator6.return();
    					}
    				} finally {
    					if (_didIteratorError6) {
    						throw _iteratorError6;
    					}
    				}
    			}

    			var _iteratorNormalCompletion7 = true;
    			var _didIteratorError7 = false;
    			var _iteratorError7 = undefined;

    			try {
    				for (var _iterator7 = this._styles[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
    					var _step7$value = slicedToArray(_step7.value, 2);

    					var property = _step7$value[0];
    					var value = _step7$value[1];

    					if (!otherElement._styles.has(property) || otherElement._styles.get(property) !== value) {
    						return false;
    					}
    				}
    			} catch (err) {
    				_didIteratorError7 = true;
    				_iteratorError7 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion7 && _iterator7.return) {
    						_iterator7.return();
    					}
    				} finally {
    					if (_didIteratorError7) {
    						throw _iteratorError7;
    					}
    				}
    			}

    			return true;
    		}

    		/**
       * Adds specified class.
       *
       *		element.addClass( 'foo' ); // Adds 'foo' class.
       *		element.addClass( 'foo', 'bar' ); // Adds 'foo' and 'bar' classes.
       *
       * @param {...String} className
       * @fires engine.view.Node#change
       */

    	}, {
    		key: 'addClass',
    		value: function addClass() {
    			var _this2 = this;

    			this._fireChange('attributes', this);

    			for (var _len = arguments.length, className = Array(_len), _key = 0; _key < _len; _key++) {
    				className[_key] = arguments[_key];
    			}

    			className.forEach(function (name) {
    				return _this2._classes.add(name);
    			});
    		}

    		/**
       * Removes specified class.
       *
      	 *		element.removeClass( 'foo' );  // Removes 'foo' class.
       *		element.removeClass( 'foo', 'bar' ); // Removes both 'foo' and 'bar' classes.
       *
       * @param {...String} className
       * @fires engine.view.Node#change
       */

    	}, {
    		key: 'removeClass',
    		value: function removeClass() {
    			var _this3 = this;

    			this._fireChange('attributes', this);

    			for (var _len2 = arguments.length, className = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    				className[_key2] = arguments[_key2];
    			}

    			className.forEach(function (name) {
    				return _this3._classes.delete(name);
    			});
    		}

    		/**
       * Returns true if class is present.
       * If more then one class is provided - returns true only when all classes are present.
       *
       *		element.hasClass( 'foo' ); // Returns true if 'foo' class is present.
       *		element.hasClass( 'foo', 'bar' ); // Returns true if 'foo' and 'bar' classes are both present.
       *
       * @param {...String} className
       */

    	}, {
    		key: 'hasClass',
    		value: function hasClass() {
    			for (var _len3 = arguments.length, className = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    				className[_key3] = arguments[_key3];
    			}

    			var _iteratorNormalCompletion8 = true;
    			var _didIteratorError8 = false;
    			var _iteratorError8 = undefined;

    			try {
    				for (var _iterator8 = className[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
    					var name = _step8.value;

    					if (!this._classes.has(name)) {
    						return false;
    					}
    				}
    			} catch (err) {
    				_didIteratorError8 = true;
    				_iteratorError8 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion8 && _iterator8.return) {
    						_iterator8.return();
    					}
    				} finally {
    					if (_didIteratorError8) {
    						throw _iteratorError8;
    					}
    				}
    			}

    			return true;
    		}

    		/**
       * Returns iterator that contains all class names.
       *
       * @returns {Iterator.<String>}
       */

    	}, {
    		key: 'getClassNames',
    		value: function getClassNames() {
    			return this._classes.keys();
    		}

    		/**
       * Adds style to the element.
       *
       *		element.setStyle( 'color', 'red' );
       *		element.setStyle( {
       *			color: 'red',
       *			position: 'fixed'
       *		} );
       *
       * @param {String|Object} property Property name or object with key - value pairs.
       * @param {String} [value] Value to set. This parameter is ignored if object is provided as the first parameter.
       * @fires engine.view.Node#change
       */

    	}, {
    		key: 'setStyle',
    		value: function setStyle(property, value) {
    			this._fireChange('attributes', this);

    			if (isPlainObject(property)) {
    				var keys = Object.keys(property);

    				var _iteratorNormalCompletion9 = true;
    				var _didIteratorError9 = false;
    				var _iteratorError9 = undefined;

    				try {
    					for (var _iterator9 = keys[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
    						var key = _step9.value;

    						this._styles.set(key, property[key]);
    					}
    				} catch (err) {
    					_didIteratorError9 = true;
    					_iteratorError9 = err;
    				} finally {
    					try {
    						if (!_iteratorNormalCompletion9 && _iterator9.return) {
    							_iterator9.return();
    						}
    					} finally {
    						if (_didIteratorError9) {
    							throw _iteratorError9;
    						}
    					}
    				}
    			} else {
    				this._styles.set(property, value);
    			}
    		}

    		/**
       * Returns style value for given property.
       * Undefined is returned if style does not exist.
       *
       * @param {String} property
       * @returns {String|undefined}
       */

    	}, {
    		key: 'getStyle',
    		value: function getStyle(property) {
    			return this._styles.get(property);
    		}

    		/**
       * Returns iterator that contains all style names.
       *
       * @returns {Iterator.<String>}
       */

    	}, {
    		key: 'getStyleNames',
    		value: function getStyleNames() {
    			return this._styles.keys();
    		}

    		/**
       * Returns true if style keys are present.
       * If more then one style property is provided - returns true only when all properties are present.
       *
       *		element.hasStyle( 'color' ); // Returns true if 'border-top' style is present.
       *		element.hasStyle( 'color', 'border-top' ); // Returns true if 'color' and 'border-top' styles are both present.
       *
       * @param {...String} property
       */

    	}, {
    		key: 'hasStyle',
    		value: function hasStyle() {
    			for (var _len4 = arguments.length, property = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    				property[_key4] = arguments[_key4];
    			}

    			var _iteratorNormalCompletion10 = true;
    			var _didIteratorError10 = false;
    			var _iteratorError10 = undefined;

    			try {
    				for (var _iterator10 = property[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
    					var name = _step10.value;

    					if (!this._styles.has(name)) {
    						return false;
    					}
    				}
    			} catch (err) {
    				_didIteratorError10 = true;
    				_iteratorError10 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion10 && _iterator10.return) {
    						_iterator10.return();
    					}
    				} finally {
    					if (_didIteratorError10) {
    						throw _iteratorError10;
    					}
    				}
    			}

    			return true;
    		}

    		/**
       * Removes specified style.
       *
       *		element.removeStyle( 'color' );  // Removes 'color' style.
       *		element.removeStyle( 'color', 'border-top' ); // Removes both 'color' and 'border-top' styles.
       *
       * @param {...String} property
       * @fires engine.view.Node#change
       */

    	}, {
    		key: 'removeStyle',
    		value: function removeStyle() {
    			var _this4 = this;

    			this._fireChange('attributes', this);

    			for (var _len5 = arguments.length, property = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    				property[_key5] = arguments[_key5];
    			}

    			property.forEach(function (name) {
    				return _this4._styles.delete(name);
    			});
    		}
    	}]);
    	return Element;
    }(Node$2);

    function parseInlineStyles(stylesMap, stylesString) {
    	var regex = /\s*([^:;\s]+)\s*:\s*([^;]+)\s*(?=;|$)/g;
    	var matchStyle = void 0;
    	stylesMap.clear();

    	while ((matchStyle = regex.exec(stylesString)) !== null) {
    		stylesMap.set(matchStyle[1], matchStyle[2].trim());
    	}
    }

    // Parses class attribute and puts all classes into classes set.
    // Classes set s cleared before insertion.
    //
    // @param {Set.<String>} classesSet Set to insert parsed classes.
    // @param {String} classesString String with classes to parse.
    function parseClasses(classesSet, classesString) {
    	var classArray = classesString.split(/\s+/);
    	classesSet.clear();
    	classArray.forEach(function (name) {
    		return classesSet.add(name);
    	});
    }

    /**
     * Containers are elements which define document structure. They define boundaries for
     * {@link engine.view.AttributeElement attributes}. They are mostly use for block elements like `<p>` or `<div>`.
     *
     * Editing engine does not define fixed HTML DTD. This is why the type of the {@link engine.view.Element} need to
     * be defined by the feature developer.
     *
     * Creating an element you should use `ContainerElement` class or {@link engine.view.AttributeElement}. This is
     * important to define the type of the element because of two reasons:
     *
     * Firstly, {@link engine.view.DomConverter} needs the information what is an editable block to convert elements to
     * DOM properly. {@link engine.view.DomConverter} will ensure that `ContainerElement` is editable and it is possible
     * to put caret inside it, even if the container is empty.
     *
     * Secondly, {@link engine.view.Writer} uses this information.
     * Nodes {@link engine.view.Writer#breakAttributes breaking} and {@link engine.view.Writer#mergeAttributes merging}
     * is performed only in a bounds of a container nodes.
     *
     * For instance if `<p>` is an container and `<b>` is attribute:
     *
     *		<p><b>fo^o</b></p>
     *
     * {@link engine.view.Writer#breakAttributes breakAttributes} will create:
     *
     *		<p><b>fo</b><b>o</b></p>
     *
     * There might be a need to mark `<span>` element as a container node, for example in situation when it will be a
     * container of an inline widget:
     *
     *		<span color="red">foobar</span>		// attribute
     *		<span data-widget>foobar</span>		// container
     *
     * @memberOf engine.view
     * @extends engine.view.Element
     */

    var ContainerElement = function (_Element) {
      inherits(ContainerElement, _Element);

      /**
       * Creates a container element.
       *
       * @see engine.view.Element
       */

      function ContainerElement(name, attrs, children) {
        classCallCheck(this, ContainerElement);
        return possibleConstructorReturn(this, Object.getPrototypeOf(ContainerElement).call(this, name, attrs, children));
      }

      /**
       * Returns block {@link engine.view.filler filler} offset or `null` if block filler is not needed.
       *
       * @returns {Number|null} Block filler offset or `null` if block filler is not needed.
       */


      createClass(ContainerElement, [{
        key: 'getFillerOffset',
        value: function getFillerOffset() {
          return this.getChildCount() === 0 ? 0 : null;
        }
      }]);
      return ContainerElement;
    }(Element$1);

    /**
     * Editable element which can be a {@link view.engine.RootEditableElement root} or nested editable area in the editor.
     *
     * @memberOf engine.view
     * @extends engine.view.ContainerElement
     * @mixes utils.ObservaleMixin
     */

    var EditableElement = function (_ContainerElement) {
    	inherits(EditableElement, _ContainerElement);

    	/**
      * Creates an editable element.
      */

    	function EditableElement(document, name, attrs, children) {
    		classCallCheck(this, EditableElement);


    		/**
       * {@link engine.view.Document} that is an owner of this root.
       *
       * @private
       * @member {engine.view.Document} engine.view.RootEditableElement#_document
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(EditableElement).call(this, name, attrs, children));

    		_this._document = document;

    		/**
       * Whether the editable is in read-write or read-only mode.
       *
       * @observable
       * @member {Boolean} engine.view.EditableElement#isReadOnly
       */
    		_this.set('isReadOnly', false);

    		/**
       * Whether the editable is focused.
       *
       * This property updates when {@link engine.view.Document#isFocused document.isFocused} is changed and after each
       * {@link engine.view.Document#render render} method call.
       *
       * @readonly
       * @observable
       * @member {Boolean} engine.view.EditableElement#isFocused
       */
    		_this.bind('isFocused').to(document, 'isFocused', function (isFocused) {
    			return isFocused && document.selection.getEditableElement() == _this;
    		});

    		// Update focus state after each rendering. Selection might be moved to different editable before rendering,
    		// but this does not mean that editable has focus - it will be placed there after rendering.
    		_this.listenTo(document, 'render', function () {
    			_this.isFocused = document.isFocused && document.selection.getEditableElement() == _this;
    		}, null, 11);
    		return _this;
    	}

    	/**
      * Gets the {@link engine.view.Document} reference.
      *
      * @returns {engine.view.Document|null} View Document of the node or `null`.
      */


    	createClass(EditableElement, [{
    		key: 'getDocument',
    		value: function getDocument() {
    			return this._document;
    		}
    	}]);
    	return EditableElement;
    }(ContainerElement);

    mix(EditableElement, ObservableMixin);

    /**
     * Position in the tree. Position is always located before or after a node.
     *
     * @memberOf engine.view
     */

    var Position$1 = function () {
    	/**
      * Creates a position.
      *
      * @param {engine.view.Node} parent Position parent node.
      * @param {Number} offset Position offset.
      */

    	function Position(parent, offset) {
    		classCallCheck(this, Position);

    		/**
       * Position parent node.
       *
       * @member {engine.view.Node} engine.view.Position#parent
       */
    		this.parent = parent;

    		/**
       * Position offset.
       *
       * @member {Number} engine.view.Position#offset
       */
    		this.offset = offset;
    	}

    	/**
      * Node directly after the position. Equals `null` when there is no node after position or position is located
      * inside text node.
      *
      * @readonly
      * @type {engine.view.Node|null}
      */


    	createClass(Position, [{
    		key: 'getShiftedBy',


    		/**
       * Returns a new instance of Position with offset incremented by `shift` value.
       *
       * @param {Number} shift How position offset should get changed. Accepts negative values.
       * @returns {engine.view.Position} Shifted position.
       */
    		value: function getShiftedBy(shift) {
    			var shifted = Position.createFromPosition(this);

    			var offset = shifted.offset + shift;
    			shifted.offset = offset < 0 ? 0 : offset;

    			return shifted;
    		}

    		/**
       * Checks whether this position equals given position.
       *
       * @param {engine.view.Position} otherPosition Position to compare with.
       * @returns {Boolean} True if positions are same.
       */

    	}, {
    		key: 'isEqual',
    		value: function isEqual(otherPosition) {
    			return this == otherPosition || this.parent == otherPosition.parent && this.offset == otherPosition.offset;
    		}

    		/**
       * Checks whether this position is located before given position. When method returns `false` it does not mean that
       * this position is after give one. Two positions may be located inside separate roots and in that situation this
       * method will still return `false`.
       *
       * @see engine.view.Position#isAfter
       * @see engine.view.Position#compareWith
       * @param {engine.view.Position} otherPosition Position to compare with.
       * @returns {Boolean} Returns `true` if this position is before given position.
       */

    	}, {
    		key: 'isBefore',
    		value: function isBefore(otherPosition) {
    			return this.compareWith(otherPosition) == 'BEFORE';
    		}

    		/**
       * Checks whether this position is located after given position. When method returns `false` it does not mean that
       * this position is before give one. Two positions may be located inside separate roots and in that situation this
       * method will still return `false`.
       *
       * @see engine.view.Position#isBefore
       * @see engine.view.Position#compareWith
       * @param {engine.view.Position} otherPosition Position to compare with.
       * @returns {Boolean} Returns `true` if this position is after given position.
       */

    	}, {
    		key: 'isAfter',
    		value: function isAfter(otherPosition) {
    			return this.compareWith(otherPosition) == 'AFTER';
    		}

    		/**
       * Checks whether this position is before, after or in same position that other position. Two positions may be also
       * different when they are located in separate roots.
       *
       * @param {engine.view.Position} otherPosition Position to compare with.
       * @returns {engine.view.PositionRelation}
       */

    	}, {
    		key: 'compareWith',
    		value: function compareWith(otherPosition) {
    			if (this.isEqual(otherPosition)) {
    				return 'SAME';
    			}

    			// If positions have same parent.
    			if (this.parent === otherPosition.parent) {
    				return this.offset - otherPosition.offset < 0 ? 'BEFORE' : 'AFTER';
    			}

    			// Get path from root to position's parent element.
    			var path = this.parent.getAncestors({ includeNode: true });
    			var otherPath = otherPosition.parent.getAncestors({ includeNode: true });

    			// Compare both path arrays to find common ancestor.
    			var result = compareArrays(path, otherPath);

    			var commonAncestorIndex = void 0;

    			switch (result) {
    				case 0:
    					// No common ancestors found.
    					return 'DIFFERENT';

    				case 'PREFIX':
    					commonAncestorIndex = path.length - 1;
    					break;

    				case 'EXTENSION':
    					commonAncestorIndex = otherPath.length - 1;
    					break;

    				default:
    					commonAncestorIndex = result - 1;
    			}

    			// Common ancestor of two positions.
    			var commonAncestor = path[commonAncestorIndex];
    			var nextAncestor1 = path[commonAncestorIndex + 1];
    			var nextAncestor2 = otherPath[commonAncestorIndex + 1];

    			// Check if common ancestor is not one of the parents.
    			if (commonAncestor === this.parent) {
    				var _index = this.offset - nextAncestor2.getIndex();

    				return _index <= 0 ? 'BEFORE' : 'AFTER';
    			} else if (commonAncestor === otherPosition.parent) {
    				var _index2 = nextAncestor1.getIndex() - otherPosition.offset;

    				return _index2 < 0 ? 'BEFORE' : 'AFTER';
    			}

    			var index = nextAncestor1.getIndex() - nextAncestor2.getIndex();

    			// Compare indexes of next ancestors inside common one.
    			return index < 0 ? 'BEFORE' : 'AFTER';
    		}

    		/**
       * Returns {@link engine.view.EditableElement EditableElement} instance that contains this position.
       *
       * @returns {engine.view.EditableElement|null} Returns closest EditableElement or null if none is found.
       */

    	}, {
    		key: 'getEditableElement',
    		value: function getEditableElement() {
    			var editable = this.parent;

    			while (!(editable instanceof EditableElement)) {
    				if (editable.parent) {
    					editable = editable.parent;
    				} else {
    					return null;
    				}
    			}

    			return editable;
    		}

    		/**
       * Creates a new position after the given node.
       *
       * @param {engine.view.Node|engine.view.TextProxy} node Node or text proxy after which the position should be located.
       * @returns {engine.view.Position}
       */

    	}, {
    		key: 'nodeAfter',
    		get: function get() {
    			if (this.parent instanceof Text$2) {
    				return null;
    			}

    			return this.parent.getChild(this.offset) || null;
    		}

    		/**
       * Node directly before the position. Equals `null` when there is no node before position or position is located
       * inside text node.
       *
       * @readonly
       * @type {engine.view.Node|null}
       */

    	}, {
    		key: 'nodeBefore',
    		get: function get() {
    			if (this.parent instanceof Text$2) {
    				return null;
    			}

    			return this.parent.getChild(this.offset - 1) || null;
    		}
    	}], [{
    		key: 'createAfter',
    		value: function createAfter(node) {
    			// {@link engine.view.TextProxy} is not a instance of {@link engine.view.Node} so we need do handle it in specific way.
    			if (node instanceof TextProxy$1) {
    				return new Position(node.textNode, node.index + node.data.length);
    			}

    			if (!node.parent) {
    				/**
         * You can not make a position after a root.
         *
         * @error position-after-root
         * @param {engine.view.Node} root
         */
    				throw new CKEditorError('position-after-root: You can not make position after root.', { root: node });
    			}

    			return new Position(node.parent, node.getIndex() + 1);
    		}

    		/**
       * Creates a new position before the given node.
       *
       * @param {engine.view.Node|engine.view.TextProxy} node Node or text proxy before which the position should be located.
       * @returns {engine.view.Position}
       */

    	}, {
    		key: 'createBefore',
    		value: function createBefore(node) {
    			// {@link engine.view.TextProxy} is not a instance of {@link engine.view.Node} so we need do handle it in specific way.
    			if (node instanceof TextProxy$1) {
    				return new Position(node.textNode, node.index);
    			}

    			if (!node.parent) {
    				/**
         * You cannot make a position before a root.
         *
         * @error position-before-root
         * @param {engine.view.Node} root
         */
    				throw new CKEditorError('position-before-root: You can not make position before root.', { root: node });
    			}

    			return new Position(node.parent, node.getIndex());
    		}

    		/**
       * Creates and returns a new instance of `Position`, which is equal to the passed position.
       *
       * @param {engine.view.Position} position Position to be cloned.
       * @returns {engine.view.Position}
       */

    	}, {
    		key: 'createFromPosition',
    		value: function createFromPosition(position) {
    			return new this(position.parent, position.offset);
    		}
    	}]);
    	return Position;
    }();

    /**
     * Tree view range.
     *
     * @memberOf engine.view
     */

    var Range$2 = function () {
    	/**
      * Creates a range spanning from `start` position to `end` position.
      * **Note:** Constructor creates it's own {@link engine.view.Position} instances basing on passed values.
      *
      * @param {engine.view.Position} start Start position.
      * @param {engine.view.Position} end End position.
      */

    	function Range(start, end) {
    		classCallCheck(this, Range);

    		/**
       * Start position.
       *
       * @member engine.view.Range#start
       * @type {engine.view.Position}
       */
    		this.start = Position$1.createFromPosition(start);

    		/**
       * End position.
       *
       * @member engine.view.Range#end
       * @type {engine.view.Position}
       */
    		this.end = Position$1.createFromPosition(end);
    	}

    	/**
      * Returns whether the range is collapsed, that is it start and end positions are equal.
      *
      * @type {Boolean}
      */


    	createClass(Range, [{
    		key: 'isEqual',


    		/**
       * Two ranges equal if their start and end positions equal.
       *
       * @param {engine.view.Range} otherRange Range to compare with.
       * @returns {Boolean} True if ranges equal.
       */
    		value: function isEqual(otherRange) {
    			return this == otherRange || this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);
    		}

    		/**
       * Checks and returns whether this range intersects with given range.
       *
       * @param {engine.view.Range} otherRange Range to compare with.
       * @returns {Boolean} True if ranges intersect.
       */

    	}, {
    		key: 'isIntersecting',
    		value: function isIntersecting(otherRange) {
    			return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);
    		}

    		/**
       * Creates a range from given parents and offsets.
       *
       * @param {engine.view.Element} startElement Start position parent element.
       * @param {Number} startOffset Start position offset.
       * @param {engine.view.Element} endElement End position parent element.
       * @param {Number} endOffset End position offset.
       * @returns {engine.view.Range} Created range.
       */

    	}, {
    		key: 'isCollapsed',
    		get: function get() {
    			return this.start.isEqual(this.end);
    		}
    	}], [{
    		key: 'createFromParentsAndOffsets',
    		value: function createFromParentsAndOffsets(startElement, startOffset, endElement, endOffset) {
    			return new this(new Position$1(startElement, startOffset), new Position$1(endElement, endOffset));
    		}

    		/**
       * Creates and returns a new instance of Range which is equal to passed range.
       *
       * @param {engine.view.Range} range Range to clone.
       * @returns {engine.view.Range}
       */

    	}, {
    		key: 'createFromRange',
    		value: function createFromRange(range) {
    			return new this(range.start, range.end);
    		}
    	}]);
    	return Range;
    }();

    /**
     * Maps elements and positions between {@link engine.view.Document view} and {@link engine.model model}.
     *
     * Mapper use binded elements to find corresponding elements and positions, so, to get proper results,
     * all Tree Model elements should be {@link engine.conversion.Mapper#bindElements binded}.
     *
     * @memberOf engine.conversion
     */

    var Mapper = function () {
    	/**
      * Creates an instance of the mapper.
      */

    	function Mapper() {
    		classCallCheck(this, Mapper);

    		/**
       * Model element to View element mapping.
       *
       * @private
       * @member {WeakMap} engine.conversion.Mapper#_modelToViewMapping
       */
    		this._modelToViewMapping = new WeakMap();

    		/**
       * View element to Model element mapping.
       *
       * @private
       * @member {WeakMap} engine.conversion.Mapper#_viewToModelMapping
       */
    		this._viewToModelMapping = new WeakMap();
    	}

    	/**
      * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using
      * the {@link engine.conversion.Mapper#toModelElement toModelElement} and
      * {@link engine.conversion.Mapper#toViewElement toViewElement} methods.
      * The information that elements are bound is also used to translate positions.
      *
      * @param {engine.model.Element} modelElement Model element.
      * @param {engine.view.Element} viewElement View element.
      */


    	createClass(Mapper, [{
    		key: 'bindElements',
    		value: function bindElements(modelElement, viewElement) {
    			this._modelToViewMapping.set(modelElement, viewElement);
    			this._viewToModelMapping.set(viewElement, modelElement);
    		}

    		/**
       * Removes all model to view and view to model bindings.
       */

    	}, {
    		key: 'clearBindings',
    		value: function clearBindings() {
    			this._modelToViewMapping = new WeakMap();
    			this._viewToModelMapping = new WeakMap();
    		}

    		/**
       * Gets the corresponding model element.
       *
       * @param {engine.view.Element} viewElement View element.
       * @returns {engine.model.Element|null} Corresponding model element or `null` if not found.
       */

    	}, {
    		key: 'toModelElement',
    		value: function toModelElement(viewElement) {
    			return this._viewToModelMapping.get(viewElement);
    		}

    		/**
       * Gets the corresponding view element.
       *
       * @param {engine.model.Element} modelElement Model element.
       * @returns {engine.view.Element|null} Corresponding view element or `null` if not found.
       */

    	}, {
    		key: 'toViewElement',
    		value: function toViewElement(modelElement) {
    			return this._modelToViewMapping.get(modelElement);
    		}

    		/**
       * Gets the corresponding model range.
       *
       * @param {engine.view.Range} viewRange View range.
       * @returns {engine.model.Range} Corresponding model range.
       */

    	}, {
    		key: 'toModelRange',
    		value: function toModelRange(viewRange) {
    			return new Range$1(this.toModelPosition(viewRange.start), this.toModelPosition(viewRange.end));
    		}

    		/**
       * Gets the corresponding view range.
       *
       * @param {engine.model.Range} modelRange Model range.
       * @returns {engine.view.Range} Corresponding view range.
       */

    	}, {
    		key: 'toViewRange',
    		value: function toViewRange(modelRange) {
    			return new Range$2(this.toViewPosition(modelRange.start), this.toViewPosition(modelRange.end));
    		}

    		/**
       * Gets the corresponding model position.
       *
       * @param {engine.view.Position} viewPosition View position.
       * @returns {engine.model.Position} Corresponding model position.
       */

    	}, {
    		key: 'toModelPosition',
    		value: function toModelPosition(viewPosition) {
    			var viewBlock = viewPosition.parent;
    			var modelParent = this._viewToModelMapping.get(viewBlock);

    			while (!modelParent) {
    				viewBlock = viewBlock.parent;
    				modelParent = this._viewToModelMapping.get(viewBlock);
    			}

    			var modelOffset = this._toModelOffset(viewPosition.parent, viewPosition.offset, viewBlock);

    			return Position.createFromParentAndOffset(modelParent, modelOffset);
    		}

    		/**
       * Gets the corresponding view position.
       *
       * @param {engine.model.Position} modelPosition Model position.
       * @returns {engine.view.Position} Corresponding view position.
       */

    	}, {
    		key: 'toViewPosition',
    		value: function toViewPosition(modelPosition) {
    			var viewContainer = this._modelToViewMapping.get(modelPosition.parent);

    			return this._findPositionIn(viewContainer, modelPosition.offset);
    		}

    		/**
       * Calculates model offset based on the view position and the block element.
       *
       * Example:
       *
       *		<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5
       *
       * Is a sum of:
       *
       *		<p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3
       *		<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2
       *
       * @private
       * @param {engine.view.Element} viewParent Position parent.
       * @param {Number} viewOffset Position offset.
       * @param {engine.view.Element} viewBlock Block used as a base to calculate offset.
       * @returns {Number} Offset in the model.
       */

    	}, {
    		key: '_toModelOffset',
    		value: function _toModelOffset(viewParent, viewOffset, viewBlock) {
    			if (viewBlock != viewParent) {
    				// See example.
    				var offsetToParentBegging = this._toModelOffset(viewParent.parent, viewParent.getIndex(), viewBlock);
    				var offsetInParent = this._toModelOffset(viewParent, viewOffset, viewParent);

    				return offsetToParentBegging + offsetInParent;
    			}

    			// viewBlock == viewParent, so we need to calculate the offset in the parent element.

    			// If the position is a text it is simple ("ba|r" -> 2).
    			if (viewParent instanceof Text$2) {
    				return viewOffset;
    			}

    			// If the position is in an element we need to sum lengths of siblings ( <b> bar </b> foo | -> 3 + 3 = 6 ).
    			var modelOffset = 0;

    			for (var i = 0; i < viewOffset; i++) {
    				modelOffset += this._getModelLength(viewParent.getChild(i));
    			}

    			return modelOffset;
    		}

    		/**
       * Gets the length of the view element in the model.
       *
       * Examples:
       *
       *		foo          -> 3 // Length of the text is the length of data.
       *		<b>foo</b>   -> 3 // Length the element which has no corresponding model element is a length of its children.
       *		<p>foo</p>   -> 1 // Length the element which has corresponding model element is always 1.
       *
       * @private
       * @param {engine.view.Element} viewNode View node.
       * @returns {Number} Length of the node in the tree model.
       */

    	}, {
    		key: '_getModelLength',
    		value: function _getModelLength(viewNode) {
    			// If we need mapping to be more flexible this method may fire event, so every feature may define the relation
    			// between length in the model to the length in the view, for example if one element in the model creates two
    			// elements in the view. Now I can not find any example where such feature would be useful.
    			if (this._viewToModelMapping.has(viewNode)) {
    				return 1;
    			} else if (viewNode instanceof Text$2) {
    				return viewNode.data.length;
    			} else {
    				var len = 0;

    				var _iteratorNormalCompletion = true;
    				var _didIteratorError = false;
    				var _iteratorError = undefined;

    				try {
    					for (var _iterator = viewNode.getChildren()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    						var child = _step.value;

    						len += this._getModelLength(child);
    					}
    				} catch (err) {
    					_didIteratorError = true;
    					_iteratorError = err;
    				} finally {
    					try {
    						if (!_iteratorNormalCompletion && _iterator.return) {
    							_iterator.return();
    						}
    					} finally {
    						if (_didIteratorError) {
    							throw _iteratorError;
    						}
    					}
    				}

    				return len;
    			}
    		}

    		/**
       * Finds the position in the view node (or its children) with the expected model offset.
       *
       * Example:
       *
       *		<p>fo<b>bar</b>bom</p> -> expected offset: 4
       *
       *		_findPositionIn( p, 4 ):
       *		<p>|fo<b>bar</b>bom</p> -> expected offset: 4, actual offset: 0
       *		<p>fo|<b>bar</b>bom</p> -> expected offset: 4, actual offset: 2
       *		<p>fo<b>bar</b>|bom</p> -> expected offset: 4, actual offset: 5 -> we are too far
       *
       *		_findPositionIn( b, 4 - ( 5 - 3 ) ):
       *		<p>fo<b>|bar</b>bom</p> -> expected offset: 2, actual offset: 0
       *		<p>fo<b>bar|</b>bom</p> -> expected offset: 2, actual offset: 3 -> we are too far
       *
       *		_findPositionIn( bar, 2 - ( 3 - 3 ) ):
       *		We are in the text node so we can simple find the offset.
       *		<p>fo<b>ba|r</b>bom</p> -> expected offset: 2, actual offset: 2 -> position found
       *
       * @private
       * @param {engine.view.Element} viewParent Tree view element in which we are looking for the position.
       * @param {Number} expectedOffset Expected offset.
       * @returns {engine.view.Position} Found position.
       */

    	}, {
    		key: '_findPositionIn',
    		value: function _findPositionIn(viewParent, expectedOffset) {
    			// Last scanned view node.
    			var viewNode = void 0;
    			// Length of the last scanned view node.
    			var lastLength = 0;

    			var modelOffset = 0;
    			var viewOffset = 0;

    			// In the text node it is simple: offset in the model equals offset in the text.
    			if (viewParent instanceof Text$2) {
    				return new Position$1(viewParent, expectedOffset);
    			}

    			// In other cases we add lengths of child nodes to find the proper offset.

    			// If it is smaller we add the length.
    			while (modelOffset < expectedOffset) {
    				viewNode = viewParent.getChild(viewOffset);
    				lastLength = this._getModelLength(viewNode);
    				modelOffset += lastLength;
    				viewOffset++;
    			}

    			// If it equals we found the position.
    			if (modelOffset == expectedOffset) {
    				return this._moveViewPositionToTextNode(new Position$1(viewParent, viewOffset));
    			}
    			// If it is higher we need to enter last child.
    			else {
    					// ( modelOffset - lastLength ) is the offset to the child we enter,
    					// so we subtract it from the expected offset to fine the offset in the child.
    					return this._findPositionIn(viewNode, expectedOffset - (modelOffset - lastLength));
    				}
    		}

    		/**
       * Because we prefer positions in text nodes over positions next to text node moves view position to the text node
       * if it was next to it.
       *
       *		<p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text
       *		<p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node
       *		<p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node
       *
       * @private
       * @param {engine.view.Position} viewPosition Position potentially next to text node.
       * @returns {engine.view.Position} Position in text node if possible.
       */

    	}, {
    		key: '_moveViewPositionToTextNode',
    		value: function _moveViewPositionToTextNode(viewPosition) {
    			// If the position is just after text node, put it at the end of that text node.
    			// If the position is just before text node, put it at the beginning of that text node.
    			var nodeBefore = viewPosition.nodeBefore;
    			var nodeAfter = viewPosition.nodeAfter;

    			if (nodeBefore instanceof Text$2) {
    				return new Position$1(nodeBefore, nodeBefore.data.length);
    			} else if (nodeAfter instanceof Text$2) {
    				return new Position$1(nodeAfter, 0);
    			}

    			// Otherwise, just return the given position.
    			return viewPosition;
    		}
    	}]);
    	return Mapper;
    }();

    /**
     * Manages a list of consumable values for {@link engine.model.Item model items}.
     *
     * Consumables are various aspects of the model. A model item can be broken down into singular properties that might be
     * taken into consideration when converting that item.
     *
     * `ModelConsumable` is used by {@link engine.conversion.ModelConversionDispatcher} while analyzing changed
     * parts of {@link engine.model.Document the document}. The added / changed / removed model items are broken down
     * into singular properties (the item itself and it's attributes). All those parts are saved in `ModelConsumable`. Then,
     * during conversion, when given part of model item is converted (i.e. the view element has been inserted into the view,
     * but without attributes), consumable value is removed from `ModelConsumable`.
     *
     * For model items, `ModelConsumable` stores consumable values of one of following types: `insert`, `addAttribute:<attributeKey>`,
     * `changeAttribute:<attributeKey>`, `removeAttribute:<attributeKey>`.
     *
     * In most cases, it is enough to let {@link engine.conversion.ModelConversionDispatcher} gather consumable values, so
     * there is no need to use {@link engine.conversion.ModelConsumable#add add method} directly. However, it is important to
     * understand how consumable values can be {@link engine.conversion.ModelConsumable#consume consumed}. See
     * {@link engine.conversion.modelToView default model to view converters} for more information.
     *
     * Keep in mind, that one conversion event may have multiple callbacks (converters) attached to it. Each of those is
     * able to convert one or more parts of the model. However, when one of those callbacks actually converts
     * something, other should not, because they would duplicate the results. Using `ModelConsumable` helps avoiding
     * this situation, because callbacks should only convert those values, which were not yet consumed from `ModelConsumable`.
     *
     * Consuming multiple values in a single callback:
     *
     *		// Converter for custom `image` element that might have a `caption` element inside which changes
     *		// how the image is displayed in the view:
     *		//
     *		// Model:
     *		//
     *		// [image]
     *		//   └─ [caption]
     *		//       ├─ f
     *		//       ├─ o
     *		//       └─ o
     *		//
     *		// View:
     *		//
     *		// <figure>
     *		//   ├─ <img />
     *		//   └─ <caption>
     *		//       └─ foo
     *		modelConversionDispatcher.on( 'insert:image', ( evt, data, consumable, conversionApi ) => {
     *			// First, consume the `image` element.
     *			consumable.consume( data.item, 'insert' );
     *
     *			// Just create normal image element for the view.
     *			// Maybe it will be "decorated" later.
     *			const viewImage = new ViewElement( 'img' );
     *			const insertPosition = conversionApi.mapper.toViewPosition( data.range.start );
     *
     *			// Check if the `image` element has children.
     *			if ( data.item.getChildCount() > 0 ) {
     *				const modelCaption = data.item.getChild( 0 );
     *
     *				// `modelCaption` insertion change is consumed from consumable values.
     *				// It will not be converted by other converters, but it's children (probably some text) will be.
     *				// Through mapping, converters for text will know where to insert contents of `modelCaption`.
     *				if ( consumable.consume( modelCaption, 'insert' ) ) {
     *					const viewCaption = new ViewElement( 'figcaption' );
     *
     *					const viewImageHolder = new ViewElement( 'figure', null, [ viewImage, viewCaption ] );
     *
     *					conversionApi.mapper.bindElements( modelCaption, viewCaption );
     *					conversionApi.mapper.bindElements( data.item, viewImageHolder );
     *					conversionApi.writer.insert( insertPosition, viewImageHolder );
     *				}
     *			} else {
     *				conversionApi.mapper.bindElements( data.item, viewImage );
     *				conversionApi.writer.insert( insertPosition, viewImage );
     *			}
     *
     *			evt.stop();
     *		} );
     *
     * @memberOf engine.conversion
     */

    var ModelConsumable = function () {
    	/**
      * Creates an empty consumables list.
      */

    	function ModelConsumable() {
    		classCallCheck(this, ModelConsumable);

    		/**
       * Contains list of consumable values.
       *
       * @private
       * @member {Map} engine.conversion.ModelConsumable#_consumable
       */
    		this._consumable = new Map();

    		/**
       * For each {@link engine.model.TextProxy} added to `ModelConsumable`, this registry holds parent
       * of that `TextProxy` and start and end indices of that `TextProxy`. This allows identification of `TextProxy`
       * instances that points to the same part of the model but are different instances. Each distinct `TextProxy`
       * is given unique `Symbol` which is then registered as consumable. This process is transparent for `ModelConsumable`
       * API user because whenever `TextProxy` is added, tested, consumed or reverted, internal mechanisms of
       * `ModelConsumable` translates `TextProxy` to that unique `Symbol`.
       *
       * @private
       * @member {Map} engine.conversion.ModelConsumable#_textProxyRegistry
       */
    		this._textProxyRegistry = new Map();
    	}

    	/**
      * Adds a consumable value to the consumables list and links it with given model item.
      *
      *		modelConsumable.add( modelElement, 'insert' ); // Add `modelElement` insertion change to consumable values.
      *		modelConsumable.add( modelElement, 'addAttribute:bold' ); // Add `bold` attribute insertion on `modelElement` change.
      *		modelConsumable.add( modelElement, 'removeAttribute:bold' ); // Add `bold` attribute removal on `modelElement` change.
      *		modelConsumable.add( modelSelection, 'selection' ); // Add `modelSelection` to consumable values.
      *		modelConsumable.add( modelSelection, 'selectionAttribute:bold' ); // Add `bold` attribute on `modelSelection` to consumables.
      *
      * @param {engine.model.Item|engine.model.Selection} item Model item or selection that has the consumable.
      * @param {String} type Consumable type.
      */


    	createClass(ModelConsumable, [{
    		key: 'add',
    		value: function add(item, type) {
    			if (item instanceof TextProxy) {
    				item = this._getSymbolForTextProxy(item);
    			}

    			if (!this._consumable.has(item)) {
    				this._consumable.set(item, new Map());
    			}

    			this._consumable.get(item).set(type, true);
    		}

    		/**
       * Removes given consumable value from given model item.
       *
       *		modelConsumable.consume( modelElement, 'insert' ); // Remove `modelElement` insertion change from consumable values.
       *		modelConsumable.consume( modelElement, 'addAttribute:bold' ); // Remove `bold` attribute insertion on `modelElement` change.
       *		modelConsumable.consume( modelElement, 'removeAttribute:bold' ); // Remove `bold` attribute removal on `modelElement` change.
       *		modelConsumable.consume( modelSelection, 'selection' ); // Remove `modelSelection` from consumable values.
       *		modelConsumable.consume( modelSelection, 'selectionAttribute:bold' ); // Remove `bold` on `modelSelection` from consumables.
       *
       * @param {engine.model.Item|engine.model.Selection} item Model item or selection from which consumable will be consumed.
       * @param {String} type Consumable type.
       * @returns {Boolean} `true` if consumable value was available and was consumed, `false` otherwise.
       */

    	}, {
    		key: 'consume',
    		value: function consume(item, type) {
    			if (item instanceof TextProxy) {
    				item = this._getSymbolForTextProxy(item);
    			}

    			if (this.test(item, type)) {
    				this._consumable.get(item).set(type, false);

    				return true;
    			} else {
    				return false;
    			}
    		}

    		/**
       * Tests whether there is a consumable value of given type connected with given model item.
       *
       *		modelConsumable.test( modelElement, 'insert' ); // Check for `modelElement` insertion change.
       *		modelConsumable.test( modelElement, 'addAttribute:bold' ); // Check for `bold` attribute insertion on `modelElement` change.
       *		modelConsumable.test( modelElement, 'removeAttribute:bold' ); // Check for `bold` attribute removal on `modelElement` change.
       *		modelConsumable.test( modelSelection, 'selection' ); // Check if `modelSelection` is consumable.
       *		modelConsumable.test( modelSelection, 'selectionAttribute:bold' ); // Check if `bold` on `modelSelection` is consumable.
       *
       * @param {engine.model.Item|engine.model.Selection} item Model item or selection that will be tested.
       * @param {String} type Consumable type.
       * @returns {null|Boolean} `null` if such consumable was never added, `false` if the consumable values was
       * already consumed or `true` if it was added and not consumed yet.
       */

    	}, {
    		key: 'test',
    		value: function test(item, type) {
    			if (item instanceof TextProxy) {
    				item = this._getSymbolForTextProxy(item);
    			}

    			var itemConsumables = this._consumable.get(item);

    			if (itemConsumables === undefined) {
    				return null;
    			}

    			var value = itemConsumables.get(type);

    			if (value === undefined) {
    				return null;
    			}

    			return value;
    		}

    		/**
       * Reverts consuming of consumable value.
       *
       *		modelConsumable.revert( modelElement, 'insert' ); // Revert consuming `modelElement` insertion change.
       *		modelConsumable.revert( modelElement, 'addAttribute:bold' ); // Revert consuming `bold` attribute insert from `modelElement`.
       *		modelConsumable.revert( modelElement, 'removeAttribute:bold' ); // Revert consuming `bold` attribute remove from `modelElement`.
       *		modelConsumable.revert( modelSelection, 'selection' ); // Revert consuming `modelSelection`.
       *		modelConsumable.revert( modelSelection, 'selectionAttribute:bold' ); // Revert consuming `bold` from `modelSelection`.
       *
       * @param {engine.model.Item|engine.model.Selection} item Model item or selection that will be reverted.
       * @param {String} type Consumable type.
       * @returns {null|Boolean} `true` if consumable has been reversed, `false` otherwise. `null` if the consumable has
       * never been added.
       */

    	}, {
    		key: 'revert',
    		value: function revert(item, type) {
    			if (item instanceof TextProxy) {
    				item = this._getSymbolForTextProxy(item);
    			}

    			var test = this.test(item, type);

    			if (test === false) {
    				this._consumable.get(item).set(type, true);

    				return true;
    			} else if (test === true) {
    				return false;
    			}

    			return null;
    		}

    		/**
       * Gets a unique symbol for passed {@link engine.model.TextProxy} instance. All `TextProxy` instances that
       * have same parent, same start index and same end index will get the same symbol.
       *
       * Used internally to correctly consume `TextProxy` instances.
       *
       * @private
       * @param {engine.model.TextProxy} textProxy `TextProxy` instance to get a symbol for.
       * @returns {Symbol} Symbol representing all equal instances of `TextProxy`.
       */

    	}, {
    		key: '_getSymbolForTextProxy',
    		value: function _getSymbolForTextProxy(textProxy) {
    			var symbol = null;

    			var startIndex = textProxy.first.getIndex();
    			var endIndex = startIndex + textProxy.text.length;
    			var parent = textProxy.commonParent;

    			var startIndexMap = this._textProxyRegistry.get(startIndex);

    			if (startIndexMap) {
    				var endIndexMap = startIndexMap.get(endIndex);

    				if (endIndexMap) {
    					symbol = endIndexMap.get(parent);
    				}
    			}

    			if (!symbol) {
    				symbol = this._addSymbolForTextProxy(startIndex, endIndex, parent);
    			}

    			return symbol;
    		}

    		/**
       * Adds a symbol for given properties that characterizes a {@link engine.model.TextProxy} instance.
       *
       * Used internally to correctly consume `TextProxy` instances.
       *
       * @private
       * @param {Number} startIndex Text proxy start index in it's parent.
       * @param {Number} endIndex Text proxy end index in it's parent.
       * @param {engine.model.Element} parent Text proxy parent.
       * @returns {Symbol} Symbol generated for given properties.
       */

    	}, {
    		key: '_addSymbolForTextProxy',
    		value: function _addSymbolForTextProxy(startIndex, endIndex, parent) {
    			var symbol = Symbol();
    			var startIndexMap = void 0,
    			    endIndexMap = void 0;

    			startIndexMap = this._textProxyRegistry.get(startIndex);

    			if (!startIndexMap) {
    				startIndexMap = new Map();
    				this._textProxyRegistry.set(startIndex, startIndexMap);
    			}

    			endIndexMap = startIndexMap.get(endIndex);

    			if (!endIndexMap) {
    				endIndexMap = new Map();
    				startIndexMap.set(endIndex, endIndexMap);
    			}

    			endIndexMap.set(parent, symbol);

    			return symbol;
    		}
    	}]);
    	return ModelConsumable;
    }();

    /**
     * `ModelConversionDispatcher` is a central point of {@link engine.model model} conversion, which is
     * a process of reacting to changes in the model and reflecting them by listeners that listen to those changes.
     * In default application, {@link engine.model model} is converted to {@link engine.view view}. This means
     * that changes in the model are reflected by changing the view (i.e. adding view nodes or changing attributes on view elements).
     *
     * During conversion process, `ModelConversionDispatcher` fires data-manipulation events, basing on state of the model and prepares
     * data for those events. It is important to note that the events are connected with "change actions" like "inserting"
     * or "removing" so one might say that we are converting "changes". This is in contrary to view to model conversion,
     * where we convert view nodes (the structure, not "changes" to the view). Note, that because changes are converted
     * and not the structure itself, there is a need to have a mapping between model and the structure on which changes are
     * reflected. To map elements during model to view conversion use {@link engine.conversion.Mapper}.
     *
     * The main use for this class is to listen to {@link engine.model.Document.change Document change event}, process it
     * and then fire specific events telling what exactly has changed. For those events, `ModelConversionDispatcher`
     * creates {@link engine.conversion.ModelConsumable list of consumable values} that should be handled by event
     * callbacks. Those events are listened to by model-to-view converters which convert changes done in the
     * {@link engine.model model} to changes in the {@link engine.view view}. `ModelConversionController` also checks
     * the current state of consumables, so it won't fire events for parts of model that were already consumed. This is
     * especially important in callbacks that consume multiple values. See {@link engine.conversion.ModelConsumable}
     * for an example of such callback.
     *
     * Although the primary usage for this class is the model-to-view conversion, `ModelConversionDispatcher` can be used
     * to build custom data processing pipelines that converts model to anything that is needed. Existing model structure can
     * be used to generate events (listening to {@link engine.model.Document.change Document change event} is not required)
     * and custom callbacks can be added to the events (these does not have to be limited to changes in the view).
     *
     * When providing your own event listeners for `ModelConversionDispatcher` keep in mind that any callback that had
     * {@link engine.conversion.ModelConsumable#consume consumed} a value from consumable (and did some changes, i.e. to
     * the view) should also stop the event. This is because whenever a callback is fired it is assumed that there is something
     * to be consumed. Thanks to that approach, you do not have to test whether there is anything to consume at the beginning
     * of your listener callback.
     *
     * Example of providing a converter for `ModelConversionDispatcher`:
     *
     *		// We will convert inserting "paragraph" model element into the model.
     *		modelDispatcher.on( 'insert:paragraph', ( evt, data, consumable, conversionApi ) => {
     *			// Remember to consume the part of consumable.
     *			consumable.consume( data.item, 'insert' );
     *
     *			// Translate position in model to position in the view.
     *			const viewPosition = conversionApi.mapper.toViewPosition( data.range.start );
     *
     *			// Create a P element (note that this converter is for inserting P elements -> 'insert:paragraph').
     *			const viewElement = new ViewElement( 'p' );
     *
     *			// Bind the newly created view element to model element so positions will map accordingly in future.
     *			conversionApi.mapper.bindElements( data.item, viewNode );
     *
     *			// Add the newly created view element to the view.
     *			conversionApi.writer.insert( viewPosition, viewElement );
     *
     *			// Remember to stop the event propagation if the data.item was consumed.
     *			evt.stop();
     *		} );
     *
     * Callback that "overrides" other callback:
     *
     *		// Special converter for `linkHref` attribute added on custom `quote` element. Note, that this
     *		// attribute may be the same as the attribute added by other features (link feature in this case).
     *		// It might be even added by that feature! It makes sense that a part of content that is a quote is linked
     *		// to an external source so it makes sense that link feature works on the custom quote element.
     *		// However, we have to make sure that the attributes added by link feature are correctly converted.
     *		// To block default `linkHref` conversion we have to:
     *		// 1) add this callback with higher priority than link feature callback,
     *		// 2) consume `linkHref` attribute add change.
     *		modelConversionDispatcher.on( 'addAttribute:linkHref:quote', ( evt, data, consumable, conversionApi ) => {
     *			consumable.consume( data.item, 'addAttribute:linkHref' );
     *
     *			// Create a button that will represent the `linkHref` attribute.
     *			let viewSourceBtn = new ViewElement( 'a', {
     *				href: data.item.getAttribute( 'linkHref' ),
     *				title: 'source'
     *			} );
     *
     *			// Add a class for the button.
     *			viewSourceBtn.addClass( 'source' );
     *
     *			// Insert the button using writer API.
     *			// If `addAttribute` event is fired by `engine.conversion.ModelConversionDispatcher#convertInsert` it is fired
     *			// after `data.item` insert conversion was done. If the event is fired due to attribute insertion coming from
     *			// different source, `data.item` already existed. This means we are safe to get `viewQuote` from mapper.
     *			const viewQuote = conversionApi.mapper.toViewElement( data.item );
     *			const position = new ViewPosition( viewQuote, viewQuote.getChildCount() );
     *			conversionApi.writer.insert( position, viewSourceBtn );
     *
     *			evt.stop();
     *		}, 1 );
     *
     * @memberOf engine.conversion
     */

    var ModelConversionDispatcher = function () {
    	/**
      * Creates a `ModelConversionDispatcher` that operates using passed API.
      *
      * @param {Object} [conversionApi] Interface passed by dispatcher to the events callbacks.
      */

    	function ModelConversionDispatcher() {
    		var conversionApi = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    		classCallCheck(this, ModelConversionDispatcher);

    		/**
       * Interface passed by dispatcher to the events callbacks.
       *
       * @member {Object} engine.conversion.ModelConversionDispatcher#conversionApi
       */
    		this.conversionApi = assignIn({}, conversionApi);
    	}

    	/**
      * Prepares data and fires a proper event.
      *
      * The method is crafted to take use of parameters passed in {@link engine.model.Document.change Document change event}.
      *
      * @see engine.model.Document.change
      * @fires engine.conversion.ModelConversionDispatcher#insert
      * @fires engine.conversion.ModelConversionDispatcher#move
      * @fires engine.conversion.ModelConversionDispatcher#remove
      * @fires engine.conversion.ModelConversionDispatcher#addAttribute
      * @fires engine.conversion.ModelConversionDispatcher#removeAttribute
      * @fires engine.conversion.ModelConversionDispatcher#changeAttribute
      * @param {String} type Change type.
      * @param {Object} data Additional information about the change.
      */


    	createClass(ModelConversionDispatcher, [{
    		key: 'convertChange',
    		value: function convertChange(type, data) {
    			// Do not convert changes if they happen in graveyard.
    			// Graveyard is a special root that has no view / no other representation and changes done in it should not be converted.
    			if (type !== 'remove' && data.range && data.range.root.rootName == '$graveyard') {
    				return;
    			}

    			if (type == 'insert' || type == 'reinsert') {
    				this.convertInsert(data.range);
    			} else if (type == 'move') {
    				this.convertMove(data.sourcePosition, data.range);
    			} else if (type == 'remove') {
    				this.convertRemove(data.sourcePosition, data.range);
    			} else if (type == 'addAttribute' || type == 'removeAttribute' || type == 'changeAttribute') {
    				this.convertAttribute(type, data.range, data.key, data.oldValue, data.newValue);
    			}
    		}

    		/**
       * Analyzes given range and fires insertion-connected events with data based on that range.
       *
       * **Note**: This method will fire separate events for node insertion and attributes insertion. All
       * attributes that are set on inserted nodes are treated like they were added just after node insertion.
       *
       * @fires engine.conversion.ModelConversionDispatcher#insert
       * @fires engine.conversion.ModelConversionDispatcher#addAttribute
       * @param {engine.model.Range} range Inserted range.
       */

    	}, {
    		key: 'convertInsert',
    		value: function convertInsert(range) {
    			// Create a list of things that can be consumed, consisting of nodes and their attributes.
    			var consumable = this._createInsertConsumable(range);

    			// Fire a separate insert event for each node and text fragment contained in the range.
    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = range[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var value = _step.value;

    					var item = value.item;
    					var itemRange = Range$1.createFromPositionAndShift(value.previousPosition, value.length);
    					var data = {
    						item: item,
    						range: itemRange
    					};

    					this._testAndFire('insert', data, consumable);

    					// Fire a separate addAttribute event for each attribute that was set on inserted items.
    					// This is important because most attributes converters will listen only to add/change/removeAttribute events.
    					// If we would not add this part, attributes on inserted nodes would not be converted.
    					var _iteratorNormalCompletion2 = true;
    					var _didIteratorError2 = false;
    					var _iteratorError2 = undefined;

    					try {
    						for (var _iterator2 = item.getAttributes()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    							var attr = _step2.value;

    							data.attributeKey = attr[0];
    							data.attributeOldValue = null;
    							data.attributeNewValue = attr[1];

    							this._testAndFire('addAttribute:' + attr[0], data, consumable);
    						}
    					} catch (err) {
    						_didIteratorError2 = true;
    						_iteratorError2 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion2 && _iterator2.return) {
    								_iterator2.return();
    							}
    						} finally {
    							if (_didIteratorError2) {
    								throw _iteratorError2;
    							}
    						}
    					}
    				}
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}
    		}

    		/**
       * Fires move event with data based on passed values.
       *
       * @fires engine.conversion.ModelConversionDispatcher#move
       * @param {engine.model.Position} sourcePosition Position from where the range has been moved.
       * @param {engine.model.Range} range Moved range (after move).
       */

    	}, {
    		key: 'convertMove',
    		value: function convertMove(sourcePosition, range) {
    			var data = {
    				sourcePosition: sourcePosition,
    				range: range
    			};

    			this.fire('move', data, this.conversionApi);
    		}

    		/**
       * Fires remove event with data based on passed values.
       *
       * @fires engine.conversion.ModelConversionDispatcher#remove
       * @param {engine.model.Position} sourcePosition Position from where the range has been removed.
       * @param {engine.model.Range} range Removed range (after remove, in {@link engine.model.Document#graveyard graveyard root}).
       */

    	}, {
    		key: 'convertRemove',
    		value: function convertRemove(sourcePosition, range) {
    			var data = {
    				sourcePosition: sourcePosition,
    				range: range
    			};

    			this.fire('remove', data, this.conversionApi);
    		}

    		/**
       * Analyzes given attribute change and fires attributes-connected events with data based on passed values.
       *
       * @fires engine.conversion.ModelConversionDispatcher#addAttribute
       * @fires engine.conversion.ModelConversionDispatcher#removeAttribute
       * @fires engine.conversion.ModelConversionDispatcher#changeAttribute
       * @param {String} type Change type. Possible values: `addAttribute`, `removeAttribute`, `changeAttribute`.
       * @param {engine.model.Range} range Changed range.
       * @param {String} key Attribute key.
       * @param {*} oldValue Attribute value before the change or `null` if attribute has not been set.
       * @param {*} newValue New attribute value or `null` if attribute has been removed.
       */

    	}, {
    		key: 'convertAttribute',
    		value: function convertAttribute(type, range, key, oldValue, newValue) {
    			// Create a list with attributes to consume.
    			var consumable = this._createAttributeConsumable(type, range, key);

    			// Create a separate attribute event for each node in the range.
    			var _iteratorNormalCompletion3 = true;
    			var _didIteratorError3 = false;
    			var _iteratorError3 = undefined;

    			try {
    				for (var _iterator3 = range[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
    					var value = _step3.value;

    					var item = value.item;
    					var itemRange = Range$1.createFromPositionAndShift(value.previousPosition, value.length);
    					var data = {
    						item: item,
    						range: itemRange,
    						attributeKey: key,
    						attributeOldValue: oldValue,
    						attributeNewValue: newValue
    					};

    					this._testAndFire(type + ':' + key, data, consumable, this.conversionApi);
    				}
    			} catch (err) {
    				_didIteratorError3 = true;
    				_iteratorError3 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion3 && _iterator3.return) {
    						_iterator3.return();
    					}
    				} finally {
    					if (_didIteratorError3) {
    						throw _iteratorError3;
    					}
    				}
    			}
    		}

    		/**
       * Fires events for given {@link engine.model.Selection selection} to start selection conversion.
       *
       * @fires engine.conversion.ModelConversionDispatcher#selection
       * @fires engine.conversion.ModelConversionDispatcher#selectionAttribute
       * @param {engine.model.Selection} selection Selection to convert.
       */

    	}, {
    		key: 'convertSelection',
    		value: function convertSelection(selection) {
    			var consumable = this._createSelectionConsumable(selection);
    			var data = {
    				selection: selection
    			};

    			this.fire('selection', data, consumable, this.conversionApi);

    			var _iteratorNormalCompletion4 = true;
    			var _didIteratorError4 = false;
    			var _iteratorError4 = undefined;

    			try {
    				for (var _iterator4 = selection.getAttributes()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
    					var attr = _step4.value;

    					data.key = attr[0];
    					data.value = attr[1];

    					// Do not fire event if the attribute has been consumed.
    					if (consumable.test(selection, 'selectionAttribute:' + data.key)) {
    						this.fire('selectionAttribute:' + data.key, data, consumable, this.conversionApi);
    					}
    				}
    			} catch (err) {
    				_didIteratorError4 = true;
    				_iteratorError4 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion4 && _iterator4.return) {
    						_iterator4.return();
    					}
    				} finally {
    					if (_didIteratorError4) {
    						throw _iteratorError4;
    					}
    				}
    			}
    		}

    		/**
       * Creates {@link engine.conversion.ModelConsumable} with values to consume from given range, assuming that
       * given range has just been inserted to the model.
       *
       * @private
       * @param {engine.model.Range} range Inserted range.
       * @returns {engine.conversion.ModelConsumable} Values to consume.
       */

    	}, {
    		key: '_createInsertConsumable',
    		value: function _createInsertConsumable(range) {
    			var consumable = new ModelConsumable();

    			var _iteratorNormalCompletion5 = true;
    			var _didIteratorError5 = false;
    			var _iteratorError5 = undefined;

    			try {
    				for (var _iterator5 = range[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
    					var value = _step5.value;

    					var item = value.item;

    					consumable.add(item, 'insert');

    					var _iteratorNormalCompletion6 = true;
    					var _didIteratorError6 = false;
    					var _iteratorError6 = undefined;

    					try {
    						for (var _iterator6 = item.getAttributes()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
    							var attr = _step6.value;

    							consumable.add(item, 'addAttribute:' + attr[0]);
    						}
    					} catch (err) {
    						_didIteratorError6 = true;
    						_iteratorError6 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion6 && _iterator6.return) {
    								_iterator6.return();
    							}
    						} finally {
    							if (_didIteratorError6) {
    								throw _iteratorError6;
    							}
    						}
    					}
    				}
    			} catch (err) {
    				_didIteratorError5 = true;
    				_iteratorError5 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion5 && _iterator5.return) {
    						_iterator5.return();
    					}
    				} finally {
    					if (_didIteratorError5) {
    						throw _iteratorError5;
    					}
    				}
    			}

    			return consumable;
    		}

    		/**
       * Creates {@link engine.conversion.ModelConsumable} with values to consume from given range, assuming that
       * given range has just had it's attributes changed.
       *
       * @private
       * @param {String} type Change type. Possible values: `addAttribute`, `removeAttribute`, `changeAttribute`.
       * @param {engine.conversion.Range} range Changed range.
       * @param {String} key Attribute key.
       * @returns {engine.conversion.ModelConsumable} Values to consume.
       */

    	}, {
    		key: '_createAttributeConsumable',
    		value: function _createAttributeConsumable(type, range, key) {
    			var consumable = new ModelConsumable();

    			var _iteratorNormalCompletion7 = true;
    			var _didIteratorError7 = false;
    			var _iteratorError7 = undefined;

    			try {
    				for (var _iterator7 = range[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
    					var value = _step7.value;

    					var item = value.item;

    					consumable.add(item, type + ':' + key);
    				}
    			} catch (err) {
    				_didIteratorError7 = true;
    				_iteratorError7 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion7 && _iterator7.return) {
    						_iterator7.return();
    					}
    				} finally {
    					if (_didIteratorError7) {
    						throw _iteratorError7;
    					}
    				}
    			}

    			return consumable;
    		}

    		/**
       * Creates {@link engine.conversion.ModelConsumable} with selection consumable values.
       *
       * @private
       * @param {engine.model.Selection} selection Selection to create consumable from.
       * @returns {engine.conversion.ModelConsumable} Values to consume.
       */

    	}, {
    		key: '_createSelectionConsumable',
    		value: function _createSelectionConsumable(selection) {
    			var consumable = new ModelConsumable();

    			consumable.add(selection, 'selection');

    			var _iteratorNormalCompletion8 = true;
    			var _didIteratorError8 = false;
    			var _iteratorError8 = undefined;

    			try {
    				for (var _iterator8 = selection.getAttributes()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
    					var attr = _step8.value;

    					consumable.add(selection, 'selectionAttribute:' + attr[0]);
    				}
    			} catch (err) {
    				_didIteratorError8 = true;
    				_iteratorError8 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion8 && _iterator8.return) {
    						_iterator8.return();
    					}
    				} finally {
    					if (_didIteratorError8) {
    						throw _iteratorError8;
    					}
    				}
    			}

    			return consumable;
    		}

    		/**
       * Tests passed `consumable` to check whether given event can be fired and if so, fires it.
       *
       * @private
       * @fires engine.conversion.ModelConversionDispatcher#insert
       * @fires engine.conversion.ModelConversionDispatcher#addAttribute
       * @fires engine.conversion.ModelConversionDispatcher#removeAttribute
       * @fires engine.conversion.ModelConversionDispatcher#changeAttribute
       * @param {String} type Event type.
       * @param {Object} data Event data.
       * @param {engine.conversion.ModelConsumable} consumable Values to consume.
       */

    	}, {
    		key: '_testAndFire',
    		value: function _testAndFire(type, data, consumable) {
    			if (!consumable.test(data.item, type)) {
    				// Do not fire event if the item was consumed.
    				return;
    			}

    			if (type === 'insert') {
    				if (data.item instanceof TextProxy) {
    					// Example: insert:$text.
    					this.fire(type + ':$text', data, consumable, this.conversionApi);
    				} else {
    					// Example: insert:paragraph.
    					this.fire(type + ':' + data.item.name, data, consumable, this.conversionApi);
    				}
    			} else {
    				// Example addAttribute:alt:img.
    				// Example addAttribute:bold:$text.
    				var name = data.item.name || '$text';

    				this.fire(type + ':' + name, data, consumable, this.conversionApi);
    			}
    		}

    		/**
       * Fired for inserted nodes.
       *
       * `insert` is a namespace for a class of events. Names of actually called events follow this pattern:
       * `insert:<type>:<elementName>`. `type` is either `text` when one or more characters has been inserted or `element`
       * when {@link engine.model.Element} has been inserted. If `type` is `element`, `elementName` is added and is
       * equal to the {@link engine.model.Element#name name} of inserted element. This way listeners can either
       * listen to very general `insert` event or, i.e., very specific `insert:paragraph` event, which is fired only for
       * model elements with name `paragraph`.
       *
       * @event engine.conversion.ModelConversionDispatcher.insert
       * @param {Object} data Additional information about the change.
       * @param {engine.model.Item} data.item Inserted item.
       * @param {engine.model.Range} data.range Range spanning over inserted item.
       * @param {engine.conversion.ModelConsumable} consumable Values to consume.
       * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
       */

    		/**
       * Fired for moved nodes.
       *
       * @event engine.conversion.ModelConversionDispatcher.move
       * @param {Object} data Additional information about the change.
       * @param {engine.model.Position} data.sourcePosition Position from where the range has been moved.
       * @param {engine.model.Range} data.range Moved range (after move).
       * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
       */

    		/**
       * Fired for removed nodes.
       *
       * @event engine.conversion.ModelConversionDispatcher.remove
       * @param {Object} data Additional information about the change.
       * @param {engine.model.Position} data.sourcePosition Position from where the range has been removed.
       * @param {engine.model.Range} data.range Removed range (in {@link engine.model.Document#graveyard graveyard root}).
       * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
       */

    		/**
       * Fired when attribute has been added on a node.
       *
       * `addAttribute` is a namespace for a class of events. Names of actually called events follow this pattern:
       * `addAttribute:<attributeKey>:<elementName>`. `attributeKey` is the key of added attribute. `elementName` is
       * equal to the {@link engine.model.Element#name name} of the element which got the attribute. This way listeners
       * can either listen to adding certain attribute, i.e. `addAttribute:bold`, or be more specific, i.e. `addAttribute:link:img`.
       *
       * @event engine.conversion.ModelConversionDispatcher.addAttribute
       * @param {Object} data Additional information about the change.
       * @param {engine.model.Item} data.item Changed item.
       * @param {engine.model.Range} data.range Range spanning over changed item.
       * @param {String} data.attributeKey Attribute key.
       * @param {null} data.attributeOldValue Attribute value before the change - always `null`. Kept for the sake of unifying events.
       * @param {*} data.attributeNewValue New attribute value.
       * @param {engine.conversion.ModelConsumable} consumable Values to consume.
       * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
       */

    		/**
       * Fired when attribute has been removed from a node.
       *
       * `removeAttribute` is a namespace for a class of events. Names of actually called events follow this pattern:
       * `removeAttribute:<attributeKey>:<elementName>`. `attributeKey` is the key of removed attribute. `elementName` is
       * equal to the {@link engine.model.Element#name name} of the element which got the attribute removed. This way listeners
       * can either listen to removing certain attribute, i.e. `removeAttribute:bold`, or be more specific, i.e. `removeAttribute:link:img`.
       *
       * @event engine.conversion.ModelConversionDispatcher.removeAttribute
       * @param {Object} data Additional information about the change.
       * @param {engine.model.Item} data.item Changed item.
       * @param {engine.model.Range} data.range Range spanning over changed item.
       * @param {String} data.attributeKey Attribute key.
       * @param {*} data.attributeOldValue Attribute value before it was removed.
       * @param {null} data.attributeNewValue New attribute value - always `null`. Kept for the sake of unifying events.
       * @param {engine.conversion.ModelConsumable} consumable Values to consume.
       * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
       */

    		/**
       * Fired when attribute of a node has been changed.
       *
       * `changeAttribute` is a namespace for a class of events. Names of actually called events follow this pattern:
       * `changeAttribute:<attributeKey>:<elementName>`. `attributeKey` is the key of changed attribute. `elementName` is
       * equal to the {@link engine.model.Element#name name} of the element which got the attribute changed. This way listeners
       * can either listen to changing certain attribute, i.e. `changeAttribute:link`, or be more specific, i.e. `changeAttribute:link:img`.
       *
       * @event engine.conversion.ModelConversionDispatcher.changeAttribute
       * @param {Object} data Additional information about the change.
       * @param {engine.model.Item} data.item Changed item.
       * @param {engine.model.Range} data.range Range spanning over changed item.
       * @param {String} data.attributeKey Attribute key.
       * @param {*} data.attributeOldValue Attribute value before the change.
       * @param {*} data.attributeNewValue New attribute value.
       * @param {engine.conversion.ModelConsumable} consumable Values to consume.
       * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
       */

    		/**
       * Fired for {@link engine.model.Selection selection} changes.
       *
       * @event engine.conversion.ModelConversionDispatcher.selection
       * @param {engine.model.Selection} selection `Selection` instance that is converted.
       * @param {engine.conversion.ModelConsumable} consumable Values to consume.
       * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
       */

    		/**
       * Fired for {@link engine.model.Selection selection} attributes changes.
       *
       * `selectionAttribute` is a namespace for a class of events. Names of actually called events follow this pattern:
       * `selectionAttribute:<attributeKey>`. `attributeKey` is the key of selection attribute. This way listen can listen to
       * certain attribute, i.e. `addAttribute:bold`.
       *
       * @event engine.conversion.ModelConversionDispatcher.selectionAttribute
       * @param {Object} data Additional information about the change.
       * @param {engine.model.Selection} data.selection Selection that is converted.
       * @param {String} data.attributeKey Key of changed attribute.
       * @param {*} data.attributeValue Value of changed attribute.
       * @param {engine.conversion.ModelConsumable} consumable Values to consume.
       * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ModelConversionDispatcher` constructor.
       */

    	}]);
    	return ModelConversionDispatcher;
    }();

    mix(ModelConversionDispatcher, EmitterMixin);

    /**
     * Contains {@link engine.model model} to {@link engine.view view} converters for
     * {@link engine.conversion.ModelConversionDispatcher}.
     *
     * @namespace engine.conversion.modelToView
     */

    /**
     * Function factory, creates a converter that converts node insertion changes from the model to the view.
     * The view element that will be added to the view depends on passed parameter. If {@link engine.view.Element} was passed,
     * it will be cloned and the copy will be inserted. If `Function` is provided, it is passed all the parameters of the
     * dispatcher's {@link engine.conversion.ModelConversionDispatcher#event:insert insert event}. It's expected that the
     * function returns a {@link engine.view.Element}. The result of the function will be inserted to the view.
     *
     * The converter automatically consumes corresponding value from consumables list, stops the event (see
     * {@link engine.conversion.ModelConversionDispatcher}) and bind model and view elements.
     *
     *		modelDispatcher.on( 'insert:paragraph', insertElement( new ViewElement( 'p' ) ) );
     *
     *		modelDispatcher.on(
     *			'insert:myElem',
     *			insertElement( ( data, consumable, conversionApi ) => {
     *				let myElem = new ViewElement( 'myElem', { myAttr: true }, new ViewText( 'myText' ) );
     *
     *				// Do something fancy with myElem using data/consumable/conversionApi ...
     *
     *				return myElem;
     *			}
     *		) );
     *
     * @external engine.conversion.modelToView
     * @function engine.conversion.modelToView.insertElement
     * @param {engine.view.Element|Function} elementCreator View element, or function returning a view element, which
     * will be inserted.
     * @returns {Function} Insert element event converter.
     */
    function insertElement(elementCreator) {
      return function (evt, data, consumable, conversionApi) {
        consumable.consume(data.item, 'insert');

        var viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
        var viewElement = elementCreator instanceof Element$1 ? elementCreator.clone(true) : elementCreator(data, consumable, conversionApi);

        conversionApi.mapper.bindElements(data.item, viewElement);
        conversionApi.writer.insert(viewPosition, viewElement);

        evt.stop();
      };
    }

    /**
     * Function factory, creates a default model-to-view converter for text insertion changes.
     *
     * The converter automatically consumes corresponding value from consumables list and stops the event (see
     * {@link engine.conversion.ModelConversionDispatcher}).
     *
     *		modelDispatcher.on( 'insert:$text', insertText() );
     *
     * @external engine.conversion.modelToView
     * @function engine.conversion.modelToView.insertText
     * @returns {Function} Insert text event converter.
     */
    function insertText() {
      return function (evt, data, consumable, conversionApi) {
        consumable.consume(data.item, 'insert');

        var viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
        var viewText = new Text$2(data.item.text);

        conversionApi.writer.insert(viewPosition, viewText);

        evt.stop();
      };
    }

    /**
     * Function factory, creates a converter that converts set/change attribute changes from the model to the view. Attributes
     * from model are converted to the view element attributes in the view. You may provide a custom function to generate a
     * key-value attribute pair to add/change. If not provided, model attributes will be converted to view elements attributes
     * on 1-to-1 basis.
     *
     * **Note:** Provided attribute creator should always return the same `key` for given attribute from the model.
     *
     * The converter automatically consumes corresponding value from consumables list and stops the event (see
     * {@link engine.conversion.ModelConversionDispatcher}).
     *
     *		modelDispatcher.on( 'addAttribute:customAttr:myElem', setAttribute( ( data ) => {
     *			// Change attribute key from `customAttr` to `class` in view.
     *			const key = 'class';
     *			let value = data.attributeNewValue;
     *
     *			// Force attribute value to 'empty' if the model element is empty.
     *			if ( data.item.getChildCount() === 0 ) {
     *				value = 'empty';
     *			}
     *
     *			// Return key-value pair.
     *			return { key, value };
     *		} ) );
     *
     * @external engine.conversion.modelToView
     * @function engine.conversion.modelToView.setAttribute
     * @param {Function} [attributeCreator] Function returning an object with two properties: `key` and `value`, which
     * represents attribute key and attribute value to be set on a {@link engine.view.Element view element}. The function
     * is passed all the parameters of the {@link engine.conversion.ModelConversionDispatcher.addAttribute}
     * or {@link engine.conversion.ModelConversionDispatcher.changeAttribute} event.
     * @returns {Function} Set/change attribute converter.
     */
    function setAttribute(attributeCreator) {
      attributeCreator = attributeCreator || function (value, key) {
        return { value: value, key: key };
      };

      return function (evt, data, consumable, conversionApi) {
        var _attributeCreator = attributeCreator(data.attributeNewValue, data.attributeKey, data, consumable, conversionApi);

        var key = _attributeCreator.key;
        var value = _attributeCreator.value;


        consumable.consume(data.item, eventNameToConsumableType(evt.name));
        conversionApi.mapper.toViewElement(data.item).setAttribute(key, value);

        evt.stop();
      };
    }

    /**
     * Function factory, creates a converter that converts remove attribute changes from the model to the view. Removes attributes
     * that were converted to the view element attributes in the view. You may provide a custom function to generate a
     * key-value attribute pair to remove. If not provided, model attributes will be removed from view elements on 1-to-1 basis.
     *
     * **Note:** Provided attribute creator should always return the same `key` for given attribute from the model.
     *
     * **Note:** You can use the same attribute creator as in {@link engine.conversion.modelToView.setAttribute}.
     *
     * The converter automatically consumes corresponding value from consumables list and stops the event (see
     * {@link engine.conversion.ModelConversionDispatcher}).
     *
     *		modelDispatcher.on( 'removeAttribute:customAttr:myElem', removeAttribute( ( data ) => {
     *			// Change attribute key from `customAttr` to `class` in view.
     *			const key = 'class';
     *			let value = data.attributeNewValue;
     *
     *			// Force attribute value to 'empty' if the model element is empty.
     *			if ( data.item.getChildCount() === 0 ) {
     *				value = 'empty';
     *			}
     *
     *			// Return key-value pair.
     *			return { key, value };
     *		} ) );
     *
     * @external engine.conversion.modelToView
     * @function engine.conversion.modelToView.removeAttribute
     * @param {Function} [attributeCreator] Function returning an object with two properties: `key` and `value`, which
     * represents attribute key and attribute value to be removed from {@link engine.view.Element view element}. The function
     * is passed all the parameters of the {@link engine.conversion.ModelConversionDispatcher#event:addAttribute addAttribute event}
     * or {@link engine.conversion.ModelConversionDispatcher#event:changeAttribute changeAttribute event}.
     * @returns {Function} Remove attribute converter.
     */
    function removeAttribute(attributeCreator) {
      attributeCreator = attributeCreator || function (value, key) {
        return { key: key };
      };

      return function (evt, data, consumable, conversionApi) {
        var _attributeCreator2 = attributeCreator(data.attributeOldValue, data.attributeKey, data, consumable, conversionApi);

        var key = _attributeCreator2.key;


        consumable.consume(data.item, eventNameToConsumableType(evt.name));
        conversionApi.mapper.toViewElement(data.item).removeAttribute(key);

        evt.stop();
      };
    }

    /**
     * Function factory, creates a converter that converts set/change attribute changes from the model to the view. In this case,
     * model attributes are converted to a view element that will be wrapping view nodes which corresponding model nodes had
     * the attribute set. This is useful for attributes like `bold`, which may be set on a text nodes in model but are
     * represented as an element in the view:
     *
     *		[paragraph]              MODEL ====> VIEW        <p>
     *			|- a {bold: true}                             |- <b>
     *			|- b {bold: true}                             |   |- ab
     *			|- c                                          |- c
     *
     * The wrapping node depends on passed parameter. If {@link engine.view.Element} was passed, it will be cloned and
     * the copy will become the wrapping element. If `Function` is provided, it is passed all the parameters of the
     * {@link engine.conversion.ModelConversionDispatcher#event:setAttribute setAttribute event}. It's expected that the
     * function returns a {@link engine.view.Element}. The result of the function will be the wrapping element.
     *
     * The converter automatically consumes corresponding value from consumables list, stops the event (see
     * {@link engine.conversion.ModelConversionDispatcher}).
     *
     *		modelDispatcher.on( 'addAttribute:bold', wrap( new ViewElement( 'strong' ) ) );
     *
     * @external engine.conversion.modelToView
     * @function engine.conversion.modelToView.wrap
     * @param {engine.view.Element|Function} elementCreator View element, or function returning a view element, which will
     * be used for wrapping.
     * @returns {Function} Set/change attribute converter.
     */
    function wrap(elementCreator) {
      return function (evt, data, consumable, conversionApi) {
        consumable.consume(data.item, eventNameToConsumableType(evt.name));

        var viewRange = conversionApi.mapper.toViewRange(data.range);

        var viewElement = elementCreator instanceof Element$1 ? elementCreator.clone(true) : elementCreator(data.attributeNewValue, data, consumable, conversionApi);

        // If this is a change event (because old value is not empty) and the creator is a function (so
        // it may create different view elements basing on attribute value) we have to create
        // view element basing on old value and unwrap it before wrapping with a newly created view element.
        if (data.attributeOldValue !== null && !(elementCreator instanceof Element$1)) {
          var oldViewElement = elementCreator(data.attributeOldValue, data, consumable, conversionApi);
          viewRange = conversionApi.writer.unwrap(viewRange, oldViewElement, evt.priority);
        }

        conversionApi.writer.wrap(viewRange, viewElement, evt.priority);

        evt.stop();
      };
    }

    /**
     * Function factory, creates a converter that converts remove attribute changes from the model to the view. It assumes, that
     * attributes from model were converted to elements in the view. This converter will unwrap view nodes from corresponding
     * view element if given attribute was removed.
     *
     * The view element type that will be unwrapped depends on passed parameter.
     * If {@link engine.view.Element} was passed, it will be used to look for similar element in the view for unwrapping. If `Function`
     * is provided, it is passed all the parameters of the
     * {@link engine.conversion.ModelConversionDispatcher#event:setAttribute setAttribute event}. It's expected that the
     * function returns a {@link engine.view.Element}. The result of the function will be used to look for similar element
     * in the view for unwrapping.
     *
     * The converter automatically consumes corresponding value from consumables list, stops the event (see
     * {@link engine.conversion.ModelConversionDispatcher}) and bind model and view elements.
     *
     *		modelDispatcher.on( 'removeAttribute:bold', unwrap( new ViewElement( 'strong' ) ) );
     *
     * @see engine.conversion.modelToView.wrap
     * @external engine.conversion.modelToView
     * @function engine.conversion.modelToView.unwrap
     * @param {engine.view.Element|Function} elementCreator View element, or function returning a view element, which will
     * be used for unwrapping.
     * @returns {Function} Remove attribute converter.
     */
    function unwrap(elementCreator) {
      return function (evt, data, consumable, conversionApi) {
        consumable.consume(data.item, eventNameToConsumableType(evt.name));

        var viewRange = conversionApi.mapper.toViewRange(data.range);
        var viewNode = elementCreator instanceof Element$1 ? elementCreator.clone(true) : elementCreator(data.attributeOldValue, data, consumable, conversionApi);

        conversionApi.writer.unwrap(viewRange, viewNode);

        evt.stop();
      };
    }

    /**
     * Function factory, creates a default model-to-view converter for nodes move changes.
     *
     *		modelDispatcher.on( 'move', move() );
     *
     * @external engine.conversion.modelToView
     * @function engine.conversion.modelToView.move
     * @returns {Function} Move event converter.
     */
    function move() {
      return function (evt, data, conversionApi) {
        var walker = new TreeWalker({ boundaries: data.range, shallow: true });

        var length = 0;

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = walker[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var value = _step.value;

            length += value.length;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var sourceModelRange = Range$1.createFromPositionAndShift(data.sourcePosition, length);

        var sourceViewRange = conversionApi.mapper.toViewRange(sourceModelRange);
        var targetViewPosition = conversionApi.mapper.toViewPosition(data.range.start);

        conversionApi.writer.move(sourceViewRange, targetViewPosition);
      };
    }

    /**
     * Function factory, creates a default model-to-view converter for nodes remove changes.
     *
     *		modelDispatcher.on( 'remove', remove() );
     *
     * @external engine.conversion.modelToView
     * @function engine.conversion.modelToView.remove
     * @returns {Function} Remove event converter.
     */
    function remove() {
      return function (evt, data, conversionApi) {
        var walker = new TreeWalker({ boundaries: data.range, shallow: true });

        var length = 0;

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = walker[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var value = _step2.value;

            length += value.length;
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        var sourceModelRange = Range$1.createFromPositionAndShift(data.sourcePosition, length);
        var sourceViewRange = conversionApi.mapper.toViewRange(sourceModelRange);

        conversionApi.writer.remove(sourceViewRange);
      };
    }

    /**
     * Returns the consumable type that is to be consumed in an event, basing on that event name.
     *
     * @param {String} evtName Event name.
     * @returns {String} Consumable type.
     */
    function eventNameToConsumableType(evtName) {
      var parts = evtName.split(':');

      return parts[0] + ':' + parts[1];
    }

    /**
     * DocumentFragment class.
     *
     * @memberOf engine.view
     */

    var DocumentFragment$1 = function () {
    	/**
      * Creates new DocumentFragment instance.
      *
      * @param {engine.view.Node|Iterable.<engine.view.Node>} [children] List of nodes to be inserted into
      * created document fragment.
      */

    	function DocumentFragment(children) {
    		classCallCheck(this, DocumentFragment);

    		/**
       * Array of child nodes.
       *
       * @protected
       * @member {Array.<engine.view.Element>} engine.view.DocumentFragment#_children
       */
    		this._children = [];

    		if (children) {
    			this.insertChildren(0, children);
    		}
    	}

    	/**
      * Iterates over nodes added to this DocumentFragment.
      */


    	createClass(DocumentFragment, [{
    		key: Symbol.iterator,
    		value: function value() {
    			return this._children[Symbol.iterator]();
    		}

    		/**
       * {@link engine.view.DocumentFragment#insertChildren Insert} a child node or a list of child nodes at the end
       * and sets the parent of these nodes to this fragment.
       *
       * @param {engine.view.Node|Iterable.<engine.view.Node>} nodes Node or the list of nodes to be inserted.
       * @returns {Number} Number of appended nodes.
       */

    	}, {
    		key: 'appendChildren',
    		value: function appendChildren(nodes) {
    			return this.insertChildren(this.getChildCount(), nodes);
    		}

    		/**
       * Gets child at the given index.
       *
       * @param {Number} index Index of child.
       * @returns {engine.view.Node} Child node.
       */

    	}, {
    		key: 'getChild',
    		value: function getChild(index) {
    			return this._children[index];
    		}

    		/**
       * Gets the number of elements in fragment.
       *
       * @returns {Number} The number of elements.
       */

    	}, {
    		key: 'getChildCount',
    		value: function getChildCount() {
    			return this._children.length;
    		}

    		/**
       * Gets index of the given child node. Returns `-1` if child node is not found.
       *
       * @param {engine.view.Node} node Child node.
       * @returns {Number} Index of the child node.
       */

    	}, {
    		key: 'getChildIndex',
    		value: function getChildIndex(node) {
    			return this._children.indexOf(node);
    		}

    		/**
       * Gets child nodes iterator.
       *
       * @returns {Iterable.<engine.view.Node>} Child nodes iterator.
       */

    	}, {
    		key: 'getChildren',
    		value: function getChildren() {
    			return this._children[Symbol.iterator]();
    		}

    		/**
       * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
       * this fragment.
       *
       * @param {Number} index Position where nodes should be inserted.
       * @param {engine.view.Node|Iterable.<engine.view.Node>} nodes Node or list of nodes to be inserted.
       * @returns {Number} Number of inserted nodes.
       */

    	}, {
    		key: 'insertChildren',
    		value: function insertChildren(index, nodes) {
    			this._fireChange('children', this);
    			var count = 0;

    			if (!isIterable(nodes)) {
    				nodes = [nodes];
    			}

    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var node = _step.value;

    					node.parent = this;

    					this._children.splice(index, 0, node);
    					index++;
    					count++;
    				}
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}

    			return count;
    		}

    		/**
       * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
       *
       * @param {Number} index Number of the first node to remove.
       * @param {Number} [howMany=1] Number of nodes to remove.
       * @returns {Array.<engine.view.Node>} The array of removed nodes.
       */

    	}, {
    		key: 'removeChildren',
    		value: function removeChildren(index) {
    			var howMany = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

    			this._fireChange('children', this);

    			for (var i = index; i < index + howMany; i++) {
    				this._children[i].parent = null;
    			}

    			return this._children.splice(index, howMany);
    		}

    		/**
       * Fires `change` event with given type of the change.
       *
       * @private
       * @param {engine.view.ChangeType} type Type of the change.
       * @param {engine.view.Node} node Changed node.
       * @fires engine.view.Node#change
       */

    	}, {
    		key: '_fireChange',
    		value: function _fireChange(type, node) {
    			this.fire('change', type, node);
    		}
    	}]);
    	return DocumentFragment;
    }();

    mix(DocumentFragment$1, EmitterMixin);

    /**
     * This is a private helper-class for {@link engine.conversion.ViewConsumable}.
     * It represents and manipulates consumable parts of a single {@link engine.view.Element}.
     *
     * @private
     * @memberOf engine.conversion
     */

    var ViewElementConsumables = function () {

    	/**
      * Creates ViewElementConsumables instance.
      */

    	function ViewElementConsumables() {
    		classCallCheck(this, ViewElementConsumables);

    		/**
       * Flag indicating if name of the element can be consumed.
       *
       * @private
       * @member {Boolean} engine.conversion.ViewElementConsumables#_canConsumeName
       */
    		this._canConsumeName = null;

    		/**
       * Contains maps of element's consumables: attributes, classes and styles.
       *
       * @private
       * @member {Object} engine.conversion.ViewElementConsumables#_consumables
       */
    		this._consumables = {
    			attribute: new Map(),
    			style: new Map(),
    			class: new Map()
    		};
    	}

    	/**
      * Adds consumable parts of the {@link engine.view.Element view element}.
      * Element's name itself can be marked to be consumed (when element's name is consumed its attributes, classes and
      * styles still could be consumed):
      *
      *		consumables.add( { name: true } );
      *
      * Attributes classes and styles:
      *
      *		consumables.add( { attribute: 'title', class: 'foo', style: 'color' } );
      *		consumables.add( { attribute: [ 'title', 'name' ], class: [ 'foo', 'bar' ] );
      *
      * Throws {@link utils.CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
      * attribute is provided - it should be handled separately by providing `style` and `class` in consumables object.
      *
      * @param {Object} consumables Object describing which parts of the element can be consumed.
      * @param {Boolean} consumables.name If set to `true` element's name will be added as consumable.
      * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names to add as consumable.
      * @param {String|Array.<String>} consumables.class Class name or array of class names to add as consumable.
      * @param {String|Array.<String>} consumables.style Style name or array of style names to add as consumable.
      */


    	createClass(ViewElementConsumables, [{
    		key: 'add',
    		value: function add(consumables) {
    			if (consumables.name) {
    				this._canConsumeName = true;
    			}

    			for (var type in this._consumables) {
    				if (type in consumables) {
    					this._add(type, consumables[type]);
    				}
    			}
    		}

    		/**
       * Tests if parts of the {@link engine.view.Element view element} can be consumed.
       *
       * Element's name can be tested:
       *
       *		consumables.test( { name: true } );
       *
       * Attributes classes and styles:
       *
       *		consumables.test( { attribute: 'title', class: 'foo', style: 'color' } );
       *		consumables.test( { attribute: [ 'title', 'name' ], class: [ 'foo', 'bar' ] );
       *
       * @param {Object} consumables Object describing which parts of the element should be tested.
       * @param {Boolean} consumables.name If set to `true` element's name will be tested.
       * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names to test.
       * @param {String|Array.<String>} consumables.class Class name or array of class names to test.
       * @param {String|Array.<String>} consumables.style Style name or array of style names to test.
       * @returns {Boolean|null} `true` when all tested items can be consumed, `null` when even one of the items
       * was never marked for consumption and `false` when even one of the items was already consumed.
       */

    	}, {
    		key: 'test',
    		value: function test(consumables) {
    			// Check if name can be consumed.
    			if (consumables.name && !this._canConsumeName) {
    				return this._canConsumeName;
    			}

    			for (var type in this._consumables) {
    				if (type in consumables) {
    					var value = this._test(type, consumables[type]);

    					if (value !== true) {
    						return value;
    					}
    				}
    			}

    			// Return true only if all can be consumed.
    			return true;
    		}

    		/**
       * Consumes parts of {@link engine.view.Element view element}. This function does not check if consumable item
       * is already consumed - it consumes all consumable items provided.
       * Element's name can be consumed:
       *
       *		consumables.consume( { name: true } );
       *
       * Attributes classes and styles:
       *
       *		consumables.consume( { attribute: 'title', class: 'foo', style: 'color' } );
       *		consumables.consume( { attribute: [ 'title', 'name' ], class: [ 'foo', 'bar' ] );
       *
       * @param {Object} consumables Object describing which parts of the element should be consumed.
       * @param {Boolean} consumables.name If set to `true` element's name will be consumed.
       * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names to consume.
       * @param {String|Array.<String>} consumables.class Class name or array of class names to consume.
       * @param {String|Array.<String>} consumables.style Style name or array of style names to consume.
       */

    	}, {
    		key: 'consume',
    		value: function consume(consumables) {
    			if (consumables.name) {
    				this._canConsumeName = false;
    			}

    			for (var type in this._consumables) {
    				if (type in consumables) {
    					this._consume(type, consumables[type]);
    				}
    			}
    		}

    		/**
       * Revert already consumed parts of {@link engine.view.Element view Element}, so they can be consumed once again.
       * Element's name can be reverted:
       *
       *		consumables.revert( { name: true } );
       *
       * Attributes classes and styles:
       *
       *		consumables.revert( { attribute: 'title', class: 'foo', style: 'color' } );
       *		consumables.revert( { attribute: [ 'title', 'name' ], class: [ 'foo', 'bar' ] );
       *
       * @param {Object} consumables Object describing which parts of the element should be reverted.
       * @param {Boolean} consumables.name If set to `true` element's name will be reverted.
       * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names to revert.
       * @param {String|Array.<String>} consumables.class Class name or array of class names to revert.
       * @param {String|Array.<String>} consumables.style Style name or array of style names to revert.
       */

    	}, {
    		key: 'revert',
    		value: function revert(consumables) {
    			if (consumables.name) {
    				this._canConsumeName = true;
    			}

    			for (var type in this._consumables) {
    				if (type in consumables) {
    					this._revert(type, consumables[type]);
    				}
    			}
    		}

    		/**
       * Helper method that adds consumables of a given type: attribute, class or style.
       *
       * Throws {@link utils.CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
       * type is provided - it should be handled separately by providing actual style/class type.
       *
       * @private
       * @param {String} type Type of the consumable item: `attribute`, `class` or `style`.
       * @param {String|Array.<String>} item Consumable item or array of items.
       */

    	}, {
    		key: '_add',
    		value: function _add(type, item) {
    			var items = isArray(item) ? item : [item];
    			var consumables = this._consumables[type];

    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var name = _step.value;

    					if (type === 'attribute' && (name === 'class' || name === 'style')) {
    						/**
           * Class and style attributes should be handled separately.
           *
           * @error viewconsumable-invalid-attribute
           */
    						throw new CKEditorError('viewconsumable-invalid-attribute: Classes and styles should be handled separately.');
    					}

    					consumables.set(name, true);
    				}
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}
    		}

    		/**
       * Helper method that tests consumables of a given type: attribute, class or style.
       *
       * @private
       * @param {String} type Type of the consumable item: `attribute`, `class` or `style`.
       * @param {String|Array.<String>} item Consumable item or array of items.
       * @returns {Boolean|null} Returns `true` if all items can be consumed, `null` when one of the items cannot be
       * consumed and `false` when one of the items is already consumed.
       */

    	}, {
    		key: '_test',
    		value: function _test(type, item) {
    			var items = isArray(item) ? item : [item];
    			var consumables = this._consumables[type];

    			var _iteratorNormalCompletion2 = true;
    			var _didIteratorError2 = false;
    			var _iteratorError2 = undefined;

    			try {
    				for (var _iterator2 = items[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    					var name = _step2.value;

    					if (type === 'attribute' && (name === 'class' || name === 'style')) {
    						// Check all classes/styles if class/style attribute is tested.
    						var value = this._test(name, [].concat(toConsumableArray(this._consumables[name].keys())));

    						if (value !== true) {
    							return value;
    						}
    					} else {
    						var _value = consumables.get(name);
    						// Return null if attribute is not found.
    						if (_value === undefined) {
    							return null;
    						}

    						if (!_value) {
    							return false;
    						}
    					}
    				}
    			} catch (err) {
    				_didIteratorError2 = true;
    				_iteratorError2 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion2 && _iterator2.return) {
    						_iterator2.return();
    					}
    				} finally {
    					if (_didIteratorError2) {
    						throw _iteratorError2;
    					}
    				}
    			}

    			return true;
    		}

    		/**
       * Helper method that consumes items of a given type: attribute, class or style.
       *
       * @private
       * @param {String} type Type of the consumable item: `attribute`, `class` or `style`.
       * @param {String|Array.<String>} item Consumable item or array of items.
       */

    	}, {
    		key: '_consume',
    		value: function _consume(type, item) {
    			var items = isArray(item) ? item : [item];
    			var consumables = this._consumables[type];

    			var _iteratorNormalCompletion3 = true;
    			var _didIteratorError3 = false;
    			var _iteratorError3 = undefined;

    			try {
    				for (var _iterator3 = items[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
    					var name = _step3.value;

    					if (type === 'attribute' && (name === 'class' || name === 'style')) {
    						// If class or style is provided for consumption - consume them all.
    						this._consume(name, [].concat(toConsumableArray(this._consumables[name].keys())));
    					} else {
    						consumables.set(name, false);
    					}
    				}
    			} catch (err) {
    				_didIteratorError3 = true;
    				_iteratorError3 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion3 && _iterator3.return) {
    						_iterator3.return();
    					}
    				} finally {
    					if (_didIteratorError3) {
    						throw _iteratorError3;
    					}
    				}
    			}
    		}

    		/**
       * Helper method that reverts items of a given type: attribute, class or style.
       *
       * @private
       * @param {String} type Type of the consumable item: `attribute`, `class` or , `style`.
       * @param {String|Array.<String>} item Consumable item or array of items.
       */

    	}, {
    		key: '_revert',
    		value: function _revert(type, item) {
    			var items = isArray(item) ? item : [item];
    			var consumables = this._consumables[type];

    			var _iteratorNormalCompletion4 = true;
    			var _didIteratorError4 = false;
    			var _iteratorError4 = undefined;

    			try {
    				for (var _iterator4 = items[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
    					var name = _step4.value;

    					if (type === 'attribute' && (name === 'class' || name === 'style')) {
    						// If class or style is provided for reverting - revert them all.
    						this._revert(name, [].concat(toConsumableArray(this._consumables[name].keys())));
    					} else {
    						var value = consumables.get(name);

    						if (value === false) {
    							consumables.set(name, true);
    						}
    					}
    				}
    			} catch (err) {
    				_didIteratorError4 = true;
    				_iteratorError4 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion4 && _iterator4.return) {
    						_iterator4.return();
    					}
    				} finally {
    					if (_didIteratorError4) {
    						throw _iteratorError4;
    					}
    				}
    			}
    		}
    	}]);
    	return ViewElementConsumables;
    }();

    /**
     * Class used for handling consumption of view {@link engine.view.Element elements},
     * {@link engine.view.Text text nodes} and {@link engine.view.DocumentFragment document fragments}.
     * Element's name and its parts (attributes, classes and styles) can be consumed separately. Consuming an element's name
     * does not consume its attributes, classes and styles.
     * To add items for consumption use {@link engine.conversion.ViewConsumable#add add method}.
     * To test items use {@link engine.conversion.ViewConsumable#test test method}.
     * To consume items use {@link engine.conversion.ViewConsumable#consume consume method}.
     * To revert already consumed items use {@link engine.conversion.ViewConsumable#revert revert method}.
     *
     *		viewConsumable.add( element, { name: true } ); // Adds element's name as ready to be consumed.
     *		viewConsumable.add( textNode ); // Adds text node for consumption.
     *		viewConsumable.add( docFragment ); // Adds document fragment for consumption.
     *		viewConsumable.test( element, { name: true }  ); // Tests if element's name can be consumed.
     *		viewConsumable.test( textNode ); // Tests if text node can be consumed.
     *		viewConsumable.test( docFragment ); // Tests if document fragment can be consumed.
     *		viewConsumable.consume( element, { name: true }  ); // Consume element's name.
     *		viewConsumable.consume( textNode ); // Consume text node.
     *		viewConsumable.consume( docFragment ); // Consume document fragment.
     *		viewConsumable.revert( element, { name: true }  ); // Revert already consumed element's name.
     *		viewConsumable.revert( textNode ); // Revert already consumed text node.
     *		viewConsumable.revert( docFragment ); // Revert already consumed document fragment.
     *
     * @memberOf engine.conversion
     */


    var ViewConsumable = function () {

    	/**
      * Creates new ViewConsumable.
      */

    	function ViewConsumable() {
    		classCallCheck(this, ViewConsumable);

    		/**
       * Map of consumable elements. If {@link engine.view.Element element} is used as a key,
       * {@link engine.conversion.ViewElementConsumables ViewElementConsumables} instance is stored as value.
       * For {@link engine.view.Text text nodes} and {@link engine.view.DocumentFragment document fragments}
       * boolean value is stored as value.
       *
       * @protected
       * @member {Map.<engine.conversion.ViewElementConsumables|Boolean>} engine.conversion.ViewConsumable#_consumables
      */
    		this._consumables = new Map();
    	}

    	/**
      * Adds {@link engine.view.Element view element}, {@link engine.view.Text text node} or
      * {@link engine.view.DocumentFragment document fragment} as ready to be consumed.
      *
      *		viewConsumable.add( p, { name: true } ); // Adds element's name to consume.
      *		viewConsumable.add( p, { attribute: 'name' } ); // Adds element's attribute.
      *		viewConsumable.add( p, { class: 'foobar' } ); // Adds element's class.
      *		viewConsumable.add( p, { style: 'color' } ); // Adds element's style
      *		viewConsumable.add( p, { attribute: 'name', style: 'color' } ); // Adds attribute and style.
      *		viewConsumable.add( p, { class: [ 'baz', 'bar' ] } ); // Multiple consumables can be provided.
      *		viewConsumable.add( textNode ); // Adds text node to consume.
      *		viewConsumable.add( docFragment ); // Adds document fragment to consume.
      *
      * Throws {@link utils.CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
      * attribute is provided - it should be handled separately by providing actual style/class.
      *
      *		viewConsumable.add( p, { attribute: 'style' } ); // This call will throw an exception.
      *		viewConsumable.add( p, { style: 'color' } ); // This is properly handled style.
      *
      * @param {engine.view.Element|engine.view.Text|engine.view.DocumentFragment} element
      * @param {Object} [consumables] Used only if first parameter is {@link engine.view.Element view element} instance.
      * @param {Boolean} consumables.name If set to true element's name will be included.
      * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names.
      * @param {String|Array.<String>} consumables.class Class name or array of class names.
      * @param {String|Array.<String>} consumables.style Style name or array of style names.
      */


    	createClass(ViewConsumable, [{
    		key: 'add',
    		value: function add(element, consumables) {
    			var elementConsumables = void 0;

    			// For text nodes and document fragments just mark them as consumable.
    			if (element instanceof Text$2 || element instanceof DocumentFragment$1) {
    				this._consumables.set(element, true);

    				return;
    			}

    			// For elements create new ViewElementConsumables or update already existing one.
    			if (!this._consumables.has(element)) {
    				elementConsumables = new ViewElementConsumables();
    				this._consumables.set(element, elementConsumables);
    			} else {
    				elementConsumables = this._consumables.get(element);
    			}

    			elementConsumables.add(consumables);
    		}

    		/**
       * Tests if {@link engine.view.Element view element}, {@link engine.view.Text text node} or
       * {@link engine.view.DocumentFragment document fragment} can be consumed.
       * It returns `true` when all items included in method's call can be consumed. Returns `false` when
       * first already consumed item is found and `null` when first non-consumable item is found.
       *
       *		viewConsumable.test( p, { name: true } ); // Tests element's name.
       *		viewConsumable.test( p, { attribute: 'name' } ); // Tests attribute.
       *		viewConsumable.test( p, { class: 'foobar' } ); // Tests class.
       *		viewConsumable.test( p, { style: 'color' } ); // Tests style.
       *		viewConsumable.test( p, { attribute: 'name', style: 'color' } ); // Tests attribute and style.
       *		viewConsumable.test( p, { class: [ 'baz', 'bar' ] } ); // Multiple consumables can be tested.
       *		viewConsumable.test( textNode ); // Tests text node.
       *		viewConsumable.test( docFragment ); // Tests document fragment.
       *
       * Testing classes and styles as attribute will test if all added classes/styles can be consumed.
       *
       *		viewConsumable.test( p, { attribute: 'class' } ); // Tests if all added classes can be consumed.
       *		viewConsumable.test( p, { attribute: 'style' } ); // Tests if all added styles can be consumed.
       *
       * @param {engine.view.Element|engine.view.Text|engine.view.DocumentFragment} element
       * @param {Object} [consumables] Used only if first parameter is {@link engine.view.Element view element} instance.
       * @param {Boolean} consumables.name If set to true element's name will be included.
       * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names.
       * @param {String|Array.<String>} consumables.class Class name or array of class names.
       * @param {String|Array.<String>} consumables.style Style name or array of style names.
       * @returns {Boolean|null} Returns `true` when all items included in method's call can be consumed. Returns `false`
       * when first already consumed item is found and `null` when first non-consumable item is found.
       */

    	}, {
    		key: 'test',
    		value: function test(element, consumables) {
    			var elementConsumables = this._consumables.get(element);

    			if (elementConsumables === undefined) {
    				return null;
    			}

    			// For text nodes and document fragments return stored boolean value.
    			if (element instanceof Text$2 || element instanceof DocumentFragment$1) {
    				return elementConsumables;
    			}

    			// For elements test consumables object.
    			return elementConsumables.test(consumables);
    		}

    		/**
       * Consumes {@link engine.view.Element view element}, {@link engine.view.Text text node} or
       * {@link engine.view.DocumentFragment document fragment}.
       * It returns `true` when all items included in method's call can be consumed, otherwise returns `false`.
       *
       *		viewConsumable.consume( p, { name: true } ); // Consumes element's name.
       *		viewConsumable.consume( p, { attribute: 'name' } ); // Consumes element's attribute.
       *		viewConsumable.consume( p, { class: 'foobar' } ); // Consumes element's class.
       *		viewConsumable.consume( p, { style: 'color' } ); // Consumes element's style.
       *		viewConsumable.consume( p, { attribute: 'name', style: 'color' } ); // Consumes attribute and style.
       *		viewConsumable.consume( p, { class: [ 'baz', 'bar' ] } ); // Multiple consumables can be consumed.
       *		viewConsumable.consume( textNode ); // Consumes text node.
       *		viewConsumable.consume( docFragment ); // Consumes document fragment.
       *
       * Consuming classes and styles as attribute will test if all added classes/styles can be consumed.
       *
       *		viewConsumable.consume( p, { attribute: 'class' } ); // Consume only if all added classes can be consumed.
       *		viewConsumable.consume( p, { attribute: 'style' } ); // Consume only if all added styles can be consumed.
       *
       * @param {engine.view.Element|engine.view.Text|engine.view.DocumentFragment} element
       * @param {Object} [consumables] Used only if first parameter is {@link engine.view.Element view element} instance.
       * @param {Boolean} consumables.name If set to true element's name will be included.
       * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names.
       * @param {String|Array.<String>} consumables.class Class name or array of class names.
       * @param {String|Array.<String>} consumables.style Style name or array of style names.
       * @returns {Boolean} Returns `true` when all items included in method's call can be consumed,
       * otherwise returns `false`.
       */

    	}, {
    		key: 'consume',
    		value: function consume(element, consumables) {
    			if (this.test(element, consumables)) {
    				if (element instanceof Text$2 || element instanceof DocumentFragment$1) {
    					// For text nodes and document fragments set value to false.
    					this._consumables.set(element, false);
    				} else {
    					// For elements - consume consumables object.
    					this._consumables.get(element).consume(consumables);
    				}

    				return true;
    			}

    			return false;
    		}

    		/**
       * Reverts {@link engine.view.Element view element}, {@link engine.view.Text text node} or
       * {@link engine.view.DocumentFragment document fragment} so they can be consumed once again.
       * Method does not revert items that were never previously added for consumption, even if they are included in
       * method's call.
       *
       *		viewConsumable.revert( p, { name: true } ); // Reverts element's name.
       *		viewConsumable.revert( p, { attribute: 'name' } ); // Reverts element's attribute.
       *		viewConsumable.revert( p, { class: 'foobar' } ); // Reverts element's class.
       *		viewConsumable.revert( p, { style: 'color' } ); // Reverts element's style.
       *		viewConsumable.revert( p, { attribute: 'name', style: 'color' } ); // Reverts attribute and style.
       *		viewConsumable.revert( p, { class: [ 'baz', 'bar' ] } ); // Multiple names can be reverted.
       *		viewConsumable.revert( textNode ); // Reverts text node.
       *		viewConsumable.revert( docFragment ); // Reverts document fragment.
       *
       * Reverting classes and styles as attribute will revert all classes/styles that were previously added for
       * consumption.
       *
       *		viewConsumable.revert( p, { attribute: 'class' } ); // Reverts all classes added for consumption.
       *		viewConsumable.revert( p, { attribute: 'style' } ); // Reverts all styles added for consumption.
       *
       * @param {engine.view.Element|engine.view.Text|engine.view.DocumentFragment} element
       * @param {Object} [consumables] Used only if first parameter is {@link engine.view.Element view element} instance.
       * @param {Boolean} consumables.name If set to true element's name will be included.
       * @param {String|Array.<String>} consumables.attribute Attribute name or array of attribute names.
       * @param {String|Array.<String>} consumables.class Class name or array of class names.
       * @param {String|Array.<String>} consumables.style Style name or array of style names.
       */

    	}, {
    		key: 'revert',
    		value: function revert(element, consumables) {
    			var elementConsumables = this._consumables.get(element);

    			if (elementConsumables !== undefined) {
    				if (element instanceof Text$2 || element instanceof DocumentFragment$1) {
    					// For text nodes and document fragments - set consumable to true.
    					this._consumables.set(element, true);
    				} else {
    					// For elements - revert items from consumables object.
    					elementConsumables.revert(consumables);
    				}
    			}
    		}

    		/**
       * Creates consumable object from {@link engine.view.Element view element}. Consumable object will include
       * element's name and all its attributes, classes and styles.
       *
       * @static
       * @param {engine.view.Element} element
       * @returns {Object} consumables
       */

    	}], [{
    		key: 'consumablesFromElement',
    		value: function consumablesFromElement(element) {
    			var consumables = {
    				name: true,
    				attribute: [],
    				class: [],
    				style: []
    			};

    			var attributes = element.getAttributeKeys();

    			var _iteratorNormalCompletion5 = true;
    			var _didIteratorError5 = false;
    			var _iteratorError5 = undefined;

    			try {
    				for (var _iterator5 = attributes[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
    					var attribute = _step5.value;

    					// Skip classes and styles - will be added separately.
    					if (attribute == 'style' || attribute == 'class') {
    						continue;
    					}

    					consumables.attribute.push(attribute);
    				}
    			} catch (err) {
    				_didIteratorError5 = true;
    				_iteratorError5 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion5 && _iterator5.return) {
    						_iterator5.return();
    					}
    				} finally {
    					if (_didIteratorError5) {
    						throw _iteratorError5;
    					}
    				}
    			}

    			var classes = element.getClassNames();

    			var _iteratorNormalCompletion6 = true;
    			var _didIteratorError6 = false;
    			var _iteratorError6 = undefined;

    			try {
    				for (var _iterator6 = classes[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
    					var className = _step6.value;

    					consumables.class.push(className);
    				}
    			} catch (err) {
    				_didIteratorError6 = true;
    				_iteratorError6 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion6 && _iterator6.return) {
    						_iterator6.return();
    					}
    				} finally {
    					if (_didIteratorError6) {
    						throw _iteratorError6;
    					}
    				}
    			}

    			var styles = element.getStyleNames();

    			var _iteratorNormalCompletion7 = true;
    			var _didIteratorError7 = false;
    			var _iteratorError7 = undefined;

    			try {
    				for (var _iterator7 = styles[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
    					var style = _step7.value;

    					consumables.style.push(style);
    				}
    			} catch (err) {
    				_didIteratorError7 = true;
    				_iteratorError7 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion7 && _iterator7.return) {
    						_iterator7.return();
    					}
    				} finally {
    					if (_didIteratorError7) {
    						throw _iteratorError7;
    					}
    				}
    			}

    			return consumables;
    		}

    		/**
       * Creates {@link engine.conversion.ViewConsumable ViewConsumable} instance from
       * {@link engine.view.Element element} or {@link engine.view.DocumentFragment document fragment}.
       * Instance will contain all elements, child nodes, attributes, styles and classes added for consumption.
       *
       * @static
       * @param {engine.view.Element|engine.view.DocumentFragment} from View element or document fragment
       * from which `ViewConsumable` will be created.
       * @param {engine.conversion.ViewConsumable} [instance] If provided, given `ViewConsumable` instance will be used
       * to add all consumables. It will be returned instead of a new instance.
       */

    	}, {
    		key: 'createFrom',
    		value: function createFrom(from, instance) {
    			if (!instance) {
    				instance = new ViewConsumable();
    			}

    			if (from instanceof Text$2) {
    				instance.add(from);

    				return instance;
    			}

    			// Add `from` itself, if it is an element.
    			if (from instanceof Element$1) {
    				instance.add(from, ViewConsumable.consumablesFromElement(from));
    			}

    			if (from instanceof DocumentFragment$1) {
    				instance.add(from);
    			}

    			var _iteratorNormalCompletion8 = true;
    			var _didIteratorError8 = false;
    			var _iteratorError8 = undefined;

    			try {
    				for (var _iterator8 = from.getChildren()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
    					var child = _step8.value;

    					instance = ViewConsumable.createFrom(child, instance);
    				}
    			} catch (err) {
    				_didIteratorError8 = true;
    				_iteratorError8 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion8 && _iterator8.return) {
    						_iterator8.return();
    					}
    				} finally {
    					if (_didIteratorError8) {
    						throw _iteratorError8;
    					}
    				}
    			}

    			return instance;
    		}
    	}]);
    	return ViewConsumable;
    }();

    /**
     * `ViewConversionDispatcher` is a central point of {@link engine.view view} conversion, which is a process of
     * converting given {@link engine.view.DocumentFragment view document fragment} or {@link engine.view.Element}
     * into another structure. In default application, {@link engine.view view} is converted to {@link engine.model}.
     *
     * During conversion process, for all {@link engine.view.Node view nodes} from the converted view document fragment,
     * `ViewConversionDispatcher` fires corresponding events. Special callbacks called "converters" should listen to
     * `ViewConversionDispatcher` for those events.
     *
     * Each callback, as a first argument, is passed a special object `data` that has `input` and `output` properties.
     * `input` property contains {@link engine.view.Node view node} or {@link engine.view.DocumentFragment view document fragment}
     * that is converted at the moment and might be handled by the callback. `output` property should be used to save the result
     * of conversion. Keep in mind that the `data` parameter is customizable and may contain other values - see
     * {@link engine.conversion.ViewConversionDispatcher#convert}. It is also shared by reference by all callbacks
     * listening to given event. **Note**: in view to model conversion - `data` contains `context` property that is an array
     * of {@link engine.model.Element model elements}. These are model elements that will be the parent of currently
     * converted view item. `context` property is used in examples below.
     *
     * The second parameter passed to a callback is an instance of {@link engine.conversion.ViewConsumable}. It stores
     * information about what parts of processed view item are still waiting to be handled. After a piece of view item
     * was converted, appropriate consumable value should be {@link engine.conversion.ViewConsumable#consume consumed}.
     *
     * The third parameter passed to a callback is an instance of {@link engine.conversion.ViewConversionDispatcher}
     * which provides additional tools for converters.
     *
     * Examples of providing callbacks for `ViewConversionDispatcher`:
     *
     *		// Converter for paragraphs (<p>).
     *		viewDispatcher.on( 'element:p', ( data, consumable, conversionApi ) => {
     *			const paragraph = new ModelElement( 'paragraph' );
     *			const schemaQuery = {
     *				name: 'paragraph',
     *				inside: data.context
     *			};
     *
     *			if ( conversionApi.schema.check( schemaQuery ) ) {
     *				if ( !consumable.consume( data.input, { name: true } ) ) {
     *					// Before converting this paragraph's children we have to update their context by this paragraph.
     *					data.context.push( paragraph );
     *					const children = conversionApi.convertChildren( data.input, consumable, data );
     *					data.context.pop();
     *					paragraph.appendChildren( children );
     *					data.output = paragraph;
     *				}
     *			}
     *		} );
     *
     *		// Converter for links (<a>).
     *		viewDispatcher.on( 'element:a', ( data, consumable, conversionApi ) => {
     *			if ( consumable.consume( data.input, { name: true, attributes: [ 'href' ] } ) ) {
     *				// <a> element is inline and is represented by an attribute in the model.
     *				// This is why we are not updating `context` property.
     *				data.output = conversionApi.convertChildren( data.input, consumable, data );
     *
     *				for ( let item of Range.createFrom( data.output ) ) {
     *					const schemaQuery = {
     *						name: item.name || '$text',
     *						attribute: 'link',
     *						inside: data.context
     *					};
     *
     *					if ( conversionApi.schema.checkQuery( schemaQuery ) ) {
     *						item.setAttribute( 'link', data.input.getAttribute( 'href' ) );
     *					}
     *				}
     *			}
     *		} );
     *
     *		// Fire conversion.
     *		// Always take care where the converted model structure will be appended to. If this `viewDocumentFragment`
     *		// is going to be appended directly to a '$root' element, use that in `context`.
     *		viewDispatcher.convert( viewDocumentFragment, { context: [ '$root' ] } );
     *
     * Before each conversion process, `ViewConversionDispatcher` fires {@link engine.conversion.ViewConversionDispatcher.viewCleanup}
     * event which can be used to prepare tree view for conversion.
     *
     * @mixes utils.EmitterMixin
     * @fires engine.conversion.ViewConversionDispatcher.viewCleanup
     * @fires engine.conversion.ViewConversionDispatcher.element
     * @fires engine.conversion.ViewConversionDispatcher.text
     * @fires engine.conversion.ViewConversionDispatcher.documentFragment
     *
     * @memberOf engine.conversion
     */

    var ViewConversionDispatcher = function () {
      /**
       * Creates a `ViewConversionDispatcher` that operates using passed API.
       *
       * @see engine.conversion.ViewConversionApi
       * @param {Object} [conversionApi] Additional properties for interface that will be passed to events fired
       * by `ViewConversionDispatcher`.
       */

      function ViewConversionDispatcher() {
        var conversionApi = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
        classCallCheck(this, ViewConversionDispatcher);

        /**
         * Interface passed by dispatcher to the events callbacks.
         *
         * @member {engine.conversion.ViewConversionApi} engine.conversion.ViewConversionDispatcher#conversionApi
         */
        this.conversionApi = assignIn({}, conversionApi);

        // `convertItem` and `convertChildren` are bound to this `ViewConversionDispatcher` instance and
        // set on `conversionApi`. This way only a part of `ViewConversionDispatcher` API is exposed.
        this.conversionApi.convertItem = this._convertItem.bind(this);
        this.conversionApi.convertChildren = this._convertChildren.bind(this);
      }

      /**
       * Starts the conversion process. The entry point for the conversion.
       *
       * @fires engine.conversion.ViewConversionDispatcher.element
       * @fires engine.conversion.ViewConversionDispatcher.text
       * @fires engine.conversion.ViewConversionDispatcher.documentFragment
       * @param {engine.view.DocumentFragment|engine.view.Element} viewItem Part of the view to be converted.
       * @param {Object} [additionalData] Additional data to be passed in `data` argument when firing `ViewConversionDispatcher`
       * events. See also {@link engine.conversion.ViewConversionDispatcher.element element event}.
       * @returns {engine.model.DocumentFragment} Model document fragment that is a result of the conversion process.
       */


      createClass(ViewConversionDispatcher, [{
        key: 'convert',
        value: function convert(viewItem) {
          var additionalData = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

          this.fire('viewCleanup', viewItem);

          var consumable = ViewConsumable.createFrom(viewItem);

          return this._convertItem(viewItem, consumable, additionalData);
        }

        /**
         * @private
         * @see engine.conversion.ViewConversionApi#convertItem
         */

      }, {
        key: '_convertItem',
        value: function _convertItem(input, consumable) {
          var additionalData = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

          var data = assignIn({}, additionalData, {
            input: input,
            output: null
          });

          if (input instanceof Element$1) {
            this.fire('element:' + input.name, data, consumable, this.conversionApi);
          } else if (input instanceof Text$2) {
            this.fire('text', data, consumable, this.conversionApi);
          } else {
            this.fire('documentFragment', data, consumable, this.conversionApi);
          }

          return data.output;
        }

        /**
         * @private
         * @see engine.conversion.ViewConversionApi#convertChildren
         */

      }, {
        key: '_convertChildren',
        value: function _convertChildren(input, consumable) {
          var _this = this;

          var additionalData = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

          var viewChildren = Array.from(input.getChildren());
          var convertedChildren = viewChildren.map(function (viewChild) {
            return _this._convertItem(viewChild, consumable, additionalData);
          });

          // Flatten and remove nulls.
          return convertedChildren.reduce(function (a, b) {
            return b ? a.concat(b) : a;
          }, []);
        }

        /**
         * Fired before the first conversion event, at the beginning of view to model conversion process.
         *
         * @event engine.conversion.ViewConversionDispatcher.viewCleanup
         * @param {engine.view.DocumentFragment|engine.view.Element} viewItem Part of the view to be converted.
         */

        /**
         * Fired when {@link engine.view.Element} is converted.
         *
         * `element` is a namespace event for a class of events. Names of actually called events follow this pattern:
         * `element:<elementName>` where `elementName` is the name of converted element. This way listeners may listen to
         * all elements conversion or to conversion of specific elements.
         *
         * @event engine.conversion.ViewConversionDispatcher.element
         * @param {Object} data Object containing conversion input and a placeholder for conversion output and possibly other
         * values (see {@link engine.conversion.ViewConversionDispatcher#convert}). Keep in mind that this object is shared
         * by reference between all callbacks that will be called. This means that callbacks can add their own values if needed,
         * and those values will be available in other callbacks.
         * @param {engine.view.Element} data.input Converted element.
         * @param {*} data.output The current state of conversion result. Every change to converted element should
         * be reflected by setting or modifying this property.
         * @param {engine.conversion.ViewConsumable} consumable Values to consume.
         * @param {Object} conversionApi Conversion interface to be used by callback, passed in `ViewConversionDispatcher` constructor.
         * Besides of properties passed in constructor, it also has `convertItem` and `convertChildren` methods which are references
         * to {@link engine.conversion.ViewConversionDispatcher#_convertItem} and
         * {@link engine.conversion.ViewConversionDispatcher#_convertChildren}. Those methods are needed to convert
         * the whole view-tree they were exposed in `conversionApi` for callbacks.
         */

        /**
         * Fired when {@link engine.view.Text} is converted.
         *
         * @event engine.conversion.ViewConversionDispatcher.text
         * @see engine.conversion.ViewConversionDispatcher.element
         */

        /**
         * Fired when {@link engine.view.DocumentFragment} is converted.
         *
         * @event engine.conversion.ViewConversionDispatcher.documentFragment
         * @see engine.conversion.ViewConversionDispatcher.element
         */

      }]);
      return ViewConversionDispatcher;
    }();

    mix(ViewConversionDispatcher, EmitterMixin);

    /**
     * Contains {@link engine.view view} to {@link engine.model model} converters for
     * {@link engine.conversion.ViewConversionDispatcher}.
     *
     * @namespace engine.conversion.viewToModel
     */

    /**
     * Function factory, creates a converter that converts {@link engine.view.DocumentFragment view document fragment} or
     * all children of {@link engine.view.Element} into {@link engine.model.DocumentFragment model document fragment}.
     * This is the "entry-point" converter for view to model conversion. This converter starts the conversion of all "children"
     * of passed view document fragment. Those "children" {@link engine.view.Node view nodes} are then handled by other converters.
     *
     * This also a "default", last resort converter for all view elements that has not been converted by other converters.
     * When a view element is converted to the model and it does not have it's converter specified, all of that elements
     * children will be converted to {@link engine.model.DocumentFragment} and returned.
     *
     * @external engine.conversion.viewToModel
     * @function engine.conversion.viewToModel.convertToModelFragment
     * @returns {Function} Universal converter for view {@link engine.view.DocumentFragment fragments} and
     * {@link engine.view.Element elements} that returns {@link engine.model.DocumentFragment model fragment} with
     * children of converted view item.
     */
    function convertToModelFragment() {
      return function (evt, data, consumable, conversionApi) {
        // Second argument in `consumable.test` is discarded for ViewDocumentFragment but is needed for ViewElement.
        if (!data.output && consumable.test(data.input, { name: true })) {
          var convertedChildren = conversionApi.convertChildren(data.input, consumable, data);

          data.output = new DocumentFragment(convertedChildren);
        }
      };
    }

    /**
     * Function factory, creates a converter that converts {@link engine.view.Text} to {@link engine.model.Text}.
     *
     * @external engine.conversion.viewToModel
     * @function engine.conversion.viewToModel.convertText
     * @returns {Function} {@link engine.view.Text View text} converter.
     */
    function convertText() {
      return function (evt, data, consumable, conversionApi) {
        var schemaQuery = {
          name: '$text',
          inside: data.context
        };

        if (conversionApi.schema.check(schemaQuery)) {
          if (consumable.consume(data.input)) {
            data.output = new Text$1(data.input.data);
          }
        }
      };
    }

    // Default attribute priority.
    var DEFAULT_PRIORITY = 10;

    /**
     * Attributes are elements which define document presentation. They are mostly elements like `<b>` or `<span>`.
     * Attributes can be broken and merged by the {@link engine.view.Writer}.
     *
     * Editing engine does not define fixed HTML DTD. This is why the type of the {@link engine.view.Element} need to
     * be defined by the feature developer. Creating an element you should use {@link engine.view.ContainerElement}
     * class or `AttributeElement`.
     *
     * @memberOf engine.view
     * @extends engine.view.Element
     */

    var AttributeElement = function (_Element) {
    	inherits(AttributeElement, _Element);

    	/**
      * Creates a attribute element.
      *
      * @see engine.view.Element
      */

    	function AttributeElement(name, attrs, children) {
    		classCallCheck(this, AttributeElement);


    		/**
       * Element priority. Attributes have to have the same priority to be
       * {@link engine.view.Element#isSimilar similar}. Setting different priorities on similar
      	 * nodes may prevent merging, e.g. two `<abbr>` nodes next each other shouldn't be merged.
       *
       * @member {Number} engine.view.AttributeElement#priority
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(AttributeElement).call(this, name, attrs, children));

    		_this.priority = DEFAULT_PRIORITY;
    		return _this;
    	}

    	/**
      * Clones provided element with priority.
      *
      * @param {Boolean} deep If set to `true` clones element and all its children recursively. When set to `false`,
      * element will be cloned without any children.
      * @returns {engine.view.AttributeElement} Clone of this element.
      */


    	createClass(AttributeElement, [{
    		key: 'clone',
    		value: function clone(deep) {
    			var cloned = get(Object.getPrototypeOf(AttributeElement.prototype), 'clone', this).call(this, deep);

    			// Clone priority too.
    			cloned.priority = this.priority;

    			return cloned;
    		}

    		/**
       * Checks if this element is similar to other element.
       * Both elements should have the same name, attributes and priority to be considered as similar.
       * Two similar elements can contain different set of children nodes.
       *
       * @param {engine.view.Element} otherElement
       * @returns {Boolean}
       */

    	}, {
    		key: 'isSimilar',
    		value: function isSimilar(otherElement) {
    			return get(Object.getPrototypeOf(AttributeElement.prototype), 'isSimilar', this).call(this, otherElement) && this.priority == otherElement.priority;
    		}

    		/**
       * Returns block {@link engine.view.filler filler} offset or `null` if a block filler is not needed.
       *
       * @returns {Number|null} Block filler offset or `null` if block filler is not needed.
       */

    	}, {
    		key: 'getFillerOffset',
    		value: function getFillerOffset() {
    			// <b>foo</b> does not need filler.
    			if (this.getChildCount()) {
    				return null;
    			}

    			var element = this.parent;

    			// <p><b></b></p> needs filler -> <p><b><br></b></p>
    			while (element instanceof AttributeElement) {
    				if (element.getChildCount() > 1) {
    					return null;
    				}

    				element = element.parent;
    			}

    			if (!element || element.getChildCount() > 1) {
    				return null;
    			}

    			return 0;
    		}
    	}]);
    	return AttributeElement;
    }(Element$1);

    AttributeElement.DEFAULT_PRIORITY = DEFAULT_PRIORITY;

    /**
     * Tree View Writer class.
     * Writer defines a high-level API for view manipulations.
     *
     * @memberOf engine.view
     */

    var Writer = function () {
    	function Writer() {
    		classCallCheck(this, Writer);
    	}

    	createClass(Writer, [{
    		key: 'getParentContainer',

    		/**
       * Returns first parent container of specified {@link engine.view.Position Position}.
       * Position's parent node is checked as first, then next parents are checked.
       *
       * Note that {@link engine.view.DocumentFragment DocumentFragment} is thread like a container.
       *
       * @param {engine.view.Position} position Position used as a start point to locate parent container.
       * @returns {engine.view.ContainerElement|engine.view.DocumentFragment|undefined} Parent container element or
       * `undefined` if container is not found.
       */
    		value: function getParentContainer(position) {
    			var parent = position.parent;

    			while (!isContainerOrFragment(parent)) {
    				if (!parent) {
    					return undefined;
    				}
    				parent = parent.parent;
    			}

    			return parent;
    		}

    		/**
       * Breaks attribute nodes at provided position. It breaks `attribute` nodes inside `container` node.
       *
       * In following examples `<p>` is a container, `<b>` and `<u>` are attribute nodes:
       *
       *		<p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>
       *		<p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>
       *		<p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>
       *
       * Note that {@link engine.view.DocumentFragment DocumentFragment} is thread like a container.
       *
       * @see engine.view.AttributeElement
       * @see engine.view.ContainerElement
       * @param {engine.view.Position} position Position where to break attributes.
       * @returns {engine.view.Position} New position after breaking the attributes.
       */

    	}, {
    		key: 'breakAttributes',
    		value: function breakAttributes(position) {
    			return this._breakAttributes(position, false);
    		}

    		/**
       * Private method used by both public breakAttributes (without splitting text nodes) and by other methods (with
       * splitting text nodes).
       *
       * @private
       * @param {engine.view.Position} position Position where to break attributes.
       * @param {Boolean} [forceSplitText = false] If set to `true`, will break text nodes even if they are directly in
       * container element. This behavior will result in incorrect view state, but is needed by other `Writer` methods
       * which then fixes view state. Defaults to `false`.
       * @returns {engine.view.Position} New position after breaking the attributes.
       */

    	}, {
    		key: '_breakAttributes',
    		value: function _breakAttributes(position) {
    			var forceSplitText = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

    			var positionOffset = position.offset;
    			var positionParent = position.parent;

    			// There are no attributes to break and text nodes breaking is not forced.
    			if (!forceSplitText && positionParent instanceof Text$2 && isContainerOrFragment(positionParent.parent)) {
    				return Position$1.createFromPosition(position);
    			}

    			// Position's parent is container, so no attributes to break.
    			if (isContainerOrFragment(positionParent)) {
    				return Position$1.createFromPosition(position);
    			}

    			// Break text and start again in new position.
    			if (positionParent instanceof Text$2) {
    				return this._breakAttributes(breakTextNode(position), forceSplitText);
    			}

    			var length = positionParent.getChildCount();

    			// <p>foo<b><u>bar{}</u></b></p>
    			// <p>foo<b><u>bar</u>[]</b></p>
    			// <p>foo<b><u>bar</u></b>[]</p>
    			if (positionOffset == length) {
    				var newPosition = new Position$1(positionParent.parent, positionParent.getIndex() + 1);

    				return this._breakAttributes(newPosition, forceSplitText);
    			} else
    				// <p>foo<b><u>{}bar</u></b></p>
    				// <p>foo<b>[]<u>bar</u></b></p>
    				// <p>foo{}<b><u>bar</u></b></p>
    				if (positionOffset === 0) {
    					var _newPosition = new Position$1(positionParent.parent, positionParent.getIndex());

    					return this._breakAttributes(_newPosition, forceSplitText);
    				}
    				// <p>foo<b><u>b{}ar</u></b></p>
    				// <p>foo<b><u>b[]ar</u></b></p>
    				// <p>foo<b><u>b</u>[]<u>ar</u></b></p>
    				// <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>
    				else {
    						var offsetAfter = positionParent.getIndex() + 1;

    						// Break element.
    						var clonedNode = positionParent.clone();

    						// Insert cloned node to position's parent node.
    						positionParent.parent.insertChildren(offsetAfter, clonedNode);

    						// Get nodes to move.
    						var count = positionParent.getChildCount() - positionOffset;
    						var nodesToMove = positionParent.removeChildren(positionOffset, count);

    						// Move nodes to cloned node.
    						clonedNode.appendChildren(nodesToMove);

    						// Create new position to work on.
    						var _newPosition2 = new Position$1(positionParent.parent, offsetAfter);

    						return this._breakAttributes(_newPosition2, forceSplitText);
    					}
    		}

    		/**
       * Uses {@link engine.view.Writer#breakAttributes breakAttributes} method to break attributes on
       * {@link engine.view.Range#start start} and {@link engine.view.Range#end end} positions of
       * provided {@link engine.view.Range Range}.
       *
       * Throws {@link utils.CKEditorError CKEditorError} `view-writer-invalid-range-container` when
       * {@link engine.view.Range#start start} and {@link engine.view.Range#end end} positions are not placed inside
       * same parent container.
       *
       * Note that {@link engine.view.DocumentFragment DocumentFragment} is thread like a container.
       *
       * @see engine.view.Writer#breakAttribute
       * @param {engine.view.Range} range Range which `start` and `end` positions will be used to break attributes.
       * @returns {engine.view.Range} New range with located at break positions.
       */

    	}, {
    		key: 'breakRange',
    		value: function breakRange(range) {
    			return this._breakRange(range);
    		}

    		/**
       * Private method used by both public breakRange (without splitting text nodes) and by other methods (with
       * splitting text nodes).
       *
       * @private
       * @see engine.view.Writer#_breakAttribute
       * @param {engine.view.Range} range Range which `start` and `end` positions will be used to break attributes.
       * @param {Boolean} [forceSplitText = false] If set to `true`, will break text nodes even if they are directly in
       * container element. This behavior will result in incorrect view state, but is needed by other `Writer` methods
       * which then fixes view state. Defaults to `false`.
       * @returns {engine.view.Range} New range with located at break positions.
       */

    	}, {
    		key: '_breakRange',
    		value: function _breakRange(range) {
    			var forceSplitText = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

    			var rangeStart = range.start;
    			var rangeEnd = range.end;

    			// Range should be placed inside one container.
    			if (this.getParentContainer(rangeStart) !== this.getParentContainer(rangeEnd)) {
    				/**
         * Range is not placed inside same container.
         *
         * @error view-writer-invalid-range-container
         */
    				throw new CKEditorError('view-writer-invalid-range-container');
    			}

    			// Break at the collapsed position. Return new collapsed range.
    			if (range.isCollapsed) {
    				var position = this._breakAttributes(range.start, forceSplitText);

    				return new Range$2(position, position);
    			}

    			var breakEnd = this._breakAttributes(rangeEnd, forceSplitText);
    			var count = breakEnd.parent.getChildCount();
    			var breakStart = this._breakAttributes(rangeStart, forceSplitText);

    			// Calculate new break end offset.
    			breakEnd.offset += breakEnd.parent.getChildCount() - count;

    			return new Range$2(breakStart, breakEnd);
    		}

    		/**
       * Merges attribute nodes. It also merges text nodes if needed.
       * Only {@link engine.view.AttributeElement#isSimilar similar} `attribute` nodes can be merged.
       *
       * In following examples `<p>` is a container and `<b>` is an attribute node:
       *
       *		<p>foo[]bar</p> -> <p>foo{}bar</p>
       *		<p><b>foo</b>[]<b>bar</b> -> <p><b>foo{}bar</b></b>
       *		<p><b foo="bar">a</b>[]<b foo="baz">b</b> -> <p><b foo="bar">a</b>[]<b foo="baz">b</b>
       *
       * It will also take care about empty attributes when merging:
       *
       *		<p><b>[]</b></p> -> <p>[]</p>
       *		<p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>
       *
       * @see engine.view.AttributeElement
       * @see engine.view.ContainerElement
       * @param {engine.view.Position} position Merge position.
       * @returns {engine.view.Position} Position after merge.
       */

    	}, {
    		key: 'mergeAttributes',
    		value: function mergeAttributes(position) {
    			var positionOffset = position.offset;
    			var positionParent = position.parent;

    			// When inside text node - nothing to merge.
    			if (positionParent instanceof Text$2) {
    				return position;
    			}

    			// When inside empty attribute - remove it.
    			if (positionParent instanceof AttributeElement && positionParent.getChildCount() === 0) {
    				var parent = positionParent.parent;
    				var offset = positionParent.getIndex();
    				positionParent.remove();

    				return this.mergeAttributes(new Position$1(parent, offset));
    			}

    			var nodeBefore = positionParent.getChild(positionOffset - 1);
    			var nodeAfter = positionParent.getChild(positionOffset);

    			// Position should be placed between two nodes.
    			if (!nodeBefore || !nodeAfter) {
    				return position;
    			}

    			// When one or both nodes are containers - no attributes to merge.
    			if (nodeBefore instanceof ContainerElement || nodeAfter instanceof ContainerElement) {
    				return position;
    			}

    			// When position is between two text nodes.
    			if (nodeBefore instanceof Text$2 && nodeAfter instanceof Text$2) {
    				return mergeTextNodes(nodeBefore, nodeAfter);
    			}

    			// When selection is between same nodes.
    			else if (nodeBefore.isSimilar(nodeAfter)) {
    					// Move all children nodes from node placed after selection and remove that node.
    					var count = nodeBefore.getChildCount();
    					nodeBefore.appendChildren(nodeAfter.getChildren());
    					nodeAfter.remove();

    					// New position is located inside the first node, before new nodes.
    					// Call this method recursively to merge again if needed.
    					return this.mergeAttributes(new Position$1(nodeBefore, count));
    				}

    			return position;
    		}

    		/**
       * Insert node or nodes at specified position. Takes care about breaking attributes before insertion
       * and merging them afterwards.
       *
       * Throws {@link utils.CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert
       * contains instances that are not {@link engine.view.Text Texts},
       * {@link engine.view.AttributeElement AttributeElements} or
       * {@link engine.view.ContainerElement ContainerElements}.
       *
       * @param {engine.view.Position} position Insertion position.
       * @param {engine.view.Text|engine.view.AttributeElement|engine.view.ContainerElement
       * |Iterable.<engine.view.Text|engine.view.AttributeElement|engine.view.ContainerElement>} nodes Node or
       * nodes to insert.
       * @returns {engine.view.Range} Range around inserted nodes.
       */

    	}, {
    		key: 'insert',
    		value: function insert(position, nodes) {
    			nodes = isIterable(nodes) ? [].concat(toConsumableArray(nodes)) : [nodes];

    			// Check if nodes to insert are instances of AttributeElements, ContainerElements or Text.
    			validateNodesToInsert(nodes);

    			var container = this.getParentContainer(position);
    			var insertionPosition = this._breakAttributes(position, true);

    			var length = container.insertChildren(insertionPosition.offset, nodes);
    			var endPosition = insertionPosition.getShiftedBy(length);
    			var start = this.mergeAttributes(insertionPosition);

    			// When no nodes were inserted - return collapsed range.
    			if (length === 0) {
    				return new Range$2(start, start);
    			} else {
    				// If start position was merged - move end position.
    				if (!start.isEqual(insertionPosition)) {
    					endPosition.offset--;
    				}

    				var end = this.mergeAttributes(endPosition);

    				return new Range$2(start, end);
    			}
    		}

    		/**
       * Removes provided range from the container.
       *
       * Throws {@link utils.CKEditorError CKEditorError} `view-writer-invalid-range-container` when
       * {@link engine.view.Range#start start} and {@link engine.view.Range#end end} positions are not placed inside
       * same parent container.
       *
       * @param {engine.view.Range} range Range to remove from container. After removing, it will be updated
       * to a collapsed range showing the new position.
       * @returns {engine.view.DocumentFragment} Document fragment containing removed nodes.
       */

    	}, {
    		key: 'remove',
    		value: function remove(range) {
    			// Range should be placed inside one container.
    			if (this.getParentContainer(range.start) !== this.getParentContainer(range.end)) {
    				/**
         * Range is not placed inside same container.
         *
         * @error view-writer-invalid-range-container
         */
    				throw new CKEditorError('view-writer-invalid-range-container');
    			}

    			// If range is collapsed - nothing to remove.
    			if (range.isCollapsed) {
    				return new DocumentFragment$1();
    			}

    			// Break attributes at range start and end.

    			var _breakRange2 = this._breakRange(range, true);

    			var breakStart = _breakRange2.start;
    			var breakEnd = _breakRange2.end;

    			var parentContainer = breakStart.parent;

    			var count = breakEnd.offset - breakStart.offset;

    			// Remove nodes in range.
    			var removed = parentContainer.removeChildren(breakStart.offset, count);

    			// Merge after removing.
    			var mergePosition = this.mergeAttributes(breakStart);
    			range.start = mergePosition;
    			range.end = Position$1.createFromPosition(mergePosition);

    			// Return removed nodes.
    			return new DocumentFragment$1(removed);
    		}

    		/**
       * Moves nodes from provided range to target position.
       *
       * Throws {@link utils.CKEditorError CKEditorError} `view-writer-invalid-range-container` when
       * {@link engine.view.Range#start start} and {@link engine.view.Range#end end} positions are not placed inside
       * same parent container.
       *
       * @param {engine.view.Range} sourceRange Range containing nodes to move.
       * @param {engine.view.Position} targetPosition Position to insert.
       * @returns {engine.view.Range} Range in target container. Inserted nodes are placed between
       * {@link engine.view.Range#start start} and {@link engine.view.Range#end end} positions.
       */

    	}, {
    		key: 'move',
    		value: function move(sourceRange, targetPosition) {
    			var nodes = this.remove(sourceRange);

    			return this.insert(targetPosition, nodes);
    		}

    		/**
       * Wraps elements within range with provided {@link engine.view.AttributeElement AttributeElement}.
       *
       * Throws {@link utils.CKEditorError} `view-writer-invalid-range-container` when {@link engine.view.Range#start}
       * and {@link engine.view.Range#end} positions are not placed inside same parent container.
       * Throws {@link utils.CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
       * an instance of {engine.view.AttributeElement AttributeElement}.
       *
       * @param {engine.view.Range} range Range to wrap.
       * @param {engine.view.AttributeElement} attribute Attribute element to use as wrapper.
       */

    	}, {
    		key: 'wrap',
    		value: function wrap(range, attribute) {
    			if (!(attribute instanceof AttributeElement)) {
    				/**
         * Attribute element need to be instance of attribute element.
         *
         * @error view-writer-wrap-invalid-attribute
         */
    				throw new CKEditorError('view-writer-wrap-invalid-attribute');
    			}

    			// Range should be placed inside one container.
    			if (this.getParentContainer(range.start) !== this.getParentContainer(range.end)) {
    				/**
         * Range is not placed inside same container.
         *
         * @error view-writer-invalid-range-container
         */
    				throw new CKEditorError('view-writer-invalid-range-container');
    			}

    			// If range is collapsed - nothing to wrap.
    			if (range.isCollapsed) {
    				return range;
    			}

    			// Range around one element.
    			if (range.end.isEqual(range.start.getShiftedBy(1))) {
    				var node = range.start.nodeAfter;

    				if (node instanceof AttributeElement && wrapAttributeElement(attribute, node)) {
    					return range;
    				}
    			}

    			// Range is inside single attribute and spans on all children.
    			if (rangeSpansOnAllChildren(range) && wrapAttributeElement(attribute, range.start.parent)) {
    				var parent = range.start.parent.parent;
    				var index = range.start.parent.getIndex();

    				return Range$2.createFromParentsAndOffsets(parent, index, parent, index + 1);
    			}

    			// Break attributes at range start and end.

    			var _breakRange3 = this._breakRange(range, true);

    			var breakStart = _breakRange3.start;
    			var breakEnd = _breakRange3.end;

    			var parentContainer = breakStart.parent;

    			// Unwrap children located between break points.
    			var unwrappedRange = unwrapChildren(this, parentContainer, breakStart.offset, breakEnd.offset, attribute);

    			// Wrap all children with attribute.
    			var newRange = wrapChildren(this, parentContainer, unwrappedRange.start.offset, unwrappedRange.end.offset, attribute);

    			// Merge attributes at the both ends and return a new range.
    			var start = this.mergeAttributes(newRange.start);

    			// If start position was merged - move end position back.
    			if (!start.isEqual(newRange.start)) {
    				newRange.end.offset--;
    			}
    			var end = this.mergeAttributes(newRange.end);

    			return new Range$2(start, end);
    		}

    		/**
       * Wraps position with provided attribute. Returns new position after wrapping. This method will also merge newly
       * added attribute with its siblings whenever possible.
       *
       * Throws {@link utils.CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
       * an instance of {engine.view.AttributeElement AttributeElement}.
       *
       * @param {engine.view.Position} position
       * @param {engine.view.AttributeElement} attribute
       * @returns {Position} New position after wrapping.
       */

    	}, {
    		key: 'wrapPosition',
    		value: function wrapPosition(position, attribute) {
    			if (!(attribute instanceof AttributeElement)) {
    				/**
         * Attribute element need to be instance of attribute element.
         *
         * @error view-writer-wrap-invalid-attribute
         */
    				throw new CKEditorError('view-writer-wrap-invalid-attribute');
    			}

    			// Return same position when trying to wrap with attribute similar to position parent.
    			if (attribute.isSimilar(position.parent)) {
    				return movePositionToTextNode(Position$1.createFromPosition(position));
    			}

    			// When position is inside text node - break it and place new position between two text nodes.
    			if (position.parent instanceof Text$2) {
    				position = breakTextNode(position);
    			}

    			// Create fake element that will represent position, and will not be merged with other attributes.
    			var fakePosition = new AttributeElement();
    			fakePosition.priority = Number.POSITIVE_INFINITY;
    			fakePosition.isSimilar = function () {
    				return false;
    			};

    			// Insert fake element in position location.
    			position.parent.insertChildren(position.offset, fakePosition);

    			// Range around inserted fake attribute element.
    			var wrapRange = new Range$2(position, position.getShiftedBy(1));

    			// Wrap fake element with attribute (it will also merge if possible).
    			this.wrap(wrapRange, attribute);

    			// Remove fake element and place new position there.
    			var newPosition = new Position$1(fakePosition.parent, fakePosition.getIndex());
    			fakePosition.remove();

    			// If position is placed between text nodes - merge them and return position inside.
    			var nodeBefore = newPosition.nodeBefore;
    			var nodeAfter = newPosition.nodeAfter;

    			if (nodeBefore instanceof Text$2 && nodeAfter instanceof Text$2) {
    				return mergeTextNodes(nodeBefore, nodeAfter);
    			}

    			// If position is next to text node - move position inside.
    			return movePositionToTextNode(newPosition);
    		}

    		/**
       * Unwraps nodes within provided range from attribute element.
       *
       * Throws {@link utils.CKEditorError CKEditorError} `view-writer-invalid-range-container` when
       * {@link engine.view.Range#start start} and {@link engine.view.Range#end end} positions are not placed inside
       * same parent container.
       *
       * @param {engine.view.Range} range
       * @param {engine.view.AttributeElement} element
       */

    	}, {
    		key: 'unwrap',
    		value: function unwrap(range, attribute) {
    			if (!(attribute instanceof AttributeElement)) {
    				/**
         * Attribute element need to be instance of attribute element.
         *
         * @error view-writer-unwrap-invalid-attribute
         */
    				throw new CKEditorError('view-writer-unwrap-invalid-attribute');
    			}

    			// Range should be placed inside one container.
    			if (this.getParentContainer(range.start) !== this.getParentContainer(range.end)) {
    				/**
         * Range is not placed inside same container.
         *
         * @error view-writer-invalid-range-container
         */
    				throw new CKEditorError('view-writer-invalid-range-container');
    			}

    			// If range is collapsed - nothing to unwrap.
    			if (range.isCollapsed) {
    				return range;
    			}

    			// Range around one element - check if AttributeElement can be unwrapped partially when it's not similar.
    			// For example:
    			// <b class="foo bar" title="baz"></b> unwrap with:	<b class="foo"></p> result: <b class"bar" title="baz"></b>
    			if (range.end.isEqual(range.start.getShiftedBy(1))) {
    				var node = range.start.nodeAfter;

    				// Unwrap single attribute element.
    				if (!attribute.isSimilar(node) && node instanceof AttributeElement && unwrapAttributeElement(attribute, node)) {
    					return range;
    				}
    			}

    			// Break attributes at range start and end.

    			var _breakRange4 = this._breakRange(range, true);

    			var breakStart = _breakRange4.start;
    			var breakEnd = _breakRange4.end;

    			var parentContainer = breakStart.parent;

    			// Unwrap children located between break points.
    			var newRange = unwrapChildren(this, parentContainer, breakStart.offset, breakEnd.offset, attribute);

    			// Merge attributes at the both ends and return a new range.
    			var start = this.mergeAttributes(newRange.start);

    			// If start position was merged - move end position back.
    			if (!start.isEqual(newRange.start)) {
    				newRange.end.offset--;
    			}
    			var end = this.mergeAttributes(newRange.end);

    			return new Range$2(start, end);
    		}
    	}]);
    	return Writer;
    }();

    function unwrapChildren(writer, parent, startOffset, endOffset, attribute) {
    	var i = startOffset;
    	var unwrapPositions = [];

    	// Iterate over each element between provided offsets inside parent.
    	while (i < endOffset) {
    		var child = parent.getChild(i);

    		// If attributes are the similar, then unwrap.
    		if (child.isSimilar(attribute)) {
    			var unwrapped = child.getChildren();
    			var count = child.getChildCount();

    			// Replace wrapper element with its children
    			child.remove();
    			parent.insertChildren(i, unwrapped);

    			// Save start and end position of moved items.
    			unwrapPositions.push(new Position$1(parent, i), new Position$1(parent, i + count));

    			// Skip elements that were unwrapped. Assuming that there won't be another element to unwrap in child
    			// elements.
    			i += count;
    			endOffset += count - 1;
    		} else {
    			// If other nested attribute is found start unwrapping there.
    			if (child instanceof AttributeElement) {
    				unwrapChildren(writer, child, 0, child.getChildCount(), attribute);
    			}

    			i++;
    		}
    	}

    	// Merge at each unwrap.
    	var offsetChange = 0;

    	var _iteratorNormalCompletion = true;
    	var _didIteratorError = false;
    	var _iteratorError = undefined;

    	try {
    		for (var _iterator = unwrapPositions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    			var position = _step.value;

    			position.offset -= offsetChange;

    			// Do not merge with elements outside selected children.
    			if (position.offset == startOffset || position.offset == endOffset) {
    				continue;
    			}

    			var newPosition = writer.mergeAttributes(position);

    			// If nodes were merged - other merge offsets will change.
    			if (!newPosition.isEqual(position)) {
    				offsetChange++;
    				endOffset--;
    			}
    		}
    	} catch (err) {
    		_didIteratorError = true;
    		_iteratorError = err;
    	} finally {
    		try {
    			if (!_iteratorNormalCompletion && _iterator.return) {
    				_iterator.return();
    			}
    		} finally {
    			if (_didIteratorError) {
    				throw _iteratorError;
    			}
    		}
    	}

    	return Range$2.createFromParentsAndOffsets(parent, startOffset, parent, endOffset);
    }

    // Wraps children with provided `attribute`. Only children contained in `parent` element between
    // `startOffset` and `endOffset` will be wrapped.

    // @private
    // @param {engine.view.Writer} writer
    // @param {engine.view.Element} parent
    // @param {Number} startOffset
    // @param {Number} endOffset
    // @param {engine.view.Element} attribute
    function wrapChildren(writer, parent, startOffset, endOffset, attribute) {
    	var i = startOffset;
    	var wrapPositions = [];

    	while (i < endOffset) {
    		var child = parent.getChild(i);
    		var isText = child instanceof Text$2;
    		var isAttribute = child instanceof AttributeElement;

    		// Wrap text or attributes with higher or equal priority.
    		if (isText || isAttribute && attribute.priority <= child.priority) {
    			// Clone attribute.
    			var newAttribute = attribute.clone();

    			// Wrap current node with new attribute;
    			child.remove();
    			newAttribute.appendChildren(child);
    			parent.insertChildren(i, newAttribute);

    			wrapPositions.push(new Position$1(parent, i));
    		} else {
    			// If other nested attribute is found start wrapping there.
    			if (child instanceof AttributeElement) {
    				wrapChildren(writer, child, 0, child.getChildCount(), attribute);
    			}
    		}

    		i++;
    	}

    	// Merge at each wrap.
    	var offsetChange = 0;

    	var _iteratorNormalCompletion2 = true;
    	var _didIteratorError2 = false;
    	var _iteratorError2 = undefined;

    	try {
    		for (var _iterator2 = wrapPositions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    			var position = _step2.value;

    			// Do not merge with elements outside selected children.
    			if (position.offset == startOffset) {
    				continue;
    			}

    			var newPosition = writer.mergeAttributes(position);

    			// If nodes were merged - other merge offsets will change.
    			if (!newPosition.isEqual(position)) {
    				offsetChange++;
    				endOffset--;
    			}
    		}
    	} catch (err) {
    		_didIteratorError2 = true;
    		_iteratorError2 = err;
    	} finally {
    		try {
    			if (!_iteratorNormalCompletion2 && _iterator2.return) {
    				_iterator2.return();
    			}
    		} finally {
    			if (_didIteratorError2) {
    				throw _iteratorError2;
    			}
    		}
    	}

    	return Range$2.createFromParentsAndOffsets(parent, startOffset, parent, endOffset);
    }

    // Returns new position that is moved to near text node. Returns same position if there is no text node before of after
    // specified position.
    //
    //		<p>foo[]</p>  ->  <p>foo{}</p>
    //		<p>[]foo</p>  ->  <p>{}foo</p>
    //
    // @private
    // @param {engine.view.Position} position
    // @returns {engine.view.Position} Position located inside text node or same position if there is no text nodes
    // before or after position location.
    function movePositionToTextNode(position) {
    	var nodeBefore = position.nodeBefore;

    	if (nodeBefore && nodeBefore instanceof Text$2) {
    		return new Position$1(nodeBefore, nodeBefore.data.length);
    	}

    	var nodeAfter = position.nodeAfter;

    	if (nodeAfter && nodeAfter instanceof Text$2) {
    		return new Position$1(nodeAfter, 0);
    	}

    	return position;
    }

    // Breaks text node into two text nodes when possible.
    //
    //		<p>foo{}bar</p> -> <p>foo[]bar</p>
    //		<p>{}foobar</p> -> <p>[]foobar</p>
    //		<p>foobar{}</p> -> <p>foobar[]</p>
    //
    // @private
    // @param {engine.view.Position} position Position that need to be placed inside text node.
    // @returns {engine.view.Position} New position after breaking text node.
    function breakTextNode(position) {
    	if (position.offset == position.parent.data.length) {
    		return new Position$1(position.parent.parent, position.parent.getIndex() + 1);
    	}

    	if (position.offset === 0) {
    		return new Position$1(position.parent.parent, position.parent.getIndex());
    	}

    	// Get part of the text that need to be moved.
    	var textToMove = position.parent.data.slice(position.offset);

    	// Leave rest of the text in position's parent.
    	position.parent.data = position.parent.data.slice(0, position.offset);

    	// Insert new text node after position's parent text node.
    	position.parent.parent.insertChildren(position.parent.getIndex() + 1, new Text$2(textToMove));

    	// Return new position between two newly created text nodes.
    	return new Position$1(position.parent.parent, position.parent.getIndex() + 1);
    }

    // Merges two text nodes into first node. Removes second node and returns merge position.
    //
    // @private
    // @param {engine.view.Text} t1 First text node to merge. Data from second text node will be moved at the end of
    // this text node.
    // @param {engine.view.Text} t2 Second text node to merge. This node will be removed after merging.
    // @returns {engine.view.Position} Position after merging text nodes.
    function mergeTextNodes(t1, t2) {
    	// Merge text data into first text node and remove second one.
    	var nodeBeforeLength = t1.data.length;
    	t1.data += t2.data;
    	t2.remove();

    	return new Position$1(t1, nodeBeforeLength);
    }

    // Wraps one {@link engine.view.AttributeElement AttributeElement} into another by merging them if possible.
    // Two AttributeElements can be merged when there is no attribute or style conflicts between them.
    // When merging is possible - all attributes, styles and classes are moved from wrapper element to element being
    // wrapped.
    //
    // @private
    // @param {engine.view.AttributeElement} wrapper Wrapper AttributeElement.
    // @param {engine.view.AttributeElement} toWrap AttributeElement to wrap using wrapper element.
    // @returns {Boolean} Returns `true` if elements are merged.
    function wrapAttributeElement(wrapper, toWrap) {
    	// Can't merge if name or priority differs.
    	if (wrapper.name !== toWrap.name || wrapper.priority !== toWrap.priority) {
    		return false;
    	}

    	// Check if attributes can be merged.
    	var _iteratorNormalCompletion3 = true;
    	var _didIteratorError3 = false;
    	var _iteratorError3 = undefined;

    	try {
    		for (var _iterator3 = wrapper.getAttributeKeys()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
    			var key = _step3.value;

    			// Classes and styles should be checked separately.
    			if (key === 'class' || key === 'style') {
    				continue;
    			}

    			// If some attributes are different we cannot wrap.
    			if (toWrap.hasAttribute(key) && toWrap.getAttribute(key) !== wrapper.getAttribute(key)) {
    				return false;
    			}
    		}

    		// Check if styles can be merged.
    	} catch (err) {
    		_didIteratorError3 = true;
    		_iteratorError3 = err;
    	} finally {
    		try {
    			if (!_iteratorNormalCompletion3 && _iterator3.return) {
    				_iterator3.return();
    			}
    		} finally {
    			if (_didIteratorError3) {
    				throw _iteratorError3;
    			}
    		}
    	}

    	var _iteratorNormalCompletion4 = true;
    	var _didIteratorError4 = false;
    	var _iteratorError4 = undefined;

    	try {
    		for (var _iterator4 = wrapper.getStyleNames()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
    			var _key = _step4.value;

    			if (toWrap.hasStyle(_key) && toWrap.getStyle(_key) !== wrapper.getStyle(_key)) {
    				return false;
    			}
    		}

    		// Move all attributes/classes/styles from wrapper to wrapped AttributeElement.
    	} catch (err) {
    		_didIteratorError4 = true;
    		_iteratorError4 = err;
    	} finally {
    		try {
    			if (!_iteratorNormalCompletion4 && _iterator4.return) {
    				_iterator4.return();
    			}
    		} finally {
    			if (_didIteratorError4) {
    				throw _iteratorError4;
    			}
    		}
    	}

    	var _iteratorNormalCompletion5 = true;
    	var _didIteratorError5 = false;
    	var _iteratorError5 = undefined;

    	try {
    		for (var _iterator5 = wrapper.getAttributeKeys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
    			var _key2 = _step5.value;

    			// Classes and styles should be checked separately.
    			if (_key2 === 'class' || _key2 === 'style') {
    				continue;
    			}

    			// Move only these attributes that are not present - other are similar.
    			if (!toWrap.hasAttribute(_key2)) {
    				toWrap.setAttribute(_key2, wrapper.getAttribute(_key2));
    			}
    		}
    	} catch (err) {
    		_didIteratorError5 = true;
    		_iteratorError5 = err;
    	} finally {
    		try {
    			if (!_iteratorNormalCompletion5 && _iterator5.return) {
    				_iterator5.return();
    			}
    		} finally {
    			if (_didIteratorError5) {
    				throw _iteratorError5;
    			}
    		}
    	}

    	var _iteratorNormalCompletion6 = true;
    	var _didIteratorError6 = false;
    	var _iteratorError6 = undefined;

    	try {
    		for (var _iterator6 = wrapper.getStyleNames()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
    			var _key3 = _step6.value;

    			if (!toWrap.hasStyle(_key3)) {
    				toWrap.setStyle(_key3, wrapper.getStyle(_key3));
    			}
    		}
    	} catch (err) {
    		_didIteratorError6 = true;
    		_iteratorError6 = err;
    	} finally {
    		try {
    			if (!_iteratorNormalCompletion6 && _iterator6.return) {
    				_iterator6.return();
    			}
    		} finally {
    			if (_didIteratorError6) {
    				throw _iteratorError6;
    			}
    		}
    	}

    	var _iteratorNormalCompletion7 = true;
    	var _didIteratorError7 = false;
    	var _iteratorError7 = undefined;

    	try {
    		for (var _iterator7 = wrapper.getClassNames()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
    			var _key4 = _step7.value;

    			if (!toWrap.hasClass(_key4)) {
    				toWrap.addClass(_key4);
    			}
    		}
    	} catch (err) {
    		_didIteratorError7 = true;
    		_iteratorError7 = err;
    	} finally {
    		try {
    			if (!_iteratorNormalCompletion7 && _iterator7.return) {
    				_iterator7.return();
    			}
    		} finally {
    			if (_didIteratorError7) {
    				throw _iteratorError7;
    			}
    		}
    	}

    	return true;
    }

    // Unwraps {@link engine.view.AttributeElement AttributeElement} from another by removing corresponding attributes,
    // classes and styles. All attributes, classes and styles from wrapper should be present inside element being unwrapped.
    //
    // @private
    // @param {engine.view.AttributeElement} wrapper Wrapper AttributeElement.
    // @param {engine.view.AttributeElement} toUnwrap AttributeElement to unwrap using wrapper element.
    // @returns {Boolean} Returns `true` if elements are unwrapped.
    function unwrapAttributeElement(wrapper, toUnwrap) {
    	// Can't unwrap if name or priority differs.
    	if (wrapper.name !== toUnwrap.name || wrapper.priority !== toUnwrap.priority) {
    		return false;
    	}

    	// Check if AttributeElement has all wrapper attributes.
    	var _iteratorNormalCompletion8 = true;
    	var _didIteratorError8 = false;
    	var _iteratorError8 = undefined;

    	try {
    		for (var _iterator8 = wrapper.getAttributeKeys()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
    			var key = _step8.value;

    			// Classes and styles should be checked separately.
    			if (key === 'class' || key === 'style') {
    				continue;
    			}

    			// If some attributes are missing or different we cannot unwrap.
    			if (!toUnwrap.hasAttribute(key) || toUnwrap.getAttribute(key) !== wrapper.getAttribute(key)) {
    				return false;
    			}
    		}

    		// Check if AttributeElement has all wrapper classes.
    	} catch (err) {
    		_didIteratorError8 = true;
    		_iteratorError8 = err;
    	} finally {
    		try {
    			if (!_iteratorNormalCompletion8 && _iterator8.return) {
    				_iterator8.return();
    			}
    		} finally {
    			if (_didIteratorError8) {
    				throw _iteratorError8;
    			}
    		}
    	}

    	if (!toUnwrap.hasClass.apply(toUnwrap, toConsumableArray(wrapper.getClassNames()))) {
    		return false;
    	}

    	// Check if AttributeElement has all wrapper styles.
    	var _iteratorNormalCompletion9 = true;
    	var _didIteratorError9 = false;
    	var _iteratorError9 = undefined;

    	try {
    		for (var _iterator9 = wrapper.getStyleNames()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
    			var _key5 = _step9.value;

    			// If some styles are missing or different we cannot unwrap.
    			if (!toUnwrap.hasStyle(_key5) || toUnwrap.getStyle(_key5) !== wrapper.getStyle(_key5)) {
    				return false;
    			}
    		}

    		// Remove all wrapper's attributes from unwrapped element.
    	} catch (err) {
    		_didIteratorError9 = true;
    		_iteratorError9 = err;
    	} finally {
    		try {
    			if (!_iteratorNormalCompletion9 && _iterator9.return) {
    				_iterator9.return();
    			}
    		} finally {
    			if (_didIteratorError9) {
    				throw _iteratorError9;
    			}
    		}
    	}

    	var _iteratorNormalCompletion10 = true;
    	var _didIteratorError10 = false;
    	var _iteratorError10 = undefined;

    	try {
    		for (var _iterator10 = wrapper.getAttributeKeys()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
    			var _key6 = _step10.value;

    			// Classes and styles should be checked separately.
    			if (_key6 === 'class' || _key6 === 'style') {
    				continue;
    			}

    			toUnwrap.removeAttribute(_key6);
    		}

    		// Remove all wrapper's classes from unwrapped element.
    	} catch (err) {
    		_didIteratorError10 = true;
    		_iteratorError10 = err;
    	} finally {
    		try {
    			if (!_iteratorNormalCompletion10 && _iterator10.return) {
    				_iterator10.return();
    			}
    		} finally {
    			if (_didIteratorError10) {
    				throw _iteratorError10;
    			}
    		}
    	}

    	toUnwrap.removeClass.apply(toUnwrap, toConsumableArray(wrapper.getClassNames()));

    	// Remove all wrapper's styles from unwrapped element.
    	toUnwrap.removeStyle.apply(toUnwrap, toConsumableArray(wrapper.getStyleNames()));

    	return true;
    }

    // Returns `true` if range is located in same {@link engine.view.AttributeElement AttributeElement}
    // (`start` and `end` positions are located inside same {@link engine.view.AttributeElement AttributeElement}),
    // starts on 0 offset and ends after last child node.
    //
    // @private
    // @param {engine.view.Range} Range
    // @returns {Boolean}
    function rangeSpansOnAllChildren(range) {
    	return range.start.parent == range.end.parent && range.start.parent instanceof AttributeElement && range.start.offset === 0 && range.end.offset === range.start.parent.getChildCount();
    }

    // Checks if provided nodes are valid to insert by writer. Checks if each node is an instance of
    // {@link engine.view.Text Text} or {@link engine.view.AttributeElement AttributeElement} or
    // {@link engine.view.ContainerElement ContainerElement}.
    //
    // Throws {@link utils.CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert
    // contains instances that are not {@link engine.view.Text Texts},
    // {@link engine.view.AttributeElement AttributeElements} or
    // {@link engine.view.ContainerElement ContainerElements}.
    //
    // @private
    // @param Iterable.<engine.view.Text|engine.view.AttributeElement|engine.view.ContainerElement> nodes
    function validateNodesToInsert(nodes) {
    	var _iteratorNormalCompletion11 = true;
    	var _didIteratorError11 = false;
    	var _iteratorError11 = undefined;

    	try {
    		for (var _iterator11 = nodes[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
    			var node = _step11.value;

    			if (!(node instanceof Text$2 || node instanceof AttributeElement || node instanceof ContainerElement)) {
    				/**
         * Inserted nodes should be instance of {@link engine.view.AttributeElement AttributeElement},
         * {@link engine.view.ContainerElement ContainerElement} or {@link engine.view.Text Text}.
         *
         * @error view-writer-insert-invalid-node
         */
    				throw new CKEditorError('view-writer-insert-invalid-node');
    			}

    			if (!(node instanceof Text$2)) {
    				validateNodesToInsert(node.getChildren());
    			}
    		}
    	} catch (err) {
    		_didIteratorError11 = true;
    		_iteratorError11 = err;
    	} finally {
    		try {
    			if (!_iteratorNormalCompletion11 && _iterator11.return) {
    				_iterator11.return();
    			}
    		} finally {
    			if (_didIteratorError11) {
    				throw _iteratorError11;
    			}
    		}
    	}
    }

    // Checks if node is ContainerElement or DocumentFragment, because in most cases they should be thread the same way.
    //
    // @private
    // @param {engine.view.Node} node
    // @returns {Boolean} Returns `true` if node is instance of ContainerElement or DocumentFragment.
    function isContainerOrFragment(node) {
    	return node instanceof ContainerElement || node instanceof DocumentFragment$1;
    }

    /**
     * Class representing selection in tree view.
     *
     * Selection can consist of {@link engine.view.Range ranges} that can be added using
     * {@link engine.view.Selection#addRange addRange} and {@link engine.view.Selection#setRanges setRanges} methods.
     * Both methods create copies of provided ranges and store those copies internally. Further modifications to passed
     * ranges will not change selection's state.
     * Selection's ranges can be obtained via {@link engine.view.Selection#getRanges getRanges},
     * {@link engine.view.Selection#getFirstRange getFirstRange} and {@link engine.view.Selection#getLastRange getLastRange}
     * methods, which return copies of ranges stored inside selection. Modifications made on these copies will not change
     * selection's state. Similar situation occurs when getting {@link engine.view.Selection#anchor anchor},
     * {@link engine.view.Selection#focus focus}, {@link engine.view.Selection#getFirstPosition first} and
     * {@link engine.view.Selection#getLastPosition last} positions - all will return copies of requested positions.
     *
     * @memberOf engine.view
     */

    var Selection = function () {
    	/**
      * Creates new selection instance.
      */

    	function Selection() {
    		classCallCheck(this, Selection);

    		/**
       * Stores all ranges that are selected.
       *
       * @protected
       * @member {Array.<engine.view.Range>} engine.view.Selection#_ranges
       */
    		this._ranges = [];

    		/**
       * Specifies whether the last added range was added as a backward or forward range.
       *
       * @protected
       * @member {Boolean} engine.view.Selection#_lastRangeBackward
       */
    		this._lastRangeBackward = false;
    	}

    	/**
      * Selection anchor. Anchor may be described as a position where the selection starts. Together with
      * {@link engine.view.Selection#focus focus} they define the direction of selection, which is important
      * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
      * It may be a bit unintuitive when there are multiple ranges in selection.
      *
      * @see engine.view.Selection#focus
      * @type {engine.view.Position}
      */


    	createClass(Selection, [{
    		key: 'addRange',


    		/**
       * Adds a range to the selection. Added range is copied. This means that passed range is not saved in the
       * selection instance and you can safely operate on it.
       *
       * Accepts a flag describing in which way the selection is made - passed range might be selected from
       * {@link engine.view.Range#start start} to {@link engine.view.Range#end end}
       * or from {@link engine.view.Range#end end} to {@link engine.view.Range#start start}.
       * The flag is used to set {@link engine.view.Selection#anchor anchor} and
       * {@link engine.view.Selection#focus focus} properties.
       *
       * Throws {@link utils.CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
       * with ranges already stored in Selection instance.
       *
       * @fires engine.view.Selection#change
       * @param {engine.view.Range} range
       */
    		value: function addRange(range, isBackward) {
    			this._pushRange(range);
    			this._lastRangeBackward = !!isBackward;
    			this.fire('change');
    		}

    		/**
       * Returns an iterator that contains copies of all ranges added to the selection.
       *
       * @returns {Iterator.<engine.view.Range>}
       */

    	}, {
    		key: 'getRanges',
    		value: regeneratorRuntime.mark(function getRanges() {
    			var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, range;

    			return regeneratorRuntime.wrap(function getRanges$(_context) {
    				while (1) {
    					switch (_context.prev = _context.next) {
    						case 0:
    							_iteratorNormalCompletion = true;
    							_didIteratorError = false;
    							_iteratorError = undefined;
    							_context.prev = 3;
    							_iterator = this._ranges[Symbol.iterator]();

    						case 5:
    							if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
    								_context.next = 12;
    								break;
    							}

    							range = _step.value;
    							_context.next = 9;
    							return Range$2.createFromRange(range);

    						case 9:
    							_iteratorNormalCompletion = true;
    							_context.next = 5;
    							break;

    						case 12:
    							_context.next = 18;
    							break;

    						case 14:
    							_context.prev = 14;
    							_context.t0 = _context['catch'](3);
    							_didIteratorError = true;
    							_iteratorError = _context.t0;

    						case 18:
    							_context.prev = 18;
    							_context.prev = 19;

    							if (!_iteratorNormalCompletion && _iterator.return) {
    								_iterator.return();
    							}

    						case 21:
    							_context.prev = 21;

    							if (!_didIteratorError) {
    								_context.next = 24;
    								break;
    							}

    							throw _iteratorError;

    						case 24:
    							return _context.finish(21);

    						case 25:
    							return _context.finish(18);

    						case 26:
    						case 'end':
    							return _context.stop();
    					}
    				}
    			}, getRanges, this, [[3, 14, 18, 26], [19,, 21, 25]]);
    		})

    		/**
       * Returns copy of the first range in the selection. First range is the one which
       * {@link engine.view.Range#start start} position {@link engine.view.Position#isBefore is before} start
       * position of all other ranges (not to confuse with the first range added to the selection).
       * Returns `null` if no ranges are added to selection.
       *
       * @returns {engine.view.Range|null}
       */

    	}, {
    		key: 'getFirstRange',
    		value: function getFirstRange() {
    			var first = null;

    			var _iteratorNormalCompletion2 = true;
    			var _didIteratorError2 = false;
    			var _iteratorError2 = undefined;

    			try {
    				for (var _iterator2 = this._ranges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    					var range = _step2.value;

    					if (!first || range.start.isBefore(first.start)) {
    						first = range;
    					}
    				}
    			} catch (err) {
    				_didIteratorError2 = true;
    				_iteratorError2 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion2 && _iterator2.return) {
    						_iterator2.return();
    					}
    				} finally {
    					if (_didIteratorError2) {
    						throw _iteratorError2;
    					}
    				}
    			}

    			return first ? Range$2.createFromRange(first) : null;
    		}

    		/**
       * Returns copy of the last range in the selection. Last range is the one which {@link engine.view.Range#end end}
       * position {@link engine.view.Position#isAfter is after} end position of all other ranges (not to confuse
       * with the last range added to the selection). Returns `null` if no ranges are added to selection.
       *
       * @returns {engine.view.Range|null}
       */

    	}, {
    		key: 'getLastRange',
    		value: function getLastRange() {
    			var last = null;

    			var _iteratorNormalCompletion3 = true;
    			var _didIteratorError3 = false;
    			var _iteratorError3 = undefined;

    			try {
    				for (var _iterator3 = this._ranges[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
    					var range = _step3.value;

    					if (!last || range.end.isAfter(last.end)) {
    						last = range;
    					}
    				}
    			} catch (err) {
    				_didIteratorError3 = true;
    				_iteratorError3 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion3 && _iterator3.return) {
    						_iterator3.return();
    					}
    				} finally {
    					if (_didIteratorError3) {
    						throw _iteratorError3;
    					}
    				}
    			}

    			return last ? Range$2.createFromRange(last) : null;
    		}

    		/**
       * Returns copy of the first position in the selection. First position is the position that
       * {@link engine.view.Position#isBefore is before} any other position in the selection ranges.
       * Returns `null` if no ranges are added to selection.
       *
       * @returns {engine.view.Position|null}
       */

    	}, {
    		key: 'getFirstPosition',
    		value: function getFirstPosition() {
    			var firstRange = this.getFirstRange();

    			return firstRange ? Position$1.createFromPosition(firstRange.start) : null;
    		}

    		/**
       * Returns copy of the last position in the selection. Last position is the position that
       * {@link engine.view.Position#isAfter is after} any other position in the selection ranges.
       * Returns `null` if no ranges are added to selection.
       *
       * @returns {engine.view.Position|null}
       */

    	}, {
    		key: 'getLastPosition',
    		value: function getLastPosition() {
    			var lastRange = this.getLastRange();

    			return lastRange ? Position$1.createFromPosition(lastRange.end) : null;
    		}

    		/**
       * Two selections equal if they have the same ranges and directions.
       *
       * @param {engine.view.Selection} otherSelection Selection to compare with.
       * @returns {Boolean} True if selections equal.
       */

    	}, {
    		key: 'isEqual',
    		value: function isEqual(otherSelection) {
    			var rangeCount = this.rangeCount;

    			if (rangeCount != otherSelection.rangeCount) {
    				return false;
    			}

    			for (var i = 0; i < this.rangeCount; i++) {
    				if (!this._ranges[i].isEqual(otherSelection._ranges[i])) {
    					return false;
    				}
    			}

    			return this._lastRangeBackward === otherSelection._lastRangeBackward;
    		}

    		/**
       * Removes all ranges that were added to the selection.
       *
       * @fires engine.view.Selection#change
       */

    	}, {
    		key: 'removeAllRanges',
    		value: function removeAllRanges() {
    			if (this._ranges.length) {
    				this._ranges = [];
    				this.fire('change');
    			}
    		}

    		/**
       * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
       * is treated like the last added range and is used to set {@link engine.view.Selection#anchor anchor} and
       * {@link engine.view.Selection#focus focus}. Accepts a flag describing in which way the selection is made
       * (see {@link engine.view.Selection#addRange addRange}).
       *
       * @fires engine.view.Selection#change
       * @param {Array.<engine.view.Range>} newRanges Array of ranges to set.
       * @param {Boolean} [isLastBackward] Flag describing if last added range was selected forward - from start to end
       * (`false`) or backward - from end to start (`true`). Defaults to `false`.
       */

    	}, {
    		key: 'setRanges',
    		value: function setRanges(newRanges, isLastBackward) {
    			this._ranges = [];

    			var _iteratorNormalCompletion4 = true;
    			var _didIteratorError4 = false;
    			var _iteratorError4 = undefined;

    			try {
    				for (var _iterator4 = newRanges[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
    					var range = _step4.value;

    					this._pushRange(range);
    				}
    			} catch (err) {
    				_didIteratorError4 = true;
    				_iteratorError4 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion4 && _iterator4.return) {
    						_iterator4.return();
    					}
    				} finally {
    					if (_didIteratorError4) {
    						throw _iteratorError4;
    					}
    				}
    			}

    			this._lastRangeBackward = !!isLastBackward;
    			this.fire('change');
    		}

    		/**
       * Set this selection's ranges and direction to the ranges and direction of the given selection.
       *
       * @param {engine.view.Selection} otherSelection Other selection.
       */

    	}, {
    		key: 'setTo',
    		value: function setTo(otherSelection) {
    			this.removeAllRanges();

    			var _iteratorNormalCompletion5 = true;
    			var _didIteratorError5 = false;
    			var _iteratorError5 = undefined;

    			try {
    				for (var _iterator5 = otherSelection.getRanges()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
    					var range = _step5.value;

    					this._pushRange(range);
    				}
    			} catch (err) {
    				_didIteratorError5 = true;
    				_iteratorError5 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion5 && _iterator5.return) {
    						_iterator5.return();
    					}
    				} finally {
    					if (_didIteratorError5) {
    						throw _iteratorError5;
    					}
    				}
    			}

    			this._lastRangeBackward = otherSelection._lastRangeBackward;
    			this.fire('change');
    		}

    		/**
       * Collapses selection to the {@link engine.view.Selection#getFirstPosition first position} in stored ranges.
       * All ranges will be removed beside one collapsed range. Nothing will be changed if there are no ranges stored
       * inside selection.
       *
       * @fires engine.view.Selection#change
       */

    	}, {
    		key: 'collapseToStart',
    		value: function collapseToStart() {
    			var startPosition = this.getFirstPosition();

    			if (startPosition !== null) {
    				this.setRanges([new Range$2(startPosition, startPosition)]);
    				this.fire('change');
    			}
    		}

    		/**
       * Collapses selection to the {@link engine.view.Selection#getLastPosition last position} in stored ranges.
       * All ranges will be removed beside one collapsed range. Nothing will be changed if there are no ranges stored
       * inside selection.
       *
       * @fires engine.view.Selection#change
       */

    	}, {
    		key: 'collapseToEnd',
    		value: function collapseToEnd() {
    			var endPosition = this.getLastPosition();

    			if (endPosition !== null) {
    				this.setRanges([new Range$2(endPosition, endPosition)]);
    				this.fire('change');
    			}
    		}

    		/**
       * Returns {@link engine.view.EditableElement EditableElement} instance that contains this selection.
       *
       * @returns {engine.view.EditableElement|null} Returns closest EditableElement or null if none is found.
       */

    	}, {
    		key: 'getEditableElement',
    		value: function getEditableElement() {
    			if (this.rangeCount) {
    				return this.getFirstPosition().getEditableElement();
    			}

    			return null;
    		}

    		/**
       * Adds range to selection - creates copy of given range so it can be safely used and modified.
       *
       * Throws {@link utils.CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
       * with ranges already stored in selection instance.
       *
       * @private
       * @param {engine.view.Range} range
       */

    	}, {
    		key: '_pushRange',
    		value: function _pushRange(range) {
    			var _iteratorNormalCompletion6 = true;
    			var _didIteratorError6 = false;
    			var _iteratorError6 = undefined;

    			try {
    				for (var _iterator6 = this._ranges[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
    					var storedRange = _step6.value;

    					if (range.isIntersecting(storedRange)) {
    						/**
           * Trying to add a range that intersects with another range from selection.
           *
           * @error view-selection-range-intersects
           * @param {engine.view.Range} addedRange Range that was added to the selection.
           * @param {engine.view.Range} intersectingRange Range from selection that intersects with `addedRange`.
           */
    						throw new CKEditorError('view-selection-range-intersects: Trying to add a range that intersects with another range from selection.', { addedRange: range, intersectingRange: storedRange });
    					}
    				}
    			} catch (err) {
    				_didIteratorError6 = true;
    				_iteratorError6 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion6 && _iterator6.return) {
    						_iterator6.return();
    					}
    				} finally {
    					if (_didIteratorError6) {
    						throw _iteratorError6;
    					}
    				}
    			}

    			this._ranges.push(Range$2.createFromRange(range));
    		}
    	}, {
    		key: 'anchor',
    		get: function get() {
    			if (!this._ranges.length) {
    				return null;
    			}
    			var range = this._ranges[this._ranges.length - 1];
    			var anchor = this._lastRangeBackward ? range.end : range.start;

    			return Position$1.createFromPosition(anchor);
    		}

    		/**
       * Selection focus. Focus is a position where the selection ends.
       *
       * @see engine.view.Selection#anchor
       * @type {engine.view.Position}
       */

    	}, {
    		key: 'focus',
    		get: function get() {
    			if (!this._ranges.length) {
    				return null;
    			}
    			var range = this._ranges[this._ranges.length - 1];
    			var focus = this._lastRangeBackward ? range.start : range.end;

    			return Position$1.createFromPosition(focus);
    		}

    		/**
       * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
       * collapsed.
       *
       * @type {Boolean}
       */

    	}, {
    		key: 'isCollapsed',
    		get: function get() {
    			return this.rangeCount === 1 && this._ranges[0].isCollapsed;
    		}

    		/**
       * Returns number of ranges in selection.
       *
       * @type {Number}
          */

    	}, {
    		key: 'rangeCount',
    		get: function get() {
    			return this._ranges.length;
    		}

    		/**
       * Specifies whether the {@link engine.view.Selection#focus} precedes {@link engine.view.Selection#anchor}.
       *
       * @type {Boolean}
       */

    	}, {
    		key: 'isBackward',
    		get: function get() {
    			return !this.isCollapsed && this._lastRangeBackward;
    		}
    	}]);
    	return Selection;
    }();

    mix(Selection, EmitterMixin);

    /**
     * Set of utils related to keyboard support.
     *
     * @namespace utils.keyboard
     */

    /**
     * Object with `keyName => keyCode` pairs for a set of known keys.
     *
     * Contains:
     *
     * * `a-z`,
     * * `0-9`,
     * * `arrow(left|up|right|bottom)`,
     * * `backspace`, `delete`, `enter`,
     * * `ctrl`, `cmd`, `shift`, `alt`.
     *
     * @member {Object} utils.keyboard.keyCodes
     */
    var keyCodes = generateKnownKeyCodes();

    /**
     * Converts a key name or a {@link utils.keyboard.KeystrokeInfo keystroke info} into a key code.
     *
     * Note: Key names are matched with {@link utils.keyboard.keyCodes} in a case-insensitive way.
     *
     * @method utils.keyboard.getCode
     * @param {String|utils.keyboard.KeystrokeInfo} Key name (see {@link utils.keyboard.keyCodes})
     * or a keystroke data object.
     * @returns {Number} Key or keystroke code.
     */
    function getCode(key) {
      var keyCode = void 0;

      if (typeof key == 'string') {
        keyCode = keyCodes[key.toLowerCase()];

        if (!keyCode) {
          /**
           * Unknown key name. Only key names contained by the {@link utils.keyboard.keyCodes} can be used.
           *
           * @errror keyboard-unknown-key
           * @param {String} key
           */
          throw new CKEditorError('keyboard-unknown-key: Unknown key name.', { key: key });
        }
      } else {
        keyCode = key.keyCode + (key.altKey ? keyCodes.alt : 0) + (key.ctrlKey ? keyCodes.ctrl : 0) + (key.shiftKey ? keyCodes.shift : 0);
      }

      return keyCode;
    }

    /**
     * Parses keystroke and returns a keystroke code that will match the code returned by
     * link {@link utils.keyboard.getCode} for a corresponding {@link utils.keyboard.KeystrokeInfo keystroke info}.
     *
     * The keystroke can be passed in two formats:
     *
     * * as a single string – e.g. `ctrl + A`,
     * * as an array of {@link utils.keyboard.keyCodes known key names} and key codes – e.g.:
     *   * `[ 'ctrl', 32 ]` (ctrl + space),
     *   * `[ 'ctrl', 'a' ]` (ctrl + A).
     *
     * Note: Key names are matched with {@link utils.keyboard.keyCodes} in a case-insensitive way.
     *
     * Note: Only keystrokes with a single non-modifier key are supported (e.g. `ctrl+A` is OK, but `ctrl+A+B` is not).
     *
     * @method utils.keyboard.parseKeystroke
     * @param {String|Array.<Number|String>} keystroke Keystroke definition.
     * @returns {Number} Keystroke code.
     */
    function parseKeystroke(keystroke) {
      if (typeof keystroke == 'string') {
        keystroke = keystroke.split(/\s*\+\s*/);
      }

      return keystroke.map(function (key) {
        return typeof key == 'string' ? getCode(key) : key;
      }).reduce(function (key, sum) {
        return sum + key;
      }, 0);
    }

    function generateKnownKeyCodes() {
      var keyCodes = {
        arrowleft: 37,
        arrowup: 38,
        arrowright: 39,
        arrowdown: 40,
        backspace: 8,
        delete: 46,
        enter: 13,

        // The idea about these numbers is that they do not collide with any real key codes, so we can use them
        // like bit masks.
        ctrl: 0x110000,
        // Has the same code as ctrl, because their behaviour should be unified across the editor.
        // See http://ckeditor.github.io/editor-recommendations/general-policies#ctrl-vs-cmd
        cmd: 0x110000,
        shift: 0x220000,
        alt: 0x440000
      };

      // a-z
      for (var code = 65; code <= 90; code++) {
        var letter = String.fromCharCode(code);

        keyCodes[letter.toLowerCase()] = code;
      }

      // 0-9
      for (var _code = 48; _code <= 57; _code++) {
        keyCodes[_code - 48] = _code;
      }

      return keyCodes;
    }

    /**
     * Information about a keystroke.
     *
     * @interface utils.keyboard.KeystrokeInfo
     */

    /**
     * The [key code](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode).
     *
     * @member {Number} utils.keyboard.KeystrokeInfo#keyCode
     */

    /**
     * Whether the <kbd>Alt</kbd> modifier was pressed.
     *
     * @member {Bolean} utils.keyboard.KeystrokeInfo#altKey
     */

    /**
     * Whether the <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> modifier was pressed.
     *
     * @member {Bolean} utils.keyboard.KeystrokeInfo#ctrlKey
     */

    /**
     * Whether the <kbd>Shift</kbd> modifier was pressed.
     *
     * @member {Bolean} utils.keyboard.KeystrokeInfo#shiftKey
     */

    /**
     * Set of utils related to block and inline fillers handling.
     *
     * Browsers do not allow to put caret in elements which does not have height. Because of it, we need to fill all
     * empty elements which should be selectable with elements or characters called "fillers". Unfortunately there is no one
     * universal filler, this is why two types are uses:
     *
     * * Block filler is an element which fill block elements, like `<p>`. CKEditor uses `<br>` as a block filler during the editing,
     * as browsers do natively. So instead of an empty `<p>` there will be `<p><br></p>`. The advantage of block filler is that
     * it is transparent for the selection, so when the caret is before the `<br>` and user presses right arrow he will be
     * moved to the next paragraph, not after the `<br>`. The disadvantage is that it breaks a block, so it can not be used
     * in the middle of a line of text. The {@link engine.view.filler.BR_FILLER `<br>` filler} can be replaced with any other
     * character in the data output, for instance {@link engine.view.filler.NBSP_FILLER non-breaking space}.
     *
     * * Inline filler is a filler which does not break a line of text, so it can be used inside the text, for instance in the empty
     * `<b>` surrendered by text: `foo<b></b>bar`, if we want to put the caret there. CKEditor uses a sequence of the zero-width
     * spaces as an {@link engine.view.filler.INLINE_FILLER inline filler} having the predetermined
     * {@link engine.view.filler.INLINE_FILLER_LENGTH length}. A sequence is used, instead of a single character to
     * avoid treating random zero-width spaces as the inline filler. Disadvantage of the inline filler is that it is not
     * transparent for the selection. The arrow key moves the caret between zero-width spaces characters, so the additional
     * code is needed to handle the caret.
     *
     * Both inline and block fillers are handled by the {@link engine.view.renderer renderer} and are not present in the
     * view.
     *
     * @namespace engine.view.filler
     */

    /**
     * `<br> filler creator. This is a function which creates `<br data-cke-filler="true">` element.
     * It defines how the filler is created.
     *
     * @see engine.view.filler.NBSP_FILLER_FILLER
     * @member {Function} engine.view.filler.BR_FILLER
     */
    var BR_FILLER = function BR_FILLER(domDocument) {
      var fillerBr = domDocument.createElement('br');
      fillerBr.dataset.ckeFiller = true;

      return fillerBr;
    };

    /**
     * Non-breaking space filler creator. This is a function which creates `&nbsp;` text node.
     * It defines how the filler is created.
     *
     * @see engine.view.filler.BR_FILLER
     * @member {Function} engine.view.filler.NBSP_FILLER_FILLER
     */
    var NBSP_FILLER = function NBSP_FILLER(domDocument) {
      return domDocument.createTextNode(' ');
    };

    /**
     * Length of the {@link engine.view.filler.INLINE_FILLER INLINE_FILLER}.
     *
     * @member {Function} engine.view.filler.INLINE_FILLER_LENGTH
     */
    var INLINE_FILLER_LENGTH = 7;

    /**
     * Inline filler which is sequence of the zero width spaces.
     *
     * @member {String} engine.view.filler.INLINE_FILLER
     */
    var INLINE_FILLER = '';

    for (var i = 0; i < INLINE_FILLER_LENGTH; i++) {
      INLINE_FILLER += '​';
    }

    /**
     * Checks if the node is a text node which starts with the {@link engine.view.filler.INLINE_FILLER inline filler}.
     *
     *		startsWithFiller( document.createTextNode( INLINE_FILLER ) ); // true
     *		startsWithFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ); // true
     *		startsWithFiller( document.createTextNode( 'foo' ) ); // false
     *		startsWithFiller( document.createElement( 'p' ) ); // false
     *
     * @param {Node} domNode DOM node.
     * @returns {Boolean} True if the text node starts with the {@link engine.view.filler.INLINE_FILLER inline filler}.
     */
    function startsWithFiller(domNode) {
      return domNode instanceof Text && domNode.data.substr(0, INLINE_FILLER_LENGTH) === INLINE_FILLER;
    }

    /**
     * Checks if the text node contains only the {@link engine.view.filler.INLINE_FILLER inline filler}.
     *
     *		isInlineFiller( document.createTextNode( INLINE_FILLER ) ); // true
     *		isInlineFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ); // false
     *
     * @param {Text} domText DOM text node.
     * @returns {Boolean} True if the text node contains only the {@link engine.view.filler.INLINE_FILLER inline filler}.
     */
    function isInlineFiller(domText) {
      return domText.data.length == INLINE_FILLER_LENGTH && startsWithFiller(domText);
    }

    /**
     * Get string data from the text node, removing an {@link engine.view.filler.INLINE_FILLER inline filler} from it,
     * if text node contains it.
     *
     *		getDataWithoutFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ) == 'foo' // true
     *		getDataWithoutFiller( document.createTextNode( 'foo' ) ) == 'foo' // true
     *
     * @param {Text} domText DOM text node, possible with inline filler.
     * @returns {String} Data without filler.
     */
    function getDataWithoutFiller(domText) {
      if (startsWithFiller(domText)) {
        return domText.data.slice(INLINE_FILLER_LENGTH);
      } else {
        return domText.data;
      }
    }

    // Cache block fillers templates to improve performance.
    var templateBlockFillers = new WeakMap();

    /**
     * Checks if the node is an instance of the block filler of the given type.
     *
     *		const brFillerInstance = BR_FILLER( document );
     *		isBlockFiller( brFillerInstance, BR_FILLER ); // true
     *
     * @param {Node} domNode DOM node to check.
     * @param {Function} blockFiller Block filler creator.
     * @returns {Boolean} True if text node contains only {@link engine.view.filler.INLINE_FILLER inline filler}.
     */
    function isBlockFiller(domNode, blockFiller) {
      var templateBlockFiller = templateBlockFillers.get(blockFiller);

      if (!templateBlockFiller) {
        templateBlockFiller = blockFiller(window.document);
        templateBlockFillers.set(blockFiller, templateBlockFiller);
      }

      return domNode.isEqualNode(templateBlockFiller);
    }

    /**
     * Assign key observer which move cursor from the end of the inline filler to the begging of it when
     * the left arrow is pressed, so the filler does not break navigation.
     *
     * @param {engine.view.Document} document Document instance we should inject quirks handling on.
     */
    function injectQuirksHandling(document) {
      document.on('keydown', jumpOverInlineFiller);
    }

    // Move cursor from the end of the inline filler to the begging of it when, so the filler does not break navigation.
    function jumpOverInlineFiller(evt, data) {
      if (data.keyCode == keyCodes.arrowleft) {
        var domSelection = data.domTarget.ownerDocument.defaultView.getSelection();

        if (domSelection.rangeCount == 1 && domSelection.getRangeAt(0).collapsed) {
          var domParent = domSelection.getRangeAt(0).startContainer;
          var domOffset = domSelection.getRangeAt(0).startOffset;

          if (startsWithFiller(domParent) && domOffset <= INLINE_FILLER_LENGTH) {
            var domRange = new Range();
            domRange.setStart(domParent, 0);
            domRange.collapse(true);
            domSelection.removeAllRanges();
            domSelection.addRange(domRange);
          }
        }
      }
    }

    /**
     * Returns index of the node in the parent element.
     *
     * @method utils.dom.indexOf
     * @param {Node} node Node which index is tested.
     * @returns {Number} Index of the node in the parent element. Returns 0 if node has no parent.
     */

    function indexOf(node) {
      var index = 0;

      while (node.previousSibling) {
        node = node.previousSibling;
        index++;
      }

      return index;
    }

    /**
     * DomConverter is a set of tools to do transformations between DOM nodes and view nodes. It also handles
     * {@link engine.view.DomConverter#bindElements binding} these nodes.
     *
     * DomConverter does not check which nodes should be rendered (use {@link engine.view.Renderer}), does not keep a
     * state of a tree nor keeps synchronization between tree view and DOM tree (use {@link engine.view.Document}).
     *
     * DomConverter keeps DOM elements to View element bindings, so when the converter will be destroyed, the binding will
     * be lost. Two converters will keep separate binding maps, so one tree view can be bound with two DOM trees.
     *
     * @memberOf engine.view
     */

    var DomConverter = function () {
    	/**
      * Creates DOM converter.
      *
      * @param {Object} options Object with configuration options.
      * @param {Function} [options.blockFiller=engine.view.filler.BR_FILLER] Block filler creator.
      */

    	function DomConverter() {
    		var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    		classCallCheck(this, DomConverter);

    		// Using WeakMap prevent memory leaks: when the converter will be destroyed all referenced between View and DOM
    		// will be removed. Also because it is a *Weak*Map when both view and DOM elements will be removed referenced
    		// will be also removed, isn't it brilliant?
    		//
    		// Yes, PJ. It is.
    		//
    		// You guys so smart.
    		//
    		// I've been here. Seen stuff. Afraid of code now.

    		/**
       * Block {@link engine.view.filler filler} creator, which is used to create all block fillers during the
       * view to DOM conversion and to recognize block fillers during the DOM to view conversion.
       *
       * @readonly
       * @member {Function} engine.view.DomConverter#blockFiller
       */
    		this.blockFiller = options.blockFiller || BR_FILLER;

    		/**
       * DOM to View mapping.
       *
       * @private
       * @member {WeakMap} engine.view.DomConverter#_domToViewMapping
       */
    		this._domToViewMapping = new WeakMap();

    		/**
       * View to DOM mapping.
       *
       * @private
       * @member {WeakMap} engine.view.DomConverter#_viewToDomMapping
       */
    		this._viewToDomMapping = new WeakMap();
    	}

    	/**
      * Binds DOM and View elements, so it will be possible to get corresponding elements using
      * {@link engine.view.DomConverter#getCorrespondingViewElement getCorrespondingViewElement} and
      * {@link engine.view.DomConverter#getCorrespondingDomElement getCorrespondingDomElement}.
      *
      * @param {HTMLElement} domElement DOM element to bind.
      * @param {engine.view.Element} viewElement View element to bind.
      */


    	createClass(DomConverter, [{
    		key: 'bindElements',
    		value: function bindElements(domElement, viewElement) {
    			this._domToViewMapping.set(domElement, viewElement);
    			this._viewToDomMapping.set(viewElement, domElement);
    		}

    		/**
       * Binds DOM and View document fragments, so it will be possible to get corresponding document fragments using
       * {@link engine.view.DomConverter#getCorrespondingViewDocumentFragment getCorrespondingViewDocumentFragment} and
       * {@link engine.view.DomConverter#getCorrespondingDomDocumentFragment getCorrespondingDomDocumentFragment}.
       *
       * @param {DocumentFragment} domFragment DOM document fragment to bind.
       * @param {engine.view.DocumentFragment} viewFragment View document fragment to bind.
       */

    	}, {
    		key: 'bindDocumentFragments',
    		value: function bindDocumentFragments(domFragment, viewFragment) {
    			this._domToViewMapping.set(domFragment, viewFragment);
    			this._viewToDomMapping.set(viewFragment, domFragment);
    		}

    		/**
       * Converts view to DOM. For all text nodes, not bound elements and document fragments new items will
       * be created. For bound elements and document fragments function will return corresponding items.
       *
       * @param {engine.view.Node|engine.view.DocumentFragment} viewNode View node or document fragment to transform.
       * @param {document} domDocument Document which will be used to create DOM nodes.
       * @param {Object} [options] Conversion options.
       * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.
       * @param {Boolean} [options.withChildren=true] If true node's and document fragment's children  will be converted too.
       * @returns {Node|DocumentFragment} Converted node or DocumentFragment.
       */

    	}, {
    		key: 'viewToDom',
    		value: function viewToDom(viewNode, domDocument) {
    			var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    			if (viewNode instanceof Text$2) {
    				return domDocument.createTextNode(viewNode.data);
    			} else {
    				if (this.getCorrespondingDom(viewNode)) {
    					return this.getCorrespondingDom(viewNode);
    				}

    				var domElement = void 0;

    				if (viewNode instanceof DocumentFragment$1) {
    					// Create DOM document fragment.
    					domElement = domDocument.createDocumentFragment();

    					if (options.bind) {
    						this.bindDocumentFragments(domElement, viewNode);
    					}
    				} else {
    					// Create DOM element.
    					domElement = domDocument.createElement(viewNode.name);

    					if (options.bind) {
    						this.bindElements(domElement, viewNode);
    					}

    					// Copy element's attributes.
    					var _iteratorNormalCompletion = true;
    					var _didIteratorError = false;
    					var _iteratorError = undefined;

    					try {
    						for (var _iterator = viewNode.getAttributeKeys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    							var key = _step.value;

    							domElement.setAttribute(key, viewNode.getAttribute(key));
    						}
    					} catch (err) {
    						_didIteratorError = true;
    						_iteratorError = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion && _iterator.return) {
    								_iterator.return();
    							}
    						} finally {
    							if (_didIteratorError) {
    								throw _iteratorError;
    							}
    						}
    					}
    				}

    				if (options.withChildren || options.withChildren === undefined) {
    					var _iteratorNormalCompletion2 = true;
    					var _didIteratorError2 = false;
    					var _iteratorError2 = undefined;

    					try {
    						for (var _iterator2 = this.viewChildrenToDom(viewNode, domDocument, options)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    							var child = _step2.value;

    							domElement.appendChild(child);
    						}
    					} catch (err) {
    						_didIteratorError2 = true;
    						_iteratorError2 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion2 && _iterator2.return) {
    								_iterator2.return();
    							}
    						} finally {
    							if (_didIteratorError2) {
    								throw _iteratorError2;
    							}
    						}
    					}
    				}

    				return domElement;
    			}
    		}

    		/**
       * Converts children of the view element to DOM using {@link engine.view.DomConverter#viewToDom} method.
       * Additionally this method adds block {@link engine.view.filler filler} to the list of children, if needed.
       *
       * @param {engine.view.Element|engine.view.DocumentFragment} viewElement Parent view element.
       * @param {document} domDocument Document which will be used to create DOM nodes.
       * @param {Object} options See {@link engine.view.DomConverter#viewToDom} options parameter.
       * @returns {Iterable.<Node>} DOM nodes.
       */

    	}, {
    		key: 'viewChildrenToDom',
    		value: regeneratorRuntime.mark(function viewChildrenToDom(viewElement, domDocument) {
    			var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    			var fillerPositionOffset, offset, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, childView;

    			return regeneratorRuntime.wrap(function viewChildrenToDom$(_context) {
    				while (1) {
    					switch (_context.prev = _context.next) {
    						case 0:
    							fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();
    							offset = 0;
    							_iteratorNormalCompletion3 = true;
    							_didIteratorError3 = false;
    							_iteratorError3 = undefined;
    							_context.prev = 5;
    							_iterator3 = viewElement.getChildren()[Symbol.iterator]();

    						case 7:
    							if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
    								_context.next = 18;
    								break;
    							}

    							childView = _step3.value;

    							if (!(fillerPositionOffset === offset)) {
    								_context.next = 12;
    								break;
    							}

    							_context.next = 12;
    							return this.blockFiller(domDocument);

    						case 12:
    							_context.next = 14;
    							return this.viewToDom(childView, domDocument, options);

    						case 14:

    							offset++;

    						case 15:
    							_iteratorNormalCompletion3 = true;
    							_context.next = 7;
    							break;

    						case 18:
    							_context.next = 24;
    							break;

    						case 20:
    							_context.prev = 20;
    							_context.t0 = _context['catch'](5);
    							_didIteratorError3 = true;
    							_iteratorError3 = _context.t0;

    						case 24:
    							_context.prev = 24;
    							_context.prev = 25;

    							if (!_iteratorNormalCompletion3 && _iterator3.return) {
    								_iterator3.return();
    							}

    						case 27:
    							_context.prev = 27;

    							if (!_didIteratorError3) {
    								_context.next = 30;
    								break;
    							}

    							throw _iteratorError3;

    						case 30:
    							return _context.finish(27);

    						case 31:
    							return _context.finish(24);

    						case 32:
    							if (!(fillerPositionOffset === offset)) {
    								_context.next = 35;
    								break;
    							}

    							_context.next = 35;
    							return this.blockFiller(domDocument);

    						case 35:
    						case 'end':
    							return _context.stop();
    					}
    				}
    			}, viewChildrenToDom, this, [[5, 20, 24, 32], [25,, 27, 31]]);
    		})

    		/**
       * Converts view {@link engine.view.Range} to DOM range.
       * Inline and block {@link engine.view.filler fillers} are handled during the conversion.
       *
       * @param {engine.view.Range} viewRange View range.
       * @returns {Range} DOM range.
       */

    	}, {
    		key: 'viewRangeToDom',
    		value: function viewRangeToDom(viewRange) {
    			var domStart = this.viewPositionToDom(viewRange.start);
    			var domEnd = this.viewPositionToDom(viewRange.end);

    			var domRange = new Range();
    			domRange.setStart(domStart.parent, domStart.offset);
    			domRange.setEnd(domEnd.parent, domEnd.offset);

    			return domRange;
    		}

    		/**
       * Converts view {@link engine.view.Position} to DOM parent and offset.
       *
       * Inline and block {@link engine.view.filler fillers} are handled during the conversion.
       * If the converted position is directly before inline filler it is moved inside the filler.
       *
       * @param {engine.view.position} viewPosition View position.
       * @returns {Object} position
       * @returns {Node} position.parent DOM position parent.
       * @returns {Number} position.offset DOM position offset.
       */

    	}, {
    		key: 'viewPositionToDom',
    		value: function viewPositionToDom(viewPosition) {
    			var viewParent = viewPosition.parent;

    			if (viewParent instanceof Text$2) {
    				var domParent = this.getCorrespondingDomText(viewParent);
    				var offset = viewPosition.offset;

    				if (startsWithFiller(domParent)) {
    					offset += INLINE_FILLER_LENGTH;
    				}

    				return { parent: domParent, offset: offset };
    			}
    			// viewParent instance of ViewElement.
    			else {
    					var _domParent = void 0,
    					    domBefore = void 0,
    					    domAfter = void 0;

    					if (viewPosition.offset === 0) {
    						_domParent = this.getCorrespondingDom(viewPosition.parent);
    						domAfter = _domParent.childNodes[0];
    					} else {
    						domBefore = this.getCorrespondingDom(viewPosition.nodeBefore);
    						_domParent = domBefore.parentNode;
    						domAfter = domBefore.nextSibling;
    					}

    					// If there is an inline filler at position return position inside the filler. We should never return
    					// the position before the inline filler.
    					if (this.isText(domAfter) && startsWithFiller(domAfter)) {
    						return { parent: domAfter, offset: INLINE_FILLER_LENGTH };
    					}

    					var _offset = domBefore ? indexOf(domBefore) + 1 : 0;

    					return { parent: _domParent, offset: _offset };
    				}
    		}

    		/**
       * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will
       * be created. For bound elements and document fragments function will return corresponding items. For
       * {@link engine.view.filler fillers} `null` will be returned.
       *
       * @param {Node|DocumentFragment} domNode DOM node or document fragment to transform.
       * @param {Object} [options] Conversion options.
       * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.
       * @param {Boolean} [options.withChildren=true] It true node's and document fragment's children will be converted too.
       * @returns {engine.view.Node|engine.view.DocumentFragment|null} Converted node or document fragment. Null
       * if DOM node is a {@link engine.view.filler filler}.
       */

    	}, {
    		key: 'domToView',
    		value: function domToView(domNode) {
    			var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    			if (isBlockFiller(domNode, this.blockFiller)) {
    				return null;
    			}

    			if (this.isText(domNode)) {
    				if (isInlineFiller(domNode)) {
    					return null;
    				} else {
    					return new Text$2(getDataWithoutFiller(domNode));
    				}
    			} else {
    				if (this.getCorrespondingView(domNode)) {
    					return this.getCorrespondingView(domNode);
    				}

    				var viewElement = void 0;

    				if (this.isDocumentFragment(domNode)) {
    					// Create view document fragment.
    					viewElement = new DocumentFragment$1();

    					if (options.bind) {
    						this.bindDocumentFragments(domNode, viewElement);
    					}
    				} else {
    					// Create view element.
    					viewElement = new Element$1(domNode.tagName.toLowerCase());

    					if (options.bind) {
    						this.bindElements(domNode, viewElement);
    					}

    					// Copy element's attributes.
    					var attrs = domNode.attributes;

    					for (var i = attrs.length - 1; i >= 0; i--) {
    						viewElement.setAttribute(attrs[i].name, attrs[i].value);
    					}
    				}

    				if (options.withChildren || options.withChildren === undefined) {
    					var _iteratorNormalCompletion4 = true;
    					var _didIteratorError4 = false;
    					var _iteratorError4 = undefined;

    					try {
    						for (var _iterator4 = this.domChildrenToView(domNode, options)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
    							var child = _step4.value;

    							viewElement.appendChildren(child);
    						}
    					} catch (err) {
    						_didIteratorError4 = true;
    						_iteratorError4 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion4 && _iterator4.return) {
    								_iterator4.return();
    							}
    						} finally {
    							if (_didIteratorError4) {
    								throw _iteratorError4;
    							}
    						}
    					}
    				}

    				return viewElement;
    			}
    		}

    		/**
       * Converts children of the DOM element to view nodes using {@link engine.view.DomConverter#domToView} method.
       * Additionally this method omits block {@link engine.view.filler filler}, if it exists in the DOM parent.
       *
       * @param {HTMLElement} domElement Parent DOM element.
       * @param {Object} options See {@link engine.view.DomConverter#domToView} options parameter.
       * @returns {Iterable.<engine.view.Node>} View nodes.
       */

    	}, {
    		key: 'domChildrenToView',
    		value: regeneratorRuntime.mark(function domChildrenToView(domElement) {
    			var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    			var i, domChild, viewChild;
    			return regeneratorRuntime.wrap(function domChildrenToView$(_context2) {
    				while (1) {
    					switch (_context2.prev = _context2.next) {
    						case 0:
    							i = 0;

    						case 1:
    							if (!(i < domElement.childNodes.length)) {
    								_context2.next = 10;
    								break;
    							}

    							domChild = domElement.childNodes[i];
    							viewChild = this.domToView(domChild, options);

    							if (!(viewChild !== null)) {
    								_context2.next = 7;
    								break;
    							}

    							_context2.next = 7;
    							return viewChild;

    						case 7:
    							i++;
    							_context2.next = 1;
    							break;

    						case 10:
    						case 'end':
    							return _context2.stop();
    					}
    				}
    			}, domChildrenToView, this);
    		})

    		/**
       * Converts DOM selection to view {@link engine.view.Selection}.
       * Ranges which cannot be converted will be omitted.
       *
       * @param {Selection} domSelection DOM selection.
       * @returns {engine.view.Selection} View selection.
       */

    	}, {
    		key: 'domSelectionToView',
    		value: function domSelectionToView(domSelection) {
    			var viewSelection = new Selection();

    			for (var i = 0; i < domSelection.rangeCount; i++) {
    				var domRange = domSelection.getRangeAt(i);
    				var viewRange = this.domRangeToView(domRange);

    				if (viewRange) {
    					viewSelection.addRange(viewRange);
    				}
    			}

    			return viewSelection;
    		}

    		/**
       * Converts DOM Range to view {@link engine.view.range}.
       * If the start or end position can not be converted `null` is returned.
       *
       * @param {Range} domRange DOM range.
       * @returns {engine.view.Range|null} View range.
       */

    	}, {
    		key: 'domRangeToView',
    		value: function domRangeToView(domRange) {
    			var viewStart = this.domPositionToView(domRange.startContainer, domRange.startOffset);
    			var viewEnd = this.domPositionToView(domRange.endContainer, domRange.endOffset);

    			if (viewStart && viewEnd) {
    				return new Range$2(viewStart, viewEnd);
    			}

    			return null;
    		}

    		/**
       * Converts DOM parent and offset to view {@link engine.view.Position}.
       *
       * If the position is inside a {@link engine.view.filler filler} which has no corresponding view node,
       * position of the filler will be converted and returned.
       *
       * If structures are too different and it is not possible to find corresponding position then `null` will be returned.
       *
       * @param {Node} domParent DOM position parent.
       * @param {Number} domOffset DOM position offset.
       * @returns {engine.view.Position} viewPosition View position.
       */

    	}, {
    		key: 'domPositionToView',
    		value: function domPositionToView(domParent, domOffset) {
    			if (isBlockFiller(domParent, this.blockFiller)) {
    				return this.domPositionToView(domParent.parentNode, indexOf(domParent));
    			}

    			if (this.isText(domParent)) {
    				if (isInlineFiller(domParent)) {
    					return this.domPositionToView(domParent.parentNode, indexOf(domParent));
    				}

    				var viewParent = this.getCorrespondingViewText(domParent);
    				var offset = domOffset;

    				if (!viewParent) {
    					return null;
    				}

    				if (startsWithFiller(domParent)) {
    					offset -= INLINE_FILLER_LENGTH;
    					offset = offset < 0 ? 0 : offset;
    				}

    				return new Position$1(viewParent, offset);
    			}
    			// domParent instanceof HTMLElement.
    			else {
    					if (domOffset === 0) {
    						var _viewParent = this.getCorrespondingView(domParent);

    						if (_viewParent) {
    							return new Position$1(_viewParent, 0);
    						}
    					} else {
    						var viewBefore = this.getCorrespondingView(domParent.childNodes[domOffset - 1]);

    						if (viewBefore) {
    							return new Position$1(viewBefore.parent, viewBefore.getIndex() + 1);
    						}
    					}

    					return null;
    				}
    		}

    		/**
       * Gets corresponding view item. This function use
       * {@link engine.view.DomConverter#getCorrespondingViewElement getCorrespondingViewElement}
       * for elements, {@link  engine.view.DomConverter#getCorrespondingViewText getCorrespondingViewText} for text
       * nodes and {@link engine.view.DomConverter#getCorrespondingViewDocumentFragment getCorrespondingViewDocumentFragment}
       * for document fragments.
       *
       * Note that for the block or inline {@link engine.view.filler filler} this method returns `null`.
       *
       * @param {Node|DocumentFragment} domNode DOM node or document fragment.
       * @returns {engine.view.Node|engine.view.DocumentFragment|null} Corresponding view item.
       */

    	}, {
    		key: 'getCorrespondingView',
    		value: function getCorrespondingView(domNode) {
    			if (this.isElement(domNode)) {
    				return this.getCorrespondingViewElement(domNode);
    			} else if (this.isDocumentFragment(domNode)) {
    				return this.getCorrespondingViewDocumentFragment(domNode);
    			} else if (this.isText(domNode)) {
    				return this.getCorrespondingViewText(domNode);
    			}

    			return null;
    		}

    		/**
       * Gets corresponding view element. Returns element if an view element was
       * {@link engine.view.DomConverter#bindElements bound} to the given DOM element or `null` otherwise.
       *
       * @param {HTMLElement} domElement DOM element.
       * @returns {engine.view.Element|null} Corresponding element or `null` if no element was bound.
       */

    	}, {
    		key: 'getCorrespondingViewElement',
    		value: function getCorrespondingViewElement(domElement) {
    			return this._domToViewMapping.get(domElement);
    		}

    		/**
       * Gets corresponding view document fragment. Returns document fragment if an view element was
       * {@link engine.view.DomConverter#bindDocumentFragments bound} to the given DOM fragment or `null` otherwise.
       *
       * @param {DocumentFragment} domFragment DOM element.
       * @returns {engine.view.DocumentFragment|null} Corresponding document fragment or `null` if none element was bound.
       */

    	}, {
    		key: 'getCorrespondingViewDocumentFragment',
    		value: function getCorrespondingViewDocumentFragment(domFragment) {
    			return this._domToViewMapping.get(domFragment);
    		}

    		/**
       * Gets corresponding text node. Text nodes are not {@link engine.view.DomConverter#bindElements bound},
       * corresponding text node is returned based on the sibling or parent.
       *
       * If the directly previous sibling is a {@link engine.view.DomConverter#bindElements bound} element, it is used
       * to find the corresponding text node.
       *
       * If this is a first child in the parent and the parent is a {@link engine.view.DomConverter#bindElements bound}
       * element, it is used to find the corresponding text node.
       *
       * Otherwise `null` is returned.
       *
       * Note that for the block or inline {@link engine.view.filler filler} this method returns `null`.
       *
       * @param {Text} domText DOM text node.
       * @returns {engine.view.Text|null} Corresponding view text node or `null`, if it was not possible to find a
       * corresponding node.
       */

    	}, {
    		key: 'getCorrespondingViewText',
    		value: function getCorrespondingViewText(domText) {
    			if (isInlineFiller(domText)) {
    				return null;
    			}

    			var previousSibling = domText.previousSibling;

    			// Try to use previous sibling to find the corresponding text node.
    			if (previousSibling) {
    				if (!this.isElement(previousSibling)) {
    					// The previous is text or comment.
    					return null;
    				}

    				var viewElement = this.getCorrespondingViewElement(previousSibling);

    				if (viewElement) {
    					var nextSibling = viewElement.getNextSibling();

    					// It might be filler which has no corresponding view node.
    					if (nextSibling instanceof Text$2) {
    						return viewElement.getNextSibling();
    					} else {
    						return null;
    					}
    				}
    			}
    			// Try to use parent to find the corresponding text node.
    			else {
    					var _viewElement = this.getCorrespondingViewElement(domText.parentNode);

    					if (_viewElement) {
    						var firstChild = _viewElement.getChild(0);

    						// It might be filler which has no corresponding view node.
    						if (firstChild instanceof Text$2) {
    							return firstChild;
    						} else {
    							return null;
    						}
    					}
    				}

    			return null;
    		}

    		/**
       * Gets corresponding DOM item. This function uses
       * {@link engine.view.DomConverter#getCorrespondingDomElement getCorrespondingDomElement} for
       * elements, {@link engine.view.DomConverter#getCorrespondingDomText getCorrespondingDomText} for text nodes
       * and {@link engine.view.DomConverter#getCorrespondingDomDocumentFragment getCorrespondingDomDocumentFragment}
       * for document fragments.
       *
       * @param {engine.view.Node|engine.view.DomFragment} viewNode View node or document fragment.
       * @returns {Node|DocumentFragment|null} Corresponding DOM node or document fragment.
       */

    	}, {
    		key: 'getCorrespondingDom',
    		value: function getCorrespondingDom(viewNode) {
    			if (viewNode instanceof Element$1) {
    				return this.getCorrespondingDomElement(viewNode);
    			} else if (viewNode instanceof DocumentFragment$1) {
    				return this.getCorrespondingDomDocumentFragment(viewNode);
    			} else if (viewNode instanceof Text$2) {
    				return this.getCorrespondingDomText(viewNode);
    			}

    			return null;
    		}

    		/**
       * Gets corresponding DOM element. Returns element if an DOM element was
       * {@link engine.view.DomConverter#bindElements bound} to the given view element or `null` otherwise.
       *
       * @param {engine.view.Element} viewElement View element.
       * @returns {HTMLElement|null} Corresponding element or `null` if none element was bound.
       */

    	}, {
    		key: 'getCorrespondingDomElement',
    		value: function getCorrespondingDomElement(viewElement) {
    			return this._viewToDomMapping.get(viewElement);
    		}

    		/**
       * Gets corresponding DOM document fragment. Returns document fragment if an DOM element was
       * {@link engine.view.DomConverter#bindDocumentFragments bound} to the given view document fragment or `null` otherwise.
       *
       * @param {engine.view.DocumentFragment} viewDocumentFragment View document fragment.
       * @returns {DocumentFragment|null} Corresponding document fragment or `null` if no fragment was bound.
       */

    	}, {
    		key: 'getCorrespondingDomDocumentFragment',
    		value: function getCorrespondingDomDocumentFragment(viewDocumentFragment) {
    			return this._viewToDomMapping.get(viewDocumentFragment);
    		}

    		/**
       * Gets corresponding text node. Text nodes are not {@link engine.view.DomConverter#bindElements bound},
       * corresponding text node is returned based on the sibling or parent.
       *
       * If the directly previous sibling is a {@link engine.view.DomConverter#bindElements bound} element, it is used
       * to find the corresponding text node.
       *
       * If this is a first child in the parent and the parent is a {@link engine.view.DomConverter#bindElements bound}
       * element, it is used to find the corresponding text node.
       *
       * Otherwise `null` is returned.
       *
       * @param {engine.view.Text} viewText View text node.
       * @returns {Text|null} Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.
       */

    	}, {
    		key: 'getCorrespondingDomText',
    		value: function getCorrespondingDomText(viewText) {
    			var previousSibling = viewText.getPreviousSibling();

    			// Try to use previous sibling to find the corresponding text node.
    			if (previousSibling && this.getCorrespondingDom(previousSibling)) {
    				return this.getCorrespondingDom(previousSibling).nextSibling;
    			}

    			// If this is a first node, try to use parent to find the corresponding text node.
    			if (!previousSibling && viewText.parent && this.getCorrespondingDom(viewText.parent)) {
    				return this.getCorrespondingDom(viewText.parent).childNodes[0];
    			}

    			return null;
    		}

    		/**
       * Focuses DOM editable that is corresponding to provided {@link engine.view.EditableElement EditableElement}.
       *
       * @param {engine.view.EditableElement} viewEditable
       */

    	}, {
    		key: 'focus',
    		value: function focus(viewEditable) {
    			var domEditable = this.getCorrespondingDomElement(viewEditable);

    			if (domEditable && domEditable.ownerDocument.activeElement !== domEditable) {
    				domEditable.focus();
    			}
    		}

    		/**
       * Returns `true` when `node.nodeType` equals `Node.TEXT_NODE`.
       *
       * @param {Node} node Node to check.
       * @returns {Boolean}
       */

    	}, {
    		key: 'isText',
    		value: function isText(node) {
    			return node && node.nodeType == Node.TEXT_NODE;
    		}

    		/**
       * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.
       *
       * @param {Node} node Node to check.
       * @returns {Boolean}
       */

    	}, {
    		key: 'isElement',
    		value: function isElement(node) {
    			return node && node.nodeType == Node.ELEMENT_NODE;
    		}

    		/**
       * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.
       *
       * @param {Node} node Node to check.
       * @returns {Boolean}
       */

    	}, {
    		key: 'isDocumentFragment',
    		value: function isDocumentFragment(node) {
    			return node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
    		}
    	}]);
    	return DomConverter;
    }();

    /**
     * Controller for the data pipeline. The data pipeline controls how data is retrieved from the document
     * and set inside it. Hence, the controller features two methods which allow to {@link engine.DataController#get get}
     * and {@link engine.DataController#set set} data of the {@link engine.DataController#model model}
     * using given:
     *
     * * {@link engine.dataProcessor.DataProcessor data processor},
     * * {@link engine.conversion.ModelConversionDispatcher model to view} and
     * {@link engine.conversion.ViewConversionDispatcher view to model} converters.
     *
     * @memberOf engine
     */

    var DataController = function () {
    	/**
      * Creates data controller instance.
      *
      * @param {engine.model.Document} model Document model.
      * @param {engine.dataProcessor.DataProcessor} [dataProcessor] Data processor which should used by the controller.
      */

    	function DataController(model, dataProcessor) {
    		classCallCheck(this, DataController);

    		/**
       * Document model.
       *
       * @readonly
       * @member {engine.model.document} engine.DataController#model
       */
    		this.model = model;

    		/**
       * Data processor used during the conversion.
       *
       * @readonly
       * @member {engine.dataProcessor.DataProcessor} engine.DataController#processor
       */
    		this.processor = dataProcessor;

    		/**
       * Mapper used for the conversion. It has no permanent bindings, because they are created when getting data and
       * cleared directly after data are converted. However, the mapper is defined as class property, because
       * it needs to be passed to the `ModelConversionDispatcher` as a conversion API.
       *
       * @private
       * @member {engine.conversion.Mapper} engine.DataController#_mapper
       */
    		this._mapper = new Mapper();

    		/**
       * Writer used during the conversion.
       *
       * @private
       * @member {engine.view.Writer} engine.DataController#_writer
       */
    		this._writer = new Writer();

    		/**
       * DOM converter used during the conversion.
       *
       * @private
       * @member {engine.view.DomConverter} engine.DataController#_domConverter
       */
    		this._domConverter = new DomConverter({ blockFiller: NBSP_FILLER });

    		/**
       * Model to view conversion dispatcher used by the {@link engine.DataController#get get method}.
       * To attach model to view converter to the data pipeline you need to add lister to this property:
       *
       *		data.modelToView( 'insert:$element', customInsertConverter );
       *
       * Or use {@link engine.conversion.ModelConverterBuilder}:
       *
       *		BuildModelConverterFor( data.modelToView ).fromAttribute( 'bold' ).toElement( 'b' );
       *
       * @readonly
       * @member {engine.conversion.ModelConversionDispatcher} engine.DataController#modelToView
       */
    		this.modelToView = new ModelConversionDispatcher({
    			writer: this._writer,
    			mapper: this._mapper
    		});
    		this.modelToView.on('insert:$text', insertText());

    		/**
       * View to model conversion dispatcher used by the {@link engine.DataController#set set method}.
       * To attach view to model converter to the data pipeline you need to add lister to this property:
       *
       *		data.viewToModel( 'element', customElementConverter );
       *
       * Or use {@link engine.conversion.ViewConverterBuilder}:
       *
       *		BuildViewConverterFor( data.viewToModel ).fromElement( 'b' ).toAttribute( 'bold', 'true' );
       *
       * @readonly
       * @member {engine.conversion.ViewConversionDispatcher} engine.DataController#viewToModel
       */
    		this.viewToModel = new ViewConversionDispatcher({
    			schema: model.schema
    		});

    		// Define default converters for text and elements.
    		//
    		// Note that if there is no default converter for the element it will be skipped, for instance `<b>foo</b>` will be
    		// converted to nothing. We add `convertToModelFragment` as a last converter so it converts children of that
    		// element to the document fragment so `<b>foo</b>` will be converted to `foo` if there is no converter for `<b>`.
    		this.viewToModel.on('text', convertText());
    		this.viewToModel.on('element', convertToModelFragment(), null, 9999);
    		this.viewToModel.on('documentFragment', convertToModelFragment(), null, 9999);
    	}

    	/**
      * Returns model's data converted by the {@link engine.DataController#modelToView model to view converters} and
      * formatted by the {@link engine.DataController#processor data processor}.
      *
      * @param {String} [rootName='main'] Root name.
      * @returns {String} Output data.
      */


    	createClass(DataController, [{
    		key: 'get',
    		value: function get() {
    			var rootName = arguments.length <= 0 || arguments[0] === undefined ? 'main' : arguments[0];

    			// Get model range.
    			var modelRoot = this.model.getRoot(rootName);
    			var modelRange = Range$1.createFromElement(modelRoot);

    			// model -> view.
    			var viewDocumentFragment = new DocumentFragment$1();
    			this._mapper.bindElements(modelRoot, viewDocumentFragment);

    			this.modelToView.convertInsert(modelRange);

    			this._mapper.clearBindings();

    			// view -> DOM.
    			var domDocumentFragment = this._domConverter.viewToDom(viewDocumentFragment, document);

    			// DOM -> data.
    			return this.processor.toData(domDocumentFragment);
    		}

    		/**
       * Sets input data parsed by the {@link engine.DataController#processor data processor} and
       * converted by the {@link engine.DataController#viewToModel view to model converters}.
       *
       * This method also creates a batch with all the changes applied. If all you need is to parse data use
       * the {@link engine.dataController#parse} method.
       *
       * @param {String} data Input data.
       * @param {String} [rootName='main'] Root name.
       */

    	}, {
    		key: 'set',
    		value: function set(data) {
    			var _this = this;

    			var rootName = arguments.length <= 1 || arguments[1] === undefined ? 'main' : arguments[1];

    			// Save to model.
    			var modelRoot = this.model.getRoot(rootName);

    			this.model.enqueueChanges(function () {
    				// Initial batch should be ignored by features like undo, etc.
    				_this.model.batch('transparent').remove(Range$1.createFromElement(modelRoot)).insert(Position.createAt(modelRoot, 0), _this.parse(data));
    			});
    		}

    		/**
       * Returns data parsed by the {@link engine.DataController#processor data processor} and then
       * converted by the {@link engine.DataController#viewToModel view to model converters}.
       *
       * @see engine.DataController#set
       * @param {String} data Data to parse.
       * @returns {engine.model.DocumentFragment} Parsed data.
       */

    	}, {
    		key: 'parse',
    		value: function parse(data) {
    			// data -> DOM.
    			var domDocumentFragment = this.processor.toDom(data);

    			// DOM -> view.
    			var viewDocumentFragment = this._domConverter.domToView(domDocumentFragment);

    			// view -> model.
    			var modelDocumentFragment = this.viewToModel.convert(viewDocumentFragment, { context: ['$root'] });

    			return modelDocumentFragment;
    		}

    		/**
       * Removes all event listeners set by the DataController.
       */

    	}, {
    		key: 'destroy',
    		value: function destroy() {}
    	}]);
    	return DataController;
    }();

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to search.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /** Used for built-in method references. */
    var arrayProto = Array.prototype;

    /** Built-in value references. */
    var splice = arrayProto.splice;

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries ? entries.length : 0;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache();
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      return this.__data__['delete'](key);
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /** Used to resolve the decompiled source of functions. */
    var funcToString$2 = Function.prototype.toString;

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to process.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$2.call(func);
        } catch (e) {}
        try {
          return func + '';
        } catch (e) {}
      }
      return '';
    }

    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
     */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

    /** Used to detect host constructors (Safari). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;

    /** Used for built-in method references. */
    var objectProto$10 = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString$1 = Function.prototype.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty$4 = objectProto$10.hasOwnProperty;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$4).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (!isObject(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = object[key];
      return isNative(value) ? value : undefined;
    }

    /* Built-in method references that are verified to be native. */
    var nativeCreate = getNative(Object, 'create');

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';

    /** Used for built-in method references. */
    var objectProto$11 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$5 = objectProto$11.hasOwnProperty;

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty$5.call(data, key) ? data[key] : undefined;
    }

    /** Used for built-in method references. */
    var objectProto$12 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$6 = objectProto$12.hasOwnProperty;

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== undefined : hasOwnProperty$6.call(data, key);
    }

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
      return this;
    }

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries ? entries.length : 0;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /* Built-in method references that are verified to be native. */
    var Map$1 = getNative(root, 'Map');

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.__data__ = {
        'hash': new Hash(),
        'map': new (Map$1 || ListCache)(),
        'string': new Hash()
      };
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
      return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      return getMapData(this, key)['delete'](key);
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries ? entries.length : 0;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache && cache.__data__.length == LARGE_ARRAY_SIZE) {
        cache = this.__data__ = new MapCache(cache.__data__);
      }
      cache.set(key, value);
      return this;
    }

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /**
     * A specialized version of `_.forEach` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    /** Used for built-in method references. */
    var objectProto$13 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$7 = objectProto$13.hasOwnProperty;

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
      // that are composed entirely of index properties, return `false` for
      // `hasOwnProperty` checks of them.
      return hasOwnProperty$7.call(object, key) || (typeof object === 'undefined' ? 'undefined' : _typeof(object)) == 'object' && key in object && getPrototype(object) === null;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys = Object.keys;

    /**
     * The base implementation of `_.keys` which doesn't skip the constructor
     * property of prototypes or treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      return nativeKeys(Object(object));
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      var isProto = isPrototype(object);
      if (!(isProto || isArrayLike(object))) {
        return baseKeys(object);
      }
      var indexes = indexKeys(object),
          skipIndexes = !!indexes,
          result = indexes || [],
          length = result.length;

      for (var key in object) {
        if (baseHas(object, key) && !(skipIndexes && (key == 'length' || isIndex(key, length))) && !(isProto && key == 'constructor')) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /** Built-in value references. */
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;

    /**
     * Creates an array of the own enumerable symbol properties of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    function getSymbols(object) {
      // Coerce `object` to an object to avoid non-object errors in V8.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=3443 for more details.
      return getOwnPropertySymbols(Object(object));
    }

    // Fallback for IE < 11.
    if (!getOwnPropertySymbols) {
      getSymbols = function getSymbols() {
        return [];
      };
    }

    var getSymbols$1 = getSymbols;

    /**
     * Copies own symbol properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols$1(source), object);
    }

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols$1);
    }

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(root, 'DataView');

    /* Built-in method references that are verified to be native. */
    var Promise$1 = getNative(root, 'Promise');

    /* Built-in method references that are verified to be native. */
    var Set$1 = getNative(root, 'Set');

    /* Built-in method references that are verified to be native. */
    var WeakMap$1 = getNative(root, 'WeakMap');

var     mapTag$1 = '[object Map]';
var     objectTag$2 = '[object Object]';
    var promiseTag = '[object Promise]';
var     setTag$1 = '[object Set]';
var     weakMapTag$1 = '[object WeakMap]';
    var dataViewTag$1 = '[object DataView]';

    /** Used for built-in method references. */
    var objectProto$14 = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString$5 = objectProto$14.toString;

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map$1);
    var promiseCtorString = toSource(Promise$1);
    var setCtorString = toSource(Set$1);
    var weakMapCtorString = toSource(WeakMap$1);
    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function getTag(value) {
      return objectToString$5.call(value);
    }

    // Fallback for data views, maps, sets, and weak maps in IE 11,
    // for data views in Edge, and promises in Node.js.
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$1 || Map$1 && getTag(new Map$1()) != mapTag$1 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$1 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
      getTag = function getTag(value) {
        var result = objectToString$5.call(value),
            Ctor = result == objectTag$2 ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : undefined;

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag$1;
            case mapCtorString:
              return mapTag$1;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag$1;
            case weakMapCtorString:
              return weakMapTag$1;
          }
        }
        return result;
      };
    }

    var getTag$1 = getTag;

    /** Used for built-in method references. */
    var objectProto$15 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$8 = objectProto$15.hasOwnProperty;

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty$8.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /** Built-in value references. */
    var Uint8Array = root.Uint8Array;

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Adds the key-value `pair` to `map`.
     *
     * @private
     * @param {Object} map The map to modify.
     * @param {Array} pair The key-value pair to add.
     * @returns {Object} Returns `map`.
     */
    function addMapEntry(map, pair) {
      // Don't return `Map#set` because it doesn't return the map instance in IE 11.
      map.set(pair[0], pair[1]);
      return map;
    }

    /**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1,
          length = array.length;

      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */
    function mapToArray(map) {
      var index = -1,
          result = Array(map.size);

      map.forEach(function (value, key) {
        result[++index] = [key, value];
      });
      return result;
    }

    /**
     * Creates a clone of `map`.
     *
     * @private
     * @param {Object} map The map to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned map.
     */
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }

    /** Used to match `RegExp` flags from their coerced string values. */
    var reFlags = /\w*$/;

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Adds `value` to `set`.
     *
     * @private
     * @param {Object} set The set to modify.
     * @param {*} value The value to add.
     * @returns {Object} Returns `set`.
     */
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }

    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */
    function setToArray(set) {
      var index = -1,
          result = Array(set.size);

      set.forEach(function (value) {
        result[++index] = value;
      });
      return result;
    }

    /**
     * Creates a clone of `set`.
     *
     * @private
     * @param {Object} set The set to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned set.
     */
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }

    /** Built-in value references. */
    var _Symbol = root.Symbol;

    var symbolProto = _Symbol ? _Symbol.prototype : undefined;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

var     boolTag$1 = '[object Boolean]';
var     dateTag$1 = '[object Date]';
var     mapTag$2 = '[object Map]';
var     numberTag$1 = '[object Number]';
var     regexpTag$1 = '[object RegExp]';
var     setTag$2 = '[object Set]';
var     stringTag$2 = '[object String]';
var     symbolTag$2 = '[object Symbol]';
var     arrayBufferTag$1 = '[object ArrayBuffer]';
var     dataViewTag$2 = '[object DataView]';
var     float32Tag$1 = '[object Float32Array]';
var     float64Tag$1 = '[object Float64Array]';
var     int8Tag$1 = '[object Int8Array]';
var     int16Tag$1 = '[object Int16Array]';
var     int32Tag$1 = '[object Int32Array]';
var     uint8Tag$1 = '[object Uint8Array]';
var     uint8ClampedTag$1 = '[object Uint8ClampedArray]';
var     uint16Tag$1 = '[object Uint16Array]';
var     uint32Tag$1 = '[object Uint32Array]';
    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag$1:
          return cloneArrayBuffer(object);

        case boolTag$1:
        case dateTag$1:
          return new Ctor(+object);

        case dataViewTag$2:
          return cloneDataView(object, isDeep);

        case float32Tag$1:case float64Tag$1:
        case int8Tag$1:case int16Tag$1:case int32Tag$1:
        case uint8Tag$1:case uint8ClampedTag$1:case uint16Tag$1:case uint32Tag$1:
          return cloneTypedArray(object, isDeep);

        case mapTag$2:
          return cloneMap(object, isDeep, cloneFunc);

        case numberTag$1:
        case stringTag$2:
          return new Ctor(object);

        case regexpTag$1:
          return cloneRegExp(object);

        case setTag$2:
          return cloneSet(object, isDeep, cloneFunc);

        case symbolTag$2:
          return cloneSymbol(object);
      }
    }

    /** Built-in value references. */
    var objectCreate = Object.create;

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var getter = _.constant(object);
     *
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function () {
        return value;
      };
    }

    /** Used to determine if values are of the language type `Object`. */
    var objectTypes$1 = {
      'function': true,
      'object': true
    };

    /** Detect free variable `exports`. */
    var freeExports$1 = objectTypes$1[typeof exports === 'undefined' ? 'undefined' : _typeof(exports)] && exports && !exports.nodeType ? exports : undefined;

    /** Detect free variable `module`. */
    var freeModule$1 = objectTypes$1[typeof module === 'undefined' ? 'undefined' : _typeof(module)] && module && !module.nodeType ? module : undefined;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule$1 && freeModule$1.exports === freeExports$1 ? freeExports$1 : undefined;

    /** Built-in value references. */
    var Buffer = moduleExports ? root.Buffer : undefined;

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = !Buffer ? constant(false) : function (value) {
      return value instanceof Buffer;
    };

var     argsTag$1 = '[object Arguments]';
    var arrayTag = '[object Array]';
    var boolTag = '[object Boolean]';
    var dateTag = '[object Date]';
    var errorTag = '[object Error]';
var     funcTag$1 = '[object Function]';
var     genTag$1 = '[object GeneratorFunction]';
    var mapTag = '[object Map]';
    var numberTag = '[object Number]';
var     objectTag$1 = '[object Object]';
    var regexpTag = '[object RegExp]';
    var setTag = '[object Set]';
var     stringTag$1 = '[object String]';
var     symbolTag$1 = '[object Symbol]';
    var weakMapTag = '[object WeakMap]';
    var arrayBufferTag = '[object ArrayBuffer]';
    var dataViewTag = '[object DataView]';
    var float32Tag = '[object Float32Array]';
    var float64Tag = '[object Float64Array]';
    var int8Tag = '[object Int8Array]';
    var int16Tag = '[object Int16Array]';
    var int32Tag = '[object Int32Array]';
    var uint8Tag = '[object Uint8Array]';
    var uint8ClampedTag = '[object Uint8ClampedArray]';
    var uint16Tag = '[object Uint16Array]';
    var uint32Tag = '[object Uint32Array]';
    /** Used to identify `toStringTag` values supported by `_.clone`. */
    var cloneableTags = {};
    cloneableTags[argsTag$1] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag$1] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag$1] = cloneableTags[weakMapTag] = false;

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {boolean} [isFull] Specify a clone including symbols.
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag$1(value),
            isFunc = tag == funcTag$1 || tag == genTag$1;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      // Recursively populate clone (susceptible to call stack limits).
      arrayEach(props || value, function (subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, false, true);
    }

    /**
     * Abstract base operation class.
     *
     * @abstract
     * @memberOf engine.model.operation
     */

    var Operation = function () {
    	/**
      * Base operation constructor.
      * @param {Number} baseVersion {@link engine.model.Document#version} on which the operation can be applied.
      */

    	function Operation(baseVersion) {
    		classCallCheck(this, Operation);

    		/**
       * {@link engine.model.Document#version} on which operation can be applied. If you try to
       * {@link engine.model.Document#applyOperation apply} operation with different base version than the
       * {@link engine.model.Document#version document version} the {@link document-applyOperation-wrong-version}
       * error is thrown.
       *
       * @member {Number} engine.model.operation.Operation#baseVersion
       */
    		this.baseVersion = baseVersion;

    		/**
       * Operation type.
       *
       * @member {String} engine.model.operation.Operation#type
       */

    		/**
       * {@link engine.model.Delta Delta} which the operation is a part of. This property is set by the
       * {@link engine.model.Delta delta} when the operations is added to it by the
       * {@link engine.model.Delta#addOperation} method.
       *
       * @member {engine.model.Delta} engine.model.operation.Operation#delta
       */

    		/**
       * Creates and returns an operation that has the same parameters as this operation.
       *
       * @method engine.model.operation.Operation#clone
       * @returns {engine.model.operation.Operation} Clone of this operation.
       */

    		/**
       * Creates and returns a reverse operation. Reverse operation when executed right after
       * the original operation will bring back tree model state to the point before the original
       * operation execution. In other words, it reverses changes done by the original operation.
       *
       * Keep in mind that tree model state may change since executing the original operation,
       * so reverse operation will be "outdated". In that case you will need to
       * {@link engine.model.operation.transform} it by all operations that were executed after the original operation.
       *
       * @method engine.model.operation.Operation#getReversed
       * @returns {engine.model.operation.Operation} Reversed operation.
       */

    		/**
       * Executes the operation - modifications described by the operation attributes
       * will be applied to the tree model.
       *
       * @protected
       * @method engine.model.operation.Operation#_execute
       * @returns {Object} Object with additional information about the applied changes. Always has `range`
       * property containing changed nodes. May have additional properties depending on the operation type.
       */
    	}

    	/**
      * Custom toJSON method to solve child-parent circular dependencies.
      *
      * @method engine.model.operation.Operation#toJSON
      * @returns {Object} Clone of this object with the delta property replaced with string.
      */


    	createClass(Operation, [{
    		key: 'toJSON',
    		value: function toJSON() {
    			var json = clone(this, true);

    			json.__className = this.constructor.className;

    			// Remove parent delta to avoid circular dependencies.
    			delete json.delta;

    			return json;
    		}

    		/**
       * Name of the operation class used for serialization.
       *
       * @type {String}
       */

    	}], [{
    		key: 'fromJSON',


    		/**
       * Creates Operation object from deserilized object, i.e. from parsed JSON string.
       *
       * @param {Object} json Deserialized JSON object.
       * @param {engine.model.Document} doc Document on which this operation will be applied.
       * @returns {engine.model.operation.Operation}
       */
    		value: function fromJSON(json) {
    			return new Operation(json.baseVersion);
    		}
    	}, {
    		key: 'className',
    		get: function get() {
    			return 'engine.model.operation.Operation';
    		}
    	}]);
    	return Operation;
    }();

    /**
     * Operation to change nodes' attribute. Using this class you can add, remove or change value of the attribute.
     *
     * @memberOf engine.model.operation
     * @extends engine.model.operation.Operation
     */

    var AttributeOperation = function (_Operation) {
    	inherits(AttributeOperation, _Operation);

    	/**
      * Creates an operation that changes, removes or adds attributes.
      *
      * If only the new attribute is set, then it will be inserted. Note that in all nodes in ranges there must be
      * no attributes with the same key as the new attribute.
      *
      * If only the old attribute is set, then it will be removed. Note that this attribute must be present in all nodes in
      * ranges.
      *
      * If both new and old attributes are set, then the operation will change the attribute value. Note that both new and
      * old attributes have to have the same key and the old attribute must be present in all nodes in ranges.
      *
      * @param {engine.model.Range} range Range on which the operation should be applied.
      * @param {String} key Key of an attribute to change or remove.
      * @param {*} oldValue Old value of the attribute with given key or `null` if adding a new attribute.
      * @param {*} newValue New value to set for the attribute. If `null`, then the operation just removes the attribute.
      * @param {Number} baseVersion {@link engine.model.Document#version} on which the operation can be applied.
      */

    	function AttributeOperation(range, key, oldValue, newValue, baseVersion) {
    		classCallCheck(this, AttributeOperation);


    		/**
       * Range on which operation should be applied.
       *
       * @readonly
       * @member {engine.model.Range} engine.model.operation.AttributeOperation#range
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(AttributeOperation).call(this, baseVersion));

    		_this.range = Range$1.createFromRange(range);

    		/**
       * Key of an attribute to change or remove.
       *
       * @readonly
       * @member {String} engine.model.operation.AttributeOperation#key
       */
    		_this.key = key;

    		/**
       * Old value of the attribute with given key or `null` if adding a new attribute.
       *
       * @readonly
       * @member {*} engine.model.operation.AttributeOperation#oldValue
       */
    		_this.oldValue = oldValue;

    		/**
       * New value to set for the attribute. If `null`, then the operation just removes the attribute.
       *
       * @readonly
       * @member {*} engine.model.operation.AttributeOperation#newValue
       */
    		_this.newValue = newValue;
    		return _this;
    	}

    	createClass(AttributeOperation, [{
    		key: 'clone',


    		/**
       * @returns {engine.model.operation.AttributeOperation}
       */
    		value: function clone() {
    			return new AttributeOperation(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
    		}

    		/**
       * @returns {engine.model.operation.AttributeOperation}
       */

    	}, {
    		key: 'getReversed',
    		value: function getReversed() {
    			return new AttributeOperation(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
    		}
    	}, {
    		key: '_execute',
    		value: function _execute() {
    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = this.range.getItems()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var item = _step.value;

    					if (this.oldValue !== null && item.getAttribute(this.key) !== this.oldValue) {
    						/**
           * The attribute which should be removed does not exists for the given node.
           *
           * @error operation-attribute-no-attr-to-remove
           * @param {engine.model.Item} item
           * @param {String} key
           * @param {*} value
           */
    						throw new CKEditorError('operation-attribute-no-attr-to-remove: The attribute which should be removed does not exists for given node.', { item: item, key: this.key });
    					}

    					if (this.oldValue === null && this.newValue !== null && item.hasAttribute(this.key)) {
    						/**
           * The attribute with given key already exists for the given node.
           *
           * @error operation-attribute-attr-exists
           * @param {engine.model.Node} node
           * @param {String} key
           */
    						throw new CKEditorError('operation-attribute-attr-exists: The attribute with given key already exists.', { node: item, key: this.key });
    					}

    					if (this.newValue !== null) {
    						item.setAttribute(this.key, this.newValue);
    					} else {
    						item.removeAttribute(this.key);
    					}
    				}
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}

    			return { range: this.range, key: this.key, oldValue: this.oldValue, newValue: this.newValue };
    		}

    		/**
       * @inheritDoc
       */

    	}, {
    		key: 'type',
    		get: function get() {
    			if (this.oldValue === null) {
    				return 'addAttribute';
    			} else if (this.newValue === null) {
    				return 'removeAttribute';
    			} else {
    				return 'changeAttribute';
    			}
    		}
    	}], [{
    		key: 'fromJSON',


    		/**
       * Creates AttributeOperation object from deserilized object, i.e. from parsed JSON string.
       *
       * @param {Object} json Deserialized JSON object.
       * @param {engine.model.Document} document Document on which this operation will be applied.
       * @returns {engine.model.operation.AttributeOperation}
       */
    		value: function fromJSON(json, document) {
    			return new AttributeOperation(Range$1.fromJSON(json.range, document), json.key, json.oldValue, json.newValue, json.baseVersion);
    		}
    	}, {
    		key: 'className',
    		get: function get() {
    			return 'engine.model.operation.AttributeOperation';
    		}
    	}]);
    	return AttributeOperation;
    }(Operation);

    /**
     * Operation to move list of subsequent nodes from one position in the document to another.
     *
     * @memberOf engine.model.operation
     * @extends engine.model.operation.Operation
     */

    var MoveOperation = function (_Operation) {
    	inherits(MoveOperation, _Operation);

    	/**
      * Creates a move operation.
      *
      * @param {engine.model.Position} sourcePosition Position before the first node to move.
      * @param {Number} howMany How many consecutive nodes to move, starting from `sourcePosition`.
      * @param {engine.model.Position} targetPosition Position where moved nodes will be inserted.
      * @param {Number} baseVersion {@link engine.model.Document#version} on which operation can be applied.
      */

    	function MoveOperation(sourcePosition, howMany, targetPosition, baseVersion) {
    		classCallCheck(this, MoveOperation);


    		/**
       * Source move position.
       *
       * @member {engine.model.Position} engine.model.operation.MoveOperation#sourcePosition
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(MoveOperation).call(this, baseVersion));

    		_this.sourcePosition = Position.createFromPosition(sourcePosition);

    		/**
       * How many nodes to move.
       *
       * @member {Number} engine.model.operation.MoveOperation#howMany
       */
    		_this.howMany = howMany;

    		/**
       * Target move position.
       *
       * @member {engine.model.Position} engine.model.operation.MoveOperation#targetPosition
       */
    		_this.targetPosition = Position.createFromPosition(targetPosition);

    		/**
       * Position of the start of the moved range after it got moved. This may be different than
       * {@link engine.model.operation.MoveOperation#targetPosition} in some cases, i.e. when a range is moved
       * inside the same parent but {@link engine.model.operation.MoveOperation#targetPosition targetPosition}
       * is after {@link engine.model.operation.MoveOperation#sourcePosition sourcePosition}.
       *
       *		 vv              vv
       *		abcdefg ===> adefbcg
       *		     ^          ^
       *		     targetPos	movedRangeStart
       *		     offset 6	offset 4
       *
       * @member {engine.model.Position} engine.model.operation.MoveOperation#movedRangeStart
       */
    		_this.movedRangeStart = _this.targetPosition.getTransformedByDeletion(_this.sourcePosition, _this.howMany);

    		/**
       * Defines whether `MoveOperation` is sticky. If `MoveOperation` is sticky, during
       * {@link engine.model.operation.transform operational transformation} if there will be an operation that
       * inserts some nodes at the position equal to the boundary of this `MoveOperation`, that operation will
       * get their insertion path updated to the position where this `MoveOperation` moves the range.
       *
       * @member {Boolean} engine.model.operation.MoveOperation#isSticky
       */
    		_this.isSticky = false;
    		return _this;
    	}

    	createClass(MoveOperation, [{
    		key: 'clone',


    		/**
       * @returns {engine.model.operation.MoveOperation}
       */
    		value: function clone() {
    			var op = new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
    			op.isSticky = this.isSticky;

    			return op;
    		}

    		/**
       * @returns {engine.model.operation.MoveOperation}
       */

    	}, {
    		key: 'getReversed',
    		value: function getReversed() {
    			var newTargetPosition = this.sourcePosition.getTransformedByInsertion(this.targetPosition, this.howMany);

    			var op = new this.constructor(this.movedRangeStart, this.howMany, newTargetPosition, this.baseVersion + 1);
    			op.isSticky = this.isSticky;

    			return op;
    		}
    	}, {
    		key: '_execute',
    		value: function _execute() {
    			var sourceElement = this.sourcePosition.parent;
    			var targetElement = this.targetPosition.parent;
    			var sourceOffset = this.sourcePosition.offset;
    			var targetOffset = this.targetPosition.offset;

    			// Validate whether move operation has correct parameters.
    			// Validation is pretty complex but move operation is one of the core ways to manipulate the document state.
    			// We expect that many errors might be connected with one of scenarios described below.
    			if (!sourceElement || !targetElement) {
    				/**
         * Source position or target position is invalid.
         *
         * @error operation-move-position-invalid
         */
    				throw new CKEditorError('operation-move-position-invalid: Source position or target position is invalid.');
    			} else if (sourceOffset + this.howMany > sourceElement.getChildCount()) {
    				/**
         * The nodes which should be moved do not exist.
         *
         * @error operation-move-nodes-do-not-exist
         */
    				throw new CKEditorError('operation-move-nodes-do-not-exist: The nodes which should be moved do not exist.');
    			} else if (sourceElement === targetElement && sourceOffset < targetOffset && targetOffset < sourceOffset + this.howMany) {
    				/**
         * Trying to move a range of nodes into the middle of that range.
         *
         * @error operation-move-range-into-itself
         */
    				throw new CKEditorError('operation-move-range-into-itself: Trying to move a range of nodes to the inside of that range.');
    			} else if (this.sourcePosition.root == this.targetPosition.root) {
    				if (compareArrays(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == 'PREFIX') {
    					var i = this.sourcePosition.path.length - 1;

    					if (this.targetPosition.path[i] >= sourceOffset && this.targetPosition.path[i] < sourceOffset + this.howMany) {
    						/**
           * Trying to move a range of nodes into one of nodes from that range.
           *
           * @error operation-move-node-into-itself
           */
    						throw new CKEditorError('operation-move-node-into-itself: Trying to move a range of nodes into one of nodes from that range.');
    					}
    				}
    			}
    			// End of validation.

    			// If we move children in the same element and we remove elements on the position before the target we
    			// need to update a target offset.
    			if (sourceElement === targetElement && sourceOffset < targetOffset) {
    				targetOffset -= this.howMany;
    			}

    			var removedNodes = sourceElement.removeChildren(sourceOffset, this.howMany);

    			targetElement.insertChildren(targetOffset, removedNodes);

    			return {
    				sourcePosition: this.sourcePosition,
    				range: Range$1.createFromPositionAndShift(this.movedRangeStart, this.howMany)
    			};
    		}

    		/**
       * @inheritDoc
       */

    	}, {
    		key: 'type',
    		get: function get() {
    			return 'move';
    		}
    	}], [{
    		key: 'fromJSON',


    		/**
       * Creates MoveOperation object from deserilized object, i.e. from parsed JSON string.
       *
       * @param {Object} json Deserialized JSON object.
       * @param {engine.model.Document} document Document on which this operation will be applied.
       * @returns {engine.model.operation.MoveOperation}
       */
    		value: function fromJSON(json, document) {
    			var sourcePosition = Position.fromJSON(json.sourcePosition, document);
    			var targetPosition = Position.fromJSON(json.targetPosition, document);

    			return new MoveOperation(sourcePosition, json.howMany, targetPosition, json.baseVersion);
    		}
    	}, {
    		key: 'className',
    		get: function get() {
    			return 'engine.model.operation.MoveOperation';
    		}
    	}]);
    	return MoveOperation;
    }(Operation);

    /**
     * Operation to reinsert previously removed nodes back to the non-graveyard root.
     * This is basically {@link engine.model.operation.MoveOperation} but it returns
     * {@link engine.model.operation.RemoveOperation} when reversed.
     *
     * With this class, we achieve two goals: by having separate classes it's easier to distinguish whether move
     * operation is actually a remove/reinsert operation and fire proper events. Also it
     * will be easier to expand if we need to change operation's behavior if it is remove/reinsert.
     *
     * @memberOf engine.model.operation
     * @extends engine.model.operation.Operation
     */

    var ReinsertOperation = function (_MoveOperation) {
    	inherits(ReinsertOperation, _MoveOperation);

    	function ReinsertOperation() {
    		classCallCheck(this, ReinsertOperation);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(ReinsertOperation).apply(this, arguments));
    	}

    	createClass(ReinsertOperation, [{
    		key: 'getReversed',


    		/**
       * @returns {engine.model.operation.RemoveOperation}
       */
    		value: function getReversed() {
    			return new RemoveOperation(this.targetPosition, this.howMany, this.baseVersion + 1);
    		}

    		/**
       * @inheritDoc
       */

    	}, {
    		key: 'position',

    		/**
       * Position where re-inserted node will be inserted.
       *
       * @type {engine.model.Position}
       */
    		get: function get() {
    			return this.targetPosition;
    		},
    		set: function set(pos) {
    			this.targetPosition = pos;
    		}
    	}, {
    		key: 'type',
    		get: function get() {
    			return 'reinsert';
    		}
    	}], [{
    		key: 'className',
    		get: function get() {
    			return 'engine.model.operation.ReinsertOperation';
    		}
    	}]);
    	return ReinsertOperation;
    }(MoveOperation);

    /**
     * Operation to remove a range of nodes.
     *
     * @memberOf engine.model.operation
     * @extends engine.model.operation.Operation
     */

    var RemoveOperation = function (_MoveOperation) {
    	inherits(RemoveOperation, _MoveOperation);

    	/**
      *
      * Creates a remove operation.
      *
      * @param {engine.model.Position} position Position before the first node to remove.
      * @param {Number} howMany How many nodes to remove.
      * @param {Number} baseVersion {@link engine.model.Document#version} on which operation can be applied.
      */

    	function RemoveOperation(position, howMany, baseVersion) {
    		classCallCheck(this, RemoveOperation);

    		var graveyard = position.root.document.graveyard;

    		return possibleConstructorReturn(this, Object.getPrototypeOf(RemoveOperation).call(this, position, howMany, new Position(graveyard, [graveyard.getChildCount(), 0]), baseVersion));
    	}

    	/**
      * @inheritDoc
      */


    	createClass(RemoveOperation, [{
    		key: 'getReversed',


    		/**
       * @returns {engine.model.operation.ReinsertOperation}
       */
    		value: function getReversed() {
    			return new ReinsertOperation(this.targetPosition, this.howMany, this.sourcePosition, this.baseVersion + 1);
    		}

    		/**
       * @returns {engine.model.operation.RemoveOperation}
       */

    	}, {
    		key: 'clone',
    		value: function clone() {
    			var removeOperation = new RemoveOperation(this.sourcePosition, this.howMany, this.baseVersion);
    			removeOperation.targetPosition = Position.createFromPosition(this.targetPosition);
    			removeOperation.movedRangeStart = Position.createFromPosition(this.movedRangeStart);

    			return removeOperation;
    		}

    		/**
       * @inheritDoc
       */

    	}, {
    		key: '_execute',
    		value: function _execute() {
    			if (this._needsHolderElement) {
    				var graveyard = this.targetPosition.root;
    				var holderElement = new Element('$graveyardHolder');

    				graveyard.insertChildren(this.targetPosition.path[0], holderElement);
    			}

    			return get(Object.getPrototypeOf(RemoveOperation.prototype), '_execute', this).call(this);
    		}

    		/**
       * @inheritDoc
       */

    	}, {
    		key: 'type',
    		get: function get() {
    			return 'remove';
    		}

    		/**
       * Offset of the graveyard "holder" element, in which nodes removed by this operation are stored.
       *
       * @protected
       * @type {Number}
       */

    	}, {
    		key: '_holderElementOffset',
    		get: function get() {
    			return this.targetPosition.path[0];
    		}

    		/**
       * Sets {@link engine.model.operation.RemoveOperation#_holderElementOffset}.
       *
       * @protected
       * @param {Number} offset
       */
    		,
    		set: function set(offset) {
    			this.targetPosition.path[0] = offset;
    		}

    		/**
       * Flag informing whether this operation should insert "holder" element (`true`) or should remove nodes
       * into existing "holder" element (`false`). It is `true` for each `RemoveOperation` that is the first `RemoveOperation`
       * in it's delta which points to given holder element.
       *
       * @protected
       * @type {Boolean}
       */

    	}, {
    		key: '_needsHolderElement',
    		get: function get() {
    			if (this.delta) {
    				// Let's look up all operations from this delta in the same order as they are in the delta.
    				var _iteratorNormalCompletion = true;
    				var _didIteratorError = false;
    				var _iteratorError = undefined;

    				try {
    					for (var _iterator = this.delta.operations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    						var operation = _step.value;

    						// We are interested only in `RemoveOperation`s.
    						if (operation instanceof RemoveOperation) {
    							// If the first `RemoveOperation` in the delta is this operation, this operation
    							// needs to insert holder element in the graveyard.
    							if (operation == this) {
    								return true;
    							} else if (operation._holderElementOffset == this._holderElementOffset) {
    								// If there is a `RemoveOperation` in this delta that "points" to the same holder element offset,
    								// that operation will already insert holder element at that offset. We should not create another holder.
    								return false;
    							}
    						}
    					}
    				} catch (err) {
    					_didIteratorError = true;
    					_iteratorError = err;
    				} finally {
    					try {
    						if (!_iteratorNormalCompletion && _iterator.return) {
    							_iterator.return();
    						}
    					} finally {
    						if (_didIteratorError) {
    							throw _iteratorError;
    						}
    					}
    				}
    			}

    			// By default `RemoveOperation` needs holder element, so set it so, if the operation does not have delta.
    			return true;
    		}
    	}], [{
    		key: 'className',
    		get: function get() {
    			return 'engine.model.operation.RemoveOperation';
    		}
    	}]);
    	return RemoveOperation;
    }(MoveOperation);

    /**
     * Operation to insert list of nodes on the given position in the tree data model.
     *
     * @memberOf engine.model.operation
     * @extends engine.model.operation.Operation
     */

    var InsertOperation = function (_Operation) {
    	inherits(InsertOperation, _Operation);

    	/**
      * Creates an insert operation.
      *
      * @param {engine.model.Position} position Position of insertion.
      * @param {engine.model.NodeSet} nodes The list of nodes to be inserted.
      * List of nodes can be any type accepted by the {@link engine.model.NodeList} constructor.
      * @param {Number} baseVersion {@link engine.model.Document#version} on which operation can be applied.
      */

    	function InsertOperation(position, nodes, baseVersion) {
    		classCallCheck(this, InsertOperation);


    		/**
       * Position of insertion.
       *
       * @readonly
       * @member {engine.model.Position} engine.model.operation.InsertOperation#position
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(InsertOperation).call(this, baseVersion));

    		_this.position = Position.createFromPosition(position);

    		/**
       * List of nodes to insert.
       *
       * @readonly
       * @member {engine.model.NodeList} engine.model.operation.InsertOperation#nodeList
       */
    		_this.nodeList = new NodeList(nodes);
    		return _this;
    	}

    	createClass(InsertOperation, [{
    		key: 'clone',


    		/**
       * @returns {engine.model.operation.InsertOperation}
       */
    		value: function clone() {
    			return new InsertOperation(this.position, this.nodeList, this.baseVersion);
    		}

    		/**
       * @returns {engine.model.operation.RemoveOperation}
       */

    	}, {
    		key: 'getReversed',
    		value: function getReversed() {
    			return new RemoveOperation(this.position, this.nodeList.length, this.baseVersion + 1);
    		}
    	}, {
    		key: '_execute',
    		value: function _execute() {
    			this.position.parent.insertChildren(this.position.offset, this.nodeList);

    			return {
    				range: Range$1.createFromPositionAndShift(this.position, this.nodeList.length)
    			};
    		}

    		/**
       * @inheritDoc
       */

    	}, {
    		key: 'type',
    		get: function get() {
    			return 'insert';
    		}
    	}], [{
    		key: 'fromJSON',


    		/**
       * Creates InsertOperation object from deserilized object, i.e. from parsed JSON string.
       *
       * @param {Object} json Deserialized JSON object.
       * @param {engine.model.Document} document Document on which this operation will be applied.
       * @returns {engine.model.operation.InsertOperation}
       */
    		value: function fromJSON(json, document) {
    			return new InsertOperation(Position.fromJSON(json.position, document), NodeList.fromJSON(json.nodeList), json.baseVersion);
    		}
    	}, {
    		key: 'className',
    		get: function get() {
    			return 'engine.model.operation.InsertOperation';
    		}
    	}]);
    	return InsertOperation;
    }(Operation);

    /**
     * Operation which is doing nothing ("empty operation", "do-nothing operation", "noop").
     * This is an operation, which when executed does not change the tree model.
     * It still has some parameters defined for transformation purposes.
     *
     * In most cases this operation is a result of transforming operations. When transformation returns
     * {@link engine.model.operation.NoOperation} it means that changes done by the transformed operation
     * have already been applied.
     *
     * @memberOf engine.model.operation
     * @extends engine.model.operation.Operation
     */

    var NoOperation = function (_Operation) {
    	inherits(NoOperation, _Operation);

    	function NoOperation() {
    		classCallCheck(this, NoOperation);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(NoOperation).apply(this, arguments));
    	}

    	createClass(NoOperation, [{
    		key: 'clone',

    		/**
       * @returns {engine.model.operation.NoOperation}
       */
    		value: function clone() {
    			return new NoOperation(this.baseVersion);
    		}

    		/**
       * @returns {engine.model.operation.NoOperation}
       */

    	}, {
    		key: 'getReversed',
    		value: function getReversed() {
    			return new NoOperation(this.baseVersion + 1);
    		}
    	}, {
    		key: '_execute',
    		value: function _execute() {}
    		// Do nothing.


    		/**
       * @inheritDoc
       */

    	}], [{
    		key: 'className',
    		get: function get() {
    			return 'engine.model.operation.NoOperation';
    		}
    	}]);
    	return NoOperation;
    }(Operation);

    /**
     * Operation to change root element's attribute. Using this class you can add, remove or change value of the attribute.
     *
     * This operation is needed, because root elements can't be changed through {@link engine.model.operation.AttributeOperation}.
     * It is because {@link engine.model.operation.AttributeOperation} requires a range to change and root element can't
     * be a part of range because every {@link engine.model.Position} has to be inside a root. {@link engine.model.Position}
     * can't be created before a root element.
     *
     * @memberOf engine.model.operation
     * @extends engine.model.operation.Operation
     */

    var RootAttributeOperation = function (_Operation) {
    	inherits(RootAttributeOperation, _Operation);

    	/**
      * Creates an operation that changes, removes or adds attributes on root element.
      *
      * @see engine.model.operation.AttributeOperation
      * @param {engine.model.RootElement} root Root element to change.
      * @param {String} key Key of an attribute to change or remove.
      * @param {*} oldValue Old value of the attribute with given key or `null` if adding a new attribute.
      * @param {*} newValue New value to set for the attribute. If `null`, then the operation just removes the attribute.
      * @param {Number} baseVersion {@link engine.model.Document#version} on which the operation can be applied.
      */

    	function RootAttributeOperation(root, key, oldValue, newValue, baseVersion) {
    		classCallCheck(this, RootAttributeOperation);


    		/**
       * Root element to change.
       *
       * @readonly
       * @member {engine.model.RootElement} engine.model.operation.RootAttributeOperation#root
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(RootAttributeOperation).call(this, baseVersion));

    		_this.root = root;

    		/**
       * Key of an attribute to change or remove.
       *
       * @readonly
       * @member {String} engine.model.operation.RootAttributeOperation#key
       */
    		_this.key = key;

    		/**
       * Old value of the attribute with given key or `null` if adding a new attribute.
       *
       * @readonly
       * @member {*} engine.model.operation.RootAttributeOperation#oldValue
       */
    		_this.oldValue = oldValue;

    		/**
       * New value to set for the attribute. If `null`, then the operation just removes the attribute.
       *
       * @readonly
       * @member {*} engine.model.operation.RootAttributeOperation#newValue
       */
    		_this.newValue = newValue;
    		return _this;
    	}

    	createClass(RootAttributeOperation, [{
    		key: 'clone',


    		/**
       * @returns {engine.model.operation.RootAttributeOperation}
       */
    		value: function clone() {
    			return new RootAttributeOperation(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
    		}

    		/**
       * @returns {engine.model.operation.RootAttributeOperation}
       */

    	}, {
    		key: 'getReversed',
    		value: function getReversed() {
    			return new RootAttributeOperation(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
    		}
    	}, {
    		key: '_execute',
    		value: function _execute() {
    			if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue) {
    				/**
         * The attribute which should be removed does not exists for the given node.
         *
         * @error operation-rootattribute-no-attr-to-remove
         * @param {engine.model.RootElement} root
         * @param {String} key
         * @param {*} value
         */
    				throw new CKEditorError('operation-rootattribute-no-attr-to-remove: The attribute which should be removed does not exists for given node.', { root: this.root, key: this.key });
    			}

    			if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key)) {
    				/**
         * The attribute with given key already exists for the given node.
         *
         * @error operation-rootattribute-attr-exists
         * @param {engine.model.RootElement} root
         * @param {String} key
         */
    				throw new CKEditorError('operation-rootattribute-attr-exists: The attribute with given key already exists.', { root: this.root, key: this.key });
    			}

    			if (this.newValue !== null) {
    				this.root.setAttribute(this.key, this.newValue);
    			} else {
    				this.root.removeAttribute(this.key);
    			}

    			return { root: this.root, key: this.key, oldValue: this.oldValue, newValue: this.newValue };
    		}

    		/**
       * @inheritDoc
       */

    	}, {
    		key: 'type',
    		get: function get() {
    			if (this.oldValue === null) {
    				return 'addRootAttribute';
    			} else if (this.newValue === null) {
    				return 'removeRootAttribute';
    			} else {
    				return 'changeRootAttribute';
    			}
    		}
    	}], [{
    		key: 'fromJSON',


    		/**
       * Creates RootAttributeOperation object from deserilized object, i.e. from parsed JSON string.
       *
       * @param {Object} json Deserialized JSON object.
       * @param {engine.model.Document} document Document on which this operation will be applied.
       * @returns {engine.model.operation.RootAttributeOperation}
       */
    		value: function fromJSON(json, document) {
    			if (!document.hasRoot(json.root)) {
    				/**
         * Cannot create RootAttributeOperation for document. Root with specified name does not exist.
         *
         * @error rootattributeoperation-fromjson-no-root
         * @param {String} rootName
         */
    				throw new CKEditorError('rootattributeoperation-fromjson-no-root: Cannot create RootAttributeOperation. Root with specified name does not exist.', { rootName: json });
    			}

    			return new RootAttributeOperation(document.getRoot(json.root), json.key, json.oldValue, json.newValue, json.baseVersion);
    		}
    	}, {
    		key: 'className',
    		get: function get() {
    			return 'engine.model.operation.RootAttributeOperation';
    		}
    	}]);
    	return RootAttributeOperation;
    }(Operation);

    var operations = {};
    operations[AttributeOperation.className] = AttributeOperation;
    operations[InsertOperation.className] = InsertOperation;
    operations[MoveOperation.className] = MoveOperation;
    operations[NoOperation.className] = NoOperation;
    operations[Operation.className] = Operation;
    operations[ReinsertOperation.className] = ReinsertOperation;
    operations[RemoveOperation.className] = RemoveOperation;
    operations[RootAttributeOperation.className] = RootAttributeOperation;

    /**
     * A factory class for creating operations.
     *
     * @abstract
     * @memberOf engine.model.operation
     */

    var OperationFactory = function () {
    	function OperationFactory() {
    		classCallCheck(this, OperationFactory);
    	}

    	createClass(OperationFactory, null, [{
    		key: 'fromJSON',

    		/**
       * Creates concrete Operation object from deserilized object, i.e. from parsed JSON string.
       *
       * @param {Object} json Deserialized JSON object.
       * @param {engine.model.Document} document Document on which this operation will be applied.
       * @returns {engine.model.operation.Operation}
       */
    		value: function fromJSON(json, document) {
    			return operations[json.__className].fromJSON(json, document);
    		}
    	}]);
    	return OperationFactory;
    }();

    var deserializers = new Map();

    /**
     * A factory class for creating operations.
     *
     * Delta is a single, from the user action point of view, change in the editable document, like insert, split or
     * rename element. Delta is composed of operations, which are unit changes needed to be done to execute user action.
     *
     * Multiple deltas are grouped into a single {@link engine.model.Batch}.
     *
     * @memberOf engine.model.delta
     */

    var DeltaFactory = function () {
    	function DeltaFactory() {
    		classCallCheck(this, DeltaFactory);
    	}

    	createClass(DeltaFactory, null, [{
    		key: 'fromJSON',

    		/**
       * Creates InsertDelta from deserialized object, i.e. from parsed JSON string.
       *
       * @param {Object} json
       * @param {engine.model.Document} doc Document on which this delta will be applied.
       * @returns {engine.model.delta.InsertDelta}
       */
    		value: function fromJSON(json, doc) {
    			if (!deserializers.has(json.__className)) {
    				/**
         * This delta has no defined deserializer.
         *
         * @error delta-fromjson-no-deserializer
         * @param {String} name
         */
    				throw new CKEditorError('delta-fromjson-no-deserializer: This delta has no defined deserializer', { name: json.__className });
    			}

    			var Delta = deserializers.get(json.__className);

    			var delta = new Delta();

    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = json.operations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var operation = _step.value;

    					delta.addOperation(OperationFactory.fromJSON(operation, doc));
    				}
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}

    			return delta;
    		}

    		/**
       * Registers a class for delta factory.
       *
       * @param {Function} Delta A delta class to register.
       */

    	}, {
    		key: 'register',
    		value: function register(Delta) {
    			deserializers.set(Delta.className, Delta);
    		}
    	}]);
    	return DeltaFactory;
    }();

    /**
     * Base class for all deltas.
     *
     * Delta is a single, from the user action point of view, change in the editable document, like insert, split or
     * rename element. Delta is composed of operations, which are unit changes needed to be done to execute user action.
     *
     * Multiple deltas are grouped into a single {@link engine.model.Batch}.
     *
     * @memberOf engine.model.delta
     */

    var Delta = function () {
    	/**
      * Creates a delta instance.
      */

    	function Delta() {
    		classCallCheck(this, Delta);

    		/**
       * {@link engine.model.Batch} which delta is a part of. This property is null by default and set by the
       * {@link engine.model.Batch#addDelta} method.
       *
       * @readonly
       * @member {engine.model.Batch} engine.model.delta.Delta#batch
       */
    		this.batch = null;

    		/**
       * Array of operations which compose delta.
       *
       * @readonly
       * @member {engine.model.operation.Operation[]} engine.model.delta.Delta#operations
       */
    		this.operations = [];
    	}

    	/**
      * Returns delta base version which is equal to the base version of the first operation in delta. If there
      * are no operations in delta, returns `null`.
      *
      * @see engine.model.Document
      * @type {Number|null}
      */


    	createClass(Delta, [{
    		key: 'addOperation',


    		/**
       * Add operation to the delta.
       *
       * @param {engine.model.operation.Operation} operation Operation instance.
       */
    		value: function addOperation(operation) {
    			operation.delta = this;
    			this.operations.push(operation);

    			return operation;
    		}

    		/**
       * Creates and returns a delta that has the same parameters as this delta.
       *
       * @returns {engine.model.delta.Delta} Clone of this delta.
       */

    	}, {
    		key: 'clone',
    		value: function clone() {
    			var delta = new this.constructor();

    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = this.operations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var op = _step.value;

    					delta.addOperation(op.clone());
    				}
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}

    			return delta;
    		}

    		/**
       * Creates and returns a reverse delta. Reverse delta when executed right after the original delta will bring back
       * tree model state to the point before the original delta execution. In other words, it reverses changes done
       * by the original delta.
       *
       * Keep in mind that tree model state may change since executing the original delta, so reverse delta may be "outdated".
       * In that case you will need to {@link engine.model.delta.transform} it by all deltas that were executed after
       * the original delta.
       *
       * @returns {engine.model.delta.Delta} Reversed delta.
       */

    	}, {
    		key: 'getReversed',
    		value: function getReversed() {
    			var delta = new this._reverseDeltaClass();

    			var _iteratorNormalCompletion2 = true;
    			var _didIteratorError2 = false;
    			var _iteratorError2 = undefined;

    			try {
    				for (var _iterator2 = this.operations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    					var op = _step2.value;

    					delta.addOperation(op.getReversed());
    				}
    			} catch (err) {
    				_didIteratorError2 = true;
    				_iteratorError2 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion2 && _iterator2.return) {
    						_iterator2.return();
    					}
    				} finally {
    					if (_didIteratorError2) {
    						throw _iteratorError2;
    					}
    				}
    			}

    			delta.operations.reverse();

    			for (var i = 0; i < delta.operations.length; i++) {
    				delta.operations[i].baseVersion = this.operations[this.operations.length - 1].baseVersion + i + 1;
    			}

    			return delta;
    		}

    		/**
       * Custom toJSON method to make deltas serializable.
       *
       * @returns {Object} Clone of this delta with added class name.
       */

    	}, {
    		key: 'toJSON',
    		value: function toJSON() {
    			var json = clone(this);

    			json.__className = this.constructor.className;

    			// Remove parent batch to avoid circular dependencies.
    			delete json.batch;

    			return json;
    		}

    		/**
       * Delta class name. Used by {@link engine.model.delta.Delta#toJSON} method for serialization and
       * {@link engine.model.delta.DeltaFactory.fromJSON} during deserialization.
       *
       * @type {String}
       * @readonly
       */

    	}, {
    		key: 'baseVersion',
    		get: function get() {
    			if (this.operations.length > 0) {
    				return this.operations[0].baseVersion;
    			}

    			return null;
    		}

    		/**
       * @protected
       * @param {Number} baseVersion
       */
    		,
    		set: function set(baseVersion) {
    			var _iteratorNormalCompletion3 = true;
    			var _didIteratorError3 = false;
    			var _iteratorError3 = undefined;

    			try {
    				for (var _iterator3 = this.operations[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
    					var operation = _step3.value;

    					operation.baseVersion = baseVersion++;
    				}
    			} catch (err) {
    				_didIteratorError3 = true;
    				_iteratorError3 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion3 && _iterator3.return) {
    						_iterator3.return();
    					}
    				} finally {
    					if (_didIteratorError3) {
    						throw _iteratorError3;
    					}
    				}
    			}
    		}

    		/**
       * A class that will be used when creating reversed delta.
       *
       * @private
       * @type {Function}
       */

    	}, {
    		key: '_reverseDeltaClass',
    		get: function get() {
    			return Delta;
    		}
    	}], [{
    		key: 'className',
    		get: function get() {
    			return 'engine.model.delta.Delta';
    		}

    		/**
       * Delta priority. Used in {@link engine.model.delta.transform delta transformations}. Delta with the higher
       * priority will be treated as more important when resolving transformation conflicts. If deltas have same
       * priority, other factors will be used to determine which delta is more important.
       *
       * @private
       * @type {Number}
       */

    	}, {
    		key: '_priority',
    		get: function get() {
    			return 0;
    		}
    	}]);
    	return Delta;
    }();

    DeltaFactory.register(Delta);

    /**
     * The Batch class groups document changes (deltas). All deltas grouped in a single Batch can be
     * reverted together, so you can think about the Batch as a single undo step. If you want to extend one
     * undo step you can call another method on the same Batch object. If you want to create a separate undo step
     * you can create a new Batch.
     *
     * For example to create two separate undo steps you can call:
     *
     *		doc.batch().insert( firstPosition, 'foo' );
     *		doc.batch().insert( secondPosition, 'bar' );
     *
     * To create a single undo step:
     *
     *		const batch = doc.batch();
     *		batch.insert( firstPosition, 'foo' );
     *		batch.insert( secondPosition, 'bar' );
     *
     * Note that all document modification methods (insert, remove, split, etc.) are chainable so you can shorten code to:
     *
     *		doc.batch().insert( firstPosition, 'foo' ).insert( secondPosition, 'bar' );
     *
     * @memberOf engine.model
     */

    var Batch = function () {
    	/**
      * Creates Batch instance. Not recommended to use directly, use {@link engine.model.Document#batch} instead.
      *
      * @param {engine.model.Document} doc Document which this Batch changes.
      * @param {'transparent'|'default'} [type='default'] Type of the batch.
      */

    	function Batch(doc) {
    		var type = arguments.length <= 1 || arguments[1] === undefined ? 'default' : arguments[1];
    		classCallCheck(this, Batch);

    		/**
       * Document which this batch changes.
       *
       * @readonly
       * @member {engine.model.Document} engine.model.Batch#doc
       */
    		this.doc = doc;

    		/**
       * Array of deltas which compose this batch.
       *
       * @readonly
       * @member {Array.<engine.model.delta.Delta>} engine.model.Batch#deltas
       */
    		this.deltas = [];

    		/**
       * Type of the batch.
       *
       * Can be one of the following values:
       * * `'default'` - all "normal" batches, most commonly used type.
       * * `'transparent'` - batch that should be ignored by other features, i.e. initial batch or collaborative editing changes.
       *
       * @readonly
       * @member {'transparent'|'default'} engine.model.Batch#type
       */
    		this.type = type;
    	}

    	/**
      * Returns this batch base version, which is equal to the base version of first delta in the batch.
      * If there are no deltas in the batch, it returns `null`.
      *
      * @readonly
      * @type {Number|null}
      */


    	createClass(Batch, [{
    		key: 'addDelta',


    		/**
       * Adds delta to the batch instance. All modification methods (insert, remove, split, etc.) use this method
       * to add created deltas.
       *
       * @param {engine.model.delta.Delta} delta Delta to add.
       * @return {engine.model.delta.Delta} Added delta.
       */
    		value: function addDelta(delta) {
    			delta.batch = this;
    			this.deltas.push(delta);

    			return delta;
    		}

    		/**
       * Gets an iterable collection of operations.
       *
       * @returns {Iterable.<engine.model.operation.Operation>}
       */

    	}, {
    		key: 'getOperations',
    		value: regeneratorRuntime.mark(function getOperations() {
    			var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, delta;

    			return regeneratorRuntime.wrap(function getOperations$(_context) {
    				while (1) {
    					switch (_context.prev = _context.next) {
    						case 0:
    							_iteratorNormalCompletion = true;
    							_didIteratorError = false;
    							_iteratorError = undefined;
    							_context.prev = 3;
    							_iterator = this.deltas[Symbol.iterator]();

    						case 5:
    							if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
    								_context.next = 11;
    								break;
    							}

    							delta = _step.value;
    							return _context.delegateYield(delta.operations, 't0', 8);

    						case 8:
    							_iteratorNormalCompletion = true;
    							_context.next = 5;
    							break;

    						case 11:
    							_context.next = 17;
    							break;

    						case 13:
    							_context.prev = 13;
    							_context.t1 = _context['catch'](3);
    							_didIteratorError = true;
    							_iteratorError = _context.t1;

    						case 17:
    							_context.prev = 17;
    							_context.prev = 18;

    							if (!_iteratorNormalCompletion && _iterator.return) {
    								_iterator.return();
    							}

    						case 20:
    							_context.prev = 20;

    							if (!_didIteratorError) {
    								_context.next = 23;
    								break;
    							}

    							throw _iteratorError;

    						case 23:
    							return _context.finish(20);

    						case 24:
    							return _context.finish(17);

    						case 25:
    						case 'end':
    							return _context.stop();
    					}
    				}
    			}, getOperations, this, [[3, 13, 17, 25], [18,, 20, 24]]);
    		})
    	}, {
    		key: 'baseVersion',
    		get: function get() {
    			return this.deltas.length > 0 ? this.deltas[0].baseVersion : null;
    		}
    	}]);
    	return Batch;
    }();

    function register(name, creator) {
    	if (Batch.prototype[name]) {
    		/**
       * This batch method name is already taken.
       *
       * @error batch-register-taken
       * @param {String} name
       */
    		throw new CKEditorError('batch-register-taken: This batch method name is already taken.', { name: name });
    	}

    	Batch.prototype[name] = creator;
    }

    /**
     * Class for nodes that are roots of trees in data model.
     *
     * @memberOf engine.model
     * @extends engine.model.Element
     */

    var RootElement = function (_Element) {
    	inherits(RootElement, _Element);

    	/**
      * Creates root element.
      *
      * @param {engine.model.Document} doc {@link engine.model.Document} that is an owner of the root.
      * @param {String} name Node name.
      * @param {String} [rootName='main'] Root name inside parent {@link engine.model.Document}.
      */

    	function RootElement(doc, name) {
    		var rootName = arguments.length <= 2 || arguments[2] === undefined ? 'main' : arguments[2];
    		classCallCheck(this, RootElement);


    		/**
       * {@link engine.model.Document} that is an owner of this root.
       *
       * @readonly
       * @member {engine.model.Document} engine.model.RootElement#document
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(RootElement).call(this, name));

    		_this.document = doc;

    		/**
       * Name of this root inside {@link engine.model.Document} that is an owner of this root.
       *
       * @readonly
       * @member {String} engine.model.RootElement#rootName
       */
    		_this.rootName = rootName;
    		return _this;
    	}

    	/**
      * Custom toJSON method to solve child-parent circular dependencies.
      *
      * @method engine.model.RootElement#toJSON
      * @returns {String} Name of this root inside {@link engine.model.Document} that is an owner of this root.
      */


    	createClass(RootElement, [{
    		key: 'toJSON',
    		value: function toJSON() {
    			return this.rootName;
    		}
    	}]);
    	return RootElement;
    }(Element);

    /**
     * To provide specific OT behavior and better collisions solving, change methods ({@link engine.model.Batch#setAttr}
     * and {@link engine.model.Batch#removeAttr}) use `AttributeDelta` class which inherits from the `Delta` class and may
     * overwrite some methods.
     *
     * @memberOf engine.model.delta
     * @extends engine.model.delta.Delta
     */

    var AttributeDelta = function (_Delta) {
    	inherits(AttributeDelta, _Delta);

    	function AttributeDelta() {
    		classCallCheck(this, AttributeDelta);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(AttributeDelta).apply(this, arguments));
    	}

    	createClass(AttributeDelta, [{
    		key: 'key',

    		/**
       * The attribute key that is changed by the delta or `null` if the delta has no operations.
       *
       * @type {String|null}
       */
    		get: function get() {
    			return this.operations[0] ? this.operations[0].key : null;
    		}

    		/**
       * The attribute value that is set by the delta or `null` if the delta has no operations.
       *
       * @type {*|null}
       */

    	}, {
    		key: 'value',
    		get: function get() {
    			return this.operations[0] ? this.operations[0].newValue : null;
    		}

    		/**
       * The range on which delta operates or `null` if the delta has no operations.
       *
       * @type {engine.model.Range|null}
       */

    	}, {
    		key: 'range',
    		get: function get() {
    			// Check if it is cached.
    			if (this._range) {
    				return this._range;
    			}

    			// If it is not cached we will evaluate it and cache it.
    			var firstOperation = this.operations[0];
    			var lastOperation = this.operations[this.operations.length - 1];

    			if (firstOperation) {
    				this._range = new Range$1(firstOperation.range.start, lastOperation.range.end);

    				return this._range;
    			}

    			return null;
    		}
    	}, {
    		key: '_reverseDeltaClass',
    		get: function get() {
    			return AttributeDelta;
    		}

    		/**
       * @inheritDoc
       */

    	}], [{
    		key: 'className',
    		get: function get() {
    			return 'engine.model.delta.AttributeDelta';
    		}
    	}, {
    		key: '_priority',
    		get: function get() {
    			return 20;
    		}
    	}]);
    	return AttributeDelta;
    }(Delta);

    var RootAttributeDelta = function (_Delta2) {
    	inherits(RootAttributeDelta, _Delta2);

    	function RootAttributeDelta() {
    		classCallCheck(this, RootAttributeDelta);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(RootAttributeDelta).apply(this, arguments));
    	}

    	createClass(RootAttributeDelta, null, [{
    		key: 'className',

    		/**
       * @inheritDoc
       */
    		get: function get() {
    			return 'engine.model.delta.RootAttributeDelta';
    		}
    	}]);
    	return RootAttributeDelta;
    }(Delta);

    /**
     * Sets the value of the attribute of the node or on the range.
     *
     * @chainable
     * @method engine.model.Batch#setAttr
     * @param {String} key Attribute key.
     * @param {*} value Attribute new value.
     * @param {engine.model.Node|engine.model.Range} nodeOrRange Node or range on which the attribute will be set.
     */
    register('setAttr', function (key, value, nodeOrRange) {
    	attribute(this, key, value, nodeOrRange);

    	return this;
    });

    /**
     * Removes an attribute from the range.
     *
     * @chainable
     * @method engine.model.Batch#removeAttr
     * @param {String} key Attribute key.
     * @param {engine.model.Node|engine.model.Range} nodeOrRange Node or range on which the attribute will be removed.
     */
    register('removeAttr', function (key, nodeOrRange) {
    	attribute(this, key, null, nodeOrRange);

    	return this;
    });

    function attribute(batch, key, value, nodeOrRange) {
    	if (nodeOrRange instanceof Range$1) {
    		changeRange(batch, batch.doc, key, value, nodeOrRange);
    	} else {
    		changeNode(batch, batch.doc, key, value, nodeOrRange);
    	}
    }

    function changeNode(batch, doc, key, value, node) {
    	var previousValue = node.getAttribute(key);
    	var range = void 0,
    	    operation = void 0;

    	var delta = node instanceof RootElement ? new RootAttributeDelta() : new AttributeDelta();
    	batch.addDelta(delta);

    	if (previousValue != value) {
    		if (node instanceof RootElement) {
    			// If we change attributes of root element, we have to use `RootAttributeOperation`.
    			operation = new RootAttributeOperation(node, key, previousValue, value, doc.version);
    		} else {
    			if (node instanceof Element) {
    				// If we change the attribute of the element, we do not want to change attributes of its children, so
    				// the end on the range can not be put after the closing tag, it should be inside that element with the
    				// offset 0, so the range will contains only the opening tag...
    				range = new Range$1(Position.createBefore(node), Position.createFromParentAndOffset(node, 0));
    			} else {
    				// ...but for characters we can not put the range inside it, so we end the range after that character.
    				range = new Range$1(Position.createBefore(node), Position.createAfter(node));
    			}

    			operation = new AttributeOperation(range, key, previousValue || null, value || null, doc.version);
    		}

    		delta.addOperation(operation);
    		doc.applyOperation(operation);
    	}
    }

    // Because attribute operation needs to have the same attribute value on the whole range, this function split the range
    // into smaller parts.
    function changeRange(batch, doc, attributeKey, attributeValue, range) {
    	var delta = new AttributeDelta();
    	batch.addDelta(delta);

    	// Position of the last split, the beginning of the new range.
    	var lastSplitPosition = range.start;

    	// Currently position in the scanning range. Because we need value after the position, it is not a current
    	// position of the iterator but the previous one (we need to iterate one more time to get the value after).
    	var position = void 0;
    	// Value before the currently position.
    	var attributeValueBefore = void 0;
    	// Value after the currently position.
    	var attributeValueAfter = void 0;

    	var _iteratorNormalCompletion = true;
    	var _didIteratorError = false;
    	var _iteratorError = undefined;

    	try {
    		for (var _iterator = range[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    			var value = _step.value;

    			attributeValueAfter = value.item.getAttribute(attributeKey);

    			// At the first run of the iterator the position in undefined. We also do not have a attributeValueBefore, but
    			// because attributeValueAfter may be null, attributeValueBefore may be equal attributeValueAfter ( undefined == null ).
    			if (position && attributeValueBefore != attributeValueAfter) {
    				// if attributeValueBefore == attributeValue there is nothing to change, so we add operation only if these values are different.
    				if (attributeValueBefore != attributeValue) {
    					addOperation();
    				}

    				lastSplitPosition = position;
    			}

    			position = value.nextPosition;
    			attributeValueBefore = attributeValueAfter;
    		}

    		// Because position in the loop is not the iterator position (see let position comment), the last position in
    		// the while loop will be last but one position in the range. We need to check the last position manually.
    	} catch (err) {
    		_didIteratorError = true;
    		_iteratorError = err;
    	} finally {
    		try {
    			if (!_iteratorNormalCompletion && _iterator.return) {
    				_iterator.return();
    			}
    		} finally {
    			if (_didIteratorError) {
    				throw _iteratorError;
    			}
    		}
    	}

    	if (position instanceof Position && position != lastSplitPosition && attributeValueBefore != attributeValue) {
    		addOperation();
    	}

    	function addOperation() {
    		var range = new Range$1(lastSplitPosition, position);
    		var operation = new AttributeOperation(range, attributeKey, attributeValueBefore || null, attributeValue || null, doc.version);

    		delta.addOperation(operation);
    		doc.applyOperation(operation);
    	}
    }

    DeltaFactory.register(AttributeDelta);

    DeltaFactory.register(RootAttributeDelta);

    /**
     * @classdesc
     * To provide specific OT behavior and better collisions solving, {@link engine.model.Batch#move} method
     * uses the `MoveDelta` class which inherits from the `Delta` class and may overwrite some methods.
     *
     * @memberOf engine.model.delta
     */

    var MoveDelta = function (_Delta) {
    	inherits(MoveDelta, _Delta);

    	function MoveDelta() {
    		classCallCheck(this, MoveDelta);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(MoveDelta).apply(this, arguments));
    	}

    	createClass(MoveDelta, [{
    		key: 'howMany',

    		/**
       * How many nodes are moved by the delta or `null` if there are no operations in the delta.
       *
       * @type {Number|null}
       */
    		get: function get() {
    			return this._moveOperation ? this._moveOperation.howMany : null;
    		}

    		/**
       * {@link engine.model.delta.MoveDelta#_moveOperation Move operation}
       * {@link engine.model.operation.MoveOperation#sourcePosition source position} or `null` if there are
       * no operations in the delta.
       *
       * @type {engine.model.Position|null}
       */

    	}, {
    		key: 'sourcePosition',
    		get: function get() {
    			return this._moveOperation ? this._moveOperation.sourcePosition : null;
    		}

    		/**
       * {@link engine.model.delta.MoveDelta#_moveOperation Move operation}
       * {@link engine.model.operation.MoveOperation#targetPosition target position} or `null` if there are
       * no operations in the delta.
       *
       * @type {engine.model.Position|null}
       */

    	}, {
    		key: 'targetPosition',
    		get: function get() {
    			return this._moveOperation ? this._moveOperation.targetPosition : null;
    		}

    		/**
       * Move operation that is saved in this delta or `null` if there are no operations in the delta.
       *
       * @protected
       * @type {engine.model.operation.MoveOperation|null}
       */

    	}, {
    		key: '_moveOperation',
    		get: function get() {
    			return this.operations[0] || null;
    		}
    	}, {
    		key: '_reverseDeltaClass',
    		get: function get() {
    			return MoveDelta;
    		}

    		/**
       * @inheritDoc
       */

    	}], [{
    		key: 'className',
    		get: function get() {
    			return 'engine.model.delta.MoveDelta';
    		}
    	}, {
    		key: '_priority',
    		get: function get() {
    			return 20;
    		}
    	}]);
    	return MoveDelta;
    }(Delta);

    function addMoveOperation(batch, delta, sourcePosition, howMany, targetPosition) {
    	var operation = new MoveOperation(sourcePosition, howMany, targetPosition, batch.doc.version);
    	delta.addOperation(operation);
    	batch.doc.applyOperation(operation);
    }

    /**
     * Moves given node or given range of nodes to target position.
     *
     * @chainable
     * @method engine.model.Batch#move
     * @param {engine.model.Node|engine.model.Range} nodeOrRange Node or range of nodes to move.
     * @param {engine.model.Position} targetPosition Position where moved nodes will be inserted.
     */
    register('move', function (nodeOrRange, targetPosition) {
    	var delta = new MoveDelta();
    	this.addDelta(delta);

    	if (nodeOrRange instanceof Range$1) {
    		if (!nodeOrRange.isFlat) {
    			/**
        * Range to move is not flat.
        *
        * @error batch-move-range-not-flat
        */
    			throw new CKEditorError('batch-move-range-not-flat: Range to move is not flat.');
    		}

    		addMoveOperation(this, delta, nodeOrRange.start, nodeOrRange.end.offset - nodeOrRange.start.offset, targetPosition);
    	} else {
    		addMoveOperation(this, delta, Position.createBefore(nodeOrRange), 1, targetPosition);
    	}

    	return this;
    });

    DeltaFactory.register(MoveDelta);

    /**
     * @classdesc
     * To provide specific OT behavior and better collisions solving, {@link engine.model.Batch#remove} method
     * uses the `RemoveDelta` class which inherits from the `Delta` class and may overwrite some methods.
     *
     * @memberOf engine.model.delta
     */

    var RemoveDelta = function (_MoveDelta) {
    	inherits(RemoveDelta, _MoveDelta);

    	function RemoveDelta() {
    		classCallCheck(this, RemoveDelta);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(RemoveDelta).apply(this, arguments));
    	}

    	createClass(RemoveDelta, null, [{
    		key: 'className',

    		/**
       * @inheritDoc
       */
    		get: function get() {
    			return 'engine.model.delta.RemoveDelta';
    		}
    	}]);
    	return RemoveDelta;
    }(MoveDelta);

    function addRemoveOperation(batch, delta, position, howMany) {
    	var operation = new RemoveOperation(position, howMany, batch.doc.version);
    	delta.addOperation(operation);
    	batch.doc.applyOperation(operation);
    }

    /**
     * Removes given node or range of nodes.
     *
     * @chainable
     * @method engine.model.Batch#remove
     * @param {engine.model.Node|engine.model.Range} nodeOrRange Node or range of nodes to remove.
     */
    register('remove', function (nodeOrRange) {
    	var delta = new RemoveDelta();
    	this.addDelta(delta);

    	if (nodeOrRange instanceof Range$1) {
    		// The array is reversed, so the ranges are correct and do not have to be updated.
    		var ranges = nodeOrRange.getMinimalFlatRanges().reverse();

    		var _iteratorNormalCompletion = true;
    		var _didIteratorError = false;
    		var _iteratorError = undefined;

    		try {
    			for (var _iterator = ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    				var flat = _step.value;

    				addRemoveOperation(this, delta, flat.start, flat.end.offset - flat.start.offset);
    			}
    		} catch (err) {
    			_didIteratorError = true;
    			_iteratorError = err;
    		} finally {
    			try {
    				if (!_iteratorNormalCompletion && _iterator.return) {
    					_iterator.return();
    				}
    			} finally {
    				if (_didIteratorError) {
    					throw _iteratorError;
    				}
    			}
    		}
    	} else {
    		addRemoveOperation(this, delta, Position.createBefore(nodeOrRange), 1);
    	}

    	return this;
    });

    DeltaFactory.register(RemoveDelta);

    /**
     * @classdesc
     * To provide specific OT behavior and better collisions solving, the {@link engine.model.Batch#insert Batch#insert} method
     * uses the `InsertDelta` class which inherits from the `Delta` class and may overwrite some methods.
     *
     * @memberOf engine.model.delta
     */

    var InsertDelta = function (_Delta) {
    	inherits(InsertDelta, _Delta);

    	function InsertDelta() {
    		classCallCheck(this, InsertDelta);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(InsertDelta).apply(this, arguments));
    	}

    	createClass(InsertDelta, [{
    		key: 'position',

    		/**
       * Position where the delta inserts nodes or `null` if there are no operations in the delta.
       *
       * @type {engine.model.Position|null}
       */
    		get: function get() {
    			return this._insertOperation ? this._insertOperation.position : null;
    		}

    		/**
       * Node list containing all the nodes inserted by the delta or `null` if there are no operations in the delta.
       *
       * @type {engine.model.NodeList|null}
       */

    	}, {
    		key: 'nodeList',
    		get: function get() {
    			return this._insertOperation ? this._insertOperation.nodeList : null;
    		}

    		/**
       * Insert operation that is saved in this delta or `null` if there are no operations in the delta.
       *
       * @protected
       * @type {engine.model.operation.InsertOperation|null}
       */

    	}, {
    		key: '_insertOperation',
    		get: function get() {
    			return this.operations[0] || null;
    		}
    	}, {
    		key: '_reverseDeltaClass',
    		get: function get() {
    			return RemoveDelta;
    		}

    		/**
       * @inheritDoc
       */

    	}], [{
    		key: 'className',
    		get: function get() {
    			return 'engine.model.delta.InsertDelta';
    		}
    	}, {
    		key: '_priority',
    		get: function get() {
    			return 20;
    		}
    	}]);
    	return InsertDelta;
    }(Delta);

    register('insert', function (position, nodes) {
    	var delta = new InsertDelta();
    	var insert = new InsertOperation(position, nodes, this.doc.version);

    	this.addDelta(delta);
    	delta.addOperation(insert);
    	this.doc.applyOperation(insert);

    	return this;
    });

    DeltaFactory.register(InsertDelta);

    /**
     * @classdesc
     * To provide specific OT behavior and better collisions solving, the {@link engine.model.Batch#split} method
     * uses `SplitDelta` class which inherits from the `Delta` class and may overwrite some methods.
     *
     * @memberOf engine.model.delta
     */

    var SplitDelta = function (_Delta) {
    	inherits(SplitDelta, _Delta);

    	function SplitDelta() {
    		classCallCheck(this, SplitDelta);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(SplitDelta).apply(this, arguments));
    	}

    	createClass(SplitDelta, [{
    		key: 'getReversed',
    		value: function getReversed() {
    			var delta = get(Object.getPrototypeOf(SplitDelta.prototype), 'getReversed', this).call(this);

    			if (delta.operations.length > 0) {
    				delta.operations[0].isSticky = true;
    			}

    			return delta;
    		}

    		/**
       * Operation in the delta that adds a node to the tree model where split elements will be moved to or `null` if
       * there are no operations in the delta.
       *
       * Most commonly this will be insert operation, as `SplitDelta` has to create a new node. If `SplitDelta` was created
       * through {@link engine.model.delta.MergeDelta MergeDelta} {@link engine.model.delta.Delta#getReversed reversing},
       * this will be a reinsert operation, as we will want to "insert-back" the node that was removed by `MergeDelta`.
       *
       * @protected
       * @type {engine.model.operation.InsertOpertaion|engine.model.operation.ReinsertOperation|null}
       */

    	}, {
    		key: 'position',

    		/**
       * Position of split or `null` if there are no operations in the delta.
       *
       * @type {engine.model.Position|null}
       */
    		get: function get() {
    			return this._moveOperation ? this._moveOperation.sourcePosition : null;
    		}
    	}, {
    		key: '_cloneOperation',
    		get: function get() {
    			return this.operations[0] || null;
    		}

    		/**
       * Operation in the delta that moves nodes from after split position to their new parent
       * or `null` if there are no operations in the delta.
       *
       * @protected
       * @type {engine.model.operation.MoveOperation|null}
       */

    	}, {
    		key: '_moveOperation',
    		get: function get() {
    			return this.operations[1] || null;
    		}
    	}, {
    		key: '_reverseDeltaClass',
    		get: function get() {
    			return MergeDelta;
    		}

    		/**
       * @inheritDoc
       */

    	}], [{
    		key: 'className',
    		get: function get() {
    			return 'engine.model.delta.SplitDelta';
    		}
    	}, {
    		key: '_priority',
    		get: function get() {
    			return 5;
    		}
    	}]);
    	return SplitDelta;
    }(Delta);

    register('split', function (position) {
    	var delta = new SplitDelta();
    	this.addDelta(delta);

    	var splitElement = position.parent;

    	if (!splitElement.parent) {
    		/**
       * Root element can not be split.
       *
       * @error batch-split-root
       */
    		throw new CKEditorError('batch-split-root: Root element can not be split.');
    	}

    	var copy = new Element(splitElement.name, splitElement._attrs);

    	var insert = new InsertOperation(Position.createAfter(splitElement), copy, this.doc.version);

    	delta.addOperation(insert);
    	this.doc.applyOperation(insert);

    	var move = new MoveOperation(position, splitElement.getChildCount() - position.offset, Position.createFromParentAndOffset(copy, 0), this.doc.version);
    	move.isSticky = true;

    	delta.addOperation(move);
    	this.doc.applyOperation(move);

    	return this;
    });

    DeltaFactory.register(SplitDelta);

    /**
     * @classdesc
     * To provide specific OT behavior and better collisions solving, {@link engine.model.Batch#merge} method
     * uses the `MergeDelta` class which inherits from the `Delta` class and may overwrite some methods.
     *
     * @memberOf engine.model.delta
     */

    var MergeDelta = function (_Delta) {
    	inherits(MergeDelta, _Delta);

    	function MergeDelta() {
    		classCallCheck(this, MergeDelta);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(MergeDelta).apply(this, arguments));
    	}

    	createClass(MergeDelta, [{
    		key: 'getReversed',
    		value: function getReversed() {
    			var delta = get(Object.getPrototypeOf(MergeDelta.prototype), 'getReversed', this).call(this);

    			if (delta.operations.length > 0) {
    				delta.operations[1].isSticky = false;
    			}

    			return delta;
    		}

    		/**
       * Operation in this delta that removes the node after merge position (which will be empty at that point) or
       * `null` if the delta has no operations. Note, that after {@link engine.model.delta.transform transformation}
       * this might be an instance of {@link engine.model.operation.MoveOperation} instead of
       * {@link engine.model.operation.RemoveOperation}.
       *
       * @protected
       * @type {engine.model.operation.MoveOperation|null}
       */

    	}, {
    		key: 'position',

    		/**
       * Position between to merged nodes or `null` if the delta has no operations.
       *
       * @type {engine.model.Position|null}
       */
    		get: function get() {
    			return this._removeOperation ? this._removeOperation.sourcePosition : null;
    		}
    	}, {
    		key: '_removeOperation',
    		get: function get() {
    			return this.operations[1] || null;
    		}
    	}, {
    		key: '_reverseDeltaClass',
    		get: function get() {
    			return SplitDelta;
    		}

    		/**
       * @inheritDoc
       */

    	}], [{
    		key: 'className',
    		get: function get() {
    			return 'engine.model.delta.MergeDelta';
    		}
    	}]);
    	return MergeDelta;
    }(Delta);

    register('merge', function (position) {
    	var delta = new MergeDelta();
    	this.addDelta(delta);

    	var nodeBefore = position.nodeBefore;
    	var nodeAfter = position.nodeAfter;

    	if (!(nodeBefore instanceof Element)) {
    		/**
       * Node before merge position must be an element.
       *
       * @error batch-merge-no-element-before
       */
    		throw new CKEditorError('batch-merge-no-element-before: Node before merge position must be an element.');
    	}

    	if (!(nodeAfter instanceof Element)) {
    		/**
       * Node after merge position must be an element.
       *
       * @error batch-merge-no-element-after
       */
    		throw new CKEditorError('batch-merge-no-element-after: Node after merge position must be an element.');
    	}

    	var positionAfter = Position.createFromParentAndOffset(nodeAfter, 0);
    	var positionBefore = Position.createFromParentAndOffset(nodeBefore, nodeBefore.getChildCount());

    	var move = new MoveOperation(positionAfter, nodeAfter.getChildCount(), positionBefore, this.doc.version);
    	move.isSticky = true;
    	delta.addOperation(move);
    	this.doc.applyOperation(move);

    	var remove = new RemoveOperation(position, 1, this.doc.version);
    	delta.addOperation(remove);
    	this.doc.applyOperation(remove);

    	return this;
    });

    DeltaFactory.register(MergeDelta);

    /**
     * To provide specific OT behavior and better collisions solving, the {@link engine.model.Batch#rename Batch#rename} method
     * uses the `RenameDelta` class which inherits from the `Delta` class and may overwrite some methods.
     *
     * @memberOf engine.model.delta
     */

    var RenameDelta = function (_Delta) {
    	inherits(RenameDelta, _Delta);

    	function RenameDelta() {
    		classCallCheck(this, RenameDelta);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(RenameDelta).apply(this, arguments));
    	}

    	createClass(RenameDelta, [{
    		key: '_reverseDeltaClass',
    		get: function get() {
    			return RenameDelta;
    		}

    		/**
       * @inheritDoc
       */

    	}], [{
    		key: 'className',
    		get: function get() {
    			return 'engine.model.delta.RenameDelta';
    		}
    	}]);
    	return RenameDelta;
    }(Delta);

    function apply$1(batch, delta, operation) {
    	batch.addDelta(delta);
    	delta.addOperation(operation);
    	batch.doc.applyOperation(operation);
    }

    /**
     * Renames the given element.
     *
     * @chainable
     * @method engine.model.Batch#rename
     * @param {String} newName New element name.
     * @param {engine.model.Element} element The element to rename.
     */
    register('rename', function (newName, element) {
    	var delta = new RenameDelta();
    	var newElement = new Element(newName);

    	apply$1(this, delta, new InsertOperation(Position.createAfter(element), newElement, this.doc.version));

    	apply$1(this, delta, new MoveOperation(Position.createAt(element), element.getChildCount(), Position.createAt(newElement), this.doc.version));

    	apply$1(this, delta, new RemoveOperation(Position.createBefore(element), 1, this.doc.version));

    	return this;
    });

    DeltaFactory.register(RenameDelta);

    /**
     * @classdesc
     * To provide specific OT behavior and better collisions solving, {@link engine.model.Batch#merge} method
     * uses the `WrapDelta` class which inherits from the `Delta` class and may overwrite some methods.
     *
     * @memberOf engine.model.delta
     */

    var WrapDelta = function (_Delta) {
    	inherits(WrapDelta, _Delta);

    	function WrapDelta() {
    		classCallCheck(this, WrapDelta);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(WrapDelta).apply(this, arguments));
    	}

    	createClass(WrapDelta, [{
    		key: 'range',

    		/**
       * Range to wrap or `null` if there are no operations in the delta.
       *
       * @type {engine.model.Range|null}
       */
    		get: function get() {
    			var moveOp = this._moveOperation;

    			return moveOp ? Range$1.createFromPositionAndShift(moveOp.sourcePosition, moveOp.howMany) : null;
    		}

    		/**
       * How many nodes is wrapped by the delta or `null` if there are no operations in delta.
       *
       * @type {Number}
       */

    	}, {
    		key: 'howMany',
    		get: function get() {
    			var range = this.range;

    			return range ? range.end.offset - range.start.offset : 0;
    		}

    		/**
       * Operation that inserts wrapping element or `null` if there are no operations in the delta.
       *
       * @protected
       * @type {engine.model.operation.InsertOperation|engine.model.operation.ReinsertOperation}
       */

    	}, {
    		key: '_insertOperation',
    		get: function get() {
    			return this.operations[0] || null;
    		}

    		/**
       * Operation that moves wrapped nodes to their new parent or `null` if there are no operations in the delta.
       *
       * @protected
       * @type {engine.model.operation.MoveOperation|null}
       */

    	}, {
    		key: '_moveOperation',
    		get: function get() {
    			return this.operations[1] || null;
    		}
    	}, {
    		key: '_reverseDeltaClass',
    		get: function get() {
    			return UnwrapDelta;
    		}
    	}], [{
    		key: 'className',
    		get: function get() {
    			return 'engine.model.delta.WrapDelta';
    		}
    	}, {
    		key: '_priority',
    		get: function get() {
    			return 10;
    		}
    	}]);
    	return WrapDelta;
    }(Delta);

    register('wrap', function (range, elementOrString) {
    	if (!range.isFlat) {
    		/**
       * Range to wrap is not flat.
       *
       * @error batch-wrap-range-not-flat
       */
    		throw new CKEditorError('batch-wrap-range-not-flat: Range to wrap is not flat.');
    	}

    	var element = elementOrString instanceof Element ? elementOrString : new Element(elementOrString);

    	if (element.getChildCount() > 0) {
    		/**
       * Element to wrap with is not empty.
       *
       * @error batch-wrap-element-not-empty
       */
    		throw new CKEditorError('batch-wrap-element-not-empty: Element to wrap with is not empty.');
    	}

    	if (element.parent !== null) {
    		/**
       * Element to wrap with is already attached to a tree model.
       *
       * @error batch-wrap-element-attached
       */
    		throw new CKEditorError('batch-wrap-element-attached: Element to wrap with is already attached to tree model.');
    	}

    	var delta = new WrapDelta();
    	this.addDelta(delta);

    	var insert = new InsertOperation(range.end, element, this.doc.version);
    	delta.addOperation(insert);
    	this.doc.applyOperation(insert);

    	var targetPosition = Position.createFromParentAndOffset(element, 0);
    	var move = new MoveOperation(range.start, range.end.offset - range.start.offset, targetPosition, this.doc.version);
    	delta.addOperation(move);
    	this.doc.applyOperation(move);

    	return this;
    });

    DeltaFactory.register(WrapDelta);

    /**
     * @classdesc
     * To provide specific OT behavior and better collisions solving, {@link engine.model.Batch#merge} method
     * uses the `UnwrapDelta` class which inherits from the `Delta` class and may overwrite some methods.
     *
     * @memberOf engine.model.delta
     */

    var UnwrapDelta = function (_Delta) {
    	inherits(UnwrapDelta, _Delta);

    	function UnwrapDelta() {
    		classCallCheck(this, UnwrapDelta);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(UnwrapDelta).apply(this, arguments));
    	}

    	createClass(UnwrapDelta, [{
    		key: 'position',

    		/**
       * Position before unwrapped element or `null` if there are no operations in the delta.
       *
       * @type {engine.model.Position|null}
       */
    		get: function get() {
    			return this._moveOperation ? this._moveOperation.targetPosition : null;
    		}

    		/**
       * Operation in the delta that moves unwrapped nodes to their new parent or `null` if there are no operations in the delta.
       *
       * @protected
       * @type {engine.model.operation.MoveOperation|null}
       */

    	}, {
    		key: '_moveOperation',
    		get: function get() {
    			return this.operations[0] || null;
    		}
    	}, {
    		key: '_reverseDeltaClass',
    		get: function get() {
    			return WrapDelta;
    		}

    		/**
       * @inheritDoc
       */

    	}], [{
    		key: 'className',
    		get: function get() {
    			return 'engine.model.delta.UnwrapDelta';
    		}
    	}, {
    		key: '_priority',
    		get: function get() {
    			return 10;
    		}
    	}]);
    	return UnwrapDelta;
    }(Delta);

    register('unwrap', function (element) {
    	if (element.parent === null) {
    		/**
       * Trying to unwrap an element that has no parent.
       *
       * @error batch-unwrap-element-no-parent
       */
    		throw new CKEditorError('batch-unwrap-element-no-parent: Trying to unwrap an element that has no parent.');
    	}

    	var delta = new UnwrapDelta();
    	this.addDelta(delta);

    	var sourcePosition = Position.createFromParentAndOffset(element, 0);

    	var move = new MoveOperation(sourcePosition, element.getChildCount(), Position.createBefore(element), this.doc.version);
    	move.isSticky = true;
    	delta.addOperation(move);
    	this.doc.applyOperation(move);

    	// Computing new position because we moved some nodes before `element`.
    	// If we would cache `Position.createBefore( element )` we remove wrong node.
    	var remove = new RemoveOperation(Position.createBefore(element), 1, this.doc.version);
    	delta.addOperation(remove);
    	this.doc.applyOperation(remove);

    	return this;
    });

    DeltaFactory.register(UnwrapDelta);

    /**
     * @classdesc
     * To provide specific OT behavior and better collisions solving, the {@link engine.model.Batch#insert} method
     * uses the `WeakInsertDelta` class which inherits from the `Delta` class and may overwrite some methods.
     *
     * @memberOf engine.model.delta
     */

    var WeakInsertDelta = function (_InsertDelta) {
      inherits(WeakInsertDelta, _InsertDelta);

      function WeakInsertDelta() {
        classCallCheck(this, WeakInsertDelta);
        return possibleConstructorReturn(this, Object.getPrototypeOf(WeakInsertDelta).apply(this, arguments));
      }

      createClass(WeakInsertDelta, null, [{
        key: 'className',

        /**
         * @inheritDoc
         */
        get: function get() {
          return 'engine.model.delta.WeakInsertDelta';
        }
      }]);
      return WeakInsertDelta;
    }(InsertDelta);

    register('weakInsert', function (position, nodes) {
      var delta = new WeakInsertDelta();
      this.addDelta(delta);

      nodes = new NodeList(nodes);

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = nodes._nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var node = _step.value;

          node._attrs = new Map(this.doc.selection.getAttributes());
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var operation = new InsertOperation(position, nodes, this.doc.version);
      delta.addOperation(operation);
      this.doc.applyOperation(operation);

      return this;
    });

    DeltaFactory.register(WeakInsertDelta);

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED$2);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values ? values.length : 0;

      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    var UNORDERED_COMPARE_FLAG = 1;
var     PARTIAL_COMPARE_FLAG$1 = 2;
    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} customizer The function to customize comparisons.
     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG$1,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(array);
      if (stacked) {
        return stacked == other;
      }
      var index = -1,
          result = true,
          seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;

      stack.set(array, other);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function (othValue, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      return result;
    }

var     UNORDERED_COMPARE_FLAG$1 = 1;
var     PARTIAL_COMPARE_FLAG$2 = 2;
var     boolTag$2 = '[object Boolean]';
var     dateTag$2 = '[object Date]';
var     errorTag$1 = '[object Error]';
var     mapTag$3 = '[object Map]';
var     numberTag$2 = '[object Number]';
var     regexpTag$2 = '[object RegExp]';
var     setTag$3 = '[object Set]';
var     stringTag$3 = '[object String]';
var     symbolTag$3 = '[object Symbol]';
var     arrayBufferTag$2 = '[object ArrayBuffer]';
var     dataViewTag$3 = '[object DataView]';
var     symbolProto$1 = _Symbol ? _Symbol.prototype : undefined;
var     symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : undefined;
    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} customizer The function to customize comparisons.
     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag$3:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag$2:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag$2:
        case dateTag$2:
          // Coerce dates and booleans to numbers, dates to milliseconds and
          // booleans to `1` or `0` treating invalid dates coerced to `NaN` as
          // not equal.
          return +object == +other;

        case errorTag$1:
          return object.name == other.name && object.message == other.message;

        case numberTag$2:
          // Treat `NaN` vs. `NaN` as equal.
          return object != +object ? other != +other : object == +other;

        case regexpTag$2:
        case stringTag$3:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/6.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == other + '';

        case mapTag$3:
          var convert = mapToArray;

        case setTag$3:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG$2;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG$1;
          stack.set(object, other);

          // Recursively compare objects (susceptible to call stack limits).
          return equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);

        case symbolTag$3:
          if (symbolValueOf$1) {
            return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
          }
      }
      return false;
    }

    /** Used to compose bitmasks for comparison styles. */
    var PARTIAL_COMPARE_FLAG$3 = 2;

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} customizer The function to customize comparisons.
     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG$3,
          objProps = keys(object),
          objLength = objProps.length,
          othProps = keys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : baseHas(other, key))) {
          return false;
        }
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      return result;
    }

var     argsTag$3 = '[object Arguments]';
var     arrayTag$2 = '[object Array]';
var     boolTag$3 = '[object Boolean]';
var     dateTag$3 = '[object Date]';
var     errorTag$2 = '[object Error]';
var     funcTag$2 = '[object Function]';
var     mapTag$4 = '[object Map]';
var     numberTag$3 = '[object Number]';
var     objectTag$4 = '[object Object]';
var     regexpTag$3 = '[object RegExp]';
var     setTag$4 = '[object Set]';
var     stringTag$4 = '[object String]';
var     weakMapTag$2 = '[object WeakMap]';
var     arrayBufferTag$3 = '[object ArrayBuffer]';
var     dataViewTag$4 = '[object DataView]';
var     float32Tag$2 = '[object Float32Array]';
var     float64Tag$2 = '[object Float64Array]';
var     int8Tag$2 = '[object Int8Array]';
var     int16Tag$2 = '[object Int16Array]';
var     int32Tag$2 = '[object Int32Array]';
var     uint8Tag$2 = '[object Uint8Array]';
var     uint8ClampedTag$2 = '[object Uint8ClampedArray]';
var     uint16Tag$2 = '[object Uint16Array]';
var     uint32Tag$2 = '[object Uint32Array]';
    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
    typedArrayTags[argsTag$3] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$2] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$4] = typedArrayTags[weakMapTag$2] = false;

    /** Used for built-in method references. */
    var objectProto$17 = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString$6 = objectProto$17.toString;

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified,
     *  else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    function isTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString$6.call(value)];
    }

    /** Used to compose bitmasks for comparison styles. */
    var PARTIAL_COMPARE_FLAG = 2;

    /** `Object#toString` result references. */
var     argsTag$2 = '[object Arguments]';
var     arrayTag$1 = '[object Array]';
var     objectTag$3 = '[object Object]';
    /** Used for built-in method references. */
    var objectProto$16 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$9 = objectProto$16.hasOwnProperty;

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
     *  for more details.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = arrayTag$1,
          othTag = arrayTag$1;

      if (!objIsArr) {
        objTag = getTag$1(object);
        objTag = objTag == argsTag$2 ? objectTag$3 : objTag;
      }
      if (!othIsArr) {
        othTag = getTag$1(other);
        othTag = othTag == argsTag$2 ? objectTag$3 : othTag;
      }
      var objIsObj = objTag == objectTag$3 && !isHostObject(object),
          othIsObj = othTag == objectTag$3 && !isHostObject(other),
          isSameTag = objTag == othTag;

      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty$9.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty$9.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {boolean} [bitmask] The bitmask of comparison flags.
     *  The bitmask may be composed of the following flags:
     *     1 - Unordered comparison
     *     2 - Partial comparison
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are **not** supported.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent,
     *  else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    var ot = {
    	InsertOperation: {
    		// Transforms InsertOperation `a` by InsertOperation `b`. Accepts a flag stating whether `a` is more important
    		// than `b` when it comes to resolving conflicts. Returns results as an array of operations.

    		InsertOperation: function InsertOperation(a, b, isStrong) {
    			// Transformed operations are always new instances, not references to the original operations.
    			var transformed = a.clone();

    			// Transform insert position by the other operation position.
    			transformed.position = transformed.position.getTransformedByInsertion(b.position, b.nodeList.length, !isStrong);

    			return [transformed];
    		},


    		AttributeOperation: doNotUpdate,

    		RootAttributeOperation: doNotUpdate,

    		// Transforms InsertOperation `a` by MoveOperation `b`. Accepts a flag stating whether `a` is more important
    		// than `b` when it comes to resolving conflicts. Returns results as an array of operations.
    		MoveOperation: function MoveOperation(a, b, isStrong) {
    			var transformed = a.clone();

    			// Transform insert position by the other operation parameters.
    			transformed.position = a.position.getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany, !isStrong, b.isSticky);

    			return [transformed];
    		}
    	},

    	AttributeOperation: {
    		// Transforms AttributeOperation `a` by InsertOperation `b`. Returns results as an array of operations.

    		InsertOperation: function InsertOperation(a, b) {
    			// Transform this operation's range.
    			var ranges = a.range.getTransformedByInsertion(b.position, b.nodeList.length, true, false);

    			// Map transformed range(s) to operations and return them.
    			return ranges.reverse().map(function (range) {
    				return new AttributeOperation(range, a.key, a.oldValue, a.newValue, a.baseVersion);
    			});
    		},


    		// Transforms AttributeOperation `a` by AttributeOperation `b`. Accepts a flag stating whether `a` is more important
    		// than `b` when it comes to resolving conflicts. Returns results as an array of operations.
    		AttributeOperation: function AttributeOperation$$(a, b, isStrong) {
    			if (a.key === b.key) {
    				// If operations attributes are in conflict, check if their ranges intersect and manage them properly.

    				// First, we want to apply change to the part of a range that has not been changed by the other operation.
    				var operations = a.range.getDifference(b.range).map(function (range) {
    					return new AttributeOperation(range, a.key, a.oldValue, a.newValue, a.baseVersion);
    				});

    				// Then we take care of the common part of ranges, but only if operations has different `newValue`.
    				if (isStrong && !isEqual(a.newValue, b.newValue)) {
    					// If this operation is more important, we also want to apply change to the part of the
    					// original range that has already been changed by the other operation. Since that range
    					// got changed we also have to update `oldValue`.
    					var common = a.range.getIntersection(b.range);

    					if (common !== null) {
    						operations.push(new AttributeOperation(common, b.key, b.oldValue, a.newValue, a.baseVersion));
    					}
    				}

    				// If no operations has been added nothing should get updated, but since we need to return
    				// an instance of Operation we add NoOperation to the array.
    				if (operations.length === 0) {
    					operations.push(new NoOperation(a.baseVersion));
    				}

    				return operations;
    			} else {
    				// If operations don't conflict, simply return an array containing just a clone of this operation.
    				return [a.clone()];
    			}
    		},


    		RootAttributeOperation: doNotUpdate,

    		// Transforms AttributeOperation `a` by MoveOperation `b`. Returns results as an array of operations.
    		MoveOperation: function MoveOperation(a, b) {
    			// Convert MoveOperation properties into a range.
    			var rangeB = Range$1.createFromPositionAndShift(b.sourcePosition, b.howMany);

    			// This will aggregate transformed ranges.
    			var ranges = [];

    			// Special case when MoveOperation is in fact a RemoveOperation. RemoveOperation not only moves nodes but also
    			// creates a "holder" element for them in graveyard. If there was a RemoveOperation pointing to an offset
    			// before this AttributeOperation, we have to increment AttributeOperation's offset.
    			if (b instanceof RemoveOperation && b._needsHolderElement && a.range.root == b.targetPosition.root && a.range.start.path[0] >= b._holderElementOffset) {
    				// Do not change original operation!
    				a = a.clone();
    				a.range.start.path[0]++;
    				a.range.end.path[0]++;
    			}

    			// Difference is a part of changed range that is modified by AttributeOperation but is not affected
    			// by MoveOperation. This can be zero, one or two ranges (if moved range is inside changed range).
    			// Right now we will make a simplification and join difference ranges and transform them as one. We will cover rangeB later.
    			var difference = joinRanges(a.range.getDifference(rangeB));

    			// Common is a range of nodes that is affected by MoveOperation. So it got moved to other place.
    			var common = a.range.getIntersection(rangeB);

    			if (difference !== null) {
    				// MoveOperation removes nodes from their original position. We acknowledge this by proper transformation.
    				// Take the start and the end of the range and transform them by deletion of moved nodes.
    				// Note that if rangeB was inside AttributeOperation range, only difference.end will be transformed.
    				// This nicely covers the joining simplification we did in the previous step.
    				difference.start = difference.start.getTransformedByDeletion(b.sourcePosition, b.howMany);
    				difference.end = difference.end.getTransformedByDeletion(b.sourcePosition, b.howMany);

    				// MoveOperation pastes nodes into target position. We acknowledge this by proper transformation.
    				// Note that since we operate on transformed difference range, we should transform by
    				// previously transformed target position.
    				// Note that we do not use Position.getTransformedByMove on range boundaries because we need to
    				// transform by insertion a range as a whole, since newTargetPosition might be inside that range.
    				ranges = difference.getTransformedByInsertion(b.movedRangeStart, b.howMany, true, false).reverse();
    			}

    			if (common !== null) {
    				// Here we do not need to worry that newTargetPosition is inside moved range, because that
    				// would mean that the MoveOperation targets into itself, and that is incorrect operation.
    				// Instead, we calculate the new position of that part of original range.
    				common.start = common.start._getCombined(b.sourcePosition, b.movedRangeStart);
    				common.end = common.end._getCombined(b.sourcePosition, b.movedRangeStart);

    				ranges.push(common);
    			}

    			// Map transformed range(s) to operations and return them.
    			return ranges.map(function (range) {
    				return new AttributeOperation(range, a.key, a.oldValue, a.newValue, a.baseVersion);
    			});
    		}
    	},

    	RootAttributeOperation: {
    		InsertOperation: doNotUpdate,

    		AttributeOperation: doNotUpdate,

    		// Transforms RootAttributeOperation `a` by RootAttributeOperation `b`. Accepts a flag stating whether `a` is more important
    		// than `b` when it comes to resolving conflicts. Returns results as an array of operations.
    		RootAttributeOperation: function RootAttributeOperation(a, b, isStrong) {
    			if (a.root === b.root && a.key === b.key) {
    				if (a.newValue !== b.newValue && !isStrong || a.newValue === b.newValue) {
    					return [new NoOperation(a.baseVersion)];
    				}
    			}

    			return [a.clone()];
    		},


    		MoveOperation: doNotUpdate
    	},

    	MoveOperation: {
    		// Transforms MoveOperation `a` by InsertOperation `b`. Accepts a flag stating whether `a` is more important
    		// than `b` when it comes to resolving conflicts. Returns results as an array of operations.

    		InsertOperation: function InsertOperation(a, b, isStrong) {
    			// Create range from MoveOperation properties and transform it by insertion.
    			var range = Range$1.createFromPositionAndShift(a.sourcePosition, a.howMany);
    			range = range.getTransformedByInsertion(b.position, b.nodeList.length, false, a.isSticky)[0];

    			var result = new a.constructor(range.start, range.end.offset - range.start.offset, a instanceof RemoveOperation ? a.baseVersion : a.targetPosition.getTransformedByInsertion(b.position, b.nodeList.length, !isStrong), a instanceof RemoveOperation ? undefined : a.baseVersion);

    			result.isSticky = a.isSticky;

    			return [result];
    		},


    		AttributeOperation: doNotUpdate,

    		RootAttributeOperation: doNotUpdate,

    		// Transforms MoveOperation `a` by MoveOperation `b`. Accepts a flag stating whether `a` is more important
    		// than `b` when it comes to resolving conflicts. Returns results as an array of operations.
    		MoveOperation: function MoveOperation(a, b, isStrong) {
    			// Special case when both move operations' target positions are inside nodes that are
    			// being moved by the other move operation. So in other words, we move ranges into inside of each other.
    			// This case can't be solved reasonably (on the other hand, it should not happen often).
    			if (moveTargetIntoMovedRange(a, b) && moveTargetIntoMovedRange(b, a)) {
    				// Instead of transforming operation, we return a reverse of the operation that we transform by.
    				// So when the results of this "transformation" will be applied, `b` MoveOperation will get reversed.
    				return [b.getReversed()];
    			}

    			// Special case when both operations are RemoveOperations. RemoveOperation not only moves nodes but also
    			// (usually) creates a "holder" element for them in graveyard. Each RemoveOperation should move nodes to different
    			// "holder" element. If `a` operation points after `b` operation, we move `a` offset to acknowledge
    			// "holder" element insertion.
    			if (a instanceof RemoveOperation && b instanceof RemoveOperation && b._needsHolderElement) {
    				var aTarget = a.targetPosition.path[0];
    				var bTarget = b.targetPosition.path[0];

    				if (aTarget > bTarget || aTarget == bTarget && isStrong) {
    					// Do not change original operation!
    					a = a.clone();
    					a.targetPosition.path[0]++;
    				}
    			}

    			// If only one of operations is a remove operation, we force remove operation to be the "stronger" one
    			// to provide more expected results.
    			if (a instanceof RemoveOperation && !(b instanceof RemoveOperation)) {
    				isStrong = true;
    			} else if (!(a instanceof RemoveOperation) && b instanceof RemoveOperation) {
    				isStrong = false;
    			}

    			// Create ranges from MoveOperations properties.
    			var rangeA = Range$1.createFromPositionAndShift(a.sourcePosition, a.howMany);
    			var rangeB = Range$1.createFromPositionAndShift(b.sourcePosition, b.howMany);

    			// This will aggregate transformed ranges.
    			var ranges = [];

    			// All the other non-special cases are treated by generic algorithm below.
    			var difference = joinRanges(rangeA.getDifference(rangeB));

    			if (difference) {
    				difference.start = difference.start.getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany, !a.isSticky, false);
    				difference.end = difference.end.getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany, a.isSticky, false);

    				ranges.push(difference);
    			}

    			// Then, we have to manage the common part of both move ranges.
    			var common = rangeA.getIntersection(rangeB);

    			// If MoveOperations has common range it can be one of two:
    			// * on the same tree level - it means that we move the same nodes into different places
    			// * on deeper tree level - it means that we move nodes that are inside moved nodes
    			// The operations are conflicting only if they try to move exactly same nodes, so only in the first case.
    			// That means that we transform common part in two cases:
    			// * `rangeA` is "deeper" than `rangeB` so it does not collide
    			// * `rangeA` is at the same level but is stronger than `rangeB`.
    			var aCompB = compareArrays(a.sourcePosition.getParentPath(), b.sourcePosition.getParentPath());

    			// If the `b` MoveOperation points inside the `a` MoveOperation range, the common part will be included in
    			// range(s) that (is) are results of processing `difference`. If that's the case, we cannot include it again.
    			var bTargetsToA = rangeA.containsPosition(b.targetPosition) || rangeA.start.isEqual(b.targetPosition) && a.isSticky || rangeA.end.isEqual(b.targetPosition) && a.isSticky;

    			// If the `b` MoveOperation range contains both whole `a` range and target position we do an exception and
    			// transform `a` operation. Normally, when same nodes are moved, we stick with stronger operation's target.
    			// Here it is a move inside larger range so there is no conflict because after all, all nodes from
    			// smaller range will be moved to larger range target. The effect of this transformation feels natural.
    			// Also if we wouldn't do that, we would get different results on both sides of transformation (i.e. in
    			// collaborative editing).
    			var aIsInside = rangeB.containsRange(rangeA) && (rangeB.containsPosition(a.targetPosition) || rangeB.start.isEqual(a.targetPosition) || rangeB.end.isEqual(a.targetPosition));

    			if (common !== null && (aCompB === 'EXTENSION' || aCompB === 'SAME' && isStrong || aIsInside) && !bTargetsToA) {
    				// Here we do not need to worry that newTargetPosition is inside moved range, because that
    				// would mean that the MoveOperation targets into itself, and that is incorrect operation.
    				// Instead, we calculate the new position of that part of original range.
    				common.start = common.start._getCombined(b.sourcePosition, b.movedRangeStart);
    				common.end = common.end._getCombined(b.sourcePosition, b.movedRangeStart);

    				// We have to take care of proper range order.
    				if (difference && difference.start.isBefore(common.start)) {
    					ranges.push(common);
    				} else {
    					ranges.unshift(common);
    				}
    			}

    			// At this point we transformed this operation's source ranges it means that nothing should be changed.
    			// But since we need to return an instance of Operation we return an array with NoOperation.
    			if (ranges.length === 0) {
    				return [new NoOperation(a.baseVersion)];
    			}

    			// Target position also could be affected by the other MoveOperation. We will transform it.
    			var newTargetPosition = a.targetPosition.getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany, !isStrong, b.isSticky || aIsInside);

    			// Map transformed range(s) to operations and return them.
    			return ranges.reverse().map(function (range) {
    				// We want to keep correct operation class.
    				var result = new a.constructor(range.start, range.end.offset - range.start.offset, a instanceof RemoveOperation ? a.baseVersion : newTargetPosition, a instanceof RemoveOperation ? undefined : a.baseVersion);

    				result.isSticky = a.isSticky;
    				result._holderElementOffset = a._holderElementOffset;

    				return result;
    			});
    		}
    	}
    };

    function transform$1(a, b, isStrong) {
    	var group = void 0;
    	var algorithm = void 0;

    	if (a instanceof InsertOperation) {
    		group = ot.InsertOperation;
    	} else if (a instanceof AttributeOperation) {
    		group = ot.AttributeOperation;
    	} else if (a instanceof RootAttributeOperation) {
    		group = ot.RootAttributeOperation;
    	} else if (a instanceof MoveOperation) {
    		group = ot.MoveOperation;
    	} else {
    		algorithm = doNotUpdate;
    	}

    	if (group) {
    		if (b instanceof InsertOperation) {
    			algorithm = group.InsertOperation;
    		} else if (b instanceof AttributeOperation) {
    			algorithm = group.AttributeOperation;
    		} else if (b instanceof RootAttributeOperation) {
    			algorithm = group.RootAttributeOperation;
    		} else if (b instanceof MoveOperation) {
    			algorithm = group.MoveOperation;
    		} else {
    			algorithm = doNotUpdate;
    		}
    	}

    	var transformed = algorithm(a, b, isStrong);

    	return updateBaseVersions(a.baseVersion, transformed);
    }

    // When we don't want to update an operation, we create and return a clone of it.
    // Returns the operation in "unified format" - wrapped in an Array.
    function doNotUpdate(operation) {
    	return [operation.clone()];
    }

    // Takes an Array of operations and sets consecutive base versions for them, starting from given base version.
    // Returns the passed array.
    function updateBaseVersions(baseVersion, operations) {
    	for (var i = 0; i < operations.length; i++) {
    		operations[i].baseVersion = baseVersion + i + 1;
    	}

    	return operations;
    }

    // Checks whether MoveOperation targetPosition is inside a node from the moved range of the other MoveOperation.
    function moveTargetIntoMovedRange(a, b) {
    	return a.targetPosition.getTransformedByDeletion(b.sourcePosition, b.howMany) === null;
    }

    // Gets an array of Ranges and produces one Range out of it. The root of a new range will be same as
    // the root of the first range in the array. If any of given ranges has different root than the first range,
    // it will be discarded.
    function joinRanges(ranges) {
    	if (ranges.length === 0) {
    		return null;
    	} else if (ranges.length == 1) {
    		return ranges[0];
    	} else {
    		ranges[0].end = ranges[ranges.length - 1].end;

    		return ranges[0];
    	}
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    var nativeCeil = Math.ceil;
var     nativeMax$1 = Math.max;
    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if (guard ? isIterateeCall(array, size, guard) : size === undefined) {
        size = 1;
      } else {
        size = nativeMax$1(toInteger(size), 0);
      }
      var length = array ? array.length : 0;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, index += size);
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value);
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length,
          args = Array(length ? length - 1 : 0),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return length ? arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1)) : [];
    }

    /**
     * Gets the index at which the first occurrence of `NaN` is found in `array`.
     *
     * @private
     * @param {Array} array The array to search.
     * @param {number} fromIndex The index to search from.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {number} Returns the index of the matched `NaN`, else `-1`.
     */
    function indexOfNaN(array, fromIndex, fromRight) {
      var length = array.length,
          index = fromIndex + (fromRight ? 0 : -1);

      while (fromRight ? index-- : ++index < length) {
        var other = array[index];
        if (other !== other) {
          return index;
        }
      }
      return -1;
    }

    /**
     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
     *
     * @private
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return indexOfNaN(array, fromIndex);
      }
      var index = fromIndex - 1,
          length = array.length;

      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * A specialized version of `_.includes` for arrays without support for
     * specifying an index to search from.
     *
     * @private
     * @param {Array} array The array to search.
     * @param {*} target The value to search for.
     * @returns {boolean} Returns `true` if `target` is found, else `false`.
     */
    function arrayIncludes(array, value) {
      return !!array.length && baseIndexOf(array, value, 0) > -1;
    }

    /**
     * This function is like `arrayIncludes` except that it accepts a comparator.
     *
     * @private
     * @param {Array} array The array to search.
     * @param {*} target The value to search for.
     * @param {Function} comparator The comparator invoked per element.
     * @returns {boolean} Returns `true` if `target` is found, else `false`.
     */
    function arrayIncludesWith(array, value, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * The base implementation of `_.unary` without support for storing wrapper metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
      return function (value) {
        return func(value);
      };
    }

    /**
     * Checks if a cache value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function cacheHas(cache, key) {
      return cache.has(key);
    }

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE$1 = 200;

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE$1) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer: while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        } else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array of unique `array` values not included in the other given
     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. The order of result values is determined by the
     * order they occur in the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([3, 2, 1], [4, 2]);
     * // => [3, 1]
     */
    var difference = rest(function (array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
    });

var     UNORDERED_COMPARE_FLAG$2 = 1;
var     PARTIAL_COMPARE_FLAG$4 = 2;
    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG$2 | PARTIAL_COMPARE_FLAG$4, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
     * of key-value pairs for `object` corresponding to the property names of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the key-value pairs.
     */
    function baseToPairs(object, props) {
      return arrayMap(props, function (key) {
        return [key, object[key]];
      });
    }

    /**
     * Converts `set` to its value-value pairs.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the value-value pairs.
     */
    function setToPairs(set) {
      var index = -1,
          result = Array(set.size);

      set.forEach(function (value) {
        result[++index] = [value, value];
      });
      return result;
    }

var     mapTag$5 = '[object Map]';
var     setTag$5 = '[object Set]';
    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function (object) {
        var tag = getTag$1(object);
        if (tag == mapTag$5) {
          return mapToArray(object);
        }
        if (tag == setTag$5) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = toPairs(object),
          length = result.length;

      while (length--) {
        result[length][2] = isStrictComparable(result[length][1]);
      }
      return result;
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function (object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
      };
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function (object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /** Used as the `TypeError` message for "Functions" methods. */
    var FUNC_ERROR_TEXT$1 = 'Expected a function';

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || resolver && typeof resolver != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      var memoized = function memoized() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }

    // Assign cache to `_.memoize`.
    memoize.Cache = MapCache;

    /** Used as references for various `Number` constants. */
    var INFINITY$1 = 1 / 0;

    /** Used to convert symbols to primitives and strings. */
var     symbolProto$2 = _Symbol ? _Symbol.prototype : undefined;
    var symbolToString = symbolProto$2 ? symbolProto$2.toString : undefined;
    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = value + '';
      return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /** Used to match property names within property paths. */
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g;

    /** Used to match backslashes in property paths. */
    var reEscapeChar = /\\(\\)?/g;

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoize(function (string) {
      var result = [];
      toString(string).replace(rePropName, function (match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
      });
      return result;
    });

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }

    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
      if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }

    /** Used as references for various `Number` constants. */
    var INFINITY$2 = 1 / 0;

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = value + '';
      return result == '0' && 1 / value == -INFINITY$2 ? '-0' : result;
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : undefined;
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is used in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get$1(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return key in Object(object);
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);

      var result,
          index = -1,
          length = path.length;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isString(object) || isArguments(object));
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

var     UNORDERED_COMPARE_FLAG$3 = 1;
var     PARTIAL_COMPARE_FLAG$5 = 2;
    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function (object) {
        var objValue = get$1(object, path);
        return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG$3 | PARTIAL_COMPARE_FLAG$5);
      };
    }

    /**
     * This method returns the first argument given to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function (object) {
        return baseGet(object, path);
      };
    }

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. Result values are chosen from the first array.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([3.1, 2.2, 1.3], [4.4, 2.5], Math.floor);
     * // => [3.1, 1.3]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = rest(function (array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), baseIteratee(iteratee)) : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. Result values
     * are chosen from the first array. The comparator is invoked with two arguments:
     * (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = rest(function (array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      n = guard || n === undefined ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      n = guard || n === undefined ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}

      return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return array && array.length ? baseWhile(array, baseIteratee(predicate, 3), true, true) : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return array && array.length ? baseWhile(array, baseIteratee(predicate, 3), true) : [];
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments to numbers.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH = 4294967295;

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end === undefined || end > length ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * The base implementation of `_.findIndex` and `_.findLastIndex` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to search.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseFindIndex(array, predicate, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to search.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate) {
      return array && array.length ? baseFindIndex(array, baseIteratee(predicate, 3)) : -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to search.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate) {
      return array && array.length ? baseFindIndex(array, baseIteratee(predicate, 3), true) : -1;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return array && array.length ? array[0] : undefined;
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, 1) : [];
    }

    /** Used as references for various `Number` constants. */
    var INFINITY$3 = 1 / 0;

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, INFINITY$3) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['fred', 30], ['barney', 40]]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs ? pairs.length : 0,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$2 = Math.max;

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf$1(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      fromIndex = toInteger(fromIndex);
      if (fromIndex < 0) {
        fromIndex = nativeMax$2(length + fromIndex, 0);
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      return dropRight(array, 1);
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMin = Math.min;

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer: while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = comparator || value !== 0 ? value : 0;
        if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. The order of result values is determined by the
     * order they occur in the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [4, 2], [1, 2]);
     * // => [2]
     */
    var intersection = rest(function (arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. Result values are chosen from the first array.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [4.3, 2.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = rest(function (arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, baseIteratee(iteratee)) : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. Result values are chosen
     * from the first array. The comparator is invoked with two arguments:
     * (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = rest(function (arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (comparator === last(mapped)) {
        comparator = undefined;
      } else {
        mapped.pop();
      }
      return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : [];
    });

    /** Used for built-in method references. */
    var arrayProto$1 = Array.prototype;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeJoin = arrayProto$1.join;

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array ? nativeJoin.call(array, separator) : '';
    }

var     nativeMax$3 = Math.max;
var     nativeMin$1 = Math.min;
    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = (index < 0 ? nativeMax$3(length + index, 0) : nativeMin$1(index, length - 1)) + 1;
      }
      if (value !== value) {
        return indexOfNaN(array, index, true);
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce `n` to an integer.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * Gets the element at `n` index of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return array && array.length ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * This function is like `baseIndexOf` except that it accepts a comparator.
     *
     * @private
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @param {Function} comparator The comparator invoked per element.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1,
          length = array.length;

      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /** Used for built-in method references. */
    var arrayProto$2 = Array.prototype;

    /** Built-in value references. */
    var splice$1 = arrayProto$2.splice;

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice$1.call(seen, fromIndex, 1);
          }
          splice$1.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     *
     * _.pullAll(array, [2, 3]);
     * console.log(array);
     * // => [1, 1]
     */
    function pullAll(array, values) {
      return array && array.length && values && values.length ? basePullAll(array, values) : array;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     *
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    var pull = rest(pullAll);

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return array && array.length && values && values.length ? basePullAll(array, values, baseIteratee(iteratee)) : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array;
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths of elements to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          isNil = object == null,
          length = paths.length,
          result = Array(length);

      while (++index < length) {
        result[index] = isNil ? undefined : get$1(object, paths[index]);
      }
      return result;
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /** Used for built-in method references. */
    var arrayProto$3 = Array.prototype;

    /** Built-in value references. */
    var splice$2 = arrayProto$3.splice;

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice$2.call(array, index, 1);
          } else if (!isKey(index, array)) {
            var path = castPath(index),
                object = parent(array, path);

            if (object != null) {
              delete object[toKey(last(path))];
            }
          } else {
            delete array[toKey(index)];
          }
        }
      }
      return array;
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [5, 10, 15, 20];
     * var evens = _.pullAt(array, 1, 3);
     *
     * console.log(array);
     * // => [5, 15]
     *
     * console.log(evens);
     * // => [10, 20]
     */
    var pullAt = rest(function (array, indexes) {
      indexes = baseFlatten(indexes, 1);

      var length = array ? array.length : 0,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function (index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove$1(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = baseIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /** Used for built-in method references. */
    var arrayProto$4 = Array.prototype;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeReverse = arrayProto$4.reverse;

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array ? nativeReverse.call(array) : array;
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      } else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

var     MAX_ARRAY_LENGTH$2 = 4294967295;
    var MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH$2 - 1;
    var nativeFloor = Math.floor;
var     nativeMin$2 = Math.min;
    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array ? array.length : 0,
          valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? computed <= value : computed < value;
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin$2(high, MAX_ARRAY_INDEX);
    }

var     MAX_ARRAY_LENGTH$1 = 4294967295;
    var HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH$1 >>> 1;
    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array ? array.length : low;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = low + high >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     *
     * _.sortedIndex([4, 5], 4);
     * // => 0
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var dict = { 'thirty': 30, 'forty': 40, 'fifty': 50 };
     *
     * _.sortedIndexBy(['thirty', 'fifty'], 'forty', _.propertyOf(dict));
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, baseIteratee(iteratee));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([1, 1, 2, 2], 2);
     * // => 2
     */
    function sortedIndexOf(array, value) {
      var length = array ? array.length : 0;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5], 4);
     * // => 1
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, baseIteratee(iteratee), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([1, 1, 2, 2], 2);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array ? array.length : 0;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return array && array.length ? baseSortedUniq(array) : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return array && array.length ? baseSortedUniq(array, baseIteratee(iteratee)) : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      return drop(array, 1);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = guard || n === undefined ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      n = guard || n === undefined ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return array && array.length ? baseWhile(array, baseIteratee(predicate, 3), false, true) : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Array|Function|Object|string} [predicate=_.identity]
     *  The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false},
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return array && array.length ? baseWhile(array, baseIteratee(predicate, 3)) : [];
    }

    /**
     * A no-operation function that returns `undefined` regardless of the
     * arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // No operation performed.
    }

    /** Used as references for various `Number` constants. */
    var INFINITY$4 = 1 / 0;

    /**
     * Creates a set of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY$4) ? noop : function (values) {
      return new Set$1(values);
    };

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE$2 = 200;

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE$2) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer: while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2, 1], [4, 2], [1, 2]);
     * // => [2, 1, 4]
     */
    var union = rest(function (arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1, 1.2], [4.3, 2.4], Math.floor);
     * // => [2.1, 1.2, 4.3]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = rest(function (arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), baseIteratee(iteratee));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = rest(function (arrays) {
      var comparator = last(arrays);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each
     * element is kept.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return array && array.length ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return array && array.length ? baseUniq(array, baseIteratee(iteratee)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The comparator is invoked with
     * two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 },  { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      return array && array.length ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax$4 = Math.max;

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     *
     * _.unzip(zipped);
     * // => [['fred', 'barney'], [30, 40], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function (group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax$4(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function (index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function (group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([1, 2, 1, 3], 1, 2);
     * // => [3]
     */
    var without = rest(function (array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, values) : [];
    });

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var index = -1,
          length = arrays.length;

      while (++index < length) {
        var result = result ? arrayPush(baseDifference(result, arrays[index], iteratee, comparator), baseDifference(arrays[index], result, iteratee, comparator)) : arrays[index];
      }
      return result && result.length ? baseUniq(result, iteratee, comparator) : [];
    }

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [4, 2]);
     * // => [1, 4]
     */
    var xor = rest(function (arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Array|Function|Object|string} [iteratee=_.identity]
     *  The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [4.3, 2.4], Math.floor);
     * // => [1.2, 4.3]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = rest(function (arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), baseIteratee(iteratee));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The comparator is invoked with
     * two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = rest(function (arrays) {
      var comparator = last(arrays);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    var zip = rest(unzip);

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      path = isKey(path, object) ? [path] : castPath(path);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]);
        if (isObject(nested)) {
          var newValue = value;
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined;
            if (newValue === undefined) {
              newValue = objValue == null ? isIndex(path[index + 1]) ? [] : {} : objValue;
            }
          }
          assignValue(nested, key, newValue);
        }
        nested = nested[key];
      }
      return object;
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = rest(function (arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    var arrayUtils = {
      chunk: chunk, compact: compact, concat: concat, difference: difference, differenceBy: differenceBy,
      differenceWith: differenceWith, drop: drop, dropRight: dropRight, dropRightWhile: dropRightWhile, dropWhile: dropWhile,
      fill: fill, findIndex: findIndex, findLastIndex: findLastIndex, first: head, flatten: flatten,
      flattenDeep: flattenDeep, flattenDepth: flattenDepth, fromPairs: fromPairs, head: head, indexOf: indexOf$1,
      initial: initial, intersection: intersection, intersectionBy: intersectionBy, intersectionWith: intersectionWith, join: join,
      last: last, lastIndexOf: lastIndexOf, nth: nth, pull: pull, pullAll: pullAll,
      pullAllBy: pullAllBy, pullAllWith: pullAllWith, pullAt: pullAt, remove: remove$1, reverse: reverse,
      slice: slice, sortedIndex: sortedIndex, sortedIndexBy: sortedIndexBy, sortedIndexOf: sortedIndexOf, sortedLastIndex: sortedLastIndex,
      sortedLastIndexBy: sortedLastIndexBy, sortedLastIndexOf: sortedLastIndexOf, sortedUniq: sortedUniq, sortedUniqBy: sortedUniqBy, tail: tail,
      take: take, takeRight: takeRight, takeRightWhile: takeRightWhile, takeWhile: takeWhile, union: union,
      unionBy: unionBy, unionWith: unionWith, uniq: uniq, uniqBy: uniqBy, uniqWith: uniqWith,
      unzip: unzip, unzipWith: unzipWith, without: without, xor: xor, xorBy: xorBy,
      xorWith: xorWith, zip: zip, zipObject: zipObject, zipObjectDeep: zipObjectDeep, zipWith: zipWith
    };

    var specialCases = new Map();

    /**
     * Transforms given {@link engine.model.delta.Delta delta} by another {@link engine.model.delta.Delta delta} and
     * returns the result of that transformation as an array containing one or more {@link engine.model.delta.Delta delta}
     * instances.
     *
     * Delta transformations heavily base on {@link engine.model.operation.transform operational transformations}. Since
     * delta is a list of operations most situations can be handled thanks to operational transformation. Unfortunately,
     * deltas are more complicated than operations and have they semantic meaning, as they represent user's editing intentions.
     *
     * Sometimes, simple operational transformation on deltas' operations might result in some unexpected results. Those
     * results would be fine from OT point of view, but would not reflect user's intentions. Because of such conflicts
     * we need to handle transformations in special cases in a custom way.
     *
     * The function itself looks whether two given delta types have a special case function registered. If so, the deltas are
     * transformed using that function. If not, {@link engine.model.delta.defaultTransform default transformation algorithm}
     * is used.
     *
     * @see engine.model.operation.transform
     *
     * @external engine.model.delta.transform
     * @function engine.model.delta.transform.transform
     * @param {engine.model.delta.Delta} a Delta that will be transformed.
     * @param {engine.model.delta.Delta} b Delta to transform by.
     * @param {Boolean} isAMoreImportantThanB Flag indicating whether the delta which will be transformed (`a`) should be treated
     * as more important when resolving conflicts. Note that this flag is used only if provided deltas have same
     * {@link engine.model.delta.priorities priority}. If deltas have different priorities, their importance is resolved
     * automatically and overwrites this flag.
     * @returns {Array.<engine.model.delta.Delta>} Result of the transformation.
     */
    function transform(a, b, isAMoreImportantThanB) {
    	var transformAlgorithm = getTransformationCase(a, b) || defaultTransform;

    	var transformed = transformAlgorithm(a, b, isAMoreImportantThanB);
    	var baseVersion = arrayUtils.last(b.operations).baseVersion;

    	return updateBaseVersion(baseVersion, transformed);
    }

    // Updates base versions of operations inside deltas (which are the results of delta transformation).
    function updateBaseVersion(baseVersion, deltas) {
    	var _iteratorNormalCompletion = true;
    	var _didIteratorError = false;
    	var _iteratorError = undefined;

    	try {
    		for (var _iterator = deltas[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    			var delta = _step.value;
    			var _iteratorNormalCompletion2 = true;
    			var _didIteratorError2 = false;
    			var _iteratorError2 = undefined;

    			try {
    				for (var _iterator2 = delta.operations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    					var op = _step2.value;

    					op.baseVersion = ++baseVersion;
    				}
    			} catch (err) {
    				_didIteratorError2 = true;
    				_iteratorError2 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion2 && _iterator2.return) {
    						_iterator2.return();
    					}
    				} finally {
    					if (_didIteratorError2) {
    						throw _iteratorError2;
    					}
    				}
    			}
    		}
    	} catch (err) {
    		_didIteratorError = true;
    		_iteratorError = err;
    	} finally {
    		try {
    			if (!_iteratorNormalCompletion && _iterator.return) {
    				_iterator.return();
    			}
    		} finally {
    			if (_didIteratorError) {
    				throw _iteratorError;
    			}
    		}
    	}

    	return deltas;
    }

    /**
     * The default delta transformation function. It is used for those deltas that are not in special case conflict.
     *
     * This algorithm is similar to popular `dOPT` algorithm used in operational transformation, as we are in fact
     * transforming two sets of operations by each other.
     *
     * @external engine.model.delta.transform
     * @function engine.model.delta.transform.defaultTransform
     * @param {engine.model.delta.Delta} a Delta that will be transformed.
     * @param {engine.model.delta.Delta} b Delta to transform by.
     * @param {Boolean} isAMoreImportantThanB Flag indicating whether the delta which will be transformed (`a`) should be treated
     * as more important when resolving conflicts. Note that this flag is used only if provided deltas have same
     * {@link engine.model.delta.priorities priority}. If deltas have different priorities, their importance is resolved
     * automatically and overwrites this flag.
     * @returns {Array.<engine.model.delta.Delta>} Result of the transformation, that is an array with single delta instance.
     */
    function defaultTransform(a, b, isAMoreImportantThanB) {
    	// First, resolve the flag real value.
    	isAMoreImportantThanB = getPriority(a.constructor, b.constructor, isAMoreImportantThanB);

    	// Create a new delta instance. Make sure that the new delta is of same type as transformed delta.
    	// We will transform operations in that delta but it doesn't mean the delta's "meaning" which is connected to
    	// the delta's type. Since the delta's type is heavily used in transformations and probably other parts
    	// of system it is important to keep proper delta type through all transformation process.
    	var transformed = new a.constructor();

    	// Array containing operations that we will transform by. At the beginning these are just operations from
    	var byOps = b.operations;

    	// This array is storing operations from `byOps` which got transformed by operation from delta `a`.
    	var newByOps = [];

    	// We take each operation from original set of operations to transform.
    	var _iteratorNormalCompletion3 = true;
    	var _didIteratorError3 = false;
    	var _iteratorError3 = undefined;

    	try {
    		for (var _iterator3 = a.operations[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
    			var opA = _step3.value;

    			// We wrap the operation in the array. This is important, because operation transformation algorithm returns
    			// an array of operations so we need to make sure that our algorithm is ready to handle arrays.
    			var ops = [opA];

    			// Now the real algorithm takes place.
    			var _iteratorNormalCompletion4 = true;
    			var _didIteratorError4 = false;
    			var _iteratorError4 = undefined;

    			try {
    				for (var _iterator4 = byOps[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
    					var opB = _step4.value;

    					// For each operation that we need transform by...
    					for (var i = 0; i < ops.length; i++) {
    						// We take each operation to transform...
    						var op = ops[i];

    						// And transform both of them by themselves.

    						// The result of transforming operation from delta B by operation from delta A is saved in
    						// `newByOps` array. We will use that array for transformations in next loops. We need delta B
    						// operations after transformed by delta A operations to get correct results of transformations
    						// of next operations from delta A.
    						//
    						// It's like this because 2nd operation from delta A assumes that 1st operation from delta A
    						// is "already applied". When we transform 2nd operation from delta A by operations from delta B
    						// we have to be sure that operations from delta B are in a state that acknowledges 1st operation
    						// from delta A.
    						//
    						// This can be easier understood when operations sets to transform are represented by diamond diagrams:
    						// http://www.codecommit.com/blog/java/understanding-and-applying-operational-transformation

    						// Using push.apply because operationTransform function is returning an array with one or multiple results.
    						Array.prototype.push.apply(newByOps, transform$1(opB, op, !isAMoreImportantThanB));

    						// Then, we transform operation from delta A by operation from delta B.
    						var results = transform$1(op, opB, isAMoreImportantThanB);

    						// We replace currently processed operation from `ops` array by the results of transformation.
    						// Note, that we process single operation but the operationTransform result might be an array, so we
    						// might splice-in more operations. We will process them further in next iterations. Right now we
    						// just save them in `ops` array and move `i` pointer by proper offset.
    						Array.prototype.splice.apply(ops, [i, 1].concat(results));

    						i += results.length - 1;
    					}

    					// At this point a single operation from delta A got transformed by a single operation from delta B.
    					// The transformation result is in `ops` array and it may be one or more operations. This was just the first step.
    					// Operation from delta A has to be further transformed by the other operations from delta B.
    					// So in next iterator loop we will take another operation from delta B and use transformed delta A (`ops`)
    					// to transform it further.
    				}

    				// We got through all delta B operations and have a final transformed state of an operation from delta A.

    				// As previously mentioned, we substitute operations from delta B by their transformed equivalents.
    			} catch (err) {
    				_didIteratorError4 = true;
    				_iteratorError4 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion4 && _iterator4.return) {
    						_iterator4.return();
    					}
    				} finally {
    					if (_didIteratorError4) {
    						throw _iteratorError4;
    					}
    				}
    			}

    			byOps = newByOps;
    			newByOps = [];

    			// We add transformed operation from delta A to newly created delta.
    			// Remember that transformed operation from delta A may consist of multiple operations.
    			var _iteratorNormalCompletion5 = true;
    			var _didIteratorError5 = false;
    			var _iteratorError5 = undefined;

    			try {
    				for (var _iterator5 = ops[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
    					var _op = _step5.value;

    					transformed.addOperation(_op);
    				}

    				// In next loop, we will take another operation from delta A and transform it through (transformed) operations
    				// from delta B...
    			} catch (err) {
    				_didIteratorError5 = true;
    				_iteratorError5 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion5 && _iterator5.return) {
    						_iterator5.return();
    					}
    				} finally {
    					if (_didIteratorError5) {
    						throw _iteratorError5;
    					}
    				}
    			}
    		}
    	} catch (err) {
    		_didIteratorError3 = true;
    		_iteratorError3 = err;
    	} finally {
    		try {
    			if (!_iteratorNormalCompletion3 && _iterator3.return) {
    				_iterator3.return();
    			}
    		} finally {
    			if (_didIteratorError3) {
    				throw _iteratorError3;
    			}
    		}
    	}

    	return [transformed];
    }

    /**
     * Adds a special case callback for given delta classes.
     *
     * @external engine.model.delta.transform
     * @function engine.model.delta.transform.addTransformationCase
     * @param {Function} A Delta constructor which instance will get transformed.
     * @param {Function} B Delta constructor which instance will be transformed by.
     * @param {Function} resolver A callback that will handle custom special case transformation for instances of given delta classes.
     */
    function addTransformationCase(A, B, resolver) {
    	var casesA = specialCases.get(A);

    	if (!casesA) {
    		casesA = new Map();
    		specialCases.set(A, casesA);
    	}

    	casesA.set(B, resolver);
    }

    /**
     * Gets a special case callback which was previously {@link engine.model.delta.transform.addTransformationCase added}.
     *
     * @external engine.model.delta.transform
     * @function engine.model.delta.transform.getTransformationCase
     * @param {engine.model.delta.Delta} a Delta to transform.
     * @param {engine.model.delta.Delta} b Delta to be transformed by.
     */
    function getTransformationCase(a, b) {
    	var casesA = specialCases.get(a.constructor);

    	// If there are no special cases registered for class which `a` is instance of, we will
    	// check if there are special cases registered for any parent class.
    	if (!casesA || !casesA.get(b.constructor)) {
    		var cases = specialCases.keys();

    		var _iteratorNormalCompletion6 = true;
    		var _didIteratorError6 = false;
    		var _iteratorError6 = undefined;

    		try {
    			for (var _iterator6 = cases[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
    				var caseClass = _step6.value;

    				if (a instanceof caseClass) {
    					casesA = specialCases.get(caseClass);
    				}
    			}
    		} catch (err) {
    			_didIteratorError6 = true;
    			_iteratorError6 = err;
    		} finally {
    			try {
    				if (!_iteratorNormalCompletion6 && _iterator6.return) {
    					_iterator6.return();
    				}
    			} finally {
    				if (_didIteratorError6) {
    					throw _iteratorError6;
    				}
    			}
    		}
    	}

    	if (casesA) {
    		return casesA.get(b.constructor);
    	}

    	return undefined;
    }

    // Checks priorities of passed constructors and decides which one is more important.
    // If both priorities are same, value passed in `isAMoreImportantThanB` parameter is used.
    function getPriority(A, B, isAMoreImportantThanB) {
    	if (A._priority > B._priority) {
    		return true;
    	} else if (A._priority < B._priority) {
    		return false;
    	} else {
    		return isAMoreImportantThanB;
    	}
    }

    // Provide transformations for default deltas.

    // Add special case for AttributeDelta x WeakInsertDelta transformation.
    addTransformationCase(AttributeDelta, WeakInsertDelta, function (a, b, isStrong) {
    	// If nodes are weak-inserted into attribute delta range, we need to apply changes from attribute delta on them.
    	// So first we do the normal transformation and if this special cases happens, we will add an extra delta.
    	var deltas = defaultTransform(a, b, isStrong);

    	if (a.range.containsPosition(b.position)) {
    		deltas.push(_getComplementaryAttrDelta(b, a));
    	}

    	return deltas;
    });

    // Add special case for InsertDelta x MergeDelta transformation.
    addTransformationCase(InsertDelta, MergeDelta, function (a, b, isStrong) {
    	// If insert is applied at the same position where merge happened, we reverse the merge (we treat it like it
    	// didn't happen) and then apply the original insert operation. This is "mirrored" in MergeDelta x InsertDelta
    	// transformation below, where we simply do not apply MergeDelta.
    	if (a.position.isEqual(b.position)) {
    		return [b.getReversed(), a.clone()];
    	}

    	return defaultTransform(a, b, isStrong);
    });

    // Add special case for MoveDelta x MergeDelta transformation.
    addTransformationCase(MoveDelta, MergeDelta, function (a, b, isStrong) {
    	// If move delta is supposed to move a node that has been merged, we reverse the merge (we treat it like it
    	// didn't happen) and then apply the original move operation. This is "mirrored" in MergeDelta x MoveDelta
    	// transformation below, where we simply do not apply MergeDelta.

    	var operateInSameParent = a.sourcePosition.root == b.position.root && compareArrays(a.sourcePosition.getParentPath(), b.position.getParentPath()) === 'SAME';

    	var mergeInsideMoveRange = a.sourcePosition.offset <= b.position.offset && a.sourcePosition.offset + a.howMany > b.position.offset;

    	if (operateInSameParent && mergeInsideMoveRange) {
    		return [b.getReversed(), a.clone()];
    	}

    	return defaultTransform(a, b, isStrong);
    });

    // Add special case for MergeDelta x InsertDelta transformation.
    addTransformationCase(MergeDelta, InsertDelta, function (a, b, isStrong) {
    	// If merge is applied at the same position where we inserted a range of nodes we cancel the merge as it's results
    	// may be unexpected and very weird. Even if we do some "magic" we don't know what really are users' expectations.
    	if (a.position.isEqual(b.position)) {
    		return [noDelta()];
    	}

    	return defaultTransform(a, b, isStrong);
    });

    // Add special case for MergeDelta x MoveDelta transformation.
    addTransformationCase(MergeDelta, MoveDelta, function (a, b, isStrong) {
    	// If merge is applied at the position between moved nodes we cancel the merge as it's results may be unexpected and
    	// very weird. Even if we do some "magic" we don't know what really are users' expectations.

    	var operateInSameParent = a.position.root == b.sourcePosition.root && compareArrays(a.position.getParentPath(), b.sourcePosition.getParentPath()) === 'SAME';

    	var mergeInsideMoveRange = b.sourcePosition.offset <= a.position.offset && b.sourcePosition.offset + b.howMany > a.position.offset;

    	if (operateInSameParent && mergeInsideMoveRange) {
    		return [noDelta()];
    	}

    	return defaultTransform(a, b, isStrong);
    });

    // Add special case for SplitDelta x SplitDelta transformation.
    addTransformationCase(SplitDelta, SplitDelta, function (a, b, isStrong) {
    	var pathA = a.position.getParentPath();
    	var pathB = b.position.getParentPath();

    	// The special case is for splits inside the same parent.
    	if (compareArrays(pathA, pathB) == 'SAME') {
    		if (a.position.offset == b.position.offset) {
    			// We are applying split at the position where split already happened. Additional split is not needed.
    			return [noDelta()];
    		} else if (a.position.offset < b.position.offset) {
    			// Incoming split delta splits at closer offset. So we simply have to once again split the same node,
    			// but since it was already split (at further offset) there are less child nodes in the split node.
    			// This means that we have to update `howMany` parameter of `MoveOperation` for that delta.

    			var delta = a.clone();
    			delta._moveOperation.howMany = b.position.offset - a.position.offset;

    			// If both SplitDeltas are taking their nodes from graveyard, we have to transform their ReinsertOperations.
    			if (a._cloneOperation instanceof ReinsertOperation && b._cloneOperation instanceof ReinsertOperation && a._cloneOperation.sourcePosition.offset > b._cloneOperation.sourcePosition.offset) {
    				delta._cloneOperation.sourcePosition.offset--;
    			}

    			return [delta];
    		} else {
    			// Incoming split delta splits at further offset. We have to simulate that we are not splitting the
    			// original split node but the node after it, which got created by the other split delta.
    			// To do so, we increment offsets so it looks like the split delta was created in the next node.

    			var _delta = a.clone();

    			_delta._cloneOperation.position.offset++;
    			_delta._moveOperation.sourcePosition.path[_delta._moveOperation.sourcePosition.path.length - 2]++;
    			_delta._moveOperation.targetPosition.path[_delta._moveOperation.targetPosition.path.length - 2]++;
    			_delta._moveOperation.sourcePosition.offset = a.position.offset - b.position.offset;

    			// If both SplitDeltas are taking their nodes from graveyard, we have to transform their ReinsertOperations.
    			if (a._cloneOperation instanceof ReinsertOperation && b._cloneOperation instanceof ReinsertOperation && a._cloneOperation.sourcePosition.offset > b._cloneOperation.sourcePosition.offset) {
    				_delta._cloneOperation.sourcePosition.offset--;
    			}

    			return [_delta];
    		}
    	}

    	return defaultTransform(a, b, isStrong);
    });

    // Add special case for SplitDelta x UnwrapDelta transformation.
    addTransformationCase(SplitDelta, UnwrapDelta, function (a, b, isStrong) {
    	// If incoming split delta tries to split a node that just got unwrapped, there is actually nothing to split,
    	// so we discard that delta.
    	if (compareArrays(b.position.path, a.position.getParentPath()) === 'SAME') {
    		return [noDelta()];
    	}

    	return defaultTransform(a, b, isStrong);
    });

    // Add special case for SplitDelta x WrapDelta transformation.
    addTransformationCase(SplitDelta, WrapDelta, function (a, b, isStrong) {
    	// If split is applied at the position between wrapped nodes, we cancel the split as it's results may be unexpected and
    	// very weird. Even if we do some "magic" we don't know what really are users' expectations.

    	var operateInSameParent = compareArrays(a.position.getParentPath(), b.range.start.getParentPath()) === 'SAME';
    	var splitInsideWrapRange = b.range.start.offset < a.position.offset && b.range.end.offset >= a.position.offset;

    	if (operateInSameParent && splitInsideWrapRange) {
    		return [noDelta()];
    	} else if (compareArrays(a.position.getParentPath(), b.range.end.getShiftedBy(-1).path) === 'SAME') {
    		// Split position is directly inside the last node from wrap range.
    		// If that's the case, we manually change split delta so it will "target" inside the wrapping element.
    		// By doing so we will be inserting split node right to the original node which feels natural and is a good UX.
    		var delta = a.clone();

    		// 1. Fix insert operation position.
    		// Node to split is the last children of the wrapping element.
    		// Wrapping element is the element inserted by WrapDelta (re)insert operation.
    		// It is inserted after the wrapped range, but the wrapped range will be moved inside it.
    		// Having this in mind, it is correct to use wrapped range start position as the position before wrapping element.
    		var splitNodePos = Position.createFromPosition(b.range.start);
    		// Now, `splitNodePos` points before wrapping element.
    		// To get a position before last children of that element, we expand position's `path` member by proper offset.
    		splitNodePos.path.push(b.howMany - 1);

    		// SplitDelta insert operation position should be right after the node we split.
    		var insertPos = splitNodePos.getShiftedBy(1);
    		delta._cloneOperation.position = insertPos;

    		// 2. Fix move operation source position.
    		// Nodes moved by SplitDelta will be moved from new position, modified by WrapDelta.
    		// To obtain that new position, `splitNodePos` will be used, as this is the node we are extracting children from.
    		var sourcePos = Position.createFromPosition(splitNodePos);
    		// Nothing changed inside split node so it is correct to use the original split position offset.
    		sourcePos.path.push(a.position.offset);
    		delta._moveOperation.sourcePosition = sourcePos;

    		// 3. Fix move operation target position.
    		// SplitDelta move operation target position should be inside the node inserted by operation above.
    		// Since the node is empty, we will insert at offset 0.
    		var targetPos = Position.createFromPosition(insertPos);
    		targetPos.path.push(0);
    		delta._moveOperation.targetPosition = targetPos;

    		return [delta];
    	}

    	return defaultTransform(a, b, isStrong);
    });

    // Add special case for UnwrapDelta x SplitDelta transformation.
    addTransformationCase(UnwrapDelta, SplitDelta, function (a, b, isStrong) {
    	// If incoming unwrap delta tries to unwrap node that got split we should unwrap the original node and the split copy.
    	// This can be achieved either by reverting split and applying unwrap to singular node, or creating additional unwrap delta.
    	if (compareArrays(a.position.path, b.position.getParentPath()) === 'SAME') {
    		var transformed = [b.getReversed(), a.clone()];

    		// It's a kind of magic-magic-magic-maaaaagiiic!
    		transformed[1].operations[1].targetPosition.path[0]++;
    		// But seriously, we have to fix RemoveOperation in the second delta because reversed UnwrapDelta creates
    		// MergeDelta which also has RemoveOperation. Those two operations cannot point to the same "holder" element
    		// in the graveyard, so we fix it by hand. This is the only case where it happens in "special" transformation
    		// cases, and it won't happen for "default" transformation apart of RemoveDelta, where it is okay.

    		return transformed;
    	}

    	return defaultTransform(a, b, isStrong);
    });

    // Add special case for WeakInsertDelta x AttributeDelta transformation.
    addTransformationCase(WeakInsertDelta, AttributeDelta, function (a, b, isStrong) {
    	// If nodes are weak-inserted into attribute delta range, we need to apply changes from attribute delta on them.
    	// So first we do the normal transformation and if this special cases happens, we will add an extra delta.
    	var deltas = defaultTransform(a, b, isStrong);

    	if (b.range.containsPosition(a.position)) {
    		deltas.push(_getComplementaryAttrDelta(a, b));
    	}

    	return deltas;
    });

    // Add special case for WrapDelta x SplitDelta transformation.
    addTransformationCase(WrapDelta, SplitDelta, function (a, b, isStrong) {
    	// If incoming wrap delta tries to wrap range that contains split position, we have to cancel the split and apply
    	// the wrap. Since split was already applied, we have to revert it.

    	var operateInSameParent = compareArrays(a.range.start.getParentPath(), b.position.getParentPath()) === 'SAME';
    	var splitInsideWrapRange = a.range.start.offset < b.position.offset && a.range.end.offset >= b.position.offset;

    	if (operateInSameParent && splitInsideWrapRange) {
    		return [b.getReversed(), a.clone()];
    	} else if (compareArrays(b.position.getParentPath(), a.range.end.getShiftedBy(-1).path) === 'SAME') {
    		var delta = a.clone();

    		// Move wrapping element insert position one node further so it is after the split node insertion.
    		delta._insertOperation.position.offset++;

    		// Include the split node copy.
    		delta._moveOperation.howMany++;

    		// Change the path to wrapping element in move operation.
    		delta._moveOperation.targetPosition.path[delta._moveOperation.targetPosition.path.length - 2]++;

    		return [delta];
    	}

    	return defaultTransform(a, b, isStrong);
    });

    // Helper function for `AttributeDelta` class transformations.
    // Creates an attribute delta that sets attribute from given `attributeDelta` on nodes from given `weakInsertDelta`.
    function _getComplementaryAttrDelta(weakInsertDelta, attributeDelta) {
    	var complementaryAttrDelta = new AttributeDelta();

    	// At the beginning we store the attribute value from the first node on `weakInsertDelta` node list.
    	var val = weakInsertDelta.nodeList.get(0).getAttribute(attributeDelta.key);

    	// This stores the last index of `weakInsertDelta` node list where the attribute value was different
    	// than in the previous node. We need it to create separate `AttributeOperation`s for nodes with different attributes.
    	var lastIndex = 0;

    	for (var i = 0; i < weakInsertDelta.nodeList.length; i++) {
    		var node = weakInsertDelta.nodeList.get(i);
    		var nodeAttrVal = node.getAttribute(attributeDelta.key);

    		// If previous node has different attribute value, we will create an operation to the point before current node.
    		// So all nodes with the same attributes up to this point will be included in one `AttributeOperation`.
    		if (nodeAttrVal != val) {
    			// New operation is created only when it is needed. If given node already has proper value for this
    			// attribute we simply skip it without adding a new operation.
    			if (val != attributeDelta.value) {
    				var _range = new Range$1(weakInsertDelta.position.getShiftedBy(lastIndex), weakInsertDelta.position.getShiftedBy(i));

    				// We don't care about base version because it will be updated after transformations anyway.
    				var attrOperation = new AttributeOperation(_range, attributeDelta.key, val, attributeDelta.value, 0);
    				complementaryAttrDelta.addOperation(attrOperation);
    			}

    			val = nodeAttrVal;
    			lastIndex = i;
    		}
    	}

    	// At the end we have to add additional `AttributeOperation` for the last part of node list. If all nodes on the
    	// node list had same attributes, this will be the only operation added to the delta.
    	var range = new Range$1(weakInsertDelta.position.getShiftedBy(lastIndex), weakInsertDelta.position.getShiftedBy(weakInsertDelta.nodeList.length));

    	complementaryAttrDelta.addOperation(new AttributeOperation(range, attributeDelta.key, val, attributeDelta.value, 0));

    	return complementaryAttrDelta;
    }

    // This is "no-op" delta, it has no type and only no-operation, it basically does nothing.
    // It is used when we don't want to apply changes but still we need to return a delta.
    function noDelta() {
    	var noDelta = new Delta();

    	// BaseVersion will be fixed later anyway.
    	noDelta.addOperation(new NoOperation(0));

    	return noDelta;
    }

    /**
     * `History` keeps the track of all the deltas applied to the {@link engine.model.Document document}. Deltas stored in
     * `History` might get updated, split into more deltas or even removed. This is used mostly to compress history, instead
     * of keeping all deltas in a state in which they were applied.
     *
     * **Note:** deltas kept in `History` should be used only to transform deltas. It's not advised to use `History` to get
     * original delta basing on it's {@link engine.model.delta.Delta#baseVersion baseVersion}. Also, after transforming a
     * delta by deltas from `History`, fix it's base version accordingly (set to {@link engine.model.Document#version}.
     *
     * @memberOf engine.model
     */

    var History = function () {
    	/**
      * Creates an empty History instance.
      */

    	function History() {
    		classCallCheck(this, History);

    		/**
       * Deltas added to the history.
       *
       * @protected
       * @member {Array.<engine.model.delta.Delta>} engine.model.History#_deltas
       */
    		this._deltas = [];

    		/**
       * Helper structure that maps added delta's base version to the index in {@link engine.model.History#_deltas}
       * at which the delta was added.
       *
       * @protected
       * @member {Map} engine.model.History#_historyPoints
       */
    		this._historyPoints = new Map();
    	}

    	/**
      * Adds delta to the history.
      *
      * @param {engine.model.delta.Delta} delta Delta to add.
      */


    	createClass(History, [{
    		key: 'addDelta',
    		value: function addDelta(delta) {
    			if (delta.operations.length > 0 && !this._historyPoints.has(delta.baseVersion)) {
    				var index = this._deltas.length;

    				this._deltas[index] = delta;
    				this._historyPoints.set(delta.baseVersion, index);
    			}
    		}

    		/**
       * Returns deltas added to the history.
       *
       * @param {Number} [from=0] Base version from which deltas should be returned (inclusive). Defaults to `0` which means
       * that deltas from the first one will be returned.
       * @param {Number} [to=Number.POSITIVE_INFINITY] Base version up to which deltas should be returned (exclusive).
       * Defaults to `Number.POSITIVE_INFINITY` which means that deltas up to the last one will be returned.
       * @returns {Iterator.<engine.model.delta.Delta>} Deltas added to the history.
       */

    	}, {
    		key: 'getDeltas',
    		value: regeneratorRuntime.mark(function getDeltas() {
    			var from = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
    			var to = arguments.length <= 1 || arguments[1] === undefined ? Number.POSITIVE_INFINITY : arguments[1];
    			var fromIndex, delta;
    			return regeneratorRuntime.wrap(function getDeltas$(_context) {
    				while (1) {
    					switch (_context.prev = _context.next) {
    						case 0:
    							if (!(this._deltas.length === 0)) {
    								_context.next = 2;
    								break;
    							}

    							return _context.abrupt('return');

    						case 2:

    							// Will throw if base version is incorrect.
    							fromIndex = this._getIndex(from);

    							// Base version is too low or too high and is not found in history.

    							if (!(fromIndex == -1)) {
    								_context.next = 5;
    								break;
    							}

    							return _context.abrupt('return');

    						case 5:
    							if (!(fromIndex < this._deltas.length)) {
    								_context.next = 13;
    								break;
    							}

    							delta = this._deltas[fromIndex++];

    							if (!(delta.baseVersion >= to)) {
    								_context.next = 9;
    								break;
    							}

    							return _context.abrupt('break', 13);

    						case 9:
    							_context.next = 11;
    							return delta;

    						case 11:
    							_context.next = 5;
    							break;

    						case 13:
    						case 'end':
    							return _context.stop();
    					}
    				}
    			}, getDeltas, this);
    		})

    		/**
       * Returns one or more deltas from history that bases on given `baseVersion`. Most often it will be just
       * one delta, but if that delta got updated by multiple deltas, all of those updated deltas will be returned.
       *
       * @see engine.model.History#updateDelta
       * @param {Number} baseVersion Base version of the delta to retrieve.
       * @returns {Array.<engine.model.delta.Delta>|null} Delta with given base version or null if no such delta is in history.
       */

    	}, {
    		key: 'getDelta',
    		value: function getDelta(baseVersion) {
    			var index = this._historyPoints.get(baseVersion);

    			if (index === undefined) {
    				return null;
    			}

    			var deltas = [];

    			for (index; index < this._deltas.length; index++) {
    				var delta = this._deltas[index];

    				if (delta.baseVersion != baseVersion) {
    					break;
    				}

    				deltas.push(delta);
    			}

    			return deltas.length === 0 ? null : deltas;
    		}

    		/**
       * Removes delta from the history. This happens i.e., when a delta is undone by another delta. Both undone delta and
       * undoing delta should be removed so they won't have an impact on transforming other deltas.
       *
       * **Note:** using this method does not change the state of {@link engine.model.Document model}. It just affects
       * the state of `History`.
       *
       * **Note:** when some deltas are removed, deltas between them should probably get updated. See
       * {@link engine.model.History#updateDelta}.
       *
       * **Note:** if delta with `baseVersion` got {@link engine.model.History#updateDelta updated} by multiple
       * deltas, all updated deltas will be removed.
       *
       * @param {Number} baseVersion Base version of a delta to be removed.
       */

    	}, {
    		key: 'removeDelta',
    		value: function removeDelta(baseVersion) {
    			this.updateDelta(baseVersion, []);
    		}

    		/**
       * Substitutes delta in history by one or more given deltas.
       *
       * **Note:** if delta with `baseVersion` was already updated by multiple deltas, all updated deltas will be removed
       * and new deltas will be inserted at their position.
       *
       * **Note:** delta marked as reversed won't get updated.
       *
       * @param {Number} baseVersion Base version of a delta to update.
       * @param {Iterable.<engine.model.delta.Delta>} updatedDeltas Deltas to be inserted in place of updated delta.
       */

    	}, {
    		key: 'updateDelta',
    		value: function updateDelta(baseVersion, updatedDeltas) {
    			var _deltas;

    			var deltas = this.getDelta(baseVersion);

    			// If there are no deltas, stop executing function as there is nothing to update.
    			if (deltas === null) {
    				return;
    			}

    			// Make sure that every updated delta has correct `baseVersion`.
    			// This is crucial for algorithms in `History` and algorithms using `History`.
    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = updatedDeltas[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var delta = _step.value;

    					delta.baseVersion = baseVersion;
    				}

    				// Put updated deltas in place of old deltas.
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}

    			(_deltas = this._deltas).splice.apply(_deltas, [this._getIndex(baseVersion), deltas.length].concat(toConsumableArray(updatedDeltas)));

    			// Update history points.
    			var changeBy = updatedDeltas.length - deltas.length;

    			var _iteratorNormalCompletion2 = true;
    			var _didIteratorError2 = false;
    			var _iteratorError2 = undefined;

    			try {
    				for (var _iterator2 = this._historyPoints.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    					var key = _step2.value;

    					if (key > baseVersion) {
    						this._historyPoints.set(key, this._historyPoints.get(key) + changeBy);
    					}
    				}
    			} catch (err) {
    				_didIteratorError2 = true;
    				_iteratorError2 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion2 && _iterator2.return) {
    						_iterator2.return();
    					}
    				} finally {
    					if (_didIteratorError2) {
    						throw _iteratorError2;
    					}
    				}
    			}
    		}

    		/**
       * Gets an index in {@link engine.model.History#_deltas} where delta with given `baseVersion` is added.
       *
       * @private
       * @param {Number} baseVersion Base version of delta.
       */

    	}, {
    		key: '_getIndex',
    		value: function _getIndex(baseVersion) {
    			var index = this._historyPoints.get(baseVersion);

    			// Base version not found - it is either too high or too low, or is in the middle of delta.
    			if (index === undefined) {
    				var lastDelta = this._deltas[this._deltas.length - 1];
    				var nextBaseVersion = lastDelta.baseVersion + lastDelta.operations.length;

    				if (baseVersion < 0 || baseVersion >= nextBaseVersion) {
    					// Base version is too high or too low - it's acceptable situation.
    					// Return -1 because `baseVersion` was correct.
    					return -1;
    				}

    				/**
         * Given base version points to the middle of a delta.
         *
         * @error history-wrong-version
         */
    				throw new CKEditorError('history-wrong-version: Given base version points to the middle of a delta.');
    			}

    			return index;
    		}
    	}]);
    	return History;
    }();

    /**
     * LiveRange is a Range in the Tree Model that updates itself as the tree changes. It may be used as a bookmark.
     *
     * **Note:** Be very careful when dealing with `LiveRange`. Each `LiveRange` instance bind events that might
     * have to be unbound. Use {@link engine.model.LiveRange#detach detach} whenever you don't need `LiveRange` anymore.
     *
     * @memberOf engine.model
     */

    var LiveRange = function (_Range) {
    	inherits(LiveRange, _Range);

    	/**
      * Creates a live range.
      *
      * @see engine.model.Range
      */

    	function LiveRange(start, end) {
    		classCallCheck(this, LiveRange);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(LiveRange).call(this, start, end));

    		bindWithDocument.call(_this);
    		return _this;
    	}

    	/**
      * Unbinds all events previously bound by LiveRange. Use it whenever you don't need LiveRange instance
      * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was
      * referring to it).
      */


    	createClass(LiveRange, [{
    		key: 'detach',
    		value: function detach() {
    			this.stopListening();
    		}

    		/**
       * @see engine.model.Range.createFromElement
       * @static
       * @method engine.model.LiveRange.createFromElement
       * @param {engine.model.Element} element
       * @returns {engine.model.LiveRange}
       */

    		/**
       * @see engine.model.Range.createFromPositionAndShift
       * @static
       * @method engine.model.LiveRange.createFromPositionAndShift
       * @param {engine.model.Position} position
       * @param {Number} shift
       * @returns {engine.model.LiveRange}
       */

    		/**
       * @see engine.model.Range.createFromParentsAndOffsets
       * @static
       * @method engine.model.LiveRange.createFromParentsAndOffsets
       * @param {engine.model.Element} startElement
       * @param {Number} startOffset
       * @param {engine.model.Element} endElement
       * @param {Number} endOffset
       * @returns {engine.model.LiveRange}
       */

    		/**
       * @see engine.model.Range.createFromRange
       * @static
       * @method engine.model.LiveRange.createFromRange
       * @param {engine.model.Range} range
       * @returns {engine.model.LiveRange}
       */

    	}]);
    	return LiveRange;
    }(Range$1);

    function bindWithDocument() {
    	var _this2 = this;

    	/*jshint validthis: true */

    	this.listenTo(this.root.document, 'change', function (event, type, changes) {
    		fixBoundaries.call(_this2, type, changes.range, changes.sourcePosition);
    	}, this);
    }

    /**
     * LiveRange boundaries are instances of {@link engine.model.LivePosition}, so it is updated thanks to them. This method
     * additionally fixes the results of updating live positions taking into account that those live positions
     * are boundaries of a range. An example case for fixing live positions is end boundary is moved before start boundary.
     *
     * @ignore
     * @private
     * @method fixBoundaries
     * @param {String} type Type of changes applied to the Tree Model.
     * @param {engine.model.Range} range Range containing the result of applied change.
     * @param {engine.model.Position} [position] Additional position parameter provided by some change events.
     */
    function fixBoundaries(type, range, position) {
    	/* jshint validthis: true */
    	var updated = void 0;
    	var howMany = range.end.offset - range.start.offset;

    	switch (type) {
    		case 'insert':
    			updated = this.getTransformedByInsertion(range.start, howMany, false, true)[0];
    			break;

    		case 'move':
    		case 'remove':
    		case 'reinsert':
    			var sourcePosition = position;

    			// Range.getTransformedByMove is expecting `targetPosition` to be "before" move
    			// (before transformation). `range.start` is already after the move happened.
    			// We have to revert `range.start` to the state before the move.
    			var targetPosition = range.start.getTransformedByInsertion(sourcePosition, howMany);

    			var result = this.getTransformedByMove(sourcePosition, targetPosition, howMany, false, true);

    			// First item in the array is the "difference" part, so a part of the range
    			// that did not get moved. We use it as reference range and expand if possible.
    			updated = result[0];

    			// We will check if there is other range and if it is touching the reference range.
    			// If it does, we will expand the reference range (at the beginning or at the end).
    			// Keep in mind that without settings `spread` flag, `getTransformedByMove` may
    			// return maximum two ranges.
    			if (result.length > 1) {
    				var otherRange = result[1];

    				if (updated.start.isTouching(otherRange.end)) {
    					updated.start = otherRange.start;
    				} else if (updated.end.isTouching(otherRange.start)) {
    					updated.end = otherRange.end;
    				}
    			}

    			break;
    	}

    	if (updated) {
    		this.start = updated.start;
    		this.end = updated.end;
    	}
    }

    mix(LiveRange, EmitterMixin);

    /**
     * `Selection` is a group of {@link engine.model.Range ranges} which has a direction specified by
     * {@link engine.model.Selection#anchor anchor} and {@link engine.model.Selection#focus focus}.
     *
     * @memberOf engine.model
     */

    var Selection$1 = function () {
    	/**
      * Creates an empty selection.
      */

    	function Selection() {
    		classCallCheck(this, Selection);

    		/**
       * Specifies whether the last added range was added as a backward or forward range.
       *
       * @private
       * @member {Boolean} engine.model.Selection#_lastRangeBackward
       */
    		this._lastRangeBackward = false;

    		/**
       * Stores all ranges that are selected.
       *
       * @protected
       * @member {Array.<engine.model.Range>} engine.model.Selection#_ranges
       */
    		this._ranges = [];
    	}

    	/**
      * Selection anchor. Anchor may be described as a position where the selection starts. Together with
      * {@link engine.model.Selection#focus} they define the direction of selection, which is important
      * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
      *
      * Is set to `null` if there are no ranges in selection.
      *
      * @see engine.model.Selection#focus
      * @type {engine.model.Position|null}
      */


    	createClass(Selection, [{
    		key: 'addRange',


    		/**
       * Adds a range to the selection. Added range is copied. This means that passed range is not saved in `Selection`
       * instance and operating on it will not change `Selection` state.
       *
       * Accepts a flag describing in which way the selection is made - passed range might be selected from
       * {@link engine.model.Range#start start} to {@link engine.model.Range#end end} or from {@link engine.model.Range#end end}
       * to {@link engine.model.Range#start start}. The flag is used to set {@link engine.model.Selection#anchor} and
       * {@link engine.model.Selection#focus} properties.
       *
       * @fires engine.model.Selection#change:range
       * @param {engine.model.Range} range Range to add.
       * @param {Boolean} [isBackward] Flag describing if added range was selected forward - from start to end (`false`)
       * or backward - from end to start (`true`). Defaults to `false`.
       */
    		value: function addRange(range, isBackward) {
    			this._pushRange(range);
    			this._lastRangeBackward = !!isBackward;

    			this.fire('change:range');
    		}

    		/**
       * Returns an iterator that iterates over copies of selection ranges.
       *
       * @returns {Iterator.<engine.model.Range>}
       */

    	}, {
    		key: 'getRanges',
    		value: regeneratorRuntime.mark(function getRanges() {
    			var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, range;

    			return regeneratorRuntime.wrap(function getRanges$(_context) {
    				while (1) {
    					switch (_context.prev = _context.next) {
    						case 0:
    							_iteratorNormalCompletion = true;
    							_didIteratorError = false;
    							_iteratorError = undefined;
    							_context.prev = 3;
    							_iterator = this._ranges[Symbol.iterator]();

    						case 5:
    							if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
    								_context.next = 12;
    								break;
    							}

    							range = _step.value;
    							_context.next = 9;
    							return Range$1.createFromRange(range);

    						case 9:
    							_iteratorNormalCompletion = true;
    							_context.next = 5;
    							break;

    						case 12:
    							_context.next = 18;
    							break;

    						case 14:
    							_context.prev = 14;
    							_context.t0 = _context['catch'](3);
    							_didIteratorError = true;
    							_iteratorError = _context.t0;

    						case 18:
    							_context.prev = 18;
    							_context.prev = 19;

    							if (!_iteratorNormalCompletion && _iterator.return) {
    								_iterator.return();
    							}

    						case 21:
    							_context.prev = 21;

    							if (!_didIteratorError) {
    								_context.next = 24;
    								break;
    							}

    							throw _iteratorError;

    						case 24:
    							return _context.finish(21);

    						case 25:
    							return _context.finish(18);

    						case 26:
    						case 'end':
    							return _context.stop();
    					}
    				}
    			}, getRanges, this, [[3, 14, 18, 26], [19,, 21, 25]]);
    		})

    		/**
       * Returns a copy of the first range in the selection. First range is the one which {@link engine.model.Range#start start} position
       * {@link engine.model.Position#isBefore is before} start position of all other ranges (not to confuse with the first range
       * added to the selection).
       *
       * Returns `null` if there are no ranges in selection.
       *
       * @returns {engine.model.Range|null}
       */

    	}, {
    		key: 'getFirstRange',
    		value: function getFirstRange() {
    			var first = null;

    			for (var i = 0; i < this._ranges.length; i++) {
    				var range = this._ranges[i];

    				if (!first || range.start.isBefore(first.start)) {
    					first = range;
    				}
    			}

    			return first ? Range$1.createFromRange(first) : null;
    		}

    		/**
       * Returns the first position in the selection. First position is the position that {@link engine.model.Position#isBefore is before}
       * any other position in the selection ranges.
       *
       * Returns `null` if there are no ranges in selection.
       *
       * @returns {engine.model.Position|null}
       */

    	}, {
    		key: 'getFirstPosition',
    		value: function getFirstPosition() {
    			var first = this.getFirstRange();

    			return first ? Position.createFromPosition(first.start) : null;
    		}

    		/**
       * Removes all ranges that were added to the selection. Fires update event.
       *
       * @fires engine.model.Selection#change:range
       */

    	}, {
    		key: 'removeAllRanges',
    		value: function removeAllRanges() {
    			this._ranges = [];

    			this.fire('change:range');
    		}

    		/**
       * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
       * is treated like the last added range and is used to set {@link #anchor} and {@link #focus}. Accepts a flag
       * describing in which way the selection is made (see {@link #addRange}).
       *
       * @fires engine.model.Selection#change:range
       * @param {Iterable.<engine.model.Range>} newRanges Iterable set of ranges that should be set.
       * @param {Boolean} [isLastBackward] Flag describing if last added range was selected forward - from start to end (`false`)
       * or backward - from end to start (`true`). Defaults to `false`.
       */

    	}, {
    		key: 'setRanges',
    		value: function setRanges(newRanges, isLastBackward) {
    			this._ranges = [];

    			var _iteratorNormalCompletion2 = true;
    			var _didIteratorError2 = false;
    			var _iteratorError2 = undefined;

    			try {
    				for (var _iterator2 = newRanges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    					var range = _step2.value;

    					this._pushRange(range);
    				}
    			} catch (err) {
    				_didIteratorError2 = true;
    				_iteratorError2 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion2 && _iterator2.return) {
    						_iterator2.return();
    					}
    				} finally {
    					if (_didIteratorError2) {
    						throw _iteratorError2;
    					}
    				}
    			}

    			this._lastRangeBackward = !!isLastBackward;

    			this.fire('change:range');
    		}

    		/**
       * Sets collapsed selection in the specified location.
       *
       * The location can be specified in the same form as {@link engine.model.Position.createAt} parameters.
       *
       * @fires engine.model.Selection#change:range
       * @param {engine.model.Node|engine.model.Position} nodeOrPosition
       * @param {Number|'END'|'BEFORE'|'AFTER'} [offset=0] Offset or one of the flags. Used only when
       * first parameter is a node.
       */

    	}, {
    		key: 'collapse',
    		value: function collapse(nodeOrPosition, offset) {
    			var pos = Position.createAt(nodeOrPosition, offset);
    			var range = new Range$1(pos, pos);

    			this.setRanges([range]);
    		}

    		/**
       * Sets {@link engine.model.Selection#focus} in the specified location.
       *
       * The location can be specified in the same form as {@link engine.model.Position.createAt} parameters.
       *
       * @fires engine.model.Selection#change:range
       * @param {engine.model.Node|engine.model.Position} nodeOrPosition
       * @param {Number|'END'|'BEFORE'|'AFTER'} [offset=0] Offset or one of the flags. Used only when
       * first parameter is a node.
       */

    	}, {
    		key: 'setFocus',
    		value: function setFocus(nodeOrPosition, offset) {
    			if (this.anchor === null) {
    				/**
         * Cannot set selection focus if there are no ranges in selection.
         *
         * @error selection-setFocus-no-ranges
         */
    				throw new CKEditorError('selection-setFocus-no-ranges: Cannot set selection focus if there are no ranges in selection.');
    			}

    			var newFocus = Position.createAt(nodeOrPosition, offset);

    			if (newFocus.compareWith(this.focus) == 'SAME') {
    				return;
    			}

    			var anchor = this.anchor;

    			if (this._ranges.length) {
    				this._popRange();
    			}

    			if (newFocus.compareWith(anchor) == 'BEFORE') {
    				this.addRange(new Range$1(newFocus, anchor), true);
    			} else {
    				this.addRange(new Range$1(anchor, newFocus));
    			}
    		}

    		/**
       * Creates and returns an instance of {@link engine.model.Selection} that is a clone of given selection,
       * meaning that it has same ranges and same direction as it.
       *
       * @params {engine.model.Selection} otherSelection Selection to be cloned.
       * @returns {engine.model.Selection} `Selection` instance that is a clone of given selection.
       */

    	}, {
    		key: '_checkRange',


    		/**
       * Checks if given range intersects with ranges that are already in the selection. Throws an error if it does.
       * This method is extracted from {@link engine.model.Selection#_pushRange } so it is easier to override it.
       *
       * @param {engine.model.Range} range Range to check.
       * @protected
       */
    		value: function _checkRange(range) {
    			for (var i = 0; i < this._ranges.length; i++) {
    				if (range.isIntersecting(this._ranges[i])) {
    					/**
          * Trying to add a range that intersects with another range from selection.
          *
          * @error selection-range-intersects
          * @param {engine.model.Range} addedRange Range that was added to the selection.
          * @param {engine.model.Range} intersectingRange Range from selection that intersects with `addedRange`.
          */
    					throw new CKEditorError('selection-range-intersects: Trying to add a range that intersects with another range from selection.', { addedRange: range, intersectingRange: this._ranges[i] });
    				}
    			}
    		}

    		/**
       * Removes most recently added range from the selection.
       *
       * @protected
       */

    	}, {
    		key: '_popRange',
    		value: function _popRange() {
    			this._ranges.pop();
    		}

    		/**
       * Adds given range to internal {@link engine.model.Selection#_ranges ranges array}. Throws an error
       * if given range is intersecting with any range that is already stored in this selection.
       *
       * @protected
       * @param {engine.model.Range} range Range to add.
       */

    	}, {
    		key: '_pushRange',
    		value: function _pushRange(range) {
    			this._checkRange(range);
    			this._ranges.push(Range$1.createFromRange(range));
    		}
    	}, {
    		key: 'anchor',
    		get: function get() {
    			if (this._ranges.length > 0) {
    				var range = this._ranges[this._ranges.length - 1];

    				return this._lastRangeBackward ? range.end : range.start;
    			}

    			return null;
    		}

    		/**
       * Selection focus. Focus is a position where the selection ends.
       *
       * Is set to `null` if there are no ranges in selection.
       *
       * @see engine.model.Selection#anchor
       * @type {engine.model.Position|null}
       */

    	}, {
    		key: 'focus',
    		get: function get() {
    			if (this._ranges.length > 0) {
    				var range = this._ranges[this._ranges.length - 1];

    				return this._lastRangeBackward ? range.start : range.end;
    			}

    			return null;
    		}

    		/**
       * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
       * collapsed.
       *
       * @type {Boolean}
       */

    	}, {
    		key: 'isCollapsed',
    		get: function get() {
    			var length = this._ranges.length;

    			if (length === 1) {
    				return this._ranges[0].isCollapsed;
    			} else {
    				return false;
    			}
    		}

    		/**
       * Returns number of ranges in selection.
       *
       * @type {Number}
          */

    	}, {
    		key: 'rangeCount',
    		get: function get() {
    			return this._ranges.length;
    		}

    		/**
       * Specifies whether the {@link engine.model.Selection#focus} precedes {@link engine.model.Selection#anchor}.
       *
       * @type {Boolean}
       */

    	}, {
    		key: 'isBackward',
    		get: function get() {
    			return !this.isCollapsed && this._lastRangeBackward;
    		}
    	}], [{
    		key: 'createFromSelection',
    		value: function createFromSelection(otherSelection) {
    			var selection = new this();
    			selection.setRanges(otherSelection.getRanges(), otherSelection.isBackward);

    			return selection;
    		}
    	}]);
    	return Selection;
    }();

    mix(Selection$1, EmitterMixin);

    var storePrefix = 'selection:';

    /**
     * `LiveSelection` is a special type of {@link engine.model.Selection selection} that listens to changes on a
     * {@link engine.model.Document document} and has it ranges updated accordingly. Internal implementation of this
     * mechanism bases on {@link engine.model.LiveRange live ranges}.
     *
     * Differences between {@link engine.model.Selection} and `LiveSelection` are three:
     * * there is always a range in `LiveSelection`, even if no ranges were added - in this case, there is a
     * "default range" in selection which is a collapsed range set at the beginning of the {@link engine.model.Document document},
     * * ranges added to this selection updates automatically when the document changes,
     * * live selection may have attributes.
     *
     * @memberOf engine.model
     */

    var LiveSelection = function (_Selection) {
    	inherits(LiveSelection, _Selection);

    	/**
      * Creates an empty document selection for given {@link engine.model.Document}.
      *
      * @param {engine.model.Document} document Document which owns this selection.
      */

    	function LiveSelection(document) {
    		classCallCheck(this, LiveSelection);


    		/**
       * Document which owns this selection.
       *
       * @private
       * @member {engine.model.Document} engine.model.Selection#_document
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(LiveSelection).call(this));

    		_this._document = document;

    		/**
       * List of attributes set on current selection.
       *
       * @protected
       * @member {Map} engine.model.LiveSelection#_attrs
       */
    		_this._attrs = new Map();
    		return _this;
    	}

    	/**
      * @inheritDoc
      */


    	createClass(LiveSelection, [{
    		key: 'destroy',


    		/**
       * Unbinds all events previously bound by document selection.
       */
    		value: function destroy() {
    			for (var i = 0; i < this._ranges.length; i++) {
    				this._ranges[i].detach();
    			}
    		}

    		/**
       * @inheritDoc
       */

    	}, {
    		key: 'getRanges',
    		value: regeneratorRuntime.mark(function getRanges() {
    			return regeneratorRuntime.wrap(function getRanges$(_context) {
    				while (1) {
    					switch (_context.prev = _context.next) {
    						case 0:
    							if (!this._ranges.length) {
    								_context.next = 4;
    								break;
    							}

    							return _context.delegateYield(get(Object.getPrototypeOf(LiveSelection.prototype), 'getRanges', this).call(this), 't0', 2);

    						case 2:
    							_context.next = 6;
    							break;

    						case 4:
    							_context.next = 6;
    							return this._getDefaultRange();

    						case 6:
    						case 'end':
    							return _context.stop();
    					}
    				}
    			}, getRanges, this);
    		})

    		/**
       * @inheritDoc
       */

    	}, {
    		key: 'getFirstRange',
    		value: function getFirstRange() {
    			return get(Object.getPrototypeOf(LiveSelection.prototype), 'getFirstRange', this).call(this) || this._getDefaultRange();
    		}

    		/**
       * @inheritDoc
       */

    	}, {
    		key: 'removeAllRanges',
    		value: function removeAllRanges() {
    			this.destroy();
    			get(Object.getPrototypeOf(LiveSelection.prototype), 'removeAllRanges', this).call(this);
    		}

    		/**
       * @inheritDoc
       */

    	}, {
    		key: 'setRanges',
    		value: function setRanges(newRanges, isLastBackward) {
    			this.destroy();
    			get(Object.getPrototypeOf(LiveSelection.prototype), 'setRanges', this).call(this, newRanges, isLastBackward);
    		}

    		/**
       * Removes all attributes from the selection.
       *
       * @fires engine.model.LiveSelection#change:attribute
       */

    	}, {
    		key: 'clearAttributes',
    		value: function clearAttributes() {
    			this._attrs.clear();
    			this._setStoredAttributesTo(new Map());

    			this.fire('change:attribute');
    		}

    		/**
       * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.
       *
       * @param {String} key Key of attribute to look for.
       * @returns {*} Attribute value or `undefined`.
       */

    	}, {
    		key: 'getAttribute',
    		value: function getAttribute(key) {
    			return this._attrs.get(key);
    		}

    		/**
       * Returns iterator that iterates over this selection attributes.
       *
       * @returns {Iterable.<*>}
       */

    	}, {
    		key: 'getAttributes',
    		value: function getAttributes() {
    			return this._attrs[Symbol.iterator]();
    		}

    		/**
       * Checks if the selection has an attribute for given key.
       *
       * @param {String} key Key of attribute to check.
       * @returns {Boolean} `true` if attribute with given key is set on selection, `false` otherwise.
       */

    	}, {
    		key: 'hasAttribute',
    		value: function hasAttribute(key) {
    			return this._attrs.has(key);
    		}

    		/**
       * Removes an attribute with given key from the selection.
       *
       * @fires engine.model.LiveSelection#change:attribute
       * @param {String} key Key of attribute to remove.
       */

    	}, {
    		key: 'removeAttribute',
    		value: function removeAttribute(key) {
    			this._attrs.delete(key);
    			this._removeStoredAttribute(key);

    			this.fire('change:attribute');
    		}

    		/**
       * Sets attribute on the selection. If attribute with the same key already is set, it overwrites its values.
       *
       * @fires engine.model.LiveSelection#change:attribute
       * @param {String} key Key of attribute to set.
       * @param {*} value Attribute value.
       */

    	}, {
    		key: 'setAttribute',
    		value: function setAttribute(key, value) {
    			this._attrs.set(key, value);
    			this._storeAttribute(key, value);

    			this.fire('change:attribute');
    		}

    		/**
       * Removes all attributes from the selection and sets given attributes.
       *
       * @fires engine.model.LiveSelection#change:attribute
       * @param {Iterable|Object} attrs Iterable object containing attributes to be set.
       */

    	}, {
    		key: 'setAttributesTo',
    		value: function setAttributesTo(attrs) {
    			this._attrs = toMap(attrs);
    			this._setStoredAttributesTo(this._attrs);

    			this.fire('change:attribute');
    		}

    		/**
       * Creates and returns an instance of {@link engine.model.LiveSelection} that is a clone of given selection,
       * meaning that it has same ranges and same direction as it.
       *
       * @params {engine.model.Selection} otherSelection Selection to be cloned.
       * @returns {engine.model.LiveSelection} `LiveSelection` instance that is a clone of given selection.
       */

    		/**
       * @inheritDoc
       */

    	}, {
    		key: '_popRange',
    		value: function _popRange() {
    			this._ranges.pop().detach();
    		}

    		/**
       * @inheritDoc
       */

    	}, {
    		key: '_pushRange',
    		value: function _pushRange(range) {
    			this._checkRange(range);
    			this._ranges.push(LiveRange.createFromRange(range));
    		}

    		/**
       * Returns a default range for this selection. The default range is a collapsed range that starts and ends
       * at the beginning of this selection's document {@link engine.model.Document#_getDefaultRoot default root}.
       * This "artificial" range is important for algorithms that base on selection, so they won't break or need
       * special logic if there are no real ranges in the selection.
       *
       * @private
       * @returns {engine.model.Range}
       */

    	}, {
    		key: '_getDefaultRange',
    		value: function _getDefaultRange() {
    			var defaultRoot = this._document._getDefaultRoot();

    			// Find the first position where the selection can be put.
    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = Range$1.createFromElement(defaultRoot).getPositions()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var _position = _step.value;

    					if (this._document.schema.check({ name: '$text', inside: _position })) {
    						return new Range$1(_position, _position);
    					}
    				}
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}

    			var position = new Position(defaultRoot, [0]);

    			return new Range$1(position, position);
    		}

    		/**
       * Iterates through all attributes stored in current selection's parent.
       *
       * @returns {Iterable.<*>}
       */

    	}, {
    		key: '_getStoredAttributes',
    		value: regeneratorRuntime.mark(function _getStoredAttributes() {
    			var selectionParent, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, attr, realKey;

    			return regeneratorRuntime.wrap(function _getStoredAttributes$(_context2) {
    				while (1) {
    					switch (_context2.prev = _context2.next) {
    						case 0:
    							selectionParent = this.getFirstPosition().parent;

    							if (!(this.isCollapsed && selectionParent.getChildCount() === 0)) {
    								_context2.next = 30;
    								break;
    							}

    							_iteratorNormalCompletion2 = true;
    							_didIteratorError2 = false;
    							_iteratorError2 = undefined;
    							_context2.prev = 5;
    							_iterator2 = selectionParent.getAttributes()[Symbol.iterator]();

    						case 7:
    							if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
    								_context2.next = 16;
    								break;
    							}

    							attr = _step2.value;

    							if (!(attr[0].indexOf(storePrefix) === 0)) {
    								_context2.next = 13;
    								break;
    							}

    							realKey = attr[0].substr(storePrefix.length);
    							_context2.next = 13;
    							return [realKey, attr[1]];

    						case 13:
    							_iteratorNormalCompletion2 = true;
    							_context2.next = 7;
    							break;

    						case 16:
    							_context2.next = 22;
    							break;

    						case 18:
    							_context2.prev = 18;
    							_context2.t0 = _context2['catch'](5);
    							_didIteratorError2 = true;
    							_iteratorError2 = _context2.t0;

    						case 22:
    							_context2.prev = 22;
    							_context2.prev = 23;

    							if (!_iteratorNormalCompletion2 && _iterator2.return) {
    								_iterator2.return();
    							}

    						case 25:
    							_context2.prev = 25;

    							if (!_didIteratorError2) {
    								_context2.next = 28;
    								break;
    							}

    							throw _iteratorError2;

    						case 28:
    							return _context2.finish(25);

    						case 29:
    							return _context2.finish(22);

    						case 30:
    						case 'end':
    							return _context2.stop();
    					}
    				}
    			}, _getStoredAttributes, this, [[5, 18, 22, 30], [23,, 25, 29]]);
    		})

    		/**
       * Removes attribute with given key from attributes stored in current selection's parent node.
       *
       * @private
       * @param {String} key Key of attribute to remove.
       */

    	}, {
    		key: '_removeStoredAttribute',
    		value: function _removeStoredAttribute(key) {
    			var _this2 = this;

    			var selectionParent = this.getFirstPosition().parent;

    			if (this.isCollapsed && selectionParent.getChildCount() === 0) {
    				(function () {
    					var storeKey = LiveSelection._getStoreAttributeKey(key);

    					_this2._document.enqueueChanges(function () {
    						_this2._document.batch().removeAttr(storeKey, selectionParent);
    					});
    				})();
    			}
    		}

    		/**
       * Stores given attribute key and value in current selection's parent node if the selection is collapsed and
       * the parent node is empty.
       *
       * @private
       * @param {String} key Key of attribute to set.
       * @param {*} value Attribute value.
       */

    	}, {
    		key: '_storeAttribute',
    		value: function _storeAttribute(key, value) {
    			var _this3 = this;

    			var selectionParent = this.getFirstPosition().parent;

    			if (this.isCollapsed && selectionParent.getChildCount() === 0) {
    				(function () {
    					var storeKey = LiveSelection._getStoreAttributeKey(key);

    					_this3._document.enqueueChanges(function () {
    						_this3._document.batch().setAttr(storeKey, value, selectionParent);
    					});
    				})();
    			}
    		}

    		/**
       * Sets selection attributes stored in current selection's parent node to given set of attributes.
       *
       * @param {Iterable|Object} attrs Iterable object containing attributes to be set.
       * @private
       */

    	}, {
    		key: '_setStoredAttributesTo',
    		value: function _setStoredAttributesTo(attrs) {
    			var _this4 = this;

    			var selectionParent = this.getFirstPosition().parent;

    			if (this.isCollapsed && selectionParent.getChildCount() === 0) {
    				this._document.enqueueChanges(function () {
    					var batch = _this4._document.batch();

    					var _iteratorNormalCompletion3 = true;
    					var _didIteratorError3 = false;
    					var _iteratorError3 = undefined;

    					try {
    						for (var _iterator3 = _this4._getStoredAttributes()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
    							var attr = _step3.value;

    							var storeKey = LiveSelection._getStoreAttributeKey(attr[0]);

    							batch.removeAttr(storeKey, selectionParent);
    						}
    					} catch (err) {
    						_didIteratorError3 = true;
    						_iteratorError3 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion3 && _iterator3.return) {
    								_iterator3.return();
    							}
    						} finally {
    							if (_didIteratorError3) {
    								throw _iteratorError3;
    							}
    						}
    					}

    					var _iteratorNormalCompletion4 = true;
    					var _didIteratorError4 = false;
    					var _iteratorError4 = undefined;

    					try {
    						for (var _iterator4 = attrs[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
    							var _attr = _step4.value;

    							var _storeKey = LiveSelection._getStoreAttributeKey(_attr[0]);

    							batch.setAttr(_storeKey, _attr[1], selectionParent);
    						}
    					} catch (err) {
    						_didIteratorError4 = true;
    						_iteratorError4 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion4 && _iterator4.return) {
    								_iterator4.return();
    							}
    						} finally {
    							if (_didIteratorError4) {
    								throw _iteratorError4;
    							}
    						}
    					}
    				});
    			}
    		}

    		/**
       * Updates this selection attributes according to it's ranges and the document.
       *
       * @fires engine.model.LiveSelection#change:attribute
       * @protected
       */

    	}, {
    		key: '_updateAttributes',
    		value: function _updateAttributes() {
    			var position = this.getFirstPosition();
    			var positionParent = position.parent;

    			var attrs = null;

    			if (!this.isCollapsed) {
    				// 1. If selection is a range...
    				var range = this.getFirstRange();

    				// ...look for a first character node in that range and take attributes from it.
    				var _iteratorNormalCompletion5 = true;
    				var _didIteratorError5 = false;
    				var _iteratorError5 = undefined;

    				try {
    					for (var _iterator5 = range[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
    						var item = _step5.value;

    						// This is not an optimal solution because of https://github.com/ckeditor/ckeditor5-engine/issues/454.
    						// It can be done better by using `break;` instead of checking `attrs === null`.
    						if (item.type == 'TEXT' && attrs === null) {
    							attrs = item.item.getAttributes();
    						}
    					}
    				} catch (err) {
    					_didIteratorError5 = true;
    					_iteratorError5 = err;
    				} finally {
    					try {
    						if (!_iteratorNormalCompletion5 && _iterator5.return) {
    							_iterator5.return();
    						}
    					} finally {
    						if (_didIteratorError5) {
    							throw _iteratorError5;
    						}
    					}
    				}
    			} else {
    				// 2. If the selection is a caret or the range does not contain a character node...

    				var nodeBefore = positionParent.getChild(position.offset - 1);
    				var nodeAfter = positionParent.getChild(position.offset);

    				// ...look at the node before caret and take attributes from it if it is a character node.
    				attrs = getAttrsIfCharacter(nodeBefore);

    				// 3. If not, look at the node after caret...
    				if (!attrs) {
    					attrs = getAttrsIfCharacter(nodeAfter);
    				}

    				// 4. If not, try to find the first character on the left, that is in the same node.
    				if (!attrs) {
    					var node = nodeBefore;

    					while (node && !attrs) {
    						node = node.previousSibling;
    						attrs = getAttrsIfCharacter(node);
    					}
    				}

    				// 5. If not found, try to find the first character on the right, that is in the same node.
    				if (!attrs) {
    					var _node = nodeAfter;

    					while (_node && !attrs) {
    						_node = _node.nextSibling;
    						attrs = getAttrsIfCharacter(_node);
    					}
    				}

    				// 6. If not found, selection should retrieve attributes from parent.
    				if (!attrs) {
    					attrs = this._getStoredAttributes();
    				}
    			}

    			if (attrs) {
    				this._attrs = new Map(attrs);
    			} else {
    				this.clearAttributes();
    			}

    			function getAttrsIfCharacter(node) {
    				if (node instanceof CharacterProxy) {
    					return node.getAttributes();
    				}

    				return null;
    			}

    			this.fire('change:attribute');
    		}

    		/**
       * Generates and returns an attribute key for selection attributes store, basing on original attribute key.
       *
       * @param {String} key Attribute key to convert.
       * @returns {String} Converted attribute key, applicable for selection store.
       */

    	}, {
    		key: 'isCollapsed',
    		get: function get$$() {
    			var length = this._ranges.length;

    			return length === 0 ? true : get(Object.getPrototypeOf(LiveSelection.prototype), 'isCollapsed', this);
    		}

    		/**
       * @inheritDoc
       */

    	}, {
    		key: 'anchor',
    		get: function get$$() {
    			return get(Object.getPrototypeOf(LiveSelection.prototype), 'anchor', this) || this._getDefaultRange().start;
    		}

    		/**
       * @inheritDoc
       */

    	}, {
    		key: 'focus',
    		get: function get$$() {
    			return get(Object.getPrototypeOf(LiveSelection.prototype), 'focus', this) || this._getDefaultRange().start;
    		}

    		/**
       * @inheritDoc
       */

    	}, {
    		key: 'rangeCount',
    		get: function get$$() {
    			return this._ranges.length ? this._ranges.length : 1;
    		}
    	}], [{
    		key: '_getStoreAttributeKey',
    		value: function _getStoreAttributeKey(key) {
    			return storePrefix + key;
    		}
    	}]);
    	return LiveSelection;
    }(Selection$1);

    /**
     * SchemaItem is a singular registry item in {@link engine.model.Schema} that groups and holds allow/disallow rules for
     * one entity. This class is used internally in {@link engine.model.Schema} and should not be used outside it.
     *
     * @see engine.model.Schema
     * @protected
     * @memberOf engine.model
     */
    var SchemaItem = function () {
    	/**
      * Creates SchemaItem instance.
      *
      * @param {engine.model.Schema} schema Schema instance that owns this item.
      */

    	function SchemaItem(schema) {
    		classCallCheck(this, SchemaItem);

    		/**
       * Schema instance that owns this item.
       *
       * @private
       * @member {engine.model.Schema} engine.model.SchemaItem#_schema
       */
    		this._schema = schema;

    		/**
       * Paths in which the entity, represented by this item, is allowed.
       *
       * @private
       * @member {Array} engine.model.SchemaItem#_allowed
       */
    		this._allowed = [];

    		/**
       * Paths in which the entity, represented by this item, is disallowed.
       *
       * @private
       * @member {Array} engine.model.SchemaItem#_disallowed
       */
    		this._disallowed = [];

    		/**
       * Attributes that are required by the entity represented by this item.
       *
       * @protected
       * @member {Array} engine.model.SchemaItem#_requiredAttributes
       */
    		this._requiredAttributes = [];
    	}

    	/**
      * Allows entity, represented by this item, to be in given path.
      *
      * @param {Array.<String>} path Path in which entity is allowed.
      * @param {Array.<String>|String} [attributes] If set, this path will be used only for entities that have attribute(s) with this key.
      */


    	createClass(SchemaItem, [{
    		key: 'allow',
    		value: function allow(path, attributes) {
    			this._addPath('_allowed', path, attributes);
    		}

    		/**
       * Disallows entity, represented by this item, to be in given path.
       *
       * @param {Array.<String>} path Path in which entity is disallowed.
       * @param {Array.<String>|String} [attributes] If set, this path will be used only for entities that have an attribute(s) with this key.
       */

    	}, {
    		key: 'disallow',
    		value: function disallow(path, attributes) {
    			this._addPath('_disallowed', path, attributes);
    		}

    		/**
       * Specifies that the entity, to be valid, requires given attributes set. It is possible to register multiple
       * different attributes set. If there are more than one attributes set required, the entity will be valid if
       * at least one of them is fulfilled.
       *
       * @param {Array.<String>} attributes Attributes that has to be set on the entity to make it valid.
       */

    	}, {
    		key: 'requireAttributes',
    		value: function requireAttributes(attributes) {
    			this._requiredAttributes.push(attributes);
    		}

    		/**
       * Adds path to the SchemaItem instance.
       *
       * @private
       * @param {String} member Name of the array member into which the path will be added. Possible values are `_allowed` or `_disallowed`.
       * @param {Array.<String>} path Path to add.
       * @param {Array.<String>|String} [attributes] If set, this path will be used only for entities that have attribute(s) with this key.
       */

    	}, {
    		key: '_addPath',
    		value: function _addPath(member, path, attributes) {
    			path = path.slice();

    			if (!isArray(attributes)) {
    				attributes = [attributes];
    			}

    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = attributes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var attribute = _step.value;

    					this[member].push({ path: path, attribute: attribute });
    				}
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}
    		}

    		/**
       * Returns all paths of given type that were previously registered in the item.
       *
       * @private
       * @param {String} type Paths' type. Possible values are `ALLOW` or `DISALLOW`.
       * @param {String} [attribute] If set, only paths registered for given attribute will be returned.
       * @returns {Array} Paths registered in the item.
       */

    	}, {
    		key: '_getPaths',
    		value: function _getPaths(type, attribute) {
    			var source = type === 'ALLOW' ? this._allowed : this._disallowed;
    			var paths = [];

    			var _iteratorNormalCompletion2 = true;
    			var _didIteratorError2 = false;
    			var _iteratorError2 = undefined;

    			try {
    				for (var _iterator2 = source[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    					var item = _step2.value;

    					if (item.attribute === attribute) {
    						paths.push(item.path);
    					}
    				}
    			} catch (err) {
    				_didIteratorError2 = true;
    				_iteratorError2 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion2 && _iterator2.return) {
    						_iterator2.return();
    					}
    				} finally {
    					if (_didIteratorError2) {
    						throw _iteratorError2;
    					}
    				}
    			}

    			return paths;
    		}

    		/**
       * Checks whether given set of attributes fulfills required attributes of this item.
       *
       * @protected
       * @see engine.model.SchemaItem#requireAttributes
       * @param {Array.<String>} attributesToCheck Attributes to check.
       * @returns {Boolean} `true` if given set or attributes fulfills required attributes, `false` otherwise.
       */

    	}, {
    		key: '_checkRequiredAttributes',
    		value: function _checkRequiredAttributes(attributesToCheck) {
    			var found = true;

    			var _iteratorNormalCompletion3 = true;
    			var _didIteratorError3 = false;
    			var _iteratorError3 = undefined;

    			try {
    				for (var _iterator3 = this._requiredAttributes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
    					var attributeSet = _step3.value;

    					found = true;

    					var _iteratorNormalCompletion4 = true;
    					var _didIteratorError4 = false;
    					var _iteratorError4 = undefined;

    					try {
    						for (var _iterator4 = attributeSet[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
    							var attribute = _step4.value;

    							if (attributesToCheck.indexOf(attribute) == -1) {
    								found = false;
    								break;
    							}
    						}
    					} catch (err) {
    						_didIteratorError4 = true;
    						_iteratorError4 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion4 && _iterator4.return) {
    								_iterator4.return();
    							}
    						} finally {
    							if (_didIteratorError4) {
    								throw _iteratorError4;
    							}
    						}
    					}

    					if (found) {
    						break;
    					}
    				}
    			} catch (err) {
    				_didIteratorError3 = true;
    				_iteratorError3 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion3 && _iterator3.return) {
    						_iterator3.return();
    					}
    				} finally {
    					if (_didIteratorError3) {
    						throw _iteratorError3;
    					}
    				}
    			}

    			return found;
    		}

    		/**
       * Checks whether this item has any registered path of given type that matches provided path.
       *
       * @protected
       * @param {String} type Paths' type. Possible values are `ALLOW` or `DISALLOW`.
       * @param {Array.<String>} checkPath Path to check.
       * @param {String} [attribute] If set, only paths registered for given attribute will be checked.
       * @returns {Boolean} `true` if item has any registered matching path, `false` otherwise.
       */

    	}, {
    		key: '_hasMatchingPath',
    		value: function _hasMatchingPath(type, checkPath, attribute) {
    			var itemPaths = this._getPaths(type, attribute);

    			// We check every path registered (possibly with given attribute) in the item.
    			var _iteratorNormalCompletion5 = true;
    			var _didIteratorError5 = false;
    			var _iteratorError5 = undefined;

    			try {
    				for (var _iterator5 = itemPaths[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
    					var itemPath = _step5.value;

    					// Pointer to last found item from `itemPath`.
    					var i = 0;

    					// Now we have to check every item name from the path to check.
    					var _iteratorNormalCompletion6 = true;
    					var _didIteratorError6 = false;
    					var _iteratorError6 = undefined;

    					try {
    						for (var _iterator6 = checkPath[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
    							var checkName = _step6.value;

    							// Every item name is expanded to all names of items that item is extending.
    							// So, if on item path, there is an item that is extended by item from checked path, it will
    							// also be treated as matching.
    							var chain = this._schema._extensionChains.get(checkName);

    							// Since our paths have to match in given order, we always check against first item from item path.
    							// So, if item path is: B D E
    							// And checked path is: A B C D E
    							// It will be matching (A won't match, B will match, C won't match, D and E will match)
    							if (chain.indexOf(itemPath[i]) > -1) {
    								// Move pointer as we found element under index `i`.
    								i++;
    							}
    						}

    						// If `itemPath` has no items it means that we removed all of them, so we matched all of them.
    						// This means that we found a matching path.
    					} catch (err) {
    						_didIteratorError6 = true;
    						_iteratorError6 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion6 && _iterator6.return) {
    								_iterator6.return();
    							}
    						} finally {
    							if (_didIteratorError6) {
    								throw _iteratorError6;
    							}
    						}
    					}

    					if (i === itemPath.length) {
    						return true;
    					}
    				}
    			} catch (err) {
    				_didIteratorError5 = true;
    				_iteratorError5 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion5 && _iterator5.return) {
    						_iterator5.return();
    					}
    				} finally {
    					if (_didIteratorError5) {
    						throw _iteratorError5;
    					}
    				}
    			}

    			return false;
    		}

    		/**
       * Custom toJSON method to solve child-parent circular dependencies.
       *
       * @returns {Object} Clone of this object with the parent property replaced with its name.
       */

    	}, {
    		key: 'toJSON',
    		value: function toJSON() {
    			var json = clone(this);

    			// Due to circular references we need to remove parent reference.
    			json._schema = '[model.Schema]';

    			return json;
    		}
    	}]);
    	return SchemaItem;
    }();

    /**
     * Schema is a definition of the structure of the document. It allows to define which tree model items (element, text, etc.)
     * can be nested within which ones and which attributes can be applied to them. It's created during the run-time of the application,
     * typically by features. Also, the features can query the schema to learn what structure is allowed and act accordingly.
     *
     * For instance, if a feature wants to define that an attribute bold is allowed on the text it needs to register this rule like this:
     *
     *		editor.document.schema.allow( '$text', 'bold' );
     *
     * Note: items prefixed with `$` are special group of items. By default, `Schema` defines three special items:
     *
     * * `$inline` represents all inline elements,
     * * `$text` is a sub-group of `$inline` and represents text nodes,
     * * `$block` represents block elements,
     * * `$root` represents default editing roots (those that allow only `$block`s inside them).
     *
     * When registering an item it's possible to tell that this item should inherit from some other existing item.
     * E.g. `p` can inherit from `$block`, so whenever given attribute is allowed on the `$block` it will automatically be
     * also allowed on the `p` element. By default, `$text` item already inherits from `$inline`.
     *
     * @memberOf engine.model
     */

    var Schema = function () {
    	/**
      * Creates Schema instance.
      */

    	function Schema() {
    		classCallCheck(this, Schema);

    		/**
       * Schema items registered in the schema.
       *
       * @private
       * @member {Map} engine.model.Schema#_items
       */
    		this._items = new Map();

    		/**
       * Description of what entities are a base for given entity.
       *
       * @private
       * @member {Map} engine.model.Schema#_extensionChains
       */
    		this._extensionChains = new Map();

    		// Register some default abstract entities.
    		this.registerItem('$root');
    		this.registerItem('$block');
    		this.registerItem('$inline');
    		this.registerItem('$text', '$inline');

    		this.allow({ name: '$block', inside: '$root' });
    		this.allow({ name: '$inline', inside: '$block' });
    	}

    	/**
      * Allows given query in the schema.
      *
      *		// Allow text with bold attribute in all P elements.
      *		schema.registerItem( 'p', '$block' );
      *		schema.allow( { name: '$text', attributes: 'bold', inside: 'p' } );
      *
      *		// Allow header in Ps that are in DIVs
      *		schema.registerItem( 'header', '$block' );
      *		schema.registerItem( 'div', '$block' );
      *		schema.allow( { name: 'header', inside: 'div p' } ); // inside: [ 'div', 'p' ] would also work.
      *
      * @param {engine.model.SchemaQuery} query Allowed query.
      */


    	createClass(Schema, [{
    		key: 'allow',
    		value: function allow(query) {
    			this._getItem(query.name).allow(Schema._normalizeQueryPath(query.inside), query.attributes);
    		}

    		/**
       * Disallows given query in the schema.
       *
       * @see {@link engine.model.Schema#allow}
       * @param {engine.model.SchemaQuery} query Disallowed query.
       */

    	}, {
    		key: 'disallow',
    		value: function disallow(query) {
    			this._getItem(query.name).disallow(Schema._normalizeQueryPath(query.inside), query.attributes);
    		}

    		/**
       * Makes a requirement in schema that entity represented by given item has to have given set of attributes. Some
       * elements in the model might require some attributes to be set. If multiple sets of attributes are required it
       * is enough that the entity fulfills only one set.
       *
       *		// "a" element must either have "href" attribute or "name" attribute
       *		schema.requireAttributes( 'a', [ 'href' ] );
       *		schema.requireAttributes( 'a', [ 'name' ] );
       *		// "img" element must have both "src" and "alt" attributes
       *		schema.requireAttributes( 'img', [ 'src', 'alt' ] );
       *
       * @param {String} name Entity name.
       * @param {Array.<String>} attributes Attributes that has to be set on the entity to make it valid.
       */

    	}, {
    		key: 'requireAttributes',
    		value: function requireAttributes(name, attributes) {
    			this._getItem(name).requireAttributes(attributes);
    		}

    		/**
       * Checks whether given query is allowed in schema.
       *
       *		// Check whether bold text is allowed in header element.
       *		let query = {
       *			name: '$text',
       *			attributes: 'bold',
       *			inside: 'header'
       *		};
       *		if ( schema.check( query ) ) { ... }
       *
       *		// Check whether bold and italic text can be placed at caret position.
       *		let caretPos = editor.document.selection.getFirstPosition();
       *		let query = {
       *			name: '$text',
       *			attributes: [ 'bold', 'italic' ],
       *			inside: caretPos
       *		};
       *		if ( schema.check( query ) ) { ... }
       *
       *		// Check whether image with alt, src and title is allowed in given elements path.
       *		let quoteElement = new Element( 'quote' );
       *		let query = {
       *			name: 'img',
       *			attributes: [ 'alt', 'src', 'title' ],
       *			// It is possible to mix strings with elements.
       *			// Query will check whether "img" can be inside "quoteElement" that is inside a block element.
       *			inside: [ '$block', quoteElement ]
       *		};
       *		if ( schema.check( query ) ) { ... }
       *
       * @param {engine.model.SchemaQuery} query Query to check.
       * @returns {Boolean} `true` if given query is allowed in schema, `false` otherwise.
       */

    	}, {
    		key: 'check',
    		value: function check(query) {
    			var _this = this;

    			if (!this.hasItem(query.name)) {
    				return false;
    			}

    			// If attributes property is a string or undefined, wrap it in an array for easier processing.
    			if (!isArray(query.attributes)) {
    				query.attributes = [query.attributes];
    			} else if (query.attributes.length === 0) {
    				// To simplify algorithms, when a SchemaItem path is added "without" attribute, it is added with
    				// attribute equal to undefined. This means that algorithms can work the same way for specified attributes
    				// and no-atrtibutes, but we have to fill empty array with "fake" undefined value for algorithms reasons.
    				query.attributes.push(undefined);
    			}

    			// Normalize the path to an array of strings.
    			var path = Schema._normalizeQueryPath(query.inside);

    			// Get extension chain of given item and retrieve all schema items that are extended by given item.
    			var schemaItems = this._extensionChains.get(query.name).map(function (name) {
    				return _this._getItem(name);
    			});

    			// First check if the query meets at required attributes for this item.
    			if (!this._getItem(query.name)._checkRequiredAttributes(query.attributes)) {
    				return false;
    			}

    			// If there is matching disallow path, this query is not valid with schema.
    			var _iteratorNormalCompletion7 = true;
    			var _didIteratorError7 = false;
    			var _iteratorError7 = undefined;

    			try {
    				for (var _iterator7 = query.attributes[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
    					var attribute = _step7.value;
    					var _iteratorNormalCompletion9 = true;
    					var _didIteratorError9 = false;
    					var _iteratorError9 = undefined;

    					try {
    						for (var _iterator9 = schemaItems[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
    							var schemaItem = _step9.value;

    							if (schemaItem._hasMatchingPath('DISALLOW', path, attribute)) {
    								return false;
    							}
    						}
    					} catch (err) {
    						_didIteratorError9 = true;
    						_iteratorError9 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion9 && _iterator9.return) {
    								_iterator9.return();
    							}
    						} finally {
    							if (_didIteratorError9) {
    								throw _iteratorError9;
    							}
    						}
    					}
    				}

    				// At this point, the query is not disallowed.
    				// If there are correct allow paths that match the query, this query is valid with schema.
    				// Since we are supporting multiple attributes, we have to make sure that if attributes are set,
    				// we have allowed paths for all of them.
    				// Keep in mind that if the query has no attributes, query.attribute was converted to an array
    				// with a single `undefined` value. This fits the algorithm well.
    			} catch (err) {
    				_didIteratorError7 = true;
    				_iteratorError7 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion7 && _iterator7.return) {
    						_iterator7.return();
    					}
    				} finally {
    					if (_didIteratorError7) {
    						throw _iteratorError7;
    					}
    				}
    			}

    			var _iteratorNormalCompletion8 = true;
    			var _didIteratorError8 = false;
    			var _iteratorError8 = undefined;

    			try {
    				for (var _iterator8 = query.attributes[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
    					var _attribute = _step8.value;

    					var matched = false;

    					var _iteratorNormalCompletion10 = true;
    					var _didIteratorError10 = false;
    					var _iteratorError10 = undefined;

    					try {
    						for (var _iterator10 = schemaItems[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
    							var _schemaItem = _step10.value;

    							if (_schemaItem._hasMatchingPath('ALLOW', path, _attribute)) {
    								matched = true;
    								break;
    							}
    						}

    						// The attribute has not been matched, so it is not allowed by any schema item.
    						// The query is disallowed.
    					} catch (err) {
    						_didIteratorError10 = true;
    						_iteratorError10 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion10 && _iterator10.return) {
    								_iterator10.return();
    							}
    						} finally {
    							if (_didIteratorError10) {
    								throw _iteratorError10;
    							}
    						}
    					}

    					if (!matched) {
    						return false;
    					}
    				}
    			} catch (err) {
    				_didIteratorError8 = true;
    				_iteratorError8 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion8 && _iterator8.return) {
    						_iterator8.return();
    					}
    				} finally {
    					if (_didIteratorError8) {
    						throw _iteratorError8;
    					}
    				}
    			}

    			return true;
    		}

    		/**
       * Checks whether there is an item registered under given name in schema.
       *
       * @param itemName
       * @returns {boolean}
       */

    	}, {
    		key: 'hasItem',
    		value: function hasItem(itemName) {
    			return this._items.has(itemName);
    		}

    		/**
       * Registers given item name in schema.
       *
       *		// Register P element that should be treated like all block elements.
       *		schema.registerItem( 'p', '$block' );
       *
       * @param {String} itemName Name to register.
       * @param [isExtending] If set, new item will extend item with given name.
       */

    	}, {
    		key: 'registerItem',
    		value: function registerItem(itemName, isExtending) {
    			if (this.hasItem(itemName)) {
    				/**
         * Item with specified name already exists in schema.
         *
         * @error schema-item-exists
         */
    				throw new CKEditorError('schema-item-exists: Item with specified name already exists in schema.');
    			}

    			if (!!isExtending && !this.hasItem(isExtending)) {
    				/**
         * Item with specified name does not exist in schema.
         *
         * @error schema-no-item
         */
    				throw new CKEditorError('schema-no-item: Item with specified name does not exist in schema.');
    			}

    			// Create new SchemaItem and add it to the items store.
    			this._items.set(itemName, new SchemaItem(this));

    			// Create an extension chain.
    			// Extension chain has all item names that should be checked when that item is on path to check.
    			// This simply means, that if item is not extending anything, it should have only itself in it's extension chain.
    			// Since extending is not dynamic, we can simply get extension chain of extended item and expand it with registered name,
    			// if the registered item is extending something.
    			var chain = this.hasItem(isExtending) ? this._extensionChains.get(isExtending).concat(itemName) : [itemName];
    			this._extensionChains.set(itemName, chain);
    		}

    		/**
       * Returns {@link engine.model.SchemaItem schema item} that was registered in the schema under given name.
       * If item has not been found, throws error.
       *
       * @private
       * @param {String} itemName Name to look for in schema.
       * @returns {engine.model.SchemaItem} Schema item registered under given name.
       */

    	}, {
    		key: '_getItem',
    		value: function _getItem(itemName) {
    			if (!this.hasItem(itemName)) {
    				/**
         * Item with specified name does not exist in schema.
         *
         * @error schema-no-item
         */
    				throw new CKEditorError('schema-no-item: Item with specified name does not exist in schema.');
    			}

    			return this._items.get(itemName);
    		}

    		/**
       * Normalizes a path to an entity by converting it from {@link engine.model.SchemaPath} to an array of strings.
       *
       * @protected
       * @param {engine.model.SchemaPath} path Path to normalize.
       * @returns {Array.<String>} Normalized path.
       */

    	}], [{
    		key: '_normalizeQueryPath',
    		value: function _normalizeQueryPath(path) {
    			var normalized = [];

    			if (isArray(path)) {
    				var _iteratorNormalCompletion11 = true;
    				var _didIteratorError11 = false;
    				var _iteratorError11 = undefined;

    				try {
    					for (var _iterator11 = path[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
    						var pathItem = _step11.value;

    						if (pathItem instanceof Element) {
    							normalized.push(pathItem.name);
    						} else if (isString(pathItem)) {
    							normalized.push(pathItem);
    						}
    					}
    				} catch (err) {
    					_didIteratorError11 = true;
    					_iteratorError11 = err;
    				} finally {
    					try {
    						if (!_iteratorNormalCompletion11 && _iterator11.return) {
    							_iterator11.return();
    						}
    					} finally {
    						if (_didIteratorError11) {
    							throw _iteratorError11;
    						}
    					}
    				}
    			} else if (path instanceof Position) {
    				var parent = path.parent;

    				while (parent !== null) {
    					normalized.push(parent.name);
    					parent = parent.parent;
    				}

    				normalized.reverse();
    			} else if (isString(path)) {
    				normalized = path.split(' ');
    			}

    			return normalized;
    		}
    	}]);
    	return Schema;
    }();

    /**
     * LivePosition is a position in {@link engine.model.Document Document} that updates itself as Document is changed
     * through operations. It may be used as a bookmark in the Document.
     * **Note:** Contrary to {@link engine.model.Position}, LivePosition works only in roots that are
     * {@link engine.model.RootElement}. If {@link engine.model.DocumentFragment} is passed, error will be thrown.
     * **Note:** Be very careful when dealing with LivePosition. Each LivePosition instance bind events that might
     * have to be unbound. Use {@link engine.model.LivePosition#detach} whenever you don't need LivePosition anymore.
     *
     * @memberOf engine.model
     * @extends engine.model.Position
     */

    var LivePosition = function (_Position) {
    	inherits(LivePosition, _Position);

    	/**
      * Creates a live position.
      *
      * @see engine.model.Position
      * @param {engine.model.RootElement} root
      * @param {Array.<Number>} path
      * @param {engine.model.PositionStickiness} [stickiness] Defaults to `'STICKS_TO_NEXT'`.
      * See {@link engine.model.LivePosition#stickiness}.
      */

    	function LivePosition(root, path, stickiness) {
    		classCallCheck(this, LivePosition);

    		if (!(root instanceof RootElement)) {
    			/**
        * LivePosition root has to be an instance of RootElement.
        *
        * @error liveposition-root-not-rootelement
        */
    			throw new CKEditorError('liveposition-root-not-rootelement: LivePosition root has to be an instance of RootElement.');
    		}

    		/**
       * Flag representing LivePosition stickiness. LivePosition might be sticking to previous node or next node.
       * Whenever some nodes are inserted at the same position as LivePosition, `stickiness` is checked to decide if
       * LivePosition should be moved. Similar applies when a range of nodes is moved and one of it's boundary
       * position is same as LivePosition.
       *
       * Examples:
       *
       *		Insert:
       *		Position is at | and we insert at the same position, marked as ^:
       *		- | sticks to previous node: `<p>f|^oo</p>` => `<p>f|baroo</p>`
       *		- | sticks to next node: `<p>f^|oo</p>` => `<p>fbar|oo</p>`
       *
       *		Move:
       *		Position is at | and range [ ] is moved to position ^:
       *		- | sticks to previous node: `<p>f|[oo]</p><p>b^ar</p>` => `<p>f|</p><p>booar</p>`
       *		- | sticks to next node: `<p>f|[oo]</p><p>b^ar</p>` => `<p>f</p><p>b|ooar</p>`
       *
       * @member {engine.model.PositionStickiness} engine.model.LivePosition#stickiness
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(LivePosition).call(this, root, path));

    		_this.stickiness = stickiness || 'STICKS_TO_NEXT';

    		bindWithDocument$1.call(_this);
    		return _this;
    	}

    	/**
      * Unbinds all events previously bound by LivePosition. Use it whenever you don't need LivePosition instance
      * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was
      * referring to it).
      */


    	createClass(LivePosition, [{
    		key: 'detach',
    		value: function detach() {
    			this.stopListening();
    		}

    		/**
       * @static
       * @method engine.model.LivePosition.createAfter
       * @see engine.model.Position.createAfter
       * @param {engine.model.Node} node
       * @returns {engine.model.LivePosition}
       */

    		/**
       * @static
       * @method engine.model.LivePosition.createBefore
       * @see engine.model.Position.createBefore
       * @param {engine.model.Node} node
       * @returns {engine.model.LivePosition}
       */

    		/**
       * @static
       * @method engine.model.LivePosition.createFromParentAndOffset
       * @see engine.model.Position.createFromParentAndOffset
       * @param {engine.model.Element} parent
       * @param {Number} offset
       * @returns {engine.model.LivePosition}
       */

    		/**
       * @static
       * @method engine.model.LivePosition.createFromPosition
       * @see engine.model.Position.createFromPosition
       * @param {engine.model.Position} position
       * @returns {engine.model.LivePosition}
       */

    	}]);
    	return LivePosition;
    }(Position);

    function bindWithDocument$1() {
    	var _this2 = this;

    	/*jshint validthis: true */

    	this.listenTo(this.root.document, 'change', function (event, type, changes) {
    		transform$2.call(_this2, type, changes.range, changes.sourcePosition);
    	}, this);
    }

    /**
     * Updates this position accordingly to the updates applied to the Tree Model. Bases on change events.
     *
     * @ignore
     * @private
     * @method transform
     * @param {String} type Type of changes applied to the Tree Model.
     * @param {engine.model.Range} range Range containing the result of applied change.
     * @param {engine.model.Position} [position] Additional position parameter provided by some change events.
     */
    function transform$2(type, range, position) {
    	/*jshint validthis: true */

    	var howMany = range.end.offset - range.start.offset;
    	var transformed = void 0;

    	switch (type) {
    		case 'insert':
    			var insertBefore = this.stickiness == 'STICKS_TO_NEXT';
    			transformed = this.getTransformedByInsertion(range.start, howMany, insertBefore);
    			break;

    		case 'move':
    		case 'remove':
    		case 'reinsert':
    			var originalRange = Range$1.createFromPositionAndShift(position, howMany);

    			var gotMoved = originalRange.containsPosition(this) || originalRange.start.isEqual(this) && this.stickiness == 'STICKS_TO_NEXT' || originalRange.end.isEqual(this) && this.stickiness == 'STICKS_TO_PREVIOUS';

    			// We can't use .getTransformedByMove() because we have a different if-condition.
    			if (gotMoved) {
    				transformed = this._getCombined(position, range.start);
    			} else {
    				var _insertBefore = this.stickiness == 'STICKS_TO_NEXT';
    				transformed = this.getTransformedByMove(position, range.start, howMany, _insertBefore);
    			}
    			break;
    		default:
    			return;
    	}

    	this.path = transformed.path;
    	this.root = transformed.root;
    }

    mix(LivePosition, EmitterMixin);

    /**
     * Delete contents of the selection and merge siblings. The resulting selection is always collapsed.
     *
     * @method engine.model.composer.deleteContents
     * @param {engine.model.Batch} batch Batch to which the deltas will be added.
     * @param {engine.model.Selection} selection Selection of which the content should be deleted.
     * @param {Object} [options]
     * @param {Boolean} [options.merge=false] Merge elements after removing the contents of the selection.
     * For example, `<h>x[x</h><p>y]y</p>` will become: `<h>x^y</h>` with the option enabled
     * and: `<h>x^</h><p>y</p>` without it.
     */
    function deleteContents(batch, selection) {
    	var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    	if (selection.isCollapsed) {
    		return;
    	}

    	var selRange = selection.getFirstRange();

    	var startPos = selRange.start;
    	var endPos = LivePosition.createFromPosition(selRange.end);

    	// 1. Remove the contents if there are any.
    	if (!selRange.isEmpty) {
    		batch.remove(selRange);
    	}

    	// 2. Merge elements in the right branch to the elements in the left branch.
    	// The only reasonable (in terms of data and selection correctness) case in which we need to do that is:
    	//
    	// <heading type=1>Fo[</heading><paragraph>]ar</paragraph> => <heading type=1>Fo^ar</heading>
    	//
    	// However, the algorithm supports also merging deeper structures (up to the depth of the shallower branch),
    	// as it's hard to imagine what should actually be the default behavior. Usually, specific features will
    	// want to override that behavior anyway.
    	if (options.merge) {
    		var endPath = endPos.path;
    		var mergeEnd = Math.min(startPos.path.length - 1, endPath.length - 1);
    		var mergeDepth = compareArrays(startPos.path, endPath);

    		if (typeof mergeDepth == 'number') {
    			for (; mergeDepth < mergeEnd; mergeDepth++) {
    				var mergePath = startPos.path.slice(0, mergeDepth);
    				mergePath.push(startPos.path[mergeDepth] + 1);

    				batch.merge(new Position(endPos.root, mergePath));
    			}
    		}
    	}

    	selection.collapse(startPos);

    	endPos.detach();
    }

    /**
     * Modifies the selection. Currently the supported modifications are:
     *
     * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`
     * (defaults to `'CHARACTER'`, other values are not not yet supported).
     * Note: if you extend a forward selection in a backward direction you will in fact shrink it.
     *
     * @method engine.model.composer.modifySelection
     * @param {engine.model.Selection} The selection to modify.
     * @param {Object} [options]
     * @param {'FORWARD'|'BACKWARD'} [options.direction='FORWARD'] The direction in which the selection should be modified.
     */
    function modifySelection(selection) {
    	var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    	var isForward = options.direction != 'BACKWARD';

    	var focus = selection.focus;
    	var walker = new TreeWalker({
    		boundaries: getSearchRange(focus, isForward),
    		singleCharacters: true,
    		direction: isForward ? 'FORWARD' : 'BACKWARD'
    	});

    	var next = walker.next();

    	// 1. Nothing to do here.
    	if (next.done) {
    		return;
    	}

    	var value = next.value;

    	// 2. Consume next character.
    	if (value.type == 'CHARACTER') {
    		selection.setFocus(value.nextPosition);

    		return;
    	}

    	// 3. We're entering an element, so let's consume it fully.
    	if (value.type == (isForward ? 'ELEMENT_START' : 'ELEMENT_END')) {
    		selection.setFocus(value.item, isForward ? 'AFTER' : 'BEFORE');

    		return;
    	}

    	// 4. We're leaving an element. That's more tricky.
    	next = walker.next();

    	// 4.1. Nothing left, so let's stay where we were.
    	if (next.done) {
    		return;
    	}

    	// Replace TreeWalker step wrapper by clean step value.
    	value = next.value;

    	// 4.2. Character found after element end. Not really a valid case in our data model, but let's
    	// do something sensible and put the selection focus before that character.
    	if (value.type == 'CHARACTER') {
    		selection.setFocus(value.previousPosition);
    	}
    	// 4.3. OK, we're entering a new element. So let's place there the focus.
    	else {
    			selection.setFocus(value.item, isForward ? 0 : 'END');
    		}
    }

    function getSearchRange(start, isForward) {
    	var root = start.root;
    	var searchEnd = Position.createAt(root, isForward ? 'END' : 0);

    	if (isForward) {
    		return new Range$1(start, searchEnd);
    	} else {
    		return new Range$1(searchEnd, start);
    	}
    }

    /**
     * Set of frequently used tools to work with a document.
     * The instance of composer is available in {@link engine.model.Document#composer}.
     *
     * By default this class implements only a very basic version of those algorithms. However, all its methods can be extended
     * by features by listening to related events. The default action of those events are implemented
     * by functions available in the {@link engine.model.composer} namespace, so they can be reused
     * in the algorithms implemented by features.
     *
     * @member engine.model.composer
     * @mixes utils.EmitterMixin
     */

    var Composer = function () {
    	/**
      * Creates an instance of the composer.
      */

    	function Composer() {
    		classCallCheck(this, Composer);

    		this.on('deleteContents', function (evt, data) {
    			return deleteContents(data.batch, data.selection, data.options);
    		});
    		this.on('modifySelection', function (evt, data) {
    			return modifySelection(data.selection, data.options);
    		});
    	}

    	/**
      * See {@link engine.model.composer.deleteContents}.
      *
      * Note: For the sake of predictability, the resulting selection should always be collapsed.
      * In cases where a feature wants to modify deleting behavior so selection isn't collapsed
      * (e.g. a table feature may want to keep row selection after pressing <kbd>Backspace</kbd>),
      * then that behavior should be implemented in the view's listener. At the same time, the table feature
      * will need to modify this method's behavior too, e.g. to "delete contents and then collapse
      * the selection inside the last selected cell" or "delete the row and collapse selection somewhere near".
      * That needs to be done in order to ensure that other features which use `deleteContents()` will work well with tables.
      *
      * @fires engine.model.composer.Composer#deleteContents
      * @param {engine.model.Batch} batch Batch to which deltas will be added.
      * @param {engine.model.Selection} selection Selection of which the content should be deleted.
      * @param {Object} options See {@link engine.model.composer.deleteContents}'s options.
      */


    	createClass(Composer, [{
    		key: 'deleteContents',
    		value: function deleteContents(batch, selection, options) {
    			this.fire('deleteContents', { batch: batch, selection: selection, options: options });
    		}

    		/**
       * See {@link engine.model.composer.modifySelection}.
       *
       * @fires engine.model.composer.Composer#modifySelection
       * @param {engine.model.Selection} The selection to modify.
       * @param {Object} options See {@link engine.model.composer.modifySelection}'s options.
       */

    	}, {
    		key: 'modifySelection',
    		value: function modifySelection(selection, options) {
    			this.fire('modifySelection', { selection: selection, options: options });
    		}
    	}]);
    	return Composer;
    }();

    mix(Composer, EmitterMixin);

    var graveyardName = '$graveyard';

    /**
     * Document tree model describes all editable data in the editor. It may contain multiple
     * {@link engine.model.Document#roots root elements}, for example if the editor have multiple editable areas, each area will be
     * represented by the separate root.
     *
     * All changes in the document are done by {@link engine.model.operation.Operation operations}. To create operations in
     * the simple way use use the {@link engine.model.Batch} API, for example:
     *
     *		doc.batch().insert( position, nodes ).split( otherPosition );
     *
     * @see engine.model.Document#batch
     *
     * @memberOf engine.model
     */

    var Document = function () {
    	/**
      * Creates an empty document instance with no {@link engine.model.Document#roots} (other than graveyard).
      */

    	function Document() {
    		var _this = this;

    		classCallCheck(this, Document);

    		/**
       * Document version. It starts from `0` and every operation increases the version number. It is used to ensure that
       * operations are applied on the proper document version. If the {@link engine.model.operation.Operation#baseVersion} will
       * not match document version the {@link document-applyOperation-wrong-version} error is thrown.
       *
       * @readonly
       * @member {Number} engine.model.Document#version
       */
    		this.version = 0;

    		/**
       * Selection done on this document.
       *
       * @readonly
       * @member {engine.model.LiveSelection} engine.model.Document#selection
       */
    		this.selection = new LiveSelection(this);

    		/**
       * Schema for this document.
       *
       * @member {engine.model.Schema} engine.model.Document#schema
       */
    		this.schema = new Schema();

    		/**
       * Composer for this document. Set of tools to work with the document.
       *
       * The features can tune up these tools to better work on their specific cases.
       *
       * @member {engine.model.composer.Composer} engine.model.Document#composer
       */
    		this.composer = new Composer();

    		/**
       * Array of pending changes. See: {@link engine.model.Document#enqueueChanges}.
       *
       * @private
       * @member {Array.<Function>} engine.model.Document#_pendingChanges
       */
    		this._pendingChanges = [];

    		/**
       * List of roots that are owned and managed by this document. Use {@link engine.model.document#createRoot} and
       * {@link engine.model.document#getRoot} to manipulate it.
       *
       * @readonly
       * @protected
       * @member {Map} engine.model.Document#roots
       */
    		this._roots = new Map();

    		// Add events that will update selection attributes.
    		this.selection.on('change:range', function () {
    			_this.selection._updateAttributes();
    		});

    		this.on('changesDone', function () {
    			_this.selection._updateAttributes();
    		});

    		// Graveyard tree root. Document always have a graveyard root, which stores removed nodes.
    		this.createRoot('$root', graveyardName);

    		/**
       * Document's history.
       *
       * **Note:** Be aware that deltas applied to the stored deltas might be removed or changed.
       *
       * @readonly
       * @member {engine.model.History} engine.model.Document#history
       */
    		this.history = new History(this);
    	}

    	/**
      * Graveyard tree root. Document always have a graveyard root, which stores removed nodes.
      *
      * @readonly
      * @type {engine.model.RootElement}
      */


    	createClass(Document, [{
    		key: 'applyOperation',


    		/**
       * This is the entry point for all document changes. All changes on the document are done using
       * {@link engine.model.operation.Operation operations}. To create operations in the simple way use the
       * {@link engine.model.Batch} API available via {@link engine.model.Document#batch} method.
       *
       * @fires @link engine.model.Document#change
       * @param {engine.model.operation.Operation} operation Operation to be applied.
       */
    		value: function applyOperation(operation) {
    			if (operation.baseVersion !== this.version) {
    				/**
         * Only operations with matching versions can be applied.
         *
         * @error document-applyOperation-wrong-version
         * @param {engine.model.operation.Operation} operation
         */
    				throw new CKEditorError('document-applyOperation-wrong-version: Only operations with matching versions can be applied.', { operation: operation });
    			}

    			var changes = operation._execute();

    			this.version++;

    			this.history.addDelta(operation.delta);

    			var batch = operation.delta && operation.delta.batch;

    			if (changes) {
    				// `NoOperation` returns no changes, do not fire event for it.
    				this.fire('change', operation.type, changes, batch);
    			}
    		}

    		/**
       * Creates a {@link engine.model.Batch} instance which allows to change the document.
       *
       * @param {String} [type] Batch type. See {@link engine.model.Batch#type}.
       * @returns {engine.model.Batch} Batch instance.
       */

    	}, {
    		key: 'batch',
    		value: function batch(type) {
    			return new Batch(this, type);
    		}

    		/**
       * Creates a new top-level root.
       *
       * @param {String} [elementName='$root'] Element name. Defaults to `'$root'` which also have
       * some basic schema defined (`$block`s are allowed inside the `$root`). Make sure to define a proper
       * schema if you use a different name.
       * @param {String} [rootName='main'] Unique root name.
       * @returns {engine.model.RootElement} Created root.
       */

    	}, {
    		key: 'createRoot',
    		value: function createRoot() {
    			var elementName = arguments.length <= 0 || arguments[0] === undefined ? '$root' : arguments[0];
    			var rootName = arguments.length <= 1 || arguments[1] === undefined ? 'main' : arguments[1];

    			if (this._roots.has(rootName)) {
    				/**
         * Root with specified name already exists.
         *
         * @error document-createRoot-name-exists
         * @param {engine.model.Document} doc
         * @param {String} name
         */
    				throw new CKEditorError('document-createRoot-name-exists: Root with specified name already exists.', { name: rootName });
    			}

    			var root = new RootElement(this, elementName, rootName);
    			this._roots.set(rootName, root);

    			return root;
    		}

    		/**
       * Removes all events listeners set by document instance.
       */

    	}, {
    		key: 'destroy',
    		value: function destroy() {
    			this.selection.destroy();
    			this.stopListening();
    		}

    		/**
       * Enqueues document changes. Any changes to be done on document (mostly using {@link engine.model.Document#batch}
       * should be placed in the queued callback. If no other plugin is changing document at the moment, the callback will be
       * called immediately. Otherwise it will wait for all previously queued changes to finish happening. This way
       * queued callback will not interrupt other callbacks.
       *
       * When all queued changes are done {@link engine.model.Document#changesDone} event is fired.
       *
       * @fires @link engine.model.Document#changesDone
       * @param {Function} callback Callback to enqueue.
       */

    	}, {
    		key: 'enqueueChanges',
    		value: function enqueueChanges(callback) {
    			this._pendingChanges.push(callback);

    			if (this._pendingChanges.length == 1) {
    				while (this._pendingChanges.length) {
    					this._pendingChanges[0]();
    					this._pendingChanges.shift();
    				}

    				this.fire('changesDone');
    			}
    		}

    		/**
       * Returns top-level root by its name.
       *
       * @param {String} [name='main'] Unique root name.
       * @returns {engine.model.RootElement} Root registered under given name.
       */

    	}, {
    		key: 'getRoot',
    		value: function getRoot() {
    			var name = arguments.length <= 0 || arguments[0] === undefined ? 'main' : arguments[0];

    			if (!this._roots.has(name)) {
    				/**
         * Root with specified name does not exist.
         *
         * @error document-getRoot-root-not-exist
         * @param {String} name
         */
    				throw new CKEditorError('document-getRoot-root-not-exist: Root with specified name does not exist.', { name: name });
    			}

    			return this._roots.get(name);
    		}

    		/**
       * Checks if root with given name is defined.
       *
       * @param {String} name Name of root to check.
       * @returns {Boolean}
       */

    	}, {
    		key: 'hasRoot',
    		value: function hasRoot(name) {
    			return this._roots.has(name);
    		}

    		/**
       * Custom toJSON method to solve child-parent circular dependencies.
       *
       * @returns {Object} Clone of this object with the document property changed to string.
       */

    	}, {
    		key: 'toJSON',
    		value: function toJSON() {
    			var json = clone(this);

    			// Due to circular references we need to remove parent reference.
    			json.selection = '[engine.model.LiveSelection]';

    			return json;
    		}

    		/**
       * Returns default root for this document which is either the first root that was added to the the document using
       * {@link engine.model.Document#createRoot} or the {@link engine.model.Document#graveyard graveyard root} if
       * no other roots were created.
       *
       * @protected
       * @returns {engine.model.RootElement} The default root for this document.
       */

    	}, {
    		key: '_getDefaultRoot',
    		value: function _getDefaultRoot() {
    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = this._roots.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var root = _step.value;

    					if (root !== this.graveyard) {
    						return root;
    					}
    				}
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}

    			return this.graveyard;
    		}

    		/**
       * Fired when document changes by applying an operation.
       *
       * There are 5 types of change:
       *
       * * 'insert' when nodes are inserted,
       * * 'remove' when nodes are removed,
       * * 'reinsert' when remove is undone,
       * * 'move' when nodes are moved,
       * * 'addAttribute' when attributes are added,
       * * 'removeAttribute' when attributes are removed,
       * * 'changeAttribute' when attributes change,
       * * 'addRootAttribute' when attribute for root is added,
       * * 'removeRootAttribute' when attribute for root is removed,
       * * 'changeRootAttribute' when attribute for root changes.
       *
       * @event engine.model.Document#change
       * @param {String} type Change type, possible option: 'insert', 'remove', 'reinsert', 'move', 'attribute'.
       * @param {Object} data Additional information about the change.
       * @param {engine.model.Range} data.range Range in model containing changed nodes. Note that the range state is
       * after changes has been done, i.e. for 'remove' the range will be in the {@link engine.model.Document#graveyard graveyard root}.
       * This is `undefined` for "...root..." types.
       * @param {engine.model.Position} [data.sourcePosition] Change source position. Exists for 'remove', 'reinsert' and 'move'.
       * Note that this position state is before changes has been done, i.e. for 'reinsert' the source position will be in the
       * {@link engine.model.Document#graveyard graveyard root}.
       * @param {String} [data.key] Only for attribute types. Key of changed / inserted / removed attribute.
       * @param {*} [data.oldValue] Only for 'removeAttribute', 'removeRootAttribute', 'changeAttribute' or
       * 'changeRootAttribute' type.
       * @param {*} [data.newValue] Only for 'addAttribute', 'addRootAttribute', 'changeAttribute' or
       * 'changeRootAttribute' type.
       * @param {engine.model.RootElement} [changeInfo.root] Root element which attributes got changed. This is defined
       * only for root types.
       * @param {engine.model.Batch} batch A {@link engine.model.Batch batch} of changes which this change is a part of.
       */

    		/**
       * Fired when all queued document changes are done. See {@link engine.model.Document#enqueueChanges}.
       *
       * @event engine.model.Document#changesDone
       */

    	}, {
    		key: 'graveyard',
    		get: function get() {
    			return this.getRoot(graveyardName);
    		}

    		/**
       * Gets names of all roots (without the {@link engine.model.Document#graveyard}).
       *
       * @readonly
       * @type {Iterable.<String>}
       */

    	}, {
    		key: 'rootNames',
    		get: function get() {
    			return Array.from(this._roots.keys()).filter(function (name) {
    				return name != graveyardName;
    			});
    		}
    	}]);
    	return Document;
    }();

    mix(Document, EmitterMixin);

    /**
     * Class representing a basic editor. It contains a base architecture, without much additional logic.
     *
     * See also {@link ckeditor5.editor.StandardEditor}.
     *
     * @memberOf ckeditor5.editor
     * @mixes utils.EmitterMixin
     */

    var Editor = function () {
    	/**
      * Creates a new instance of the Editor class.
      *
      * @param {Object} config The editor config.
      */

    	function Editor(config) {
    		classCallCheck(this, Editor);

    		/**
       * Holds all configurations specific to this editor instance.
       *
       * @readonly
       * @member {utils.Config} ckeditor5.Editor#config
       */
    		this.config = new Config(config);

    		/**
       * The plugins loaded and in use by this editor instance.
       *
       * @readonly
       * @member {ckeditor5.PluginCollection} ckeditor5.Editor#plugins
       */
    		this.plugins = new PluginCollection(this);

    		/**
       * Commands registered to the editor.
       *
       * @readonly
       * @member {Map.<ckeditor5.command.Command>} ckeditor5.Editor#commands
       */
    		this.commands = new Map();

    		/**
       * @readonly
       * @member {utils.Locale} ckeditor5.Editor#locale
       */
    		this.locale = new Locale(this.config.get('lang'));

    		/**
       * Shorthand for {@link utils.Locale#t}.
       *
       * @see utils.Locale#t
       * @method ckeditor5.Editor#t
       */
    		this.t = this.locale.t;

    		/**
       * Tree Model document managed by this editor.
       *
       * @readonly
       * @member {engine.model.Document} ckeditor5.Editor#document
       */
    		this.document = new Document();

    		/**
       * Instance of the {@link engine.DataController data controller}.
       *
       * @readonly
       * @member {engine.DataController} ckeditor5.Editor#data
       */
    		this.data = new DataController(this.document);

    		/**
       * Instance of the {@link engine.EditingController editing controller}.
       *
       * This property is set by more specialized editor classes (such as {@link ckeditor5.editor.StandardEditor}),
       * however, it's required for features to work as their engine-related parts will try to connect converters.
       *
       * When defining a virtual editor class, like one working in Node.js, it's possible to plug a virtual
       * editing controller which only instantiates necessary properties, but without any observers and listeners.
       *
       * @readonly
       * @member {engine.EditingController} ckeditor5.editor.Editor#editing
       */
    	}

    	/**
      * Loads and initilizes plugins specified in config features.
      *
      * @returns {Promise} A promise which resolves once the initialization is completed.
      */


    	createClass(Editor, [{
    		key: 'initPlugins',
    		value: function initPlugins() {
    			var that = this;
    			var config = this.config;

    			return loadPlugins().then(initPlugins);

    			function loadPlugins() {
    				var plugins = config.get('features') || [];

    				// Handle features passed as a string.
    				if (!isArray(plugins)) {
    					plugins = plugins.split(',');
    				}

    				return that.plugins.load(plugins);
    			}

    			function initPlugins(loadedPlugins) {
    				return loadedPlugins.reduce(function (promise, plugin) {
    					return promise.then(plugin.init.bind(plugin));
    				}, Promise.resolve());
    			}
    		}

    		/**
       * Destroys the editor instance, releasing all resources used by it.
       *
       * @fires ckeditor5.editor.Editor#destroy
       * @returns {Promise} A promise that resolves once the editor instance is fully destroyed.
       */

    	}, {
    		key: 'destroy',
    		value: function destroy() {
    			var _this = this;

    			this.fire('destroy');
    			this.stopListening();

    			return Promise.resolve().then(function () {
    				_this.document.destroy();
    				_this.data.destroy();
    			});
    		}

    		/**
       * Executes specified command with given parameter.
       *
       * @param {String} commandName Name of command to execute.
       * @param {*} [commandParam] If set, command will be executed with this parameter.
       */

    	}, {
    		key: 'execute',
    		value: function execute(commandName, commandParam) {
    			var command = this.commands.get(commandName);

    			if (!command) {
    				/**
         * Specified command has not been added to the editor.
         *
         * @error editor-command-not-found
         */
    				throw new CKEditorError('editor-command-not-found: Specified command has not been added to the editor.');
    			}

    			command._execute(commandParam);
    		}

    		/**
       * Creates a basic editor instance.
       *
       * @param {Object} config See {@link ckeditor5.editor.StandardEditor}'s param.
       * @returns {Promise} Promise resolved once editor is ready.
       * @returns {ckeditor5.editor.StandardEditor} return.editor The editor instance.
       */

    	}], [{
    		key: 'create',
    		value: function create(config) {
    			var _this2 = this;

    			return new Promise(function (resolve) {
    				var editor = new _this2(config);

    				resolve(editor.initPlugins().then(function () {
    					return editor;
    				}));
    			});
    		}
    	}]);
    	return Editor;
    }();

    mix(Editor, EmitterMixin);

    /**
     * Keystroke handler. Its instance is available in {@link ckeditor5.Editor#keystrokes} so features
     * can register their keystrokes.
     *
     * E.g. an undo feature would do this:
     *
     *		editor.keystrokes.set( 'ctrl + Z', 'undo' );
     *		editor.keystrokes.set( 'ctrl + shift + Z', 'redo' );
     *		editor.keystrokes.set( 'ctrl + Y', 'redo' );
     *
     * @memberOf ckeditor5
     */

    var KeystrokeHandler = function () {
    	/**
      * Creates an instance of the keystroke handler.
      *
      * @param {engine.treeView.TreeView} editingView
      */

    	function KeystrokeHandler(editor) {
    		var _this = this;

    		classCallCheck(this, KeystrokeHandler);

    		/**
       * The editor instance.
       *
       * @readonly
       * @member {ckeditor5.Editor} ckeditor5.KeystrokeHandler#editor
       */
    		this.editor = editor;

    		/**
       * Listener used to listen to events for easier keystroke handler destruction.
       *
       * @private
       * @member {utils.Emitter} ckeditor5.KeystrokeHandler#_listener
       */
    		this._listener = Object.create(EmitterMixin);

    		/**
       * Map of the defined keystrokes. Keystroke codes are the keys.
       *
       * @private
       * @member {Map} ckeditor5.KeystrokeHandler#_keystrokes
       */
    		this._keystrokes = new Map();

    		this._listener.listenTo(editor.editing.view, 'keydown', function (evt, data) {
    			var handled = _this.press(data);

    			if (handled) {
    				data.preventDefault();
    			}
    		});
    	}

    	/**
      * Registers a handler for the specified keystroke.
      *
      * The handler can be specified as a command name or a callback.
      *
      * @param {String|Array.<String|Number>} keystroke Keystroke defined in a format accepted by
      * the {@link utils.keyboard.parseKeystroke} function.
      * @param {String|Function} callback If a string is passed, then the keystroke will
      * {@link ckeditor5.Editor#execute execute a command}.
      * If a function, then it will be called with the
      * {@link engine.view.observer.keyObserver.KeyEventData key event data} object.
      */


    	createClass(KeystrokeHandler, [{
    		key: 'set',
    		value: function set(keystroke, callback) {
    			this._keystrokes.set(parseKeystroke(keystroke), callback);
    		}

    		/**
       * Triggers a keystroke handler for a specified key combination, if such a keystroke was {@link #set defined}.
       *
       * @param {engine.view.observer.keyObserver.KeyEventData} keyEventData Key event data.
       * @returns {Boolean} Whether the keystroke was handled.
       */

    	}, {
    		key: 'press',
    		value: function press(keyEventData) {
    			var keyCode = getCode(keyEventData);
    			var callback = this._keystrokes.get(keyCode);

    			if (!callback) {
    				return false;
    			}

    			if (typeof callback == 'string') {
    				this.editor.execute(callback);
    			} else {
    				callback(keyEventData);
    			}

    			return true;
    		}

    		/**
       * Destroys the keystroke handler.
       */

    	}, {
    		key: 'destroy',
    		value: function destroy() {
    			this._keystrokes = new Map();
    			this._listener.stopListening();
    		}
    	}]);
    	return KeystrokeHandler;
    }();

    // The following code is based on the "O(NP) Sequence Comparison Algorithm"
    // by Sun Wu, Udi Manber, Gene Myers, Webb Miller.

    /**
     * Calculates the difference between two arrays or strings producing an array containing a list of changes
     * necessary to transform input into output.
     *
     *		diff( 'aba', 'acca' ); // [ 'EQUAL', 'INSERT', 'INSERT', 'DELETE', 'EQUAL' ]
     *
     * @method utils.diff
     * @param {Array|String} a Input array or string.
     * @param {Array|String} b Output array or string.
     * @param {Function} [cmp] Optional function used to compare array values, by default === is used.
     * @returns {Array} Array of changes.
     */

    function diff(a, b, cmp) {
    	// Set the comparator function.
    	cmp = cmp || function (a, b) {
    		return a === b;
    	};

    	// Temporary action type statics.
    	var _INSERT = void 0,
    	    _DELETE = void 0;

    	// Swapped the arrays to use the shorter one as the first one.
    	if (b.length < a.length) {
    		var tmp = a;

    		a = b;
    		b = tmp;

    		// We swap the action types as well.
    		_INSERT = 'DELETE';
    		_DELETE = 'INSERT';
    	} else {
    		_INSERT = 'INSERT';
    		_DELETE = 'DELETE';
    	}

    	var m = a.length;
    	var n = b.length;
    	var delta = n - m;

    	// Edit scripts, for each diagonal.
    	var es = {};
    	// Furthest points, the furthest y we can get on each diagonal.
    	var fp = {};

    	function snake(k) {
    		// We use -1 as an alternative below to handle initial values ( instead of filling the fp with -1 first ).
    		// Furthest points (y) on the diagonal below k.
    		var y1 = (fp[k - 1] !== undefined ? fp[k - 1] : -1) + 1;
    		// Furthest points (y) on the diagonal above k.
    		var y2 = fp[k + 1] !== undefined ? fp[k + 1] : -1;
    		// The way we should go to get further.
    		var dir = y1 > y2 ? -1 : 1;

    		// Clone previous changes array (if any).
    		if (es[k + dir]) {
    			es[k] = es[k + dir].slice(0);
    		}

    		// Create changes array.
    		if (!es[k]) {
    			es[k] = [];
    		}

    		// Push the action.
    		es[k].push(y1 > y2 ? _INSERT : _DELETE);

    		// Set the beginning coordinates.
    		var y = Math.max(y1, y2);
    		var x = y - k;

    		// Traverse the diagonal as long as the values match.
    		while (x < m && y < n && cmp(a[x], b[y])) {
    			x++;
    			y++;
    			// Push no change action.
    			es[k].push('EQUAL');
    		}

    		return y;
    	}

    	var p = 0;
    	var k = void 0;

    	// Traverse the graph until we reach the end of the longer string.
    	do {
    		// Updates furthest points and edit scripts for diagonals below delta.
    		for (k = -p; k < delta; k++) {
    			fp[k] = snake(k);
    		}

    		// Updates furthest points and edit scripts for diagonals above delta.
    		for (k = delta + p; k > delta; k--) {
    			fp[k] = snake(k);
    		}

    		// Updates furthest point and edit script for the delta diagonal.
    		// note that the delta diagonal is the one which goes through the sink (m, n).
    		fp[delta] = snake(delta);

    		p++;
    	} while (fp[delta] !== n);

    	// Return the final list of edit changes.
    	// We remove the first item that represents the action for the injected nulls.
    	return es[delta].slice(1);
    }

    /**
     * Inserts node to the parent at given index.
     *
     * @method utils.dom.insertAt
     * @param {Element} parentElement Parent element.
     * @param {Number} index Insertions index.
     * @param {Node} nodeToInsert Node to insert.
     */

    function insertAt(parentElement, index, nodeToInsert) {
      parentElement.insertBefore(nodeToInsert, parentElement.childNodes[index] || null);
    }

    /**
     * Removes given node from parent.
     *
     * @method utils.dom.remove
     * @param {Node} node Node to remove.
     */

    function remove$2(node) {
      var parent = node.parentNode;

      if (parent) {
        parent.removeChild(node);
      }
    }

    /**
     * Renderer updates DOM structure and selection, to make them a reflection of the view structure and selection.
     *
     * View nodes which may need to be rendered needs to be {@link engine.view.Renderer#markToSync marked}.
     * Then, on {@link engine.view.Renderer#render render}, renderer compares the view nodes with the DOM nodes
     * in order to check which ones really need to be refreshed. Finally, it creates DOM nodes from these view nodes,
     * {@link engine.view.DomConverter#bindElements binds} them and inserts into the DOM tree.
     *
     * Every time {@link engine.view.Renderer#render render} is called, renderer additionally checks if
     * {@link engine.view.Renderer#selection selection} needs update and updates it if so.
     *
     * Renderer uses {@link engine.view.DomConverter} to transform and bind nodes.
     *
     * @memberOf engine.view
     */

    var Renderer = function () {
    	/**
      * Creates a renderer instance.
      *
      * @param {engine.view.DomConverter} domConverter Converter instance.
      * @param {engine.view.Selection} selection View selection.
      */

    	function Renderer(domConverter, selection) {
    		classCallCheck(this, Renderer);

    		/**
       * Set of DOM Documents instances.
       *
       * @member {Set.<Document>} engine.view.Renderer#domDocuments
       */
    		this.domDocuments = new Set();

    		/**
       * Converter instance.
       *
       * @readonly
       * @member {engine.view.DomConverter} engine.view.Renderer#domConverter
       */
    		this.domConverter = domConverter;

    		/**
       * Set of nodes which attributes changed and may need to be rendered.
       *
       * @readonly
       * @member {Set.<engine.view.Node>} engine.view.Renderer#markedAttributes
       */
    		this.markedAttributes = new Set();

    		/**
       * Set of elements which child lists changed and may need to be rendered.
       *
       * @readonly
       * @member {Set.<engine.view.Node>} engine.view.Renderer#markedChildren
       */
    		this.markedChildren = new Set();

    		/**
       * Set of text nodes which text data changed and may need to be rendered.
       *
       * @readonly
       * @member {Set.<engine.view.Node>} engine.view.Renderer#markedTexts
       */
    		this.markedTexts = new Set();

    		/**
       * View selection. Renderer updates DOM Selection to make it match this one.
       *
       * @readonly
       * @member {engine.view.Selection} engine.view.Renderer#selection
       */
    		this.selection = selection;

    		/**
       * Position of the inline {@link engine.view.filler filler}.
       * It should always be put BEFORE the text which contains filler.
       *
       * @private
       * @member {engine.view.Position} engine.view.Renderer#_inlineFillerPosition
       */
    		this._inlineFillerPosition = null;

    		/**
       * Indicates if view document is focused and selection can be rendered. Selection will not be rendered if
       * this is set to `false`.
       *
       * @member {Boolean} engine.view.Renderer#isFocused
       */
    		this.isFocused = false;
    	}

    	/**
      * Mark node to be synchronized.
      *
      * Note that only view nodes which parents have corresponding DOM elements need to be marked to be synchronized.
      *
      * @see engine.view.Renderer#markedAttributes
      * @see engine.view.Renderer#markedChildren
      * @see engine.view.Renderer#markedTexts
      *
      * @param {engine.view.ChangeType} type Type of the change.
      * @param {engine.view.Node} node Node to be marked.
      */


    	createClass(Renderer, [{
    		key: 'markToSync',
    		value: function markToSync(type, node) {
    			if (type === 'text') {
    				if (this.domConverter.getCorrespondingDom(node.parent)) {
    					this.markedTexts.add(node);
    				}
    			} else {
    				// If the node has no DOM element it is not rendered yet,
    				// its children/attributes do not need to be marked to be sync.
    				if (!this.domConverter.getCorrespondingDom(node)) {
    					return;
    				}

    				if (type === 'attributes') {
    					this.markedAttributes.add(node);
    				} else if (type === 'children') {
    					this.markedChildren.add(node);
    				} else {
    					/**
          * Unknown type passed to Renderer.markToSync.
          *
          * @error renderer-unknown-type
          */
    					throw new CKEditorError('renderer-unknown-type: Unknown type passed to Renderer.markToSync.');
    				}
    			}
    		}

    		/**
       * Render method checks {@link engine.view.Renderer#markedAttributes},
       * {@link engine.view.Renderer#markedChildren} and {@link engine.view.Renderer#markedTexts} and updates all
       * nodes which need to be updated. Then it clears all three sets. Also, every time render is called it compares and
       * if needed updates the selection.
       *
       * Renderer tries not to break text composition (e.g. IME) and x-index of the selection,
       * so it does as little as it is needed to update the DOM.
       *
       * For attributes it adds new attributes to DOM elements, updates values and removes
       * attributes which do not exist in the view element.
       *
       * For text nodes it updates the text string if it is different. Note that if parent element is marked as an element
       * which changed child list, text node update will not be done, because it may not be possible do find a
       * {@link engine.view.DomConverter#getCorrespondingDomText corresponding DOM text}. The change will be handled
       * in the parent element.
       *
       * For elements, which child lists have changed, it calculates a {@link diff} and adds or removes children which have changed.
       *
       * Rendering also handles {@link engine.view.filler fillers}. Especially, it checks if the inline filler is needed
       * at selection position and adds or removes it. To prevent breaking text composition inline filler will not be
       * removed as long selection is in the text node which needed it at first.
       */

    	}, {
    		key: 'render',
    		value: function render() {
    			if (!this._isInlineFillerAtSelection()) {
    				this._removeInlineFiller();

    				if (this._needAddInlineFiller()) {
    					this._inlineFillerPosition = this.selection.getFirstPosition();
    					// Do not use `markToSync` so it will be added even if the parent is already added.
    					this.markedChildren.add(this._inlineFillerPosition.parent);
    				} else {
    					this._inlineFillerPosition = null;
    				}
    			}

    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = this.markedTexts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var node = _step.value;

    					if (!this.markedChildren.has(node.parent) && this.domConverter.getCorrespondingDom(node.parent)) {
    						this._updateText(node);
    					}
    				}
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}

    			var _iteratorNormalCompletion2 = true;
    			var _didIteratorError2 = false;
    			var _iteratorError2 = undefined;

    			try {
    				for (var _iterator2 = this.markedAttributes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    					var element = _step2.value;

    					this._updateAttrs(element);
    				}
    			} catch (err) {
    				_didIteratorError2 = true;
    				_iteratorError2 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion2 && _iterator2.return) {
    						_iterator2.return();
    					}
    				} finally {
    					if (_didIteratorError2) {
    						throw _iteratorError2;
    					}
    				}
    			}

    			var _iteratorNormalCompletion3 = true;
    			var _didIteratorError3 = false;
    			var _iteratorError3 = undefined;

    			try {
    				for (var _iterator3 = this.markedChildren[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
    					var _element = _step3.value;

    					this._updateChildren(_element);
    				}
    			} catch (err) {
    				_didIteratorError3 = true;
    				_iteratorError3 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion3 && _iterator3.return) {
    						_iterator3.return();
    					}
    				} finally {
    					if (_didIteratorError3) {
    						throw _iteratorError3;
    					}
    				}
    			}

    			this._updateSelection();
    			this._updateFocus();

    			this.markedTexts.clear();
    			this.markedAttributes.clear();
    			this.markedChildren.clear();
    		}

    		/**
       * Returns `true` if the inline filler and selection are in the same place.
       * If it is true it means filler had been added for a reason and selection does not
       * left text node, user can be in the middle of the composition so it should not be touched.
       *
       * @private
       * @returns {Boolean} True if the inline filler and selection are in the same place.
       */

    	}, {
    		key: '_isInlineFillerAtSelection',
    		value: function _isInlineFillerAtSelection() {
    			if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
    				return false;
    			}

    			var selectionPosition = this.selection.getFirstPosition();
    			var fillerPosition = this._inlineFillerPosition;

    			if (!fillerPosition) {
    				return false;
    			}

    			if (fillerPosition.isEqual(selectionPosition)) {
    				return true;
    			}

    			if (selectionPosition.parent instanceof Text$2) {
    				if (fillerPosition.isEqual(Position$1.createBefore(selectionPosition.parent))) {
    					return true;
    				}
    			}

    			return false;
    		}

    		/**
       * Removes inline filler.
       *
       * @private
       */

    	}, {
    		key: '_removeInlineFiller',
    		value: function _removeInlineFiller() {
    			if (!this._inlineFillerPosition) {
    				// Nothing to remove.
    				return;
    			}

    			var domFillerPosition = this.domConverter.viewPositionToDom(this._inlineFillerPosition);
    			var domFillerNode = domFillerPosition.parent;

    			// If there is no filler viewPositionToDom will return parent node, so domFillerNode will be an element.
    			if (!this.domConverter.isText(domFillerNode) || !startsWithFiller(domFillerNode)) {
    				/**
         * No inline filler on expected position.
         *
         * @error renderer-render-no-inline-filler.
         */
    				throw new CKEditorError('renderer-render-no-inline-filler: No inline filler on expected position.');
    			}

    			if (isInlineFiller(domFillerNode)) {
    				domFillerNode.parentNode.removeChild(domFillerNode);
    			} else {
    				domFillerNode.data = domFillerNode.data.substr(INLINE_FILLER_LENGTH);
    			}
    		}

    		/**
       * Checks if the inline {@link engine.view.filler fillers} should be added.
       *
       * @private
       * @returns {Boolean} True if the inline fillers should be added.
       */

    	}, {
    		key: '_needAddInlineFiller',
    		value: function _needAddInlineFiller() {
    			if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
    				return false;
    			}

    			var selectionPosition = this.selection.getFirstPosition();
    			var selectionParent = selectionPosition.parent;
    			var selectionOffset = selectionPosition.offset;

    			// If there is no DOM root we do not care about fillers.
    			if (!this.domConverter.getCorrespondingDomElement(selectionParent.getRoot())) {
    				return false;
    			}

    			if (!(selectionParent instanceof Element$1)) {
    				return false;
    			}

    			// We have block filler, we do not need inline one.
    			if (selectionOffset === selectionParent.getFillerOffset()) {
    				return false;
    			}

    			var nodeBefore = selectionPosition.nodeBefore;
    			var nodeAfter = selectionPosition.nodeAfter;

    			if (nodeBefore instanceof Text$2 || nodeAfter instanceof Text$2) {
    				return false;
    			}

    			return true;
    		}

    		/**
       * Checks if text needs to be updated and possibly updates it.
       *
       * @private
       * @param {engine.view.Text} viewText View text to update.
       */

    	}, {
    		key: '_updateText',
    		value: function _updateText(viewText) {
    			var domText = this.domConverter.getCorrespondingDom(viewText);

    			var actualText = domText.data;
    			var expectedText = viewText.data;

    			var filler = this._inlineFillerPosition;

    			if (filler && filler.parent == viewText.parent && filler.offset == viewText.getIndex()) {
    				expectedText = INLINE_FILLER + expectedText;
    			}

    			if (actualText != expectedText) {
    				domText.data = expectedText;
    			}
    		}

    		/**
       * Checks if attributes list needs to be updated and possibly updates it.
       *
       * @private
       * @param {engine.view.Element} viewElement View element to update.
       */

    	}, {
    		key: '_updateAttrs',
    		value: function _updateAttrs(viewElement) {
    			var domElement = this.domConverter.getCorrespondingDom(viewElement);
    			var domAttrKeys = Array.from(domElement.attributes).map(function (attr) {
    				return attr.name;
    			});
    			var viewAttrKeys = viewElement.getAttributeKeys();

    			// Add or overwrite attributes.
    			var _iteratorNormalCompletion4 = true;
    			var _didIteratorError4 = false;
    			var _iteratorError4 = undefined;

    			try {
    				for (var _iterator4 = viewAttrKeys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
    					var key = _step4.value;

    					domElement.setAttribute(key, viewElement.getAttribute(key));
    				}

    				// Remove from DOM attributes which do not exists in the view.
    			} catch (err) {
    				_didIteratorError4 = true;
    				_iteratorError4 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion4 && _iterator4.return) {
    						_iterator4.return();
    					}
    				} finally {
    					if (_didIteratorError4) {
    						throw _iteratorError4;
    					}
    				}
    			}

    			var _iteratorNormalCompletion5 = true;
    			var _didIteratorError5 = false;
    			var _iteratorError5 = undefined;

    			try {
    				for (var _iterator5 = domAttrKeys[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
    					var _key = _step5.value;

    					if (!viewElement.hasAttribute(_key)) {
    						domElement.removeAttribute(_key);
    					}
    				}
    			} catch (err) {
    				_didIteratorError5 = true;
    				_iteratorError5 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion5 && _iterator5.return) {
    						_iterator5.return();
    					}
    				} finally {
    					if (_didIteratorError5) {
    						throw _iteratorError5;
    					}
    				}
    			}
    		}

    		/**
       * Checks if elements child list needs to be updated and possibly updates it.
       *
       * @private
       * @param {engine.view.Element} viewElement View element to update.
       */

    	}, {
    		key: '_updateChildren',
    		value: function _updateChildren(viewElement) {
    			var domConverter = this.domConverter;
    			var domElement = domConverter.getCorrespondingDom(viewElement);
    			var domDocument = domElement.ownerDocument;

    			var filler = this._inlineFillerPosition;

    			var actualDomChildren = domElement.childNodes;
    			var expectedDomChildren = Array.from(domConverter.viewChildrenToDom(viewElement, domDocument, { bind: true }));

    			if (filler && filler.parent == viewElement) {
    				var expectedNodeAfterFiller = expectedDomChildren[filler.offset];

    				if (this.domConverter.isText(expectedNodeAfterFiller)) {
    					expectedNodeAfterFiller.data = INLINE_FILLER + expectedNodeAfterFiller.data;
    				} else {
    					expectedDomChildren.splice(filler.offset, 0, domDocument.createTextNode(INLINE_FILLER));
    				}
    			}

    			var actions = diff(actualDomChildren, expectedDomChildren, sameNodes);

    			var i = 0;

    			var _iteratorNormalCompletion6 = true;
    			var _didIteratorError6 = false;
    			var _iteratorError6 = undefined;

    			try {
    				for (var _iterator6 = actions[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
    					var action = _step6.value;

    					if (action === 'INSERT') {
    						insertAt(domElement, i, expectedDomChildren[i]);
    						i++;
    					} else if (action === 'DELETE') {
    						remove$2(actualDomChildren[i]);
    					} else {
    						// 'EQUAL'
    						i++;
    					}
    				}
    			} catch (err) {
    				_didIteratorError6 = true;
    				_iteratorError6 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion6 && _iterator6.return) {
    						_iterator6.return();
    					}
    				} finally {
    					if (_didIteratorError6) {
    						throw _iteratorError6;
    					}
    				}
    			}

    			function sameNodes(actualDomChild, expectedDomChild) {
    				// Elements.
    				if (actualDomChild === expectedDomChild) {
    					return true;
    				}
    				// Texts.
    				else if (domConverter.isText(actualDomChild) && domConverter.isText(expectedDomChild)) {
    						return actualDomChild.data === expectedDomChild.data;
    					}
    					// Block fillers.
    					else if (isBlockFiller(actualDomChild, domConverter.blockFiller) && isBlockFiller(expectedDomChild, domConverter.blockFiller)) {
    							return true;
    						}

    				// Not matching types.
    				return false;
    			}
    		}

    		/**
       * Checks if selection needs to be updated and possibly updates it.
       *
       * @private
       */

    	}, {
    		key: '_updateSelection',
    		value: function _updateSelection() {
    			// If there is no selection - remove it from DOM elements that belongs to the editor.
    			if (this.selection.rangeCount === 0) {
    				this._removeDomSelction();

    				return;
    			}

    			if (!this.isFocused) {
    				return;
    			}

    			var selectedEditable = this.selection.getEditableElement();
    			var domRoot = this.domConverter.getCorrespondingDomElement(selectedEditable);

    			if (!domRoot) {
    				return;
    			}

    			var domSelection = domRoot.ownerDocument.defaultView.getSelection();
    			var oldViewSelection = domSelection && this.domConverter.domSelectionToView(domSelection);

    			if (oldViewSelection && this.selection.isEqual(oldViewSelection)) {
    				return;
    			}

    			domSelection.removeAllRanges();

    			var _iteratorNormalCompletion7 = true;
    			var _didIteratorError7 = false;
    			var _iteratorError7 = undefined;

    			try {
    				for (var _iterator7 = this.selection.getRanges()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
    					var range = _step7.value;

    					// Update ranges only in currently selected editable.
    					if (range.start.parent.getRoot() == selectedEditable) {
    						var domRangeStart = this.domConverter.viewPositionToDom(range.start);
    						var domRangeEnd = this.domConverter.viewPositionToDom(range.end);
    						var domRange = new Range();
    						domRange.setStart(domRangeStart.parent, domRangeStart.offset);
    						domRange.setEnd(domRangeEnd.parent, domRangeEnd.offset);
    						domSelection.addRange(domRange);
    					}
    				}
    			} catch (err) {
    				_didIteratorError7 = true;
    				_iteratorError7 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion7 && _iterator7.return) {
    						_iterator7.return();
    					}
    				} finally {
    					if (_didIteratorError7) {
    						throw _iteratorError7;
    					}
    				}
    			}
    		}
    	}, {
    		key: '_removeDomSelction',
    		value: function _removeDomSelction() {
    			var _iteratorNormalCompletion8 = true;
    			var _didIteratorError8 = false;
    			var _iteratorError8 = undefined;

    			try {
    				for (var _iterator8 = this.domDocuments[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
    					var doc = _step8.value;

    					var domSelection = doc.getSelection();

    					if (domSelection.rangeCount) {
    						var activeDomElement = doc.activeElement;
    						var viewElement = this.domConverter.getCorrespondingViewElement(activeDomElement);

    						if (activeDomElement && viewElement) {
    							doc.getSelection().removeAllRanges();
    						}
    					}
    				}
    			} catch (err) {
    				_didIteratorError8 = true;
    				_iteratorError8 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion8 && _iterator8.return) {
    						_iterator8.return();
    					}
    				} finally {
    					if (_didIteratorError8) {
    						throw _iteratorError8;
    					}
    				}
    			}
    		}

    		/**
       * Checks if focus needs to be updated and possibly updates it.
       *
       * @private
       */

    	}, {
    		key: '_updateFocus',
    		value: function _updateFocus() {
    			if (this.isFocused) {
    				var editable = this.selection.getEditableElement();

    				if (editable) {
    					this.domConverter.focus(editable);
    				}
    			}
    		}
    	}]);
    	return Renderer;
    }();

    mix(Renderer, ObservableMixin);

    /**
     * Class representing a single root in the data view. A root can be either {@link #isReadOnly editable or read-only}, but
     * in both cases it is called "an editable". Roots can contain other {@link engine.view.EditableElement editable elements}
     * making them "nested editables".
     *
     * @memberOf engine.view
     * @extends engine.view.EditableElement
     */

    var RootEditableElement = function (_EditableElement) {
    	inherits(RootEditableElement, _EditableElement);

    	/**
      * Creates root editable element.
      *
      * @param {engine.view.Document} document {@link engine.view.Document} that is an owner of the root.
      * @param {String} name Node name.
      * @param {String} [rootName='main'] Root name inside parent {@link engine.view.Document}.
      */

    	function RootEditableElement(document, name) {
    		var rootName = arguments.length <= 2 || arguments[2] === undefined ? 'main' : arguments[2];
    		classCallCheck(this, RootEditableElement);


    		/**
       * Name of this root inside {@link engine.view.Document} that is an owner of this root.
       *
       * @readonly
       * @member {String} engine.view.RootEditableElement#rootName
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(RootEditableElement).call(this, document, name));

    		_this.rootName = rootName;
    		return _this;
    	}

    	return RootEditableElement;
    }(EditableElement);

    /**
     * Document class creates an abstract layer over the content editable area.
     * It combines the actual tree of view elements, tree of DOM elements,
     * {@link engine.view.DomConverter DOM Converter}, {@link engine.view.Renderer renderer} and all
     * {@link engine.view.Observer observers}.
     *
     * If you want to only transform the tree of view elements to the DOM elements you can use the
     * {@link engine.view.DomConverter DomConverter}.
     *
     * @memberOf engine.view
     * @mixes utils.EmitterMixin
     */

    var Document$1 = function () {
    	/**
      * Creates a Document instance.
      */

    	function Document() {
    		var _this = this;

    		classCallCheck(this, Document);

    		/**
       * Roots of the DOM tree. Map on the `HTMLElement`s with roots names as keys.
       *
       * @readonly
       * @member {Map} engine.view.Document#domRoots
       */
    		this.domRoots = new Map();

    		/**
       * Selection done on this document.
       *
       * @readonly
       * @member {engine.view.Selection} engine.view.Document#selection
       */
    		this.selection = new Selection();

    		/**
       * Tree View writer.
       *
       * @readonly
       * @member {engine.view.Writer} engine.view.Document#writer
       */
    		this.writer = new Writer();

    		/**
       * Instance of the {@link engine.view.DomConverter domConverter} use by
       * {@link engine.view.Document#renderer renderer} and {@link engine.view.observer.Observer observers}.
       *
       * @readonly
       * @member {engine.view.DomConverter} engine.view.Document#domConverter
       */
    		this.domConverter = new DomConverter();

    		/**
       * Roots of the view tree. Map of the {engine.view.Element view elements} with roots names as keys.
       *
       * @readonly
       * @member {Map} engine.view.Document#roots
       */
    		this.roots = new Map();

    		/**
       * True if document is focused.
       *
       * This property is updated by the {@link engine.view.obsever.FocusObserver}.
       * If the {@link engine.view.obsever.FocusObserver} is disabled this property will not change.
       *
       * @readonly
       * @observable
       * @member {Boolean} engine.view.Document#isFocused
       */
    		this.set('isFocused', false);

    		/**
       * Instance of the {@link engine.view.Document#renderer renderer}.
       *
       * @readonly
       * @member {engine.view.Renderer} engine.view.Document#renderer
       */
    		this.renderer = new Renderer(this.domConverter, this.selection);
    		this.renderer.bind('isFocused').to(this, 'isFocused');

    		/**
       * Map of registered {@link engine.view.Observer observers}.
       *
       * @private
       * @member {Map.<Function, engine.view.Observer>} engine.view.Document#_observers
       */
    		this._observers = new Map();

    		injectQuirksHandling(this);

    		// Listens `render` event on default priority.
    		// This way we can attach other listeners before or after rendering execution.
    		this.on('render', function () {
    			_this.disableObservers();
    			_this.renderer.render();
    			_this.enableObservers();
    		});
    	}

    	/**
      * Creates observer of the given type if not yet created, {@link engine.view.Observer#enable enables} it
      * and {@link engine.view.observer.Observer#observe attaches} to all existing and future
      * {@link engine.view.Document#domRoots DOM roots}.
      *
      * Note: Observers are recognized by their constructor (classes). A single observer will be instantiated and used only
      * when registered for the first time. This means that features and other components can register a single observer
      * multiple times without caring whether it has been already added or not.
      *
      * @param {Function} Observer The constructor of an observer to add.
      * Should create an instance inheriting from {@link engine.view.observer.Observer}.
      * @returns {engine.view.observer.Observer} Added observer instance.
      */


    	createClass(Document, [{
    		key: 'addObserver',
    		value: function addObserver(Observer) {
    			var observer = this._observers.get(Observer);

    			if (observer) {
    				return observer;
    			}

    			observer = new Observer(this);

    			this._observers.set(Observer, observer);

    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = this.domRoots[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var _step$value = slicedToArray(_step.value, 2);

    					var name = _step$value[0];
    					var domElement = _step$value[1];

    					observer.observe(domElement, name);
    				}
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}

    			observer.enable();

    			return observer;
    		}

    		/**
       * Returns observer of the given type or `undefined` if such observer has not been added yet.
       *
       * @param {Function} Observer The constructor of an observer to get.
       * @returns {engine.view.observer.Observer|undefined} Observer instance or undefined.
       */

    	}, {
    		key: 'getObserver',
    		value: function getObserver(Observer) {
    			return this._observers.get(Observer);
    		}

    		/**
       * Creates a {@link engine.view.Document#roots view root element}.
       *
       * If the DOM element is passed as a first parameter it will be automatically
       * {@link engine.view.Document#attachDomRoot attached}:
       *
       *		document.createRoot( document.querySelector( 'div#editor' ) ); // Will call document.attachDomRoot.
       *
       * However, if the string is passed, then only the view element will be created and the DOM element have to be
       * attached separately:
       *
       *		document.createRoot( 'body' );
       *		document.attachDomRoot( document.querySelector( 'body#editor' ) );
       *
       * @param {Element|String} domRoot DOM root element or the tag name of view root element if the DOM element will be
       * attached later.
       * @param {String} [name='main'] Name of the root.
       * @returns {engine.view.RootEditableElement} The created view root element.
       */

    	}, {
    		key: 'createRoot',
    		value: function createRoot(domRoot) {
    			var _this2 = this;

    			var name = arguments.length <= 1 || arguments[1] === undefined ? 'main' : arguments[1];

    			var rootTag = typeof domRoot == 'string' ? domRoot : domRoot.tagName;

    			var viewRoot = new RootEditableElement(this, rootTag, name);

    			this.roots.set(name, viewRoot);

    			// Mark changed nodes in the renderer.
    			viewRoot.on('change:children', function (evt, node) {
    				return _this2.renderer.markToSync('children', node);
    			});
    			viewRoot.on('change:attributes', function (evt, node) {
    				return _this2.renderer.markToSync('attributes', node);
    			});
    			viewRoot.on('change:text', function (evt, node) {
    				return _this2.renderer.markToSync('text', node);
    			});

    			if (this.domConverter.isElement(domRoot)) {
    				this.attachDomRoot(domRoot, name);
    			}

    			return viewRoot;
    		}

    		/**
       * Attaches DOM root element to the view element and enable all observers on that element. This method also
       * {@link engine.view.Renderer#markToSync mark element} to be synchronized with the view what means that all child
       * nodes will be removed and replaced with content of the view root.
       *
       * Note that {@link engine.view.Document#createRoot} will call this method automatically if the DOM element is
       * passed to it.
       *
       * @param {Element|String} domRoot DOM root element.
       * @param {String} [name='main'] Name of the root.
       */

    	}, {
    		key: 'attachDomRoot',
    		value: function attachDomRoot(domRoot) {
    			var name = arguments.length <= 1 || arguments[1] === undefined ? 'main' : arguments[1];

    			var viewRoot = this.getRoot(name);

    			this.domRoots.set(name, domRoot);

    			this.domConverter.bindElements(domRoot, viewRoot);

    			this.renderer.markToSync('children', viewRoot);
    			this.renderer.domDocuments.add(domRoot.ownerDocument);

    			var _iteratorNormalCompletion2 = true;
    			var _didIteratorError2 = false;
    			var _iteratorError2 = undefined;

    			try {
    				for (var _iterator2 = this._observers.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    					var observer = _step2.value;

    					observer.observe(domRoot, name);
    				}
    			} catch (err) {
    				_didIteratorError2 = true;
    				_iteratorError2 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion2 && _iterator2.return) {
    						_iterator2.return();
    					}
    				} finally {
    					if (_didIteratorError2) {
    						throw _iteratorError2;
    					}
    				}
    			}
    		}

    		/**
       * Gets a {@link engine.view.Document#roots view root element} with the specified name. If the name is not
       * specific "main" root is returned.
       *
       * @param {String} [name='main'] Name of the root.
       * @returns {engine.view.RootEditableElement} The view root element with the specified name.
       */

    	}, {
    		key: 'getRoot',
    		value: function getRoot() {
    			var name = arguments.length <= 0 || arguments[0] === undefined ? 'main' : arguments[0];

    			return this.roots.get(name);
    		}

    		/**
       * Gets DOM root element.
       *
       * @param {String} [name='main']  Name of the root.
       * @returns {Element} DOM root element instance.
       */

    	}, {
    		key: 'getDomRoot',
    		value: function getDomRoot() {
    			var name = arguments.length <= 0 || arguments[0] === undefined ? 'main' : arguments[0];

    			return this.domRoots.get(name);
    		}

    		/**
       * Renders all changes. In order to avoid triggering the observers (e.g. mutations) all observers are disabled
       * before rendering and re-enabled after that.
       *
       * @fires engine.view.Document#render
       */

    	}, {
    		key: 'render',
    		value: function render() {
    			this.fire('render');
    		}

    		/**
       * Focuses document. It will focus {@link engine.view.EditableElement EditableElement} that is currently having
       * selection inside.
       */

    	}, {
    		key: 'focus',
    		value: function focus() {
    			if (!this.isFocused) {
    				var editable = this.selection.getEditableElement();

    				if (editable) {
    					this.domConverter.focus(editable);
    					this.render();
    				} else {
    					/**
          * Before focusing view document, selection should be placed inside one of the view's editables.
          * Normally its selection will be converted from model document (which have default selection), but
          * when using view document on its own, we need to manually place selection before focusing it.
          *
          * @error view-focus-no-selection
          */
    					log.warn('view-focus-no-selection: There is no selection in any editable to focus.');
    				}
    			}
    		}

    		/**
       * Disables all added observers.
       */

    	}, {
    		key: 'disableObservers',
    		value: function disableObservers() {
    			var _iteratorNormalCompletion3 = true;
    			var _didIteratorError3 = false;
    			var _iteratorError3 = undefined;

    			try {
    				for (var _iterator3 = this._observers.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
    					var observer = _step3.value;

    					observer.disable();
    				}
    			} catch (err) {
    				_didIteratorError3 = true;
    				_iteratorError3 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion3 && _iterator3.return) {
    						_iterator3.return();
    					}
    				} finally {
    					if (_didIteratorError3) {
    						throw _iteratorError3;
    					}
    				}
    			}
    		}

    		/**
       * Enables all added observers.
       */

    	}, {
    		key: 'enableObservers',
    		value: function enableObservers() {
    			var _iteratorNormalCompletion4 = true;
    			var _didIteratorError4 = false;
    			var _iteratorError4 = undefined;

    			try {
    				for (var _iterator4 = this._observers.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
    					var observer = _step4.value;

    					observer.enable();
    				}
    			} catch (err) {
    				_didIteratorError4 = true;
    				_iteratorError4 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion4 && _iterator4.return) {
    						_iterator4.return();
    					}
    				} finally {
    					if (_didIteratorError4) {
    						throw _iteratorError4;
    					}
    				}
    			}
    		}
    	}]);
    	return Document;
    }();

    mix(Document$1, ObservableMixin);

    /**
     * Abstract base observer class. Observers are classes which observe changes on DOM elements, do the preliminary
     * processing and fire events on the {@link engine.view.Document} objects. Observers can also add features to the view,
     * for instance by updating its status or marking elements which need refresh on DOM events.
     *
     * @abstract
     * @memberOf engine.view.observer
     */

    var Observer = function () {
    	/**
      * Creates an instance of the observer.
      *
      * @param {engine.view.Document} document
      */

    	function Observer(document) {
    		classCallCheck(this, Observer);

    		/**
       * Reference to the {@link engine.view.Document} object.
       *
       * @readonly
       * @member {engine.view.Document} engine.view.observer.Observer#document
       */
    		this.document = document;

    		/**
       * State of the observer. If it is disabled events will not be fired.
       *
       * @readonly
       * @member {Boolean} engine.view.observer.Observer#isEnabled
       */
    		this.isEnabled = false;
    	}

    	/**
      * Enables the observer. This method is called when then observer is registered to the
      * {@link engine.view.Document} and after {@link engine.view.Document#render rendering}
      * (all observers are {@link engine.view.observer.Observer#disable disabled} before rendering).
      *
      * A typical use case for disabling observers is that mutation observers need to be disabled for the rendering.
      * However, a child class may not need to be disabled, so it can implement an empty method.
      *
      * @see engine.view.observer.Observer#disable
      */


    	createClass(Observer, [{
    		key: 'enable',
    		value: function enable() {
    			this.isEnabled = true;
    		}

    		/**
       * Disables the observer. This method is called before
       * {@link engine.view.Document#render rendering} to prevent firing events during rendering.
       *
       * @see engine.view.observer.Observer#enable
       */

    	}, {
    		key: 'disable',
    		value: function disable() {
    			this.isEnabled = false;
    		}

    		/**
       * Starts observing the given root element.
       *
       * @method engine.view.observer.Observer#observe
       * @param {HTMLElement} domElement
       * @param {String} name The name of the root element.
       */

    	}]);
    	return Observer;
    }();

    /**
     * Mutation observer class observes changes in the DOM, fires {@link engine.view.Document#mutations} event, mark view elements
     * as changed and call {@link engine.view.render}. Because all mutated nodes are marked as "to be rendered" and the
     * {@link engine.view.render} is called, all changes will be reverted, unless the mutation will be handled by the
     * {@link engine.view.Document#mutations} event listener. It means user will see only handled changes, and the editor will
     * block all changes which are not handled.
     *
     * Mutation Observer also take care of reducing number of mutations which are fired. It removes duplicates and
     * mutations on elements which do not have corresponding view elements. Also
     * {@link engine.view.Document.MutatatedText text mutation} is fired only if parent element do not change child list.
     *
     * Note that this observer is attached by the {@link engine.EditingController} and is available by default.
     *
     * @memberOf engine.view.observer
     * @extends engine.view.observer.Observer
     */

    var MutationObserver = function (_Observer) {
    	inherits(MutationObserver, _Observer);

    	function MutationObserver(document) {
    		classCallCheck(this, MutationObserver);


    		/**
       * Native mutation observer config.
       *
       * @private
       * @member {Object} engine.view.observer.MutationObserver#_config
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(MutationObserver).call(this, document));

    		_this._config = {
    			childList: true,
    			characterData: true,
    			characterDataOldValue: true,
    			subtree: true
    		};

    		/**
       * Reference to the {@link engine.view.Document#domConverter}.
       *
       * @member {engine.view.DomConverter} engine.view.observer.MutationObserver#domConverter
       */
    		_this.domConverter = document.domConverter;

    		/**
       * Reference to the {@link engine.view.Document#renderer}.
       *
       * @member {engine.view.Renderer} engine.view.observer.MutationObserver#renderer
       */
    		_this.renderer = document.renderer;

    		/**
       * Observed DOM elements.
       *
       * @private
       * @member {Array.<HTMLElement>} engine.view.observer.MutationObserver#_domElements
       */
    		_this._domElements = [];

    		/**
       * Native mutation observer.
       *
       * @private
       * @member {MutationObserver} engine.view.observer.MutationObserver#_mutationObserver
       */
    		_this._mutationObserver = new window.MutationObserver(_this._onMutations.bind(_this));
    		return _this;
    	}

    	/**
      * Synchronously fires {@link engine.view.Document#mutations} event with all mutations in record queue.
      * At the same time empties the queue so mutations will not be fired twice.
      */


    	createClass(MutationObserver, [{
    		key: 'flush',
    		value: function flush() {
    			this._onMutations(this._mutationObserver.takeRecords());
    		}

    		/**
       * @inheritDoc
       */

    	}, {
    		key: 'observe',
    		value: function observe(domElement) {
    			this._domElements.push(domElement);

    			if (this.isEnabled) {
    				this._mutationObserver.observe(domElement, this._config);
    			}
    		}

    		/**
       * @inheritDoc
       */

    	}, {
    		key: 'enable',
    		value: function enable() {
    			get(Object.getPrototypeOf(MutationObserver.prototype), 'enable', this).call(this);

    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = this._domElements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var domElement = _step.value;

    					this._mutationObserver.observe(domElement, this._config);
    				}
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}
    		}

    		/**
       * @inheritDoc
       */

    	}, {
    		key: 'disable',
    		value: function disable() {
    			get(Object.getPrototypeOf(MutationObserver.prototype), 'disable', this).call(this);

    			this._mutationObserver.disconnect();
    		}

    		/**
       * Handles mutations. Deduplicates, mark view elements to sync, fire event and call render.
       *
       * @private
       * @method engine.view.observer.MutationObserver#_onMutations
       * @param {Array.<Object>} domMutations Array of native mutations.
       */

    	}, {
    		key: '_onMutations',
    		value: function _onMutations(domMutations) {
    			// As a result of this.flush() we can have an empty collection.
    			if (domMutations.length === 0) {
    				return;
    			}

    			var domConverter = this.domConverter;

    			// Use　map and set for deduplication.
    			var mutatedTexts = new Map();
    			var mutatedElements = new Set();

    			// Handle `childList` mutations first, so we will be able to check if the `characterData` mutation is in the
    			// element with changed structure anyway.
    			var _iteratorNormalCompletion2 = true;
    			var _didIteratorError2 = false;
    			var _iteratorError2 = undefined;

    			try {
    				for (var _iterator2 = domMutations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    					var mutation = _step2.value;

    					if (mutation.type === 'childList') {
    						var element = domConverter.getCorrespondingViewElement(mutation.target);

    						if (element) {
    							mutatedElements.add(element);
    						}
    					}
    				}

    				// Handle `characterData` mutations later, when we have the full list of nodes which changed structure.
    			} catch (err) {
    				_didIteratorError2 = true;
    				_iteratorError2 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion2 && _iterator2.return) {
    						_iterator2.return();
    					}
    				} finally {
    					if (_didIteratorError2) {
    						throw _iteratorError2;
    					}
    				}
    			}

    			var _iteratorNormalCompletion3 = true;
    			var _didIteratorError3 = false;
    			var _iteratorError3 = undefined;

    			try {
    				for (var _iterator3 = domMutations[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
    					var _mutation = _step3.value;

    					if (_mutation.type === 'characterData') {
    						var text = domConverter.getCorrespondingViewText(_mutation.target);

    						if (text && !mutatedElements.has(text.parent)) {
    							// Use text as a key, for deduplication. If there will be another mutation on the same text element
    							// we will have only one in the map.
    							mutatedTexts.set(text, {
    								type: 'text',
    								oldText: text.data,
    								newText: getDataWithoutFiller(_mutation.target),
    								node: text
    							});
    						}
    						// When we added first letter to the text node which had only inline filler, for the DOM it is mutation
    						// on text, but for the view, where filler text node did not existed, new text node was created, so we
    						// need to fire 'children' mutation instead of 'text'.
    						else if (!text && startsWithFiller(_mutation.target)) {
    								mutatedElements.add(domConverter.getCorrespondingViewElement(_mutation.target.parentNode));
    							}
    					}
    				}

    				// Now we build the list of mutations to fire and mark elements. We did not do it earlier to avoid marking the
    				// same node multiple times in case of duplication.

    				// List of mutations we will fire.
    			} catch (err) {
    				_didIteratorError3 = true;
    				_iteratorError3 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion3 && _iterator3.return) {
    						_iterator3.return();
    					}
    				} finally {
    					if (_didIteratorError3) {
    						throw _iteratorError3;
    					}
    				}
    			}

    			var viewMutations = [];

    			var _iteratorNormalCompletion4 = true;
    			var _didIteratorError4 = false;
    			var _iteratorError4 = undefined;

    			try {
    				for (var _iterator4 = mutatedTexts.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
    					var mutatedText = _step4.value;

    					this.renderer.markToSync('text', mutatedText.node);
    					viewMutations.push(mutatedText);
    				}
    			} catch (err) {
    				_didIteratorError4 = true;
    				_iteratorError4 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion4 && _iterator4.return) {
    						_iterator4.return();
    					}
    				} finally {
    					if (_didIteratorError4) {
    						throw _iteratorError4;
    					}
    				}
    			}

    			var _iteratorNormalCompletion5 = true;
    			var _didIteratorError5 = false;
    			var _iteratorError5 = undefined;

    			try {
    				for (var _iterator5 = mutatedElements[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
    					var viewElement = _step5.value;

    					var domElement = domConverter.getCorrespondingDomElement(viewElement);
    					var viewChildren = viewElement.getChildren();
    					var newViewChildren = domConverter.domChildrenToView(domElement);

    					this.renderer.markToSync('children', viewElement);
    					viewMutations.push({
    						type: 'children',
    						oldChildren: Array.from(viewChildren),
    						newChildren: Array.from(newViewChildren),
    						node: viewElement
    					});
    				}
    			} catch (err) {
    				_didIteratorError5 = true;
    				_iteratorError5 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion5 && _iterator5.return) {
    						_iterator5.return();
    					}
    				} finally {
    					if (_didIteratorError5) {
    						throw _iteratorError5;
    					}
    				}
    			}

    			this.document.fire('mutations', viewMutations);

    			this.document.render();
    		}
    	}]);
    	return MutationObserver;
    }(Observer);

    /**
     * Selection observer class observes selection changes in the document. If selection changes on the document this
     * observer checks if there are any mutations and if DOM selection is different than the
     * {@link engine.view.Document#selection view selection}. Selection observer fires
     * {@link engine.view.Document#selectionChange} event only if selection change was the only change in the document
     * and DOM selection is different then the view selection.
     *
     * Note that this observer is attached by the {@link engine.EditingController} and is available by default.
     *
     * @see engine.view.MutationObserver
     * @memberOf engine.view.observer
     * @extends engine.view.observer.Observer
     */

    var SelectionObserver = function (_Observer) {
    	inherits(SelectionObserver, _Observer);

    	function SelectionObserver(document) {
    		classCallCheck(this, SelectionObserver);


    		/**
       * Instance of the mutation observer. Selection observer calls
       * {@link engine.view.observer.MutationObserver#flush} to ensure that the mutations will be handled before the
       * {@link engine.view.Document#selectionChange} event is fired.
       *
       * @readonly
       * @member {engine.view.observer.MutationObserver} engine.view.observer.SelectionObserver#mutationObserver
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(SelectionObserver).call(this, document));

    		_this.mutationObserver = document.getObserver(MutationObserver);

    		/**
       * Reference to the {@link engine.view.Document} object.
       *
       * @readonly
       * @member {engine.view.Document} engine.view.observer.SelectionObserver#document
       */
    		_this.document = document;

    		/**
       * Reference to the view {@link engine.view.Selection} object used to compare new selection with it.
       *
       * @readonly
       * @member {engine.view.Selection} engine.view.observer.SelectionObserver#selection
       */
    		_this.selection = document.selection;

    		/**
       * Reference to the {@link engine.view.Document#domConverter}.
       *
       * @readonly
       * @member {engine.view.DomConverter} engine.view.observer.SelectionObserver#domConverter
       */
    		_this.domConverter = document.domConverter;

    		/**
       * Set of documents which have added "selectionchange" listener to avoid adding listener twice to the same
       * document.
       *
       * @private
       * @member {WeakSet.<Document>} engine.view.observer.SelectionObserver#_documents
       */
    		_this._documents = new WeakSet();

    		/**
       * Private property to store the last selection, to check if the code does not enter infinite loop.
       *
       * @private
       * @member {engine.view.Selection} engine.view.observer.SelectionObserver#_lastSelection
       */

    		/**
       * Private property to store the last but one selection, to check if the code does not enter infinite loop.
       *
       * @private
       * @member {engine.view.Selection} engine.view.observer.SelectionObserver#_lastButOneSelection
       */

    		/**
       * Private property to check if the code does not enter infinite loop.
       *
       * @private
       * @member {Number} engine.view.observer.SelectionObserver#_loopbackCounter
       */
    		return _this;
    	}

    	/**
      * @inheritDoc
      */


    	createClass(SelectionObserver, [{
    		key: 'observe',
    		value: function observe(domElement) {
    			var _this2 = this;

    			var domDocument = domElement.ownerDocument;

    			// Add listener once per each document.
    			if (this._documents.has(domDocument)) {
    				return;
    			}

    			domDocument.addEventListener('selectionchange', function () {
    				return _this2._handleSelectionChange(domDocument);
    			});

    			this._documents.add(domDocument);
    		}

    		/**
       * Selection change listener. {@link engine.view.observer.MutationObserver#flush Flush} mutations, check if
       * selection changes and fires {@link engine.view.Document#selectionChange} event.
       *
       * @private
       * @param {Document} domDocument DOM document.
       */

    	}, {
    		key: '_handleSelectionChange',
    		value: function _handleSelectionChange(domDocument) {
    			if (!this.isEnabled || !this.document.isFocused) {
    				return;
    			}

    			// Ensure the mutation event will be before selection event on all browsers.
    			this.mutationObserver.flush();

    			// If there were mutations then the view will be re-rendered by the mutation observer and selection
    			// will be updated, so selections will equal and event will not be fired, as expected.
    			var domSelection = domDocument.defaultView.getSelection();

    			var newViewSelection = this.domConverter.domSelectionToView(domSelection);

    			if (this.selection.isEqual(newViewSelection)) {
    				return;
    			}

    			// Ensure we are not in the infinite loop (#400).
    			if (this._isInfiniteLoop(newViewSelection)) {
    				/**
         * Selection change observer detected an infinite rendering loop.
         * Most probably you try to put the selection in the position which is not allowed
         * by the browser and browser fixes it automatically what causes `selectionchange` event on
         * which a loopback through a model tries to re-render the wrong selection and again.
         *
         * @error selectionchange-infinite-loop
         */
    				log.warn('selectionchange-infinite-loop: Selection change observer detected an infinite rendering loop.');

    				return;
    			}

    			// Should be fired only when selection change was the only document change.
    			this.document.fire('selectionChange', {
    				oldSelection: this.selection,
    				newSelection: newViewSelection,
    				domSelection: domSelection
    			});

    			this.document.render();
    		}

    		/**
       * Checks if selection rendering entered an infinite loop.
       *
       * See https://github.com/ckeditor/ckeditor5-engine/issues/400.
       *
       * @private
       * @param {engine.view.Selection} newSelection DOM selection converted to view.
       * @returns {Boolean} True is the same selection repeat more then 10 times.
       */

    	}, {
    		key: '_isInfiniteLoop',
    		value: function _isInfiniteLoop(newSelection) {
    			// If the position is the same a the last one or the last but one we increment the counter.
    			// We need to check last two selections because the browser will first fire a selectionchange event
    			// for an incorrect selection and then for a corrected one.
    			if (this._lastSelection && this._lastButOneSelection && (newSelection.isEqual(this._lastSelection) || newSelection.isEqual(this._lastButOneSelection))) {
    				this._loopbackCounter++;
    			} else {
    				this._lastButOneSelection = this._lastSelection;
    				this._lastSelection = newSelection;
    				this._loopbackCounter = 0;
    			}

    			if (this._loopbackCounter > 10) {
    				return true;
    			}

    			return false;
    		}
    	}]);
    	return SelectionObserver;
    }(Observer);

    /**
     * Information about a DOM event in context of the {@link engine.view.Document}.
     * It wraps the native event, which usually should not be used as the wrapper contains
     * additional data (like key code for keyboard events).
     *
     * @memberOf engine.view.observer
     */

    var DomEventData = function () {
    	/**
      * @param {engine.view.Document} document The instance of the tree view Document.
      * @param {Event} domEvent The DOM event.
      * @param {Object} [additionalData] Additional properties that the instance should contain.
      */

    	function DomEventData(document, domEvent, additionalData) {
    		classCallCheck(this, DomEventData);

    		/**
       * The instance of the document.
       *
       * @readonly
       * @member {engine.view.Document} engine.view.observer.DomEvent#view
       */
    		this.document = document;

    		/**
       * The DOM event.
       *
       * @readonly
       * @member {Event} engine.view.observer.DomEvent#domEvent
       */
    		this.domEvent = domEvent;

    		/**
       * The DOM target.
       *
       * @readonly
       * @member {HTMLElement} engine.view.observer.DomEvent#target
       */
    		this.domTarget = domEvent.target;

    		assignIn(this, additionalData);
    	}

    	/**
      * The tree view element representing the target.
      *
      * @readonly
      * @type engine.view.Element
      */


    	createClass(DomEventData, [{
    		key: 'preventDefault',


    		/**
       * Prevents the native's event default action.
       */
    		value: function preventDefault() {
    			this.domEvent.preventDefault();
    		}

    		/**
       * Stops native event propagation.
       */

    	}, {
    		key: 'stopPropagation',
    		value: function stopPropagation() {
    			this.domEvent.stopPropagation();
    		}
    	}, {
    		key: 'target',
    		get: function get() {
    			return this.document.domConverter.getCorrespondingViewElement(this.domTarget);
    		}
    	}]);
    	return DomEventData;
    }();

    /**
     * Base class for DOM event observers. This class handles
     * {@link engine.view.observer.Observer#observe adding} listeners to DOM elements,
     * {@link engine.view.observer.Observer#disable disabling} and
     * {@link engine.view.observer.Observer#enable re-enabling} events.
     * Child class needs to define
     * {@link engine.view.observer.DomEventObserver#domEventType DOM event type} and
     * {@link engine.view.observer.DomEventObserver#onDomEvent callback}.
     *
     * For instance:
     *
     *		class ClickObserver extends DomEventObserver {
     *			// It can also be defined as a normal property in the constructor.
     *			get domEventType() {
     *				return 'click';
     *			}
     *
     *			onDomEvent( domEvt ) {
     *				this.fire( 'click' );
     *			}
     *		}
     *
     * @memberOf engine.view.observer
     * @extends engine.view.observer.Observer
     */

    var DomEventObserver = function (_Observer) {
    	inherits(DomEventObserver, _Observer);

    	function DomEventObserver() {
    		classCallCheck(this, DomEventObserver);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(DomEventObserver).apply(this, arguments));
    	}

    	createClass(DomEventObserver, [{
    		key: 'observe',

    		/**
       * Type of the DOM event the observer should listen on. Array of types can be defined
       * if the obsever should listen to multiple DOM events.
       *
       * @readonly
       * @member {String|Array.<String>} engine.view.observer.DomEventObserver#domEventType
       */

    		/**
       * Callback which should be called when the DOM event occurred. Note that the callback will not be called if
       * observer {@link engine.view.observer.DomEventObserver#isEnabled is not enabled}.
       *
       * @see engine.view.observer.DomEventObserver#domEventType
       * @abstract
       * @method engine.view.observer.DomEventObserver#onDomEvent
       */

    		/**
       * @inheritDoc
       */
    		value: function observe(domElement) {
    			var _this2 = this;

    			var types = typeof this.domEventType == 'string' ? [this.domEventType] : this.domEventType;

    			types.forEach(function (type) {
    				domElement.addEventListener(type, function (domEvent) {
    					return _this2.isEnabled && _this2.onDomEvent(domEvent);
    				});
    			});
    		}

    		/**
       * Calls {@link engine.view.Document#fire} if observer
       * {@link engine.view.observer.DomEventObserver#isEnabled is enabled}.
       *
       * @see engine.view.Document#fire
       * @param {String} eventType The event type (name).
       * @param {Event} domEvent The DOM event.
       * @param {Object} [additionalData] The additional data which should extend the
       * {@link engine.view.observer.DomEventData event data} object.
       */

    	}, {
    		key: 'fire',
    		value: function fire(eventType, domEvent, additionalData) {
    			if (this.isEnabled) {
    				this.document.fire(eventType, new DomEventData(this.document, domEvent, additionalData));
    			}
    		}
    	}]);
    	return DomEventObserver;
    }(Observer);

    /**
     * {@link engine.view.Document#focus Focus} and {@link engine.view.Document#blur blur} events observer.
     * Focus observer handle also {@link engine.view.RootEditableElement#isFocused isFocused} property of the
     * {@link engine.view.RootEditableElement root elements}.
     *
     * Note that this observer is attached by the {@link engine.EditingController} and is available by default.
     *
     * @memberOf engine.view.observer
     * @extends engine.view.observer.DomEventObserver
     */

    var FocusObserver = function (_DomEventObserver) {
      inherits(FocusObserver, _DomEventObserver);

      function FocusObserver(document) {
        classCallCheck(this, FocusObserver);

        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(FocusObserver).call(this, document));

        _this.domEventType = ['focus', 'blur'];

        document.on('focus', function () {
          document.isFocused = true;
        });

        document.on('blur', function (evt, data) {
          var selectedEditable = document.selection.getEditableElement();

          if (selectedEditable === null || selectedEditable === data.target) {
            document.isFocused = false;
          }
        });
        return _this;
      }

      createClass(FocusObserver, [{
        key: 'onDomEvent',
        value: function onDomEvent(domEvent) {
          this.fire(domEvent.type, domEvent);
        }
      }]);
      return FocusObserver;
    }(DomEventObserver);

    /**
     * {@link engine.view.Document#keydown Key down} event observer.
     *
     * Note that this observer is attached by the {@link engine.EditingController} and is available by default.
     *
     * @memberOf engine.view.observer
     * @extends engine.view.observer.DomEventObserver
     */

    var KeyObserver = function (_DomEventObserver) {
      inherits(KeyObserver, _DomEventObserver);

      function KeyObserver(document) {
        classCallCheck(this, KeyObserver);

        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(KeyObserver).call(this, document));

        _this.domEventType = 'keydown';
        return _this;
      }

      createClass(KeyObserver, [{
        key: 'onDomEvent',
        value: function onDomEvent(domEvt) {
          this.fire('keydown', domEvt, {
            keyCode: domEvt.keyCode,

            altKey: domEvt.altKey,
            ctrlKey: domEvt.ctrlKey || domEvt.metaKey,
            shiftKey: domEvt.shiftKey,

            get keystroke() {
              return getCode(this);
            }
          });
        }
      }]);
      return KeyObserver;
    }(DomEventObserver);

    /**
     * Contains {@link engine.view.Selection view selection} to {@link engine.model.Selection model selection} conversion
     * helper.
     *
     * @namespace engine.conversion.viewSelectionToModel
     */

    /**
     * Function factory, creates a callback function which converts a {@link engine.view.Selection view selection} taken
     * from the {@link engine.view.Document#selectionChange} event and set in on the
     * {@link engine.model.Document#selection model}.
     *
     * Note that because there is not view selection change dispatcher nor any other advance view selection to model
     * conversion mechanism, this method is simple event listener.
     *
     *		view.document.on( 'selectionChange', convertSelectionChange( model, mapper ) );
     *
     * @function engine.conversion.viewSelectionToModel.convertSelectionChange
     * @param {engine.model.Document} model Document model on which selection should be updated.
     * @param {engine.conversion.Mapper} mapper Conversion mapper.
     * @returns {Function} {@link engine.view.Document#selectionChange} callback function.
     */

    function convertSelectionChange(model, mapper) {
      return function (evt, data) {
        model.enqueueChanges(function () {
          var viewSelection = data.newSelection;

          model.selection.removeAllRanges();

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = viewSelection.getRanges()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var viewRange = _step.value;

              var modelRange = mapper.toModelRange(viewRange);
              model.selection.addRange(modelRange, viewSelection.isBackward);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        });
      };
    }

    /**
     * Contains {@link engine.model.Selection model selection} to {@link engine.view.Selection view selection} converters for
     * {@link engine.conversion.ModelConversionDispatcher}.
     *
     * @namespace engine.conversion.modelSelectionToView
     */

    /**
     * Function factory, creates a converter that converts non-collapsed {@link engine.model.Selection model selection} to
     * {@link engine.view.Selection view selection}. The converter consumes appropriate value from `consumable` object
     * and maps model positions from selection to view positions.
     *
     *		modelDispatcher.on( 'selection', convertRangeSelection() );
     *
     * @external engine.conversion.modelSelectionToView
     * @function engine.conversion.modelSelectionToView.convertRangeSelection
     * @returns {Function} Selection converter.
     */
    function convertRangeSelection() {
      return function (evt, data, consumable, conversionApi) {
        var selection = data.selection;

        if (selection.isCollapsed) {
          return;
        }

        if (!consumable.consume(selection, 'selection')) {
          return;
        }

        conversionApi.viewSelection.removeAllRanges();

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = selection.getRanges()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var range = _step.value;

            var viewRange = conversionApi.mapper.toViewRange(range);
            conversionApi.viewSelection.addRange(viewRange, selection.isBackward);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      };
    }

    /**
     * Function factory, creates a converter that converts collapsed {@link engine.model.Selection model selection} to
     * {@link engine.view.Selection view selection}. The converter consumes appropriate value from `consumable` object,
     * maps model selection position to view position and breaks {@link engine.view.AttributeElement attribute elements}
     * at the selection position.
     *
     *		modelDispatcher.on( 'selection', convertCollapsedSelection() );
     *
     * Example of view state before and after converting collapsed selection:
     *
     *		<p><strong>f^oo<strong>bar</p>
     *		-> <p><strong>f</strong>^<strong>oo</strong>bar</p>
     *
     * By breaking attribute elements like `<strong>` selection is in correct elements. See also complementary
     * {@link engine.conversion.modelSelectionToView.convertSelectionAttribute attribute converter} for selection attributes,
     * which wraps collapsed selection into view elements. Those converters together ensure, that selection ends up in
     * appropriate elements.
     *
     * See also {@link engine.conversion.modelSelectionToView.clearAttributes} which do the clean-up by merging attributes.
     *
     * @external engine.conversion.modelSelectionToView
     * @function engine.conversion.modelSelectionToView.convertCollapsedSelection
     * @returns {Function} Selection converter.
     */
    function convertCollapsedSelection() {
      return function (evt, data, consumable, conversionApi) {
        var selection = data.selection;

        if (!selection.isCollapsed) {
          return;
        }

        if (!consumable.consume(selection, 'selection')) {
          return;
        }

        var modelPosition = selection.getFirstPosition();
        var viewPosition = conversionApi.mapper.toViewPosition(modelPosition);
        var brokenPosition = conversionApi.writer.breakAttributes(viewPosition);

        conversionApi.viewSelection.removeAllRanges();
        conversionApi.viewSelection.addRange(new Range$2(brokenPosition, brokenPosition));
      };
    }

    /**
     * Function factory, creates a converter that converts {@link engine.model.Selection model selection} attributes to
     * {@link engine.view.AttributeElement view attribute elements}. The converter works only for collapsed selection.
     * The converter consumes appropriate value from `consumable` object, maps model selection position to view position and
     * wraps that position into a view attribute element.
     *
     * The wrapping node depends on passed parameter. If {@link engine.view.Element} was passed, it will be cloned and
     * the copy will become the wrapping element. If `Function` is provided, it is passed all the parameters of the
     * {@link engine.conversion.ModelConversionDispatcher#event:selectionAttribute selectionAttribute event}. It's expected that
     * the function returns a {@link engine.view.AttributeElement}. The result of the function will be the wrapping element.
     *
     *		modelDispatcher.on( 'selectionAttribute:italic', convertSelectionAttribute( new ViewAttributeElement( 'em' ) ) );
     *
     *		function styleElementCreator( styleValue ) {
     *			if ( styleValue == 'important' ) {
     *				return new ViewAttributeElement( 'strong', { style: 'text-transform:uppercase;' } );
     *			} else if ( styleValue == 'gold' ) {
     *				return new ViewAttributeElement( 'span', { style: 'color:yellow;' } );
     *			}
     *		}
     *		modelDispatcher.on( 'selectionAttribute:style', convertSelectionAttribute( styleCreator ) );
     *
     * **Note:** You can use the same `elementCreator` function for this converter factory and {@link engine.conversion.modelToView.wrap}
     * model to view converter, as long as the `elementCreator` function uses only the first parameter (attribute value).
     *
     * Example of view state after converting collapsed selection. The scenario is: selection is inside bold text (`<strong>` element)
     * but it does not have bold attribute itself, but has italic attribute instead (let's assume that user turned off bold and turned
     * on italic with selection collapsed):
     *
     *		modelDispatcher.on( 'selection', convertCollapsedSelection() );
     *		modelDispatcher.on( 'selectionAttribute:italic', convertSelectionAttribute( new ViewAttributeElement( 'em' ) ) );
     *
     * Example of view states before and after converting collapsed selection:
     *
     *		<p><em>f^oo</em>bar</p>
     *		-> <p><em>f</em>^<em>oo</em>bar</p>
     *		-> <p><em>f^oo</em>bar</p>
     *
     *		<p><strong>f^oo<strong>bar</p>
     *		-> <p><strong>f</strong>^<strong>oo<strong>bar</p>
     *		-> <p><strong>f</strong><em>^</em><strong>oo</strong>bar</p>
     *
     * In first example, nothing has changed, because first `<em>` element got broken by `convertCollapsedSelection()` converter,
     * but then it got wrapped-back by `convertSelectionAttribute()` converter. In second example, notice how `<strong>` element
     * is broken to prevent putting selection in it, since selection has no `bold` attribute.
     *
     * @external engine.conversion.modelSelectionToView
     * @function engine.conversion.modelSelectionToView.convertCollapsedSelection
     * @param {engine.view.AttributeElement|Function} elementCreator View element, or function returning a view element, which will
     * be used for wrapping.
     * @returns {Function} Selection converter.
     */
    function convertSelectionAttribute(elementCreator) {
      return function (evt, data, consumable, conversionApi) {
        var selection = data.selection;

        if (!selection.isCollapsed) {
          return;
        }

        if (!consumable.consume(selection, 'selectionAttribute:' + data.key)) {
          return;
        }

        var viewPosition = conversionApi.viewSelection.getFirstPosition();
        conversionApi.viewSelection.removeAllRanges();

        var viewElement = elementCreator instanceof Element$1 ? elementCreator.clone(true) : elementCreator(data.value, selection, consumable, conversionApi);

        viewPosition = conversionApi.writer.wrapPosition(viewPosition, viewElement);

        conversionApi.viewSelection.addRange(new Range$2(viewPosition, viewPosition));
      };
    }

    /**
     * Function factory, creates a converter that clears artifacts after the previous
     * {@link engine.model.Selection model selection} conversion. It removes all empty
     * {@link engine.view.AttributeElement view attribute elements} and merge sibling attributes at all start and end
     * positions of all ranges.
     *
     *		<p><strong>^</strong></p>
     *		-> <p>^</p>
     *
     *		<p><strong>foo</strong>^<strong>bar</strong>bar</p>
     *		-> <p><strong>foo^bar<strong>bar</p>
     *
     *		<p><strong>foo</strong><em>^</em><strong>bar</strong>bar</p>
     *		-> <p><strong>foo^bar<strong>bar</p>
     *
     * This listener should be assigned before any converter for the new selection:
     *
     *		modelDispatcher.on( 'selection', clearAttributes() );
     *
     * See {@link engine.conversion.modelSelectionToView.convertCollapsedSelection} which do the opposite by breaking
     * attributes in the selection position.
     *
     * @external engine.conversion.modelSelectionToView
     * @function engine.conversion.modelSelectionToView.clearAttributes
     * @returns {Function} Selection converter.
     */
    function clearAttributes() {
      return function (evt, data, consumable, conversionApi) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = conversionApi.viewSelection.getRanges()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var range = _step2.value;

            // Not collapsed selection should not have artifacts.
            if (range.isCollapsed) {
              // Position might be in the node removed by the Writer.
              if (range.end.parent.getDocument()) {
                conversionApi.writer.mergeAttributes(range.start);
              }
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        conversionApi.viewSelection.removeAllRanges();
      };
    }

    /**
     * Controller for the editing pipeline. The editing pipeline controls {@link engine.EditingController#model model} rendering,
     * including selection handling. It also creates {@link engine.EditingController#view view document} which build a
     * browser-independent virtualization over the DOM elements. Editing controller also attach default converters and
     * observers.
     *
     * Note that the following observers are attached by the controller and are always available:
     *
     * * {@link view.observer.MutationObserver},
     * * {@link view.observer.SelectionObserver},
     * * {@link view.observer.FocusObserver},
     * * {@link view.observer.KeyObserver}.
     *
     * @memberOf engine
     */

    var EditingController = function () {
    	/**
      * Creates editing controller instance.
      *
      * @param {engine.model.Document} model Document model.
      */

    	function EditingController(model) {
    		var _this = this;

    		classCallCheck(this, EditingController);

    		/**
       * Document model.
       *
       * @readonly
       * @member {engine.model.document} engine.EditingController#model
       */
    		this.model = model;

    		/**
       * View document.
       *
       * @readonly
       * @member {engine.view.document} engine.EditingController#view
       */
    		this.view = new Document$1();

    		// Attach default observers.
    		this.view.addObserver(MutationObserver);
    		this.view.addObserver(SelectionObserver);
    		this.view.addObserver(FocusObserver);
    		this.view.addObserver(KeyObserver);

    		/**
       * Mapper which describes model-view binding.
       *
       * @readonly
       * @member {engine.conversion.Mapper} engine.EditingController#mapper
       */
    		this.mapper = new Mapper();

    		/**
       * Model to view conversion dispatcher, which converts changes from the model to
       * {@link engine.EditingController#view editing view}.
       *
       * To attach model to view converter to the editing pipeline you need to add lister to this property:
       *
       *		editing.modelToView( 'insert:$element', customInsertConverter );
       *
       * Or use {@link engine.conversion.ModelConverterBuilder}:
       *
       *		BuildModelConverterFor( editing.modelToView ).fromAttribute( 'bold' ).toElement( 'b' );
       *
       * @readonly
       * @member {engine.conversion.ModelConversionDispatcher} engine.EditingController#modelToView
       */
    		this.modelToView = new ModelConversionDispatcher({
    			writer: this.view.writer,
    			mapper: this.mapper,
    			viewSelection: this.view.selection
    		});

    		/**
       * Property keeping all listenters attached by controller on other objects, so it can
       * stop listening on {@link engine.EditingController#destroy}.
       *
       * @private
       * @member {utils.EmitterMixin} engine.EditingController#_listenter
       */
    		this._listenter = Object.create(EmitterMixin);

    		// Convert view selection to model.
    		this._listenter.listenTo(this.view, 'selectionChange', convertSelectionChange(model, this.mapper));

    		this._listenter.listenTo(this.model, 'change', function (evt, type, changes) {
    			_this.modelToView.convertChange(type, changes);
    		});

    		this._listenter.listenTo(this.model, 'changesDone', function () {
    			_this.modelToView.convertSelection(model.selection);
    			_this.view.render();
    		});

    		// Attach default content converters.
    		this.modelToView.on('insert:$text', insertText());
    		this.modelToView.on('remove', remove());
    		this.modelToView.on('move', move());

    		// Attach default selection converters.
    		this.modelToView.on('selection', clearAttributes());
    		this.modelToView.on('selection', convertRangeSelection());
    		this.modelToView.on('selection', convertCollapsedSelection());
    	}

    	/**
      * {@link engine.view.Document#createRoot Creates} a view root and {@link engine.conversion.Mapper#bindElements binds}
      * the model root with view root and and view root with DOM element:
      *
      *		editing.createRoot( document.querySelector( div#editor ) );
      *
      * If the DOM element is not available at the time you want to create a view root, for instance it is iframe body
      * element, it is possible to create view element and bind the DOM element later:
      *
      *		editing.createRoot( 'body' );
      *		editing.view.attachDomRoot( iframe.contentDocument.body );
      *
      * @param {Element|String} domRoot DOM root element or the name of view root element if the DOM element will be
      * attached later.
      * @param {String} [name='main'] Root name.
      * @returns {engine.view.ContainerElement} View root element.
      */


    	createClass(EditingController, [{
    		key: 'createRoot',
    		value: function createRoot(domRoot) {
    			var name = arguments.length <= 1 || arguments[1] === undefined ? 'main' : arguments[1];

    			var viewRoot = this.view.createRoot(domRoot, name);
    			var modelRoot = this.model.getRoot(name);

    			this.mapper.bindElements(modelRoot, viewRoot);

    			return viewRoot;
    		}

    		/**
       * Removes all event listeners attached by the EditingController.
       */

    	}, {
    		key: 'destroy',
    		value: function destroy() {
    			this._listenter.stopListening();
    		}
    	}]);
    	return EditingController;
    }();

    /**
     * Gets data from a given source element.
     *
     * @method utils.dom.getDataFromElement
     * @param {HTMLElement} el The element from which the data will be retrieved.
     * @returns {String} The data string.
     */

    function getDataFromElement(el) {
      if (el instanceof HTMLTextAreaElement) {
        return el.value;
      }

      return el.innerHTML;
    }

    /**
     * Sets data in a given element.
     *
     * @method utils.dom.setDataInElement
     * @param {HTMLElement} el The element in which the data will be set.
     * @param {String} data The data string.
     */

    function setDataInElement(el, data) {
      if (el instanceof HTMLTextAreaElement) {
        el.value = data;
      }

      el.innerHTML = data;
    }

    /**
     * Class representing a typical browser-based editor. It handles a single source element and
     * uses {@link engine.EditingController}.
     *
     * @memberOf ckeditor5.editor
     */

    var StandardEditor = function (_Editor) {
    	inherits(StandardEditor, _Editor);

    	/**
      * Creates a new instance of the standard editor.
      *
      * @param {HTMLElement} element The DOM element that will be the source
      * for the created editor.
      * @param {Object} config The editor config.
      */

    	function StandardEditor(element, config) {
    		classCallCheck(this, StandardEditor);


    		/**
       * The element on which the editor has been initialized.
       *
       * @readonly
       * @member {HTMLElement} ckeditor5.editor.StandardEditor#element
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(StandardEditor).call(this, config));

    		_this.element = element;

    		// Documented in Editor.
    		_this.editing = new EditingController(_this.document);

    		/**
       * Instance of the {@link ckeditor5.KeystrokeHandler}.
       *
       * @readonly
       * @member {engine.treecontroller.DataController} ckeditor5.editor.StandardEditor#keystrokes
       */
    		_this.keystrokes = new KeystrokeHandler(_this);

    		/**
       * Editor UI instance.
       *
       * This property is set by more specialized editor constructors. However, it's required
       * for features to work (their UI-related part will try to interact with editor UI),
       * so every editor class which is meant to work with default features should set this property.
       *
       * @readonly
       * @member {ui.editorUI.EditorUI} ckeditor5.editor.StandardEditor#ui
       */
    		return _this;
    	}

    	/**
      * @inheritDoc
      */


    	createClass(StandardEditor, [{
    		key: 'destroy',
    		value: function destroy() {
    			var _this2 = this;

    			return Promise.resolve().then(function () {
    				return _this2.editing.destroy();
    			}).then(get(Object.getPrototypeOf(StandardEditor.prototype), 'destroy', this).call(this));
    		}

    		/**
       * Sets the data in the editor's main root.
       *
       * @param {*} data The data to load.
       */

    	}, {
    		key: 'setData',
    		value: function setData(data) {
    			this.data.set(data);
    		}

    		/**
       * Gets the data from the editor's main root.
       */

    	}, {
    		key: 'getData',
    		value: function getData() {
    			return this.data.get();
    		}

    		/**
       * Updates the {@link ckeditor5.editor.StandardEditor#element editor element}'s content with the data.
       */

    	}, {
    		key: 'updateEditorElement',
    		value: function updateEditorElement() {
    			setDataInElement(this.element, this.getData());
    		}

    		/**
       * Loads the data from the {@link ckeditor5.editor.StandardEditor#element editor element} to the main root.
       */

    	}, {
    		key: 'loadDataFromEditorElement',
    		value: function loadDataFromEditorElement() {
    			this.setData(getDataFromElement(this.element));
    		}

    		/**
       * Creates a standard editor instance.
       *
       * @param {HTMLElement} element See {@link ckeditor5.editor.StandardEditor}'s param.
       * @param {Object} config See {@link ckeditor5.editor.StandardEditor}'s param.
       * @returns {Promise} Promise resolved once editor is ready.
       * @returns {ckeditor5.editor.StandardEditor} return.editor The editor instance.
       */

    	}], [{
    		key: 'create',
    		value: function create(element, config) {
    			var _this3 = this;

    			return new Promise(function (resolve) {
    				var editor = new _this3(element, config);

    				resolve(editor.initPlugins().then(function () {
    					return editor;
    				}));
    			});
    		}
    	}]);
    	return StandardEditor;
    }(Editor);

    /**
     * Basic HTML writer, it uses the native `innerHTML` property for basic conversion
     * from DocumentFragment to an HTML string.
     *
     * @memberOf engine.dataProcessor
     * @implements engine.dataProcessor.HtmlWriter
     */

    var BasicHtmlWriter = function () {
    	function BasicHtmlWriter() {
    		classCallCheck(this, BasicHtmlWriter);
    	}

    	createClass(BasicHtmlWriter, [{
    		key: 'getHtml',

    		/**
       * Returns HTML string created from DocumentFragment.
       *
       * @param {DocumentFragment} fragment
       * @returns {String}
       */
    		value: function getHtml(fragment) {
    			var doc = document.implementation.createHTMLDocument('');
    			var container = doc.createElement('div');
    			container.appendChild(fragment);

    			return container.innerHTML;
    		}
    	}]);
    	return BasicHtmlWriter;
    }();

    /**
     * HtmlDataProcessor class.
     * This data processor implementation uses HTML as input/output data.
     *
     * @memberOf engine.dataProcessor
     * @implements engine.dataProcessor.DataProcessor
     */

    var HtmlDataProcessor = function () {
    	/**
      * Creates a new instance of the HtmlDataProcessor class.
      */

    	function HtmlDataProcessor() {
    		classCallCheck(this, HtmlDataProcessor);

    		/**
       * DOMParser instance used to parse HTML string to HTMLDocument.
       *
       * @private
       * @member {DOMParser} engine.dataProcessor.HtmlDataProcessor#_domParser
       */
    		this._domParser = new DOMParser();

    		/**
       * BasicHtmlWriter instance used to convert DOM elements to HTML string.
       *
       * @private
       * @member {engine.dataProcessor.BasicHtmlWriter} engine.dataProcessor.HtmlDataProcessor#_htmlWriter
       */
    		this._htmlWriter = new BasicHtmlWriter();
    	}

    	/**
      * Converts provided document fragment to data format - in this case HTML string.
      *
      * @param {DocumentFragment} fragment
      * @returns {String}
      */


    	createClass(HtmlDataProcessor, [{
    		key: 'toData',
    		value: function toData(fragment) {
    			return this._htmlWriter.getHtml(fragment);
    		}

    		/**
       * Converts HTML String to its DOM representation. Returns DocumentFragment, containing nodes parsed from
       * provided data.
       *
       * @param {String} data
       * @returns {DocumentFragment}
       */

    	}, {
    		key: 'toDom',
    		value: function toDom(data) {
    			var document = this._domParser.parseFromString(data, 'text/html');
    			var fragment = document.createDocumentFragment();
    			var nodes = document.body.childNodes;

    			while (nodes.length > 0) {
    				fragment.appendChild(nodes[0]);
    			}

    			return fragment;
    		}
    	}]);
    	return HtmlDataProcessor;
    }();

    /**
     * Collections are ordered sets of objects. Items in the collection can be retrieved by their indexes
     * in the collection (like in an array) or by their ids.
     *
     * If an object without an `id` property is being added to the collection, the `id` property will be generated
     * automatically. Note that the automatically generated id is unique only within this single collection instance.
     *
     * By default an item in the collection is identified by its `id` property. The name of the identifier can be
     * configured through the constructor of the collection.
     *
     * @memberOf utils
     * @mixes EventEmitter
     */

    var Collection = function () {
    	/**
      * Creates a new Collection instance.
      *
      * @param {Iterable} [items] Items to be added to the collection.
      * @param {Object} options The options object.
      * @param {String} [options.idProperty='id'] The name of the property which is considered to identify an item.
      */

    	function Collection(options) {
    		classCallCheck(this, Collection);

    		/**
       * The internal list of items in the collection.
       *
       * @private
       * @type {Object[]}
       */
    		this._items = [];

    		/**
       * The internal map of items in the collection.
       *
       * @private
       * @type {Map}
       */
    		this._itemMap = new Map();

    		/**
       * The name of the property which is considered to identify an item.
       *
       * @private
       * @type {String}
       */
    		this._idProperty = options && options.idProperty || 'id';
    	}

    	/**
      * The number of items available in the collection.
      *
      * @property length
      */


    	createClass(Collection, [{
    		key: 'add',


    		/**
       * Adds an item into the collection.
       *
       * If the item does not have an id, then it will be automatically generated and set on the item.
       *
       * @chainable
       * @param {Object} item
       * @param {Number} [index] The position of the item in the collection. The item
       * is pushed to the collection when `index` not specified.
       * @fires utils.Collection#add
       */
    		value: function add(item, index) {
    			var itemId = void 0;
    			var idProperty = this._idProperty;

    			if (idProperty in item) {
    				itemId = item[idProperty];

    				if (typeof itemId != 'string') {
    					/**
          * This item's id should be a string.
          *
          * @error collection-add-invalid-id
          */
    					throw new CKEditorError('collection-add-invalid-id');
    				}

    				if (this.get(itemId)) {
    					/**
          * This item already exists in the collection.
          *
          * @error collection-add-item-already-exists
          */
    					throw new CKEditorError('collection-add-item-already-exists');
    				}
    			} else {
    				itemId = this._getNextId();
    				item[idProperty] = itemId;
    			}

    			// TODO: Use ES6 default function argument.
    			if (index === undefined) {
    				index = this._items.length;
    			} else if (index > this._items.length || index < 0) {
    				/**
         * The index number has invalid value.
         *
         * @error collection-add-item-bad-index
         */
    				throw new CKEditorError('collection-add-item-invalid-index');
    			}

    			this._items.splice(index, 0, item);

    			this._itemMap.set(itemId, item);

    			this.fire('add', item, index);

    			return this;
    		}

    		/**
       * Gets item by its id or index.
       *
       * @param {String|Number} idOrIndex The item id or index in the collection.
       * @returns {Object} The requested item or `null` if such item does not exist.
       */

    	}, {
    		key: 'get',
    		value: function get(idOrIndex) {
    			var item = void 0;

    			if (typeof idOrIndex == 'string') {
    				item = this._itemMap.get(idOrIndex);
    			} else if (typeof idOrIndex == 'number') {
    				item = this._items[idOrIndex];
    			} else {
    				/**
         * Index or id must be given.
         *
         * @error collection-get-invalid-arg
         */
    				throw new CKEditorError('collection-get-invalid-arg: Index or id must be given.');
    			}

    			return item || null;
    		}

    		/**
       * Removes an item from the collection.
       *
       * @param {Object|Number|String} subject The item to remove, its id or index in the collection.
       * @returns {Object} The removed item.
       * @fires utils.Collection#remove
       */

    	}, {
    		key: 'remove',
    		value: function remove(subject) {
    			var index = void 0,
    			    id = void 0,
    			    item = void 0;
    			var itemDoesNotExist = false;
    			var idProperty = this._idProperty;

    			if (typeof subject == 'string') {
    				id = subject;
    				item = this._itemMap.get(id);
    				itemDoesNotExist = !item;

    				if (item) {
    					index = this._items.indexOf(item);
    				}
    			} else if (typeof subject == 'number') {
    				index = subject;
    				item = this._items[index];
    				itemDoesNotExist = !item;

    				if (item) {
    					id = item[idProperty];
    				}
    			} else {
    				item = subject;
    				id = item[idProperty];
    				index = this._items.indexOf(item);
    				itemDoesNotExist = index == -1 || !this._itemMap.get(id);
    			}

    			if (itemDoesNotExist) {
    				/**
         * Item not found.
         *
         * @error collection-remove-404
         */
    				throw new CKEditorError('collection-remove-404: Item not found.');
    			}

    			this._items.splice(index, 1);
    			this._itemMap.delete(id);

    			this.fire('remove', item);

    			return item;
    		}

    		/**
       * Executes the callback for each item in the collection and composes an array or values returned by this callback.
       *
       * @param {Function} callback
       * @param {Item} callback.item
       * @param {Number} callback.index
       * @params {Object} ctx Context in which the `callback` will be called.
       * @returns {Array} The result of mapping.
       */

    	}, {
    		key: 'map',
    		value: function map(callback, ctx) {
    			return this._items.map(callback, ctx);
    		}

    		/**
       * Finds the first item in the collection for which the `callback` returns a true value.
       *
       * @param {Function} callback
       * @param {Object} callback.item
       * @param {Number} callback.index
       * @returns {Object} The item for which `callback` returned a true value.
       * @params {Object} ctx Context in which the `callback` will be called.
       */

    	}, {
    		key: 'find',
    		value: function find(callback, ctx) {
    			return this._items.find(callback, ctx);
    		}

    		/**
       * Returns an array with items for which the `callback` returned a true value.
       *
       * @param {Function} callback
       * @param {Object} callback.item
       * @param {Number} callback.index
       * @params {Object} ctx Context in which the `callback` will be called.
       * @returns {Object[]} The array with matching items.
       */

    	}, {
    		key: 'filter',
    		value: function filter(callback, ctx) {
    			return this._items.filter(callback, ctx);
    		}

    		/**
       * Removes all items from the collection.
       */

    	}, {
    		key: 'clear',
    		value: function clear() {
    			while (this.length) {
    				this.remove(0);
    			}
    		}

    		/**
       * Collection iterator.
       */

    	}, {
    		key: Symbol.iterator,
    		value: function value() {
    			return this._items[Symbol.iterator]();
    		}

    		/**
       * Generates next (not yet used) id for unidentified item being add to the collection.
       *
       * @private
       * @returns {String} The next id.
       */

    	}, {
    		key: '_getNextId',
    		value: function _getNextId() {
    			var id = void 0;

    			do {
    				id = String(uid());
    			} while (this._itemMap.has(id));

    			return id;
    		}
    	}, {
    		key: 'length',
    		get: function get() {
    			return this._items.length;
    		}
    	}]);
    	return Collection;
    }();

    mix(Collection, EmitterMixin);

    /**
     * Basic Controller class.
     *
     * @memberOf ui
     * @mixes utils.EmitterMixin
     */

    var Controller = function () {
    	/**
      * Creates an instance of the {@link ui.Controller} class.
      *
      * @param {ui.Model} [model] Model of this Controller.
      * @param {ui.View} [view] View instance of this Controller.
      */

    	function Controller(model, view) {
    		var _this = this;

    		classCallCheck(this, Controller);

    		/**
       * Model of this controller.
       *
       * @member {ui.Model} ui.Controller#model
       */
    		this.model = model || null;

    		/**
       * Set `true` after {@link #init}.
       *
       * @member {Boolean} ui.Controller#ready
       */
    		this.ready = false;

    		/**
       * View of this controller.
       *
       * @member {ui.View} ui.Controller#view
       */
    		this.view = view || null;

    		/**
       * A collection of {@link ControllerCollection} instances containing
       * child controllers.
       *
       * @member {utils.Collection} ui.Controller#collections
       */
    		this.collections = new Collection({
    			idProperty: 'name'
    		});

    		// Listen to {@link ControllerCollection#add} and {@link ControllerCollection#remove}
    		// of newly added Collection to synchronize this controller's view and children
    		// controllers' views in the future.
    		this.collections.on('add', function (evt, collection) {
    			// Set the {@link ControllerCollection#parent} to this controller.
    			// It allows the collection to determine the {@link #ready} state of this controller
    			// and accordingly initialize a child controller when added.
    			collection.parent = _this;

    			_this.listenTo(collection, 'add', function (evt, childController, index) {
    				// Child view is added to corresponding region in this controller's view
    				// when a new Controller joins the collection.
    				if (_this.ready && childController.view) {
    					_this.view.regions.get(collection.name).views.add(childController.view, index);
    				}
    			});

    			_this.listenTo(collection, 'remove', function (evt, childController) {
    				// Child view is removed from corresponding region in this controller's view
    				// when a new Controller is removed from the the collection.
    				if (_this.ready && childController.view) {
    					_this.view.regions.get(collection.name).views.remove(childController.view);
    				}
    			});
    		});

    		this.collections.on('remove', function (evt, collection) {
    			// Release the collection. Once removed from {@link #collections}, it can be
    			// moved to another controller.
    			collection.parent = null;

    			_this.stopListening(collection);
    		});
    	}

    	/**
      * Initializes the controller instance. The process includes:
      *
      * 1. Initialization of the child {@link #view}.
      * 2. Initialization of child controllers in {@link #collections}.
      * 3. Setting {@link #ready} flag `true`.
      *
      * @returns {Promise} A Promise resolved when the initialization process is finished.
      */


    	createClass(Controller, [{
    		key: 'init',
    		value: function init() {
    			var _this2 = this;

    			if (this.ready) {
    				/**
         * This Controller already been initialized.
         *
         * @error ui-controller-init-reinit
         */
    				throw new CKEditorError('ui-controller-init-reinit: This Controller already been initialized.');
    			}

    			return Promise.resolve().then(this._initView.bind(this)).then(this._initCollections.bind(this)).then(function () {
    				_this2.ready = true;
    				_this2.fire('ready');
    			});
    		}

    		/**
       * Destroys the controller instance. The process includes:
       *
       * 1. Destruction of the child {@link #view}.
       * 2. Destruction of child controllers in {@link #collections}.
       *
       * @returns {Promise} A Promise resolved when the destruction process is finished.
       */

    	}, {
    		key: 'destroy',
    		value: function destroy() {
    			var _this3 = this;

    			var promises = [];
    			var collection = void 0,
    			    childController = void 0;

    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = this.collections[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					collection = _step.value;
    					var _iteratorNormalCompletion2 = true;
    					var _didIteratorError2 = false;
    					var _iteratorError2 = undefined;

    					try {
    						for (var _iterator2 = collection[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    							childController = _step2.value;

    							promises.push(childController.destroy());
    						}
    					} catch (err) {
    						_didIteratorError2 = true;
    						_iteratorError2 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion2 && _iterator2.return) {
    								_iterator2.return();
    							}
    						} finally {
    							if (_didIteratorError2) {
    								throw _iteratorError2;
    							}
    						}
    					}

    					collection.clear();
    				}
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}

    			this.collections.clear();

    			if (this.view) {
    				promises.push(Promise.resolve().then(function () {
    					return _this3.view.destroy();
    				}));
    			}

    			promises.push(Promise.resolve().then(function () {
    				_this3.model = _this3.ready = _this3.view = _this3.collections = null;
    			}));

    			return Promise.all(promises);
    		}

    		/**
       * Adds a child {@link Controller} instance to {@link #collections} at given index.
       *
       * @param {String} collectionName Name of the Controller Collection.
       * @param {ui.Controller} controller A controller instance to be added.
       * @param {Number} [index] An index in the collection.
       */

    	}, {
    		key: 'add',
    		value: function add(collectionName, controller, index) {
    			this.collections.get(collectionName).add(controller, index);
    		}

    		/**
       * Removes a child {@link ui.Controller} instance from one of {@link ui.Controller#collections}.
       *
       * @param {String} collectionName Name of the Controller Collection.
       * @param {ui.Controller|Number} toRemove A Controller instance or index to be removed.
       */

    	}, {
    		key: 'remove',
    		value: function remove(collectionName, toRemove) {
    			return this.collections.get(collectionName).remove(toRemove);
    		}

    		/**
       * Initializes the {@link #view} of this controller instance.
       *
       * @protected
       * @returns {Promise} A Promise resolved when initialization process is finished.
       */

    	}, {
    		key: '_initView',
    		value: function _initView() {
    			var promise = Promise.resolve();

    			if (this.view) {
    				promise = promise.then(this.view.init.bind(this.view));
    			}

    			return promise;
    		}

    		/**
       * Initializes the {@link #collections} of this controller instance.
       *
       * @protected
       * @returns {Promise} A Promise resolved when initialization process is finished.
       */

    	}, {
    		key: '_initCollections',
    		value: function _initCollections() {
    			var promises = [];
    			var collection = void 0,
    			    childController = void 0;

    			var _iteratorNormalCompletion3 = true;
    			var _didIteratorError3 = false;
    			var _iteratorError3 = undefined;

    			try {
    				for (var _iterator3 = this.collections[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
    					collection = _step3.value;
    					var _iteratorNormalCompletion4 = true;
    					var _didIteratorError4 = false;
    					var _iteratorError4 = undefined;

    					try {
    						for (var _iterator4 = collection[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
    							childController = _step4.value;

    							if (this.view && childController.view) {
    								this.view.regions.get(collection.name).views.add(childController.view);
    							}

    							promises.push(childController.init());
    						}
    					} catch (err) {
    						_didIteratorError4 = true;
    						_iteratorError4 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion4 && _iterator4.return) {
    								_iterator4.return();
    							}
    						} finally {
    							if (_didIteratorError4) {
    								throw _iteratorError4;
    							}
    						}
    					}
    				}
    			} catch (err) {
    				_didIteratorError3 = true;
    				_iteratorError3 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion3 && _iterator3.return) {
    						_iterator3.return();
    					}
    				} finally {
    					if (_didIteratorError3) {
    						throw _iteratorError3;
    					}
    				}
    			}

    			return Promise.all(promises);
    		}
    	}]);
    	return Controller;
    }();

    mix(Controller, EmitterMixin);

    /**
     * Manages UI Controllers.
     *
     * @memberOf ui
     * @extends utils.Collection
     */

    var ControllerCollection = function (_Collection) {
    	inherits(ControllerCollection, _Collection);

    	/**
      * Creates an instance of the ControllerCollection class, initializing it with a name.
      */

    	function ControllerCollection(name) {
    		classCallCheck(this, ControllerCollection);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ControllerCollection).call(this));

    		if (!name) {
    			/**
        * ControllerCollection must be initialized with a name.
        *
        * @error ui-controllercollection-no-name
        */
    			throw new CKEditorError('ui-controllercollection-no-name: ControllerCollection must be initialized with a name.');
    		}

    		/**
       * Name of this collection.
       *
       * @member {String} ui.ControllerCollection#name
       */
    		_this.name = name;

    		/**
       * Parent controller of this collection.
       *
       * @member {ui.Controller} ui.ControllerCollection#parent
       */
    		_this.parent = null;
    		return _this;
    	}

    	/**
      * Adds a child controller to the collection. If {@link ui.ControllerCollection#parent} {@link ui.Controller}
      * instance is ready, the child view is initialized when added.
      *
      * @param {ui.Controller} controller A child controller.
      * @param {Number} [index] Index at which the child will be added to the collection.
      * @returns {Promise} A Promise resolved when the child {@link ui.Controller#init} is done.
      */


    	createClass(ControllerCollection, [{
    		key: 'add',
    		value: function add(controller, index) {
    			get(Object.getPrototypeOf(ControllerCollection.prototype), 'add', this).call(this, controller, index);

    			// ChildController.init() returns Promise.
    			var promise = Promise.resolve();

    			if (this.parent && this.parent.ready && !controller.ready) {
    				promise = promise.then(function () {
    					return controller.init();
    				});
    			}

    			return promise;
    		}
    	}]);
    	return ControllerCollection;
    }(Collection);

    /**
     * Class implementing the UI component factory.
     *
     * Factories of specific UI components can be registered under their unique names. Registered
     * components can be later instantiated by providing the name of the component. The model is shared between all
     * instances of that component and has to be provided upon registering its factory.
     *
     * The main use case for the component factory is the {@link ui.editorUI.EditorUI#featureComponents} factory.
     *
     * @memberOf ui
     */

    var ComponentFactory = function () {
    	/**
      * Creates ComponentFactory instance.
      *
      * @constructor
      * @param {ckeditor5.Editor} editor The editor instance.
      */

    	function ComponentFactory(editor) {
    		classCallCheck(this, ComponentFactory);

    		/**
       * @readonly
       * @member {ckeditor5.Editor} ui.ComponentFactory#editor
       */
    		this.editor = editor;

    		/**
       * Registered component factories.
       *
       * @private
       * @member {Map} ui.ComponentFactory#_components
       */
    		this._components = new Map();
    	}

    	/**
      * Registers a component factory.
      *
      * @param {String} name The name of the component.
      * @param {Function} ControllerClass The component controller constructor.
      * @param {Function} ViewClass The component view constructor.
      * @param {ui.Model} model The model of the component.
      */


    	createClass(ComponentFactory, [{
    		key: 'add',
    		value: function add(name, ControllerClass, ViewClass, model) {
    			if (this._components.get(name)) {
    				throw new CKEditorError('componentfactory-item-exists: The item already exists in the component factory.', { name: name });
    			}

    			this._components.set(name, {
    				ControllerClass: ControllerClass,
    				ViewClass: ViewClass,
    				model: model
    			});
    		}

    		/**
       * Creates a component instance.
       *
       * @param {String} name The name of the component.
       * @returns {ui.Controller} The instantiated component.
       */

    	}, {
    		key: 'create',
    		value: function create(name) {
    			var component = this._components.get(name);

    			var model = component.model;
    			var view = new component.ViewClass(model, this.editor.locale);
    			var controller = new component.ControllerClass(model, view, this.editor);

    			return controller;
    		}
    	}]);
    	return ComponentFactory;
    }();

    /**
     * The icon manager controller class. It provides SVG icons, which then can
     * be used by {@link ui.icon.Icon} component and similar.
     *
     *		const model = new Model( {
     *			icons: [ 'bold', 'italic', ... ],
     *			sprite: '...' // SVG sprite
     *		} );
     *
     *		// An instance of IconManager.
     *		new IconManager( model, new IconManagerView() );
     *
     * See {@link ui.iconManager.IconManagerView}.
     *
     * @memberOf ui.iconManager
     * @extends ui.Controller
     */

    var IconManager = function (_Controller) {
      inherits(IconManager, _Controller);

      /**
       * Creates an instance of {@link ui.iconManager.IconManager} class.
       *
       * @param {ui.iconManager.IconManagerModel} model Model of this IconManager.
       * @param {ui.View} view View of this IconManager.
       */

      function IconManager(model, view) {
        classCallCheck(this, IconManager);

        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(IconManager).call(this, model, view));

        view.model.bind('sprite').to(model);
        return _this;
      }

      return IconManager;
    }(Controller);

    /**
     * The base MVC model class.
     *
     * @memberOf ui
     * @mixes utils.ObservaleMixin
     */

    var Model =
    /**
     * Creates a new Model instance.
     *
     * @param {Object} [attributes] The model state attributes to be defined during the instance creation.
     * @param {Object} [properties] The (out of state) properties to be appended to the instance during creation.
     */
    function Model(attributes, properties) {
    	classCallCheck(this, Model);

    	// Extend this instance with the additional (out of state) properties.
    	if (properties) {
    		assignIn(this, properties);
    	}

    	// Initialize the attributes.
    	if (attributes) {
    		this.set(attributes);
    	}
    };

    mix(Model, ObservableMixin);

    /**
     * Basic Region class.
     *
     * @memberOf ui
     */

    var Region = function () {
    	/**
      * Creates an instance of the {@link ui.Region} class.
      *
      * @param {String} name The name of the Region.
      */

    	function Region(name) {
    		classCallCheck(this, Region);

    		/**
       * The name of the region.
       *
       * @member {String} ui.Region#name
       */
    		this.name = name;

    		/**
       * Views which belong to the region.
       *
       * @member {utils.Collection} ui.Region#views
       */
    		this.views = new Collection();

    		/**
       * Element of this region (see {@link #init}).
       *
       * @member {HTMLElement} ui.Region#element
       */
    		this.element = null;
    	}

    	/**
      * Initializes region instance with an element. Usually it comes from {@link View#init}.
      *
      * @param {HTMLElement} regionElement Element of this region.
      */


    	createClass(Region, [{
    		key: 'init',
    		value: function init(regionElement) {
    			this.element = regionElement;

    			if (regionElement) {
    				this.views.on('add', function (evt, childView, index) {
    					regionElement.insertBefore(childView.element, regionElement.childNodes[index]);
    				});

    				this.views.on('remove', function (evt, childView) {
    					childView.element.remove();
    				});
    			}
    		}

    		/**
       * Destroys region instance.
       */

    	}, {
    		key: 'destroy',
    		value: function destroy() {
    			if (this.element) {
    				var _iteratorNormalCompletion = true;
    				var _didIteratorError = false;
    				var _iteratorError = undefined;

    				try {
    					for (var _iterator = this.views[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    						var view = _step.value;

    						view.element.remove();
    						this.views.remove(view);
    					}
    				} catch (err) {
    					_didIteratorError = true;
    					_iteratorError = err;
    				} finally {
    					try {
    						if (!_iteratorNormalCompletion && _iterator.return) {
    							_iterator.return();
    						}
    					} finally {
    						if (_didIteratorError) {
    							throw _iteratorError;
    						}
    					}
    				}
    			}

    			// Drop the reference to HTMLElement but don't remove it from DOM.
    			// Element comes as a parameter and it could be a part of the View.
    			// Then it's up to the View what to do with it when the View is destroyed.
    			this.element = this.views = null;
    		}
    	}]);
    	return Region;
    }();

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      return baseClone(value, true, true, customizer);
    }

    var bindToSymbol = Symbol('bindTo');
    var bindIfSymbol = Symbol('bindIf');

    /**
     * A basic Template class. It renders DOM HTMLElements from {@link ui.TemplateDefinition} and supports
     * element attributes, children, bindings to {@link utils.ObservableMixin} instances and DOM events
     * propagation. For example:
     *
     *		new Template( {
     *			tag: 'p',
     *			attributes: {
     *				class: 'foo',
     *				style: {
     *					backgroundColor: 'yellow'
     *				}
     *			},
     *			children: [
     *				'A paragraph.'
     *			]
     *		} ).render();
     *
     * will render the following HTMLElement:
     *
     *		<p class="foo" style="background-color: yellow;">A paragraph.</p>
     *
     * See {@link ui.TemplateDefinition} to know more about templates and see complex examples.
     *
     * @memberOf ui
     */

    var Template = function () {
    	/**
      * Creates an instance of the {@link ui.Template} class.
      *
      * @param {ui.TemplateDefinition} def The definition of the template.
      */

    	function Template(def) {
    		classCallCheck(this, Template);

    		var defClone = clone$1(def);

    		normalize(defClone);

    		/**
       * Definition of this template.
       *
       * @readonly
       * @member {ui.TemplateDefinition} ui.Template#definition
       */
    		this.definition = defClone;
    	}

    	/**
      * Renders DOM Node using {@link ui.Template#definition}.
      *
      * @see ui.Template#apply
      *
      * @returns {HTMLElement}
      */


    	createClass(Template, [{
    		key: 'render',
    		value: function render() {
    			return this._renderNode(this.definition, undefined, true);
    		}

    		/**
       * Applies template {@link ui.Template#def} to existing DOM tree.
       *
       * **Note:** No new DOM nodes (elements, text nodes) will be created.
       *		const element = document.createElement( 'div' );
       *		const bind = Template.bind( observableInstance, emitterInstance );
       *
       *		const template = new Template( {
       *			attrs: {
       *				id: 'first-div',
       *				class: bind.to( 'divClass' )
       *			},
       *			on: {
       *				click: bind( 'elementClicked' ) // Will be fired by the observableInstance.
       *			}
       *			children: [
       *				'Div text.'
       *			]
       *		} );
       *
       *		template.apply( element );
       *
       *		element.outerHTML == "<div id="first-div" class="my-div">Div text.</div>"
       *
       * @see ui.Template#render
       * @param {Node} element Root element for template to apply.
       */

    	}, {
    		key: 'apply',
    		value: function apply(node) {
    			if (!node) {
    				/**
         * No DOM Node specified.
         *
         * @error ui-template-wrong-syntax
         */
    				throw new CKEditorError('ui-template-wrong-node: No DOM Node specified.');
    			}

    			return this._renderNode(this.definition, node);
    		}

    		/**
       * An entry point to the interface which allows binding DOM nodes to {@link utils.ObservableMixin}.
       * There are two types of bindings:
       *
       * * `HTMLElement` attributes or Text Node `textContent` can be synchronized with {@link utils.ObservableMixin}
       * instance attributes. See {@link ui.Template.bind#to} and {@link ui.Template.bind#if}.
       *
       * * DOM events fired on `HTMLElement` can be propagated through {@link utils.ObservableMixin}.
       * See {@link ui.Template.bind#to}.
       *
       * @param {utils.ObservableMixin} observable An instance of ObservableMixin class.
       * @param {utils.EmitterMixin} emitter An instance of `EmitterMixin` class. It listens
       * to `observable` attribute changes and DOM Events, depending on the binding. Usually {@link ui.View} instance.
       * @returns {Object}
       */

    	}, {
    		key: '_renderNode',


    		/**
       * Renders a DOM Node from definition.
       *
       * @protected
       * @param {ui.TemplateDefinition} def Definition of a Node.
       * @param {Node} applyNode If specified, template `def` will be applied to existing DOM Node.
       * @param {Boolean} intoFragment If set, children are rendered into DocumentFragment.
       * @returns {HTMLElement} A rendered Node.
       */
    		value: function _renderNode(def, applyNode, intoFragment) {
    			var isInvalid = void 0;

    			if (applyNode) {
    				// When applying, a definition cannot have "tag" and "text" at the same time.
    				isInvalid = def.tag && def.text;
    			} else {
    				// When rendering, a definition must have either "tag" or "text": XOR( def.tag, def.text ).
    				isInvalid = def.tag ? def.text : !def.text;
    			}

    			if (isInvalid) {
    				/**
         * Node definition cannot have "tag" and "text" properties at the same time.
         * Node definition must have either "tag" or "text" when rendering new Node.
         *
         * @error ui-template-wrong-syntax
         */
    				throw new CKEditorError('ui-template-wrong-syntax: Node definition must have either "tag" or "text" when rendering new Node.');
    			}

    			return def.text ? this._renderText(def, applyNode) : this._renderElement(def, applyNode, intoFragment);
    		}

    		/**
       * Renders an HTMLElement from TemplateDefinition.
       *
       * @protected
       * @param {ui.TemplateDefinition} def Definition of an element.
       * @param {HTMLElement} applyElement If specified, template `def` will be applied to existing HTMLElement.
       * @param {Boolean} intoFragment If set, children are rendered into DocumentFragment.
       * @returns {HTMLElement} A rendered element.
       */

    	}, {
    		key: '_renderElement',
    		value: function _renderElement(def, applyElement, intoFragment) {
    			var el = applyElement || document.createElementNS(def.ns || 'http://www.w3.org/1999/xhtml', def.tag);

    			this._renderElementAttributes(def, el);

    			// Invoke children recursively.
    			if (intoFragment) {
    				var docFragment = document.createDocumentFragment();

    				this._renderElementChildren(def, docFragment);

    				el.appendChild(docFragment);
    			} else {
    				this._renderElementChildren(def, el, !!applyElement);
    			}

    			// Setup DOM bindings event listeners.
    			this._setUpListeners(def, el);

    			return el;
    		}

    		/**
       * Renders a Text from TemplateDefinition or String.
       *
       * @protected
       * @param {TemplateDefinition|String} def Definition of Text or its value.
       * @param {HTMLElement} textNode If specified, template `def` will be applied to existing Text Node.
       * @returns {Text} A rendered Text.
       */

    	}, {
    		key: '_renderText',
    		value: function _renderText(valueSchemaOrText) {
    			var textNode = arguments.length <= 1 || arguments[1] === undefined ? document.createTextNode('') : arguments[1];

    			// Check if this Text Node is bound to Observable. Cases:
    			//		{ text: [ Template.bind( ... ).to( ... ) ] }
    			//		{ text: [ 'foo', Template.bind( ... ).to( ... ), ... ] }
    			if (hasBinding(valueSchemaOrText.text)) {
    				this._bindToObservable(valueSchemaOrText.text, textNode, getTextUpdater(textNode));
    			}

    			// Simply set text. Cases:
    			// 		{ text: [ 'all', 'are', 'static' ] }
    			// 		{ text: [ 'foo' ] }
    			else {
    					textNode.textContent = valueSchemaOrText.text.join('');
    				}

    			return textNode;
    		}

    		/**
       * Renders element attributes from definition.
       *
       * @protected
       * @param {ui.TemplateDefinition} def Definition of an element.
       * @param {HTMLElement} el Element which is rendered.
       */

    	}, {
    		key: '_renderElementAttributes',
    		value: function _renderElementAttributes(_ref, el) {
    			var attributes = _ref.attributes;

    			var attrName = void 0,
    			    attrValue = void 0,
    			    attrNs = void 0;

    			if (!attributes) {
    				return;
    			}

    			for (attrName in attributes) {
    				attrValue = attributes[attrName];
    				attrNs = attrValue[0].ns || null;

    				// Activate binding if one is found. Cases:
    				// 		{ class: [ Template.bind( ... ).to( ... ) ] }
    				// 		{ class: [ 'bar', Template.bind( ... ).to( ... ), 'baz' ] }
    				// 		{ class: { ns: 'abc', value: Template.bind( ... ).to( ... ) } }
    				if (hasBinding(attrValue)) {
    					// Normalize attributes with additional data like namespace:
    					//		{ class: { ns: 'abc', value: [ ... ] } }
    					this._bindToObservable(attrValue[0].value || attrValue, el, getAttributeUpdater(el, attrName, attrNs));
    				}

    				// Style attribute could be an Object so it needs to be parsed in a specific way.
    				//		style: {
    				//			width: '100px',
    				//			height: Template.bind( ... ).to( ... )
    				//		}
    				else if (attrName == 'style' && typeof attrValue[0] !== 'string') {
    						this._renderStyleAttribute(attrValue[0], el);
    					}

    					// Otherwise simply set the static attribute.
    					// 		{ class: [ 'foo' ] }
    					// 		{ class: [ 'all', 'are', 'static' ] }
    					// 		{ class: [ { ns: 'abc', value: [ 'foo' ] } ] }
    					else {
    							attrValue = attrValue
    							// Retrieve "values" from { class: [ { ns: 'abc', value: [ ... ] } ] }
    							.map(function (v) {
    								return v ? v.value || v : v;
    							})
    							// Flatten the array.
    							.reduce(function (p, n) {
    								return p.concat(n);
    							}, [])
    							// Convert into string.
    							.reduce(arrayValueReducer);

    							el.setAttributeNS(attrNs, attrName, attrValue);
    						}
    			}
    		}

    		/**
       * Renders `style` attribute.
       *
       * Style attribute is an {Object} with static values:
       *
       *		attributes: {
       * 			style: {
       * 				color: 'red'
       * 			}
       * 		}
       *
       * or values bound to {@link ui.Model} properties:
       *
       *		attributes: {
       * 			style: {
       * 				color: bind.to( ... )
       * 			}
       * 		}
       *
       * Note: `style` attribute is rendered without setting namespace. It does not seem to be
       * needed.
       *
       * @private
       * @param {ui.TemplateDefinition.attributes.styles} styles Styles definition.
       * @param {HTMLElement} el Element which is rendered.
       */

    	}, {
    		key: '_renderStyleAttribute',
    		value: function _renderStyleAttribute(styles, el) {
    			for (var styleName in styles) {
    				var styleValue = styles[styleName];

    				// style: {
    				//	color: bind.to( 'attribute' )
    				// }
    				if (hasBinding(styleValue)) {
    					this._bindToObservable([styleValue], el, getStyleUpdater(el, styleName));
    				}

    				// style: {
    				//	color: 'red'
    				// }
    				else {
    						el.style[styleName] = styleValue;
    					}
    			}
    		}

    		/**
       * Recursively renders element children from definition by
       * calling {@link ui.Template#_renderElement}.
       *
       * @protected
       * @param {ui.TemplateDefinition} def Definition of an element.
       * @param {HTMLElement} el Element which is rendered.
       * @param {Boolean} isApply Traverse existing DOM structure only, don't modify DOM.
       */

    	}, {
    		key: '_renderElementChildren',
    		value: function _renderElementChildren(def, el, isApply) {
    			var _this = this;

    			if (def.children) {
    				def.children.forEach(function (childDef, index) {
    					if (isApply) {
    						_this._renderNode(childDef, el.childNodes[index]);
    					} else {
    						el.appendChild(_this._renderNode(childDef));
    					}
    				});
    			}
    		}

    		/**
       * Activates element `on` listeners passed in element definition.
       *
       * @protected
       * @param {ui.TemplateDefinition} def Definition of an element.
       * @param {HTMLElement} el Element which is being rendered.
       */

    	}, {
    		key: '_setUpListeners',
    		value: function _setUpListeners(def, el) {
    			if (!def.on) {
    				return;
    			}

    			var _loop = function _loop(key) {
    				var _key$split = key.split('@');

    				var _key$split2 = slicedToArray(_key$split, 2);

    				var domEvtName = _key$split2[0];
    				var domSelector = _key$split2[1];
    				var _iteratorNormalCompletion = true;
    				var _didIteratorError = false;
    				var _iteratorError = undefined;

    				try {
    					var _loop2 = function _loop2() {
    						var schemaItem = _step.value;

    						schemaItem.emitter.listenTo(el, domEvtName, function (evt, domEvt) {
    							if (!domSelector || domEvt.target.matches(domSelector)) {
    								if (typeof schemaItem.eventNameOrFunction == 'function') {
    									schemaItem.eventNameOrFunction(domEvt);
    								} else {
    									schemaItem.observable.fire(schemaItem.eventNameOrFunction, domEvt);
    								}
    							}
    						});
    					};

    					for (var _iterator = def.on[key][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    						_loop2();
    					}
    				} catch (err) {
    					_didIteratorError = true;
    					_iteratorError = err;
    				} finally {
    					try {
    						if (!_iteratorNormalCompletion && _iterator.return) {
    							_iterator.return();
    						}
    					} finally {
    						if (_didIteratorError) {
    							throw _iteratorError;
    						}
    					}
    				}
    			};

    			for (var key in def.on) {
    				_loop(key);
    			}
    		}

    		/**
       * For given {@link ui.TemplateValueSchema} containing {@link ui.TemplateBinding} it activates the
       * binding and sets its initial value.
       *
       * Note: {@link ui.TemplateValueSchema} can be for HTMLElement attributes or Text Node `textContent`.
       *
       * @protected
       * @param {ui.TemplateValueSchema} valueSchema
       * @param {Node} node DOM Node to be updated when {@link utils.ObservableMixin} changes.
       * @param {Function} domUpdater A function which updates DOM (like attribute or text).
       */

    	}, {
    		key: '_bindToObservable',
    		value: function _bindToObservable(valueSchema) {
    			var _arguments = arguments;

    			valueSchema
    			// Filter inactive bindings from schema, like static strings, etc.
    			.filter(function (item) {
    				return item.observable;
    			})
    			// Let the emitter listen to observable change:attribute event.
    			// TODO: Reduce the number of listeners attached as many bindings may listen
    			// to the same observable attribute.
    			.forEach(function (_ref2) {
    				var emitter = _ref2.emitter;
    				var observable = _ref2.observable;
    				var attribute = _ref2.attribute;

    				emitter.listenTo(observable, 'change:' + attribute, function () {
    					syncBinding.apply(undefined, _arguments);
    				});
    			});

    			// Set initial values.
    			syncBinding.apply(undefined, arguments);
    		}
    	}], [{
    		key: 'bind',
    		value: function bind(observable, emitter) {
    			return {
    				/**
         * Binds {@link utils.ObservableMixin} instance to:
         *  * HTMLElement attribute or Text Node `textContent` so remains in sync with the Observable when it changes:
         *  * HTMLElement DOM event, so the DOM events are propagated through Observable.
         *
         *		const bind = Template.bind( observableInstance, emitterInstance );
         *
         *		new Template( {
         *			tag: 'p',
         *			attributes: {
         *				// class="..." attribute gets bound to `observableInstance#a`
         *				'class': bind.to( 'a' )
         *			},
         *			children: [
         *				// <p>...</p> gets bound to `observableInstance#b`; always `toUpperCase()`.
         *				{ text: bind.to( 'b', ( value, node ) => value.toUpperCase() ) }
         *			],
         *			on: {
         *				click: [
         *					// "clicked" event will be fired on `observableInstance` when "click" fires in DOM.
         *					bind( 'clicked' ),
         *
         *					// A custom callback function will be executed when "click" fires in DOM.
         *					bind( () => {
         *						...
         *					} )
         *				]
         *			}
         *		} ).render();
         *
         *		const bind = Template.bind( observableInstance, emitterInstance );
         *
         *		new Template( {
         *			tag: 'p',
         *		} ).render();
         *
         * @static
         * @method ui.Template.bind#to
         * @param {String} attribute Name of {@link utils.ObservableMixin} used in the binding.
         * @param {Function} [callback] Allows processing of the value. Accepts `Node` and `value` as arguments.
         * @return {ui.TemplateBinding}
         */

    				to: function to(eventNameOrFuncionOrAttribute, callback) {
    					return {
    						type: bindToSymbol,
    						eventNameOrFunction: eventNameOrFuncionOrAttribute,
    						attribute: eventNameOrFuncionOrAttribute,
    						observable: observable, emitter: emitter, callback: callback
    					};
    				},


    				/**
         * Binds {@link utils.ObservableMixin} to HTMLElement attribute or Text Node `textContent`
         * so remains in sync with the Model when it changes. Unlike {@link ui.Template.bind#to},
         * it controls the presence of the attribute/`textContent` depending on the "falseness" of
         * {@link utils.ObservableMixin} attribute.
         *
         *		const bind = Template.bind( observableInstance, emitterInstance );
         *
         *		new Template( {
         *			tag: 'input',
         *			attributes: {
         *				// <input checked> when `observableInstance#a` is not undefined/null/false/''
         *				// <input> when `observableInstance#a` is undefined/null/false
         *				checked: bind.if( 'a' )
         *			},
         *			children: [
         *				{
         *					// <input>"b-is-not-set"</input> when `observableInstance#b` is undefined/null/false/''
         *					// <input></input> when `observableInstance#b` is not "falsy"
         *					text: bind.if( 'b', 'b-is-not-set', ( value, node ) => !value )
         *				}
         *			]
         *		} ).render();
         *
         * @static
         * @method ui.Template.bind#if
         * @param {String} attribute An attribute name of {@link utils.ObservableMixin} used in the binding.
         * @param {String} [valueIfTrue] Value set when {@link utils.ObservableMixin} attribute is not undefined/null/false/''.
         * @param {Function} [callback] Allows processing of the value. Accepts `Node` and `value` as arguments.
         * @return {ui.TemplateBinding}
         */
    				if: function _if(attribute, valueIfTrue, callback) {
    					return {
    						type: bindIfSymbol,
    						observable: observable, emitter: emitter, attribute: attribute, valueIfTrue: valueIfTrue, callback: callback
    					};
    				}
    			};
    		}

    		/**
       * Extends {@link ui.Template} or {@link ui.TemplateDefinition} with additional content.
       *
       *		const bind = Template.bind( observable, emitterInstance );
       *		const instance = new Template( {
       *			tag: 'p',
       *			attributes: {
       *				class: 'a',
       *				data-x: bind.to( 'foo' )
       *			},
       *			children: [
       *				{
       *					tag: 'span',
       *					attributes: {
       *						class: 'b'
       *					},
       *					children: [
       *						'Span'
       *					]
       *				}
       *			]
       *		 } );
       *
       *		// Instance-level extension.
       *		Template.extend( instance, {
       *			attributes: {
       *				class: 'b',
       *				data-x: bind.to( 'bar' )
       *			},
       *			children: [
       *				{
       *					attributes: {
       *						class: 'c'
       *					}
       *				}
       *			]
       *		} );
       *
       *		// Fragment extension.
       *		Template.extend( instance.definition.children[ 0 ], {
       *			attributes: {
       *				class: 'd'
       *			}
       *		} );
       *
       * the `instance.render().outerHTML` is
       *
       *		<p class="a b" data-x="{ observable.foo } { observable.bar }">
       *			<span class="b c d">Span</span>
       *		</p>
       *
       * @param {ui.Template|ui.TemplateDefinition} instanceOrDef Existing Template instance or definition to be extended.
       * @param {ui.TemplateDefinition} extDef An extension to existing instance or definition.
       */

    	}, {
    		key: 'extend',
    		value: function extend(instanceOrDef, extDef) {
    			var extDefClone = clone$1(extDef);

    			normalize(extDefClone);

    			if (instanceOrDef instanceof Template) {
    				extendTemplateDefinition(instanceOrDef.definition, extDefClone);
    			}
    			// Extend a particular child in existing template instance.
    			//
    			//		Template.extend( instance.definition.children[ 0 ], {
    			//			attributes: {
    			//				class: 'd'
    			//			}
    			//		} );
    			//
    			else {
    					extendTemplateDefinition(instanceOrDef, extDefClone);
    				}
    		}
    	}]);
    	return Template;
    }();

    mix(Template, EmitterMixin);

    // Checks whether given {@link ui.TemplateValueSchema} contains a
    // {@link ui.TemplateBinding}.
    //
    // @param {ui.TemplateValueSchema} valueSchema
    // @returns {Boolean}
    function hasBinding(valueSchema) {
    	if (!valueSchema) {
    		return false;
    	}

    	// Normalize attributes with additional data like namespace:
    	// 		class: { ns: 'abc', value: [ ... ] }
    	if (valueSchema.value) {
    		valueSchema = valueSchema.value;
    	}

    	if (Array.isArray(valueSchema)) {
    		return valueSchema.some(hasBinding);
    	} else if (valueSchema.observable) {
    		return true;
    	}

    	return false;
    }

    // Assembles the value using {@link ui.TemplateValueSchema} and stores it in a form of
    // an Array. Each entry of an Array corresponds to one of {@link ui.TemplateValueSchema}
    // items.
    //
    // @param {ui.TemplateValueSchema} valueSchema
    // @param {Node} node DOM Node updated when {@link utils.ObservableMixin} changes.
    // @return {Array}
    function getBindingValue(valueSchema, domNode) {
    	return valueSchema.map(function (schemaItem) {
    		var observable = schemaItem.observable;
    		var callback = schemaItem.callback;
    		var type = schemaItem.type;


    		if (observable) {
    			var modelValue = observable[schemaItem.attribute];

    			// Process the value with the callback.
    			if (callback) {
    				modelValue = callback(modelValue, domNode);
    			}

    			if (type === bindIfSymbol) {
    				return !!modelValue ? schemaItem.valueIfTrue || true : '';
    			} else {
    				return modelValue;
    			}
    		} else {
    			return schemaItem;
    		}
    	});
    }

    // A function executed each time bound Observable attribute changes, which updates DOM with a value
    // constructed from {@link ui.TemplateValueSchema}.
    //
    // @param {ui.TemplateValueSchema} valueSchema
    // @param {Node} node DOM Node updated when {@link utils.ObservableMixin} changes.
    // @param {Function} domUpdater A function which updates DOM (like attribute or text).
    function syncBinding(valueSchema, domNode, domUpdater) {
    	var value = getBindingValue(valueSchema, domNode);
    	var shouldSet = void 0;

    	// Check if valueSchema is a single Template.bind.if, like:
    	//		{ class: Template.bind.if( 'foo' ) }
    	if (valueSchema.length == 1 && valueSchema[0].type == bindIfSymbol) {
    		value = value[0];
    		shouldSet = value !== '';

    		if (shouldSet) {
    			value = value === true ? '' : value;
    		}
    	} else {
    		value = value.reduce(arrayValueReducer, '');
    		shouldSet = value;
    	}

    	if (shouldSet) {
    		domUpdater.set(value);
    	} else {
    		domUpdater.remove();
    	}
    }

    // Returns an object consisting of `set` and `remove` functions, which
    // can be used in the context of DOM Node to set or reset `textContent`.
    // @see ui.View#_bindToObservable
    //
    // @param {Node} node DOM Node to be modified.
    // @returns {Object}
    function getTextUpdater(node) {
    	return {
    		set: function set(value) {
    			node.textContent = value;
    		},
    		remove: function remove() {
    			node.textContent = '';
    		}
    	};
    }

    // Returns an object consisting of `set` and `remove` functions, which
    // can be used in the context of DOM Node to set or reset an attribute.
    // @see ui.View#_bindToObservable
    //
    // @param {Node} node DOM Node to be modified.
    // @param {String} attrName Name of the attribute to be modified.
    // @param {String} [ns=null] Namespace to use.
    // @returns {Object}
    function getAttributeUpdater(el, attrName) {
    	var ns = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

    	return {
    		set: function set(value) {
    			el.setAttributeNS(ns, attrName, value);
    		},
    		remove: function remove() {
    			el.removeAttributeNS(ns, attrName);
    		}
    	};
    }

    // Returns an object consisting of `set` and `remove` functions, which
    // can be used in the context of CSSStyleDeclaration to set or remove a style.
    // @see ui.View#_bindToObservable
    //
    // @param {Node} node DOM Node to be modified.
    // @param {String} styleName Name of the style to be modified.
    // @returns {Object}
    function getStyleUpdater(el, styleName) {
    	return {
    		set: function set(value) {
    			el.style[styleName] = value;
    		},
    		remove: function remove() {
    			el.style[styleName] = null;
    		}
    	};
    }

    // Clones definition of the template.
    //
    // @param {ui.TemplateDefinition} def
    // @returns {ui.TemplateDefinition}
    function clone$1(def) {
    	var clone = cloneDeepWith(def, function (value) {
    		// Don't clone Template.bind* bindings because there are references
    		// to Observable and DOMEmitterMixin instances inside, which are external
    		// to the Template.
    		if (value && value.type) {
    			return value;
    		}
    	});

    	return clone;
    }

    // Normalizes given {@link ui.TemplateDefinition}.
    //
    // See:
    //  * {@link normalizeAttributes}
    //  * {@link normalizeListeners}
    //  * {@link normalizeTextString}
    //  * {@link normalizeTextDefinition}
    //
    // @param {ui.TemplateDefinition} def
    function normalize(def) {
    	if (def.text) {
    		normalizeTextDefinition(def);
    	}

    	if (def.attributes) {
    		normalizeAttributes(def.attributes);
    	}

    	if (def.on) {
    		normalizeListeners(def.on);
    	}

    	if (def.children) {
    		// Splicing children array inside so no forEach.
    		for (var i = def.children.length; i--;) {
    			normalizeTextString(def.children, def.children[i], i);
    			normalize(def.children[i]);
    		}
    	}
    }

    // Normalizes "attributes" section of {@link ui.TemplateDefinition}.
    //
    //		attributes: {
    //			a: 'bar',
    //			b: {@link ui.TemplateBinding},
    //			c: {
    //				value: 'bar'
    //			}
    //		}
    //
    // becomes
    //
    //		attributes: {
    //			a: [ 'bar' ],
    //			b: [ {@link ui.TemplateBinding} ],
    //			c: {
    //				value: [ 'bar' ]
    //			}
    //		}
    //
    // @param {Object} attrs
    function normalizeAttributes(attrs) {
    	for (var a in attrs) {
    		if (attrs[a].value) {
    			attrs[a].value = [].concat(attrs[a].value);
    		}

    		arrayify(attrs, a);
    	}
    }

    // Normalizes "on" section of {@link ui.TemplateDefinition}.
    //
    //		on: {
    //			a: 'bar',
    //			b: {@link ui.TemplateBinding},
    //			c: [ {@link ui.TemplateBinding}, () => { ... } ]
    //		}
    //
    // becomes
    //
    //		on: {
    //			a: [ 'bar' ],
    //			b: [ {@link ui.TemplateBinding} ],
    //			c: [ {@link ui.TemplateBinding}, () => { ... } ]
    //		}
    //
    // @param {Object} listeners
    function normalizeListeners(listeners) {
    	for (var l in listeners) {
    		arrayify(listeners, l);
    	}
    }

    // Normalizes "string" text in "children" section of {@link ui.TemplateDefinition}.
    //
    //		children: [
    //			'abc',
    //		]
    //
    // becomes
    //
    //		children: [
    //			{ text: [ 'abc' ] },
    //		]
    //
    // @param {Array} children
    // @param {ui.TemplateDefinition} child
    // @param {Number} index
    function normalizeTextString(children, child, index) {
    	if (typeof child == 'string') {
    		children.splice(index, 1, {
    			text: [child]
    		});
    	}
    }

    // Normalizes text {@link ui.TemplateDefinition}.
    //
    //		children: [
    //			{ text: 'def' },
    //			{ text: {@link ui.TemplateBinding} }
    //		]
    //
    // becomes
    //
    //		children: [
    //			{ text: [ 'def' ] },
    //			{ text: [ {@link ui.TemplateBinding} ] }
    //		]
    //
    // @param {ui.TemplateDefinition} def
    function normalizeTextDefinition(def) {
    	if (!Array.isArray(def.text)) {
    		def.text = [def.text];
    	}
    }

    // Wraps an entry in Object in an Array, if not already one.
    //
    //		{
    //			x: 'y',
    //			a: [ 'b' ]
    //		}
    //
    // becomes
    //
    //		{
    //			x: [ 'y' ],
    //			a: [ 'b' ]
    //		}
    //
    // @param {Object} obj
    // @param {String} key
    function arrayify(obj, key) {
    	if (!Array.isArray(obj[key])) {
    		obj[key] = [obj[key]];
    	}
    }

    // A helper which concatenates the value avoiding unwanted
    // leading white spaces.
    //
    // @param {String} prev
    // @param {String} cur
    // @returns {String}
    function arrayValueReducer(prev, cur) {
    	return prev === '' ? '' + cur : cur === '' ? '' + prev : prev + ' ' + cur;
    }

    // Extends one object defined in the following format:
    //
    //		{
    //			key1: [Array1],
    //			key2: [Array2],
    //			...
    //			keyN: [ArrayN]
    //		}
    //
    // with another object of the same data format.
    //
    // @param {Object} obj Base object.
    // @param {Object} ext Object extending base.
    // @returns {String}
    function extendObjectValueArray(obj, ext) {
    	for (var a in ext) {
    		if (obj[a]) {
    			var _obj$a;

    			(_obj$a = obj[a]).push.apply(_obj$a, toConsumableArray(ext[a]));
    		} else {
    			obj[a] = ext[a];
    		}
    	}
    }

    // A helper for {@link ui.Template#extend}. Recursively extends {@link ui.Template#definition}
    // with content from another definition. See {@link ui.Template#extend} to learn more.
    //
    // @param {ui.TemplateDefinition} def A base template definition.
    // @param {ui.TemplateDefinition} extDef An extension to existing definition.
    function extendTemplateDefinition(def, extDef) {
    	if (extDef.attributes) {
    		if (!def.attributes) {
    			def.attributes = {};
    		}

    		extendObjectValueArray(def.attributes, extDef.attributes);
    	}

    	if (extDef.on) {
    		if (!def.on) {
    			def.on = {};
    		}

    		extendObjectValueArray(def.on, extDef.on);
    	}

    	if (extDef.text) {
    		var _def$text;

    		(_def$text = def.text).push.apply(_def$text, toConsumableArray(extDef.text));
    	}

    	if (extDef.children) {
    		if (!def.children || def.children.length != extDef.children.length) {
    			/**
        * The number of children in extended definition does not match.
        *
        * @error ui-template-extend-children-mismatch
        */
    			throw new CKEditorError('ui-template-extend-children-mismatch: The number of children in extended definition does not match.');
    		}

    		extDef.children.forEach(function (extChildDef, index) {
    			extendTemplateDefinition(def.children[index], extChildDef);
    		});
    	}
    }

    /**
     * Creates a ProxyEmitter instance. Such an instance is a bridge between a DOM Node firing events
     * and any Host listening to them. It is backwards compatible with {@link utils.EmitterMixin#on}.
     *
     * @memberOf ui
     * @mixes utils.EmitterMixin
     * @implements ui.DOMEmitter
     */

    var ProxyEmitter =
    /**
     * @param {Node} node DOM Node that fires events.
     * @returns {Object} ProxyEmitter instance bound to the DOM Node.
     */
    function ProxyEmitter(node) {
    	classCallCheck(this, ProxyEmitter);

    	// Set emitter ID to match DOM Node "expando" property.
    	this._emitterId = getNodeUID(node);

    	// Remember the DOM Node this ProxyEmitter is bound to.
    	this._domNode = node;
    };

    assignIn(ProxyEmitter.prototype, EmitterMixin, {
    	/**
      * Collection of native DOM listeners.
      *
      * @private
      * @member {Object} ui.ProxyEmitter#_domListeners
      */

    	/**
      * Registers a callback function to be executed when an event is fired.
      *
      * It attaches a native DOM listener to the DOM Node. When fired,
      * a corresponding Emitter event will also fire with DOM Event object as an argument.
      *
      * @param {String} event The name of the event.
      * @param {Function} callback The function to be called on event.
      * @param {Object} [ctx] The object that represents `this` in the callback. Defaults to the object firing the
      * event.
      * @param {Number} [priority=10] The priority of this callback in relation to other callbacks to that same event.
      * Lower values are called first.
      *
      * @method ui.ProxyEmitter#on
      */

    	on: function on(event) {
    		// Execute parent class method first.
    		EmitterMixin.on.apply(this, arguments);

    		// If the DOM Listener for given event already exist it is pointless
    		// to attach another one.
    		if (this._domListeners && this._domListeners[event]) {
    			return;
    		}

    		var domListener = this._createDomListener(event);

    		// Attach the native DOM listener to DOM Node.
    		this._domNode.addEventListener(event, domListener);

    		if (!this._domListeners) {
    			this._domListeners = {};
    		}

    		// Store the native DOM listener in this ProxyEmitter. It will be helpful
    		// when stopping listening to the event.
    		this._domListeners[event] = domListener;
    	},


    	/**
      * Stops executing the callback on the given event.
      *
      * @param {String} event The name of the event.
      * @param {Function} callback The function to stop being called.
      * @param {Object} [ctx] The context object to be removed, pared with the given callback. To handle cases where
      * the same callback is used several times with different contexts.
      *
      * @method ui.ProxyEmitter#off
      */
    	off: function off(event) {
    		// Execute parent class method first.
    		EmitterMixin.off.apply(this, arguments);

    		var events = void 0;

    		// Remove native DOM listeners which are orphans. If no callbacks
    		// are awaiting given event, detach native DOM listener from DOM Node.
    		// See: {@link on}.
    		if (!(events = this._events[event]) || !events.callbacks.length) {
    			this._domListeners[event].removeListener();
    		}
    	},


    	/**
      * Create a native DOM listener callback. When the native DOM event
      * is fired it will fire corresponding event on this ProxyEmitter.
      * Note: A native DOM Event is passed as an argument.
      *
      * @param {String} event
      *
      * @method ui.ProxyEmitter#_createDomListener
      * @returns {Function} The DOM listener callback.
      */
    	_createDomListener: function _createDomListener(event) {
    		var _this = this;

    		var domListener = function domListener(domEvt) {
    			_this.fire(event, domEvt);
    		};

    		// Supply the DOM listener callback with a function that will help
    		// detach it from the DOM Node, when it is no longer necessary.
    		// See: {@link off}.
    		domListener.removeListener = function () {
    			_this._domNode.removeEventListener(event, domListener);
    			delete _this._domListeners[event];
    		};

    		return domListener;
    	}
    });

    /**
     * Mixin that injects the DOM events API into its host. It provides the API
     * compatible with {@link utils.EmitterMixin}.
     *
     *                                  listenTo( click, ... )
     *                    +-----------------------------------------+
     *                    |              stopListening( ... )       |
     *     +----------------------------+                           |             addEventListener( click, ... )
     *     | Host                       |                           |   +---------------------------------------------+
     *     +----------------------------+                           |   |       removeEventListener( click, ... )     |
     *     | _listeningTo: {            |                +----------v-------------+                                   |
     *     |   UID: {                   |                | ProxyEmitter           |                                   |
     *     |     emitter: ProxyEmitter, |                +------------------------+                      +------------v----------+
     *     |     callbacks: {           |                | events: {              |                      | Node (HTMLElement)    |
     *     |       click: [ callbacks ] |                |   click: [ callbacks ] |                      +-----------------------+
     *     |     }                      |                | },                     |                      | data-cke-expando: UID |
     *     |   }                        |                | _domNode: Node,        |                      +-----------------------+
     *     | }                          |                | _domListeners: {},     |                                   |
     *     | +------------------------+ |                | _emitterId: UID        |                                   |
     *     | | DOMEmitterMixin        | |                +--------------^---------+                                   |
     *     | +------------------------+ |                           |   |                                             |
     *     +--------------^-------------+                           |   +---------------------------------------------+
     *                    |                                         |                  click (DOM Event)
     *                    +-----------------------------------------+
     *                                fire( click, DOM Event )
     *
     * @mixin ui.DOMEmitterMixin
     * @mixes utils.EmitterMixin
     * @implements ui.DOMEmitter
     */
    var DOMEmitterMixin = assignIn({}, EmitterMixin, {
    	/**
      * Registers a callback function to be executed when an event is fired in a specific Emitter or DOM Node.
      * It is backwards compatible with {@link utils.EmitterMixin#listenTo}.
      *
      * @param {utils.Emitter|Node} emitter The object that fires the event.
      * @param {String} event The name of the event.
      * @param {Function} callback The function to be called on event.
      * @param {Object} [ctx] The object that represents `this` in the callback. Defaults to `emitter`.
      * @param {Number} [priority=10] The priority of this callback in relation to other callbacks to that same event.
      * Lower values are called first.
      *
      * @method ui.DOMEmitterMixin#listenTo
      */

    	listenTo: function listenTo() {
    		var args = Array.prototype.slice.call(arguments);
    		var emitter = args[0];

    		// Check if emitter is an instance of DOM Node. If so, replace the argument with
    		// corresponding ProxyEmitter (or create one if not existing).
    		if (isDomNode(emitter)) {
    			args[0] = this._getProxyEmitter(emitter) || new ProxyEmitter(emitter);
    		}

    		// Execute parent class method with Emitter (or ProxyEmitter) instance.
    		EmitterMixin.listenTo.apply(this, args);
    	},


    	/**
      * Stops listening for events. It can be used at different levels:
      * It is backwards compatible with {@link utils.EmitterMixin#listenTo}.
      *
      * * To stop listening to a specific callback.
      * * To stop listening to a specific event.
      * * To stop listening to all events fired by a specific object.
      * * To stop listening to all events fired by all object.
      *
      * @param {utils.Emitter|Node} [emitter] The object to stop listening to. If omitted, stops it for all objects.
      * @param {String} [event] (Requires the `emitter`) The name of the event to stop listening to. If omitted, stops it
      * for all events from `emitter`.
      * @param {Function} [callback] (Requires the `event`) The function to be removed from the call list for the given
      * `event`.
      *
      * @method ui.DOMEmitterMixin#stopListening
      */
    	stopListening: function stopListening() {
    		var args = Array.prototype.slice.call(arguments);
    		var emitter = args[0];

    		// Check if emitter is an instance of DOM Node. If so, replace the argument with corresponding ProxyEmitter.
    		if (isDomNode(emitter)) {
    			var proxy = this._getProxyEmitter(emitter);

    			if (proxy) {
    				args[0] = proxy;
    			} else {
    				log.error('domemittermixin-stoplistening: Stopped listening on a DOM Node that has no emitter or emitter is gone.', emitter);
    			}
    		}

    		// Execute parent class method with Emitter (or ProxyEmitter) instance.
    		EmitterMixin.stopListening.apply(this, args);
    	},


    	/**
      * Retrieves ProxyEmitter instance for given DOM Node residing in this Host.
      *
      * @param {Node} node DOM Node of the ProxyEmitter.
      * @method ui.DOMEmitterMixin#_getProxyEmitter
      * @return {ProxyEmitter} ProxyEmitter instance or null.
      */
    	_getProxyEmitter: function _getProxyEmitter(node) {
    		var proxy = void 0,
    		    emitters = void 0,
    		    emitterInfo = void 0;

    		// Get node UID. It allows finding Proxy Emitter for this DOM Node.
    		var uid = getNodeUID(node);

    		// Find existing Proxy Emitter for this DOM Node among emitters.
    		if (emitters = this._listeningTo) {
    			if (emitterInfo = emitters[uid]) {
    				proxy = emitterInfo.emitter;
    			}
    		}

    		return proxy || null;
    	}
    });

    // Gets an unique DOM Node identifier. The identifier will be set if not defined.
    //
    // @private
    // @param {Node} node
    // @return {Number} UID for given DOM Node.
    function getNodeUID(node) {
    	return node['data-ck-expando'] || (node['data-ck-expando'] = uid());
    }

    // Checks (naively) if given node is native DOM Node.
    //
    // @private
    // @param {Node} node
    // @return {Boolean} True when native DOM Node.
    function isDomNode(node) {
    	return node && isNative(node.addEventListener);
    }

    /**
     * Basic View class.
     *
     * @memberOf ui
     * @mixes DOMEmitterMixin
     */

    var View = function () {
    	/**
      * Creates an instance of the {@link ui.View} class.
      *
      * @param {utils.Locale} [locale] The {@link ckeditor5.Editor#locale editor's locale} instance.
      */

    	function View(locale) {
    		classCallCheck(this, View);

    		/**
       * Model of this view.
       *
       * @member {ui.Model} ui.View#model
       */
    		this.model = new Model();

    		/**
       * @readonly
       * @member {utils.Locale} ui.View#locale
       */
    		this.locale = locale;

    		/**
       * Shorthand for {@link utils.Locale#t}.
       *
       * Note: If locale instance hasn't been passed to the view this method may not be available.
       *
       * @see utils.Locale#t
       * @method ui.View#t
       */
    		this.t = locale && locale.t;

    		/**
       * Regions of this view. See {@link ui.View#register}.
       *
       * @member {utils.Collection} ui.View#regions
       */
    		this.regions = new Collection({
    			idProperty: 'name'
    		});

    		/**
       * Template of this view.
       *
       * @member {ui.Template} ui.View#template
       */

    		/**
       * Region selectors of this view. See {@link ui.View#register}.
       *
       * @private
       * @member {Object} ui.View#_regionSelectors
       */
    		this._regionSelectors = {};

    		/**
       * Element of this view.
       *
       * @private
       * @member {HTMLElement} ui.View.#_element
       */

    		/**
       * Cached {@link ui.Template} binder object specific for this instance.
       * See {@link ui.View#bind}.
       *
       * @private
       * @member {Object} ui.View.#_bind
       */
    	}

    	/**
      * Element of this view. The element is rendered on first reference
      * using {@link ui.View#template} definition.
      *
      * @type {HTMLElement}
      */


    	createClass(View, [{
    		key: 'init',


    		/**
       * Initializes the view.
       *
       * Note: {@link ui.Controller} supports if a promise is returned by this method,
       * what means that view initialization may be asynchronous.
       */
    		value: function init() {
    			this._initRegions();
    		}

    		/**
       * Registers a region in {@link ui.View#regions}.
       *
       *		let view = new View();
       *
       *		// region.name == "foo", region.element == view.element.firstChild
       *		view.register( 'foo', el => el.firstChild );
       *
       *		// region.name == "bar", region.element == view.element.querySelector( 'span' )
       *		view.register( new Region( 'bar' ), 'span' );
       *
       *		// region.name == "bar", region.element == view.element.querySelector( '#div#id' )
       *		view.register( 'bar', 'div#id', true );
       *
       *		// region.name == "baz", region.element == null
       *		view.register( 'baz', true );
       *
       * @param {String|Region} stringOrRegion The name or an instance of the Region
       * to be registered. If `String`, the region will be created on the fly.
       * @param {String|Function|true} regionSelector The selector to retrieve region's element
       * in DOM when the region instance is initialized (see {@link Region#init}, {@link ui.View#init}).
       * @param {Boolean} [override] When set `true` it will allow overriding of registered regions.
       */

    	}, {
    		key: 'register',
    		value: function register() {
    			var region = void 0,
    			    regionName = void 0;

    			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    				args[_key] = arguments[_key];
    			}

    			if (typeof args[0] === 'string') {
    				regionName = args[0];
    				region = this.regions.get(regionName) || new Region(regionName);
    			} else if (args[0] instanceof Region) {
    				regionName = args[0].name;
    				region = args[0];
    			} else {
    				/**
         * A name of the region or an instance of Region is required.
         *
         * @error ui-view-register-wrongtype
         */
    				throw new CKEditorError('ui-view-register-wrongtype');
    			}

    			var regionSelector = args[1];

    			if (!regionSelector || !isValidRegionSelector(regionSelector)) {
    				/**
         * The selector must be String, Function or `true`.
         *
         * @error ui-view-register-badselector
         */
    				throw new CKEditorError('ui-view-register-badselector');
    			}

    			var registered = this.regions.get(regionName);

    			if (!registered) {
    				this.regions.add(region);
    			} else {
    				if (registered !== region) {
    					if (!args[2]) {
    						/**
           * Overriding is possible only when `override` flag is set.
           *
           * @error ui-view-register-override
           */
    						throw new CKEditorError('ui-view-register-override');
    					}

    					this.regions.remove(registered);
    					this.regions.add(region);
    				}
    			}

    			this._regionSelectors[regionName] = regionSelector;
    		}

    		/**
       * Destroys the view instance. The process includes:
       *
       * 1. Removal of child views from {@link ui.View#regions}.
       * 2. Destruction of the {@link ui.View#regions}.
       * 3. Removal of {@link #_el} from DOM.
       */

    	}, {
    		key: 'destroy',
    		value: function destroy() {
    			var childView = void 0;

    			this.stopListening();

    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = this.regions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var region = _step.value;

    					while (childView = region.views.get(0)) {
    						region.views.remove(childView);
    					}

    					this.regions.remove(region).destroy();
    				}
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}

    			if (this.template) {
    				this.element.remove();
    			}

    			this.model = this.regions = this.template = this.locale = this.t = null;
    			this._regionSelectors = this._element = null;
    		}

    		/**
       * Initializes {@link ui.View#regions} of this view by passing a DOM element
       * generated from {@link ui.View#_regionSelectors} into {@link Region#init}.
       *
       * @protected
       */

    	}, {
    		key: '_initRegions',
    		value: function _initRegions() {
    			var region = void 0,
    			    regionEl = void 0,
    			    regionSelector = void 0;

    			var _iteratorNormalCompletion2 = true;
    			var _didIteratorError2 = false;
    			var _iteratorError2 = undefined;

    			try {
    				for (var _iterator2 = this.regions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    					region = _step2.value;

    					regionSelector = this._regionSelectors[region.name];

    					if (typeof regionSelector == 'string') {
    						regionEl = this.element.querySelector(regionSelector);
    					} else if (typeof regionSelector == 'function') {
    						regionEl = regionSelector(this.element);
    					} else {
    						regionEl = null;
    					}

    					region.init(regionEl);
    				}
    			} catch (err) {
    				_didIteratorError2 = true;
    				_iteratorError2 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion2 && _iterator2.return) {
    						_iterator2.return();
    					}
    				} finally {
    					if (_didIteratorError2) {
    						throw _iteratorError2;
    					}
    				}
    			}
    		}
    	}, {
    		key: 'element',
    		get: function get() {
    			if (this._element) {
    				return this._element;
    			}

    			// No template means no element (a virtual view).
    			if (!this.template) {
    				return null;
    			}

    			return this._element = this.template.render();
    		},
    		set: function set(el) {
    			this._element = el;
    		}

    		/**
       * Shorthand for {@link ui.Template#bind}, bound to {@link ui.View#model}
       * and {@link ui.View} on the first access.
       *
       * Cached {@link ui.Template#bind} object is stored in {@link ui.View.#_bind}.
       *
       * @method ui.View#bind
       */

    	}, {
    		key: 'bind',
    		get: function get() {
    			if (this._bind) {
    				return this._bind;
    			}

    			return this._bind = Template.bind(this.model, this);
    		}
    	}]);
    	return View;
    }();

    mix(View, DOMEmitterMixin);

    var validSelectorTypes = new Set(['string', 'boolean', 'function']);

    /**
     * Check whether region selector is valid.
     *
     * @ignore
     * @private
     * @param {*} selector Selector to be checked.
     * @returns {Boolean}
     */
    function isValidRegionSelector(selector) {
    	return validSelectorTypes.has(typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) && selector !== false;
    }

    /**
     * The icon manager view class.
     *
     * See {@link ui.iconManager.IconManager}.
     *
     * @memberOf ui.iconManager
     * @extends ui.View
     */

    var IconManagerView = function (_View) {
    	inherits(IconManagerView, _View);

    	function IconManagerView(locale) {
    		classCallCheck(this, IconManagerView);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(IconManagerView).call(this, locale));

    		_this.template = new Template({
    			tag: 'svg',
    			ns: 'http://www.w3.org/2000/svg',
    			attributes: {
    				class: 'ck-icon-manager-sprite'
    			}
    		});

    		/**
       * Model of this icon manager view.
       *
       * @member {ui.iconManager.IconManagerViewModel} ui.iconManager.IconManagerView#model
       */
    		return _this;
    	}

    	createClass(IconManagerView, [{
    		key: 'init',
    		value: function init() {
    			this.element.innerHTML = this.model.sprite;

    			return get(Object.getPrototypeOf(IconManagerView.prototype), 'init', this).call(this);
    		}
    	}]);
    	return IconManagerView;
    }(View);

    var iconIds = ['ck-icon-align-center', 'ck-icon-align-left', 'ck-icon-align-right', 'ck-icon-bold', 'ck-icon-bold', 'ck-icon-bulletedlist', 'ck-icon-image', 'ck-icon-italic', 'ck-icon-italic', 'ck-icon-link', 'ck-icon-numberedlist', 'ck-icon-picker', 'ck-icon-quote', 'ck-icon-redo', 'ck-icon-source', 'ck-icon-table', 'ck-icon-underline', 'ck-icon-undo', 'ck-icon-unlink'];
    var iconPrefix = 'ck-icon-';

    var iconManagerModel = new Model({
      icons: iconIds.map(function (i) {
        return i.slice(iconPrefix.length);
      }),
      sprite: '<symbol viewBox="0 0 20 20" id="ck-icon-align-center"><title>align-center</title><path d="M16 10v1H4v-1h12zm-1 6v1H5v-1h10zm3-3v1H2v-1h16zm-2-9v1H4V4h12zm2 3v1H2V7h16z" fill="#444" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-align-left"><title>align-left</title><path d="M3 10v1h12v-1H3zm0 6v1h10v-1H3zm0-3v1h15v-1H3zm0-9v1h12V4H3zm0 3v1h15V7H3z" fill="#444" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-align-right"><title>align-right</title><path d="M17 10v1H5v-1h12zm0 6v1H7v-1h10zm0-3v1H2v-1h15zm0-9v1H5V4h12zm0 3v1H2V7h15z" fill="#444" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-bold"><title>bold</title><path d="M15.135 10.41c.36.247.654.558.88.933.225.375.338.816.338 1.324 0 .61-.128 1.123-.385 1.543-.256.42-.624.75-1.103.994a5.908 5.908 0 0 1-1.755.55c-.663.107-1.442.16-2.338.16H4.54v-.66a22.5 22.5 0 0 0 .66-.076c.264-.033.45-.073.557-.118.208-.085.35-.196.427-.334.076-.138.114-.317.114-.537V5.73c0-.203-.03-.372-.093-.507-.062-.135-.21-.254-.448-.355a3.326 3.326 0 0 0-.61-.182c-.23-.048-.433-.086-.608-.114v-.66h6.52c1.64 0 2.824.226 3.55.677.728.452 1.092 1.117 1.092 1.996 0 .406-.082.763-.245 1.07a2.388 2.388 0 0 1-.702.8c-.277.208-.606.388-.99.54-.383.153-.795.28-1.234.38v.162c.44.045.897.142 1.37.29.474.15.886.344 1.235.58zm-2.723-3.612c0-.665-.187-1.184-.562-1.556-.375-.372-.937-.558-1.687-.558a8.89 8.89 0 0 0-.42.012c-.17.01-.32.016-.443.02v4.45h.44c.913 0 1.587-.213 2.02-.64.435-.424.652-1 .652-1.728zm.592 5.76c0-.836-.248-1.476-.744-1.92-.496-.446-1.21-.67-2.14-.67a22.977 22.977 0 0 0-.82.034v4.39c.05.208.21.385.474.528.265.144.586.216.964.216.67 0 1.216-.225 1.636-.676.42-.452.63-1.086.63-1.903z" fill="#454545" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-bold"><title>bold</title><path d="M15.135 10.41c.36.247.654.558.88.933.225.375.338.816.338 1.324 0 .61-.128 1.123-.385 1.543-.256.42-.624.75-1.103.994a5.908 5.908 0 0 1-1.755.55c-.663.107-1.442.16-2.338.16H4.54v-.66a22.5 22.5 0 0 0 .66-.076c.264-.033.45-.073.557-.118.208-.085.35-.196.427-.334.076-.138.114-.317.114-.537V5.73c0-.203-.03-.372-.093-.507-.062-.135-.21-.254-.448-.355a3.326 3.326 0 0 0-.61-.182c-.23-.048-.433-.086-.608-.114v-.66h6.52c1.64 0 2.824.226 3.55.677.728.452 1.092 1.117 1.092 1.996 0 .406-.082.763-.245 1.07a2.388 2.388 0 0 1-.702.8c-.277.208-.606.388-.99.54-.383.153-.795.28-1.234.38v.162c.44.045.897.142 1.37.29.474.15.886.344 1.235.58zm-2.723-3.612c0-.665-.187-1.184-.562-1.556-.375-.372-.937-.558-1.687-.558a8.89 8.89 0 0 0-.42.012c-.17.01-.32.016-.443.02v4.45h.44c.913 0 1.587-.213 2.02-.64.435-.424.652-1 .652-1.728zm.592 5.76c0-.836-.248-1.476-.744-1.92-.496-.446-1.21-.67-2.14-.67a22.977 22.977 0 0 0-.82.034v4.39c.05.208.21.385.474.528.265.144.586.216.964.216.67 0 1.216-.225 1.636-.676.42-.452.63-1.086.63-1.903z" fill="#454545" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-bulletedlist"><title>bulletedlist</title><path d="M6 16v1h10v-1H6zM6 4v1h12V4H6zm0 6v1h11v-1H6zM1 4.5C1 3.672 1.666 3 2.5 3 3.328 3 4 3.666 4 4.5 4 5.328 3.334 6 2.5 6 1.672 6 1 5.334 1 4.5zm0 6C1 9.672 1.666 9 2.5 9c.828 0 1.5.666 1.5 1.5 0 .828-.666 1.5-1.5 1.5-.828 0-1.5-.666-1.5-1.5zm0 6c0-.828.666-1.5 1.5-1.5.828 0 1.5.666 1.5 1.5 0 .828-.666 1.5-1.5 1.5-.828 0-1.5-.666-1.5-1.5z" fill="#454545" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-image"><title>image</title><path d="M2 14.994A2 2 0 0 0 3.994 17h12.012A2 2 0 0 0 18 14.994V5.006A2 2 0 0 0 16.006 3H3.994A2 2 0 0 0 2 5.006v9.988zm1-9.992C3 4.45 3.45 4 4.007 4h11.986A1.01 1.01 0 0 1 17 5.002v9.996C17 15.55 16.55 16 15.993 16H4.007A1.01 1.01 0 0 1 3 14.998V5.002zm1.024 10H16v-3.096l-2.89-4.263-3.096 5.257-3.003-2.103L4 13.96l.024 1.043zM6.406 6A1.4 1.4 0 0 0 5 7.393a1.4 1.4 0 0 0 1.406 1.393 1.4 1.4 0 0 0 1.407-1.393A1.4 1.4 0 0 0 6.406 6z" fill="#454545" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-italic"><title>italic</title><path d="M13.825 3.914l-.126.558a5.7 5.7 0 0 0-.686.076c-.282.045-.49.088-.626.127-.237.073-.406.186-.508.338-.1.153-.174.32-.22.5l-2.03 8.77a1.24 1.24 0 0 0-.034.27c0 .13.03.24.086.33.056.09.157.168.304.236.085.04.27.085.558.14.288.052.502.085.643.096l-.127.558H5.656l.127-.558c.158-.01.383-.028.677-.05.293-.023.5-.057.625-.102.22-.08.387-.188.5-.326.112-.138.188-.306.228-.503l2.02-8.778a1.428 1.428 0 0 0 .035-.305.59.59 0 0 0-.072-.295c-.048-.085-.148-.16-.3-.23a3.457 3.457 0 0 0-.622-.19 5 5 0 0 0-.58-.105l.128-.558h5.403z" fill="#454545" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-italic"><title>italic</title><path d="M13.825 3.914l-.126.558a5.7 5.7 0 0 0-.686.076c-.282.045-.49.088-.626.127-.237.073-.406.186-.508.338-.1.153-.174.32-.22.5l-2.03 8.77a1.24 1.24 0 0 0-.034.27c0 .13.03.24.086.33.056.09.157.168.304.236.085.04.27.085.558.14.288.052.502.085.643.096l-.127.558H5.656l.127-.558c.158-.01.383-.028.677-.05.293-.023.5-.057.625-.102.22-.08.387-.188.5-.326.112-.138.188-.306.228-.503l2.02-8.778a1.428 1.428 0 0 0 .035-.305.59.59 0 0 0-.072-.295c-.048-.085-.148-.16-.3-.23a3.457 3.457 0 0 0-.622-.19 5 5 0 0 0-.58-.105l.128-.558h5.403z" fill="#454545" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-link"><title>link</title><g transform="rotate(45 5.793 16.243)" fill="#222" fill-rule="evenodd"><path d="M8 6.56V4.824a4 4 0 0 0-8 0v2.93c0 2.212 1.79 3.997 4 3.997.55 0 1.077-.112 1.555-.314H5.12v-.903a2.99 2.99 0 0 1-1.12.217c-1.657 0-3-1.336-3-2.997v-2.93a3 3 0 0 1 6 0V6.56h1z"/><path d="M2.636 6.902A3.99 3.99 0 0 1 4 6.662c2.21 0 4 1.786 4 3.997v2.93a4 4 0 0 1-4 3.996c-2.21 0-4-1.785-4-3.996v-1.927h1v1.927a3 3 0 0 0 6 0v-2.93a2.995 2.995 0 0 0-3-2.997c-.49 0-.954.118-1.364.327V6.902z"/></g></symbol><symbol viewBox="0 0 20 20" id="ck-icon-numberedlist"><title>numberedlist</title><g transform="translate(2 2)" fill="#454545" fill-rule="evenodd"><path d="M5 15h10v-1H5v1zM4 2v1h13V2H4zm1 6v1h11V8H5zM0 .5a.5.5 0 0 0 .5.5H1v3.5a.5.5 0 0 0 1 0v-4a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5zM.5 6a.5.5 0 0 0 0 1H2v1H.5a.5.5 0 0 0-.5.5v2a.5.5 0 0 0 .5.5h2a.5.5 0 0 0 0-1H1V9h1.5a.46.46 0 0 0 .188-.03.45.45 0 0 0 .28-.282A.46.46 0 0 0 3 8.5v-2a.46.46 0 0 0-.03-.187.45.45 0 0 0-.283-.282.463.463 0 0 0-.124-.03H.5zM2.852 16.853a.493.493 0 0 0 .148-.35v-4.005A.493.493 0 0 0 2.505 12H.495a.494.494 0 0 0-.495.5c0 .268.222.5.495.5H2v1H.495a.494.494 0 0 0-.495.5c0 .268.222.5.495.5H2v1H.495a.494.494 0 0 0-.495.5c0 .268.222.5.495.5h2.01a.49.49 0 0 0 .35-.146z"/></g></symbol><symbol viewBox="0 0 20 20" id="ck-icon-picker"><title>picker</title><path d="M9.635 7.53l-6.252 6.473A2 2 0 0 0 6.26 16.78l6.252-6.472-.72-.695-6.25 6.474a1 1 0 0 1-1.44-1.39l6.252-6.473-.72-.695zm5.125.745c.115-.096.238-.21.37-.346 1.33-1.38 1.758-3.128.954-3.904-.805-.777-2.537-.29-3.868 1.09-.13.136-.24.262-.332.38l2.876 2.78zm-4.755-3.27l4.774 4.61-.663.685-4.774-4.61.662-.685z" fill="#454545" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-quote"><title>quote</title><path d="M12.06 15.51v-.882c1.396-.847 2.346-1.633 2.852-2.358.37-.533.553-1.162.553-1.887 0-.437-.082-.76-.246-.964-.15-.206-.33-.308-.534-.308-.137 0-.328.048-.574.143-.37.123-.67.185-.902.185-.547 0-1.033-.205-1.456-.615-.424-.41-.636-.923-.636-1.538 0-.698.212-1.238.636-1.62.587-.52 1.27-.78 2.05-.78.93 0 1.757.39 2.482 1.17.724.778 1.087 1.742 1.087 2.89 0 1.614-.602 3.084-1.805 4.41-.807.875-1.976 1.593-3.507 2.153zm-8.385 0v-.882c1.394-.847 2.345-1.633 2.85-2.358.37-.533.554-1.162.554-1.887 0-.437-.083-.76-.247-.964-.15-.206-.328-.308-.533-.308-.137 0-.328.048-.574.143-.37.123-.67.185-.903.185-.547 0-1.032-.205-1.456-.615-.424-.41-.636-.923-.636-1.538 0-.698.213-1.238.637-1.62.588-.52 1.272-.78 2.05-.78.93 0 1.758.39 2.482 1.17.724.778 1.086 1.742 1.086 2.89 0 1.614-.6 3.084-1.804 4.41-.807.875-1.976 1.593-3.507 2.153z" fill="#454545" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-redo"><title>redo</title><path d="M10 16l1-3.982c-3.417 0-8.616.87-10 3.982 0-5.983 6.6-7.96 10-7.96 0-.85-1-3.32-1-4.04l8 6-8 6z" fill="#454545" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-source"><title>source</title><path d="M15.116 7.96l2.426 2.207-.01-.417-.01-.525-5.87 5.83.916.924 5.87-5.833.485-.482-.506-.46-2.42-2.198-.88.954zm-2.96-2.69l-.483-.44.874-.96.49.446-.88.955zm-7.04 7.613l-2.443-2.22-.507-.46.486-.483 5.87-5.83.915.922-5.87 5.83-.02-.94 2.45 2.226-.882.955zm2.96 2.69L8.54 16l.875-.962-.46-.417-.882.954zM4.517 17.43L17.475 3.422l-.954-.882L3.565 16.548l.954.882z" fill="#232323" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-table"><title>table</title><path d="M3.994 4A2 2 0 0 0 2 6.006v9.988A2 2 0 0 0 3.994 18h12.012A2 2 0 0 0 18 15.994V6.006A2 2 0 0 0 16.006 4H3.994zM3 6.018h4v3H3v-3zm5 0h4v3H8v-3zm5 0h4v3h-4v-3zm-10 4h4v3H3v-3zm5 0h4v3H8v-3zm5 0h4v3h-4v-3zm-10 4h4v3H3v-3zm5 0h4v3H8v-3zm5 0h4v3h-4v-3z" fill="#454545" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-underline"><title>underline</title><g transform="translate(4 3)" fill="none" fill-rule="evenodd"><path d="M12.628 1.5a4.51 4.51 0 0 0-.678.1c-.297.06-.54.15-.726.272-.188.127-.317.388-.388.785-.072.396-.108.88-.108 1.453v5.096c0 .65-.135 1.214-.405 1.693-.27.478-.624.872-1.065 1.18a4.49 4.49 0 0 1-1.375.64c-.482.13-.943.194-1.383.194-.705 0-1.333-.092-1.883-.277-.55-.184-1.013-.433-1.388-.747a3.143 3.143 0 0 1-.835-1.078 2.986 2.986 0 0 1-.28-1.268v-6.93c0-.19-.032-.352-.096-.482s-.192-.25-.385-.36a1.93 1.93 0 0 0-.528-.185 4.137 4.137 0 0 0-.53-.087V.914H5.46V1.5c-.155.006-.35.03-.583.075a3.874 3.874 0 0 0-.516.124c-.187.065-.312.175-.375.33a1.313 1.313 0 0 0-.095.503v6.475c0 .313.034.642.103.987.07.344.205.664.41.962.214.303.505.55.874.743.37.193.876.29 1.52.29.606 0 1.114-.097 1.524-.29.41-.193.734-.446.97-.76a2.84 2.84 0 0 0 .48-.933c.094-.325.14-.652.14-.983V4.218c0-.612-.044-1.11-.132-1.5-.088-.388-.217-.642-.388-.763-.192-.138-.455-.245-.788-.322a5.096 5.096 0 0 0-.764-.133V.914h4.79V1.5z" fill="#454545"/><path fill="#585858" d="M0 14h12v1H0z"/></g></symbol><symbol viewBox="0 0 20 20" id="ck-icon-undo"><title>undo</title><path d="M2 10l8 6-1-3.982c3.417 0 8.616.87 10 3.982 0-5.983-6.6-7.96-10-7.96 0-.85 1-3.32 1-4.04l-8 6z" fill="#454545" fill-rule="evenodd"/></symbol><symbol viewBox="0 0 20 20" id="ck-icon-unlink"><title>unlink</title><g transform="rotate(45 5.793 16.243)" fill="#222" fill-rule="evenodd"><path d="M8 6.56V4.824a4 4 0 0 0-8 0v2.93c0 2.212 1.79 3.997 4 3.997.55 0 1.077-.112 1.555-.314H5.12v-.903a2.99 2.99 0 0 1-1.12.217c-1.657 0-3-1.336-3-2.997v-2.93a3 3 0 0 1 6 0V6.56h1z"/><path d="M12.13 9.692V6.076h-1.02v3.616H7.793v1.02h3.317v3.616h1.02v-3.616h3.915v-1.02H12.13zm-4.604-1.05A4.067 4.067 0 0 0 2.69 6.98v1.123a3.02 3.02 0 0 1 1.39-.338c1.167 0 2.18.656 2.698 1.625l.748-.748zm.636 3.752v1.484c0 2.276-1.83 4.122-4.08 4.122C1.825 18 0 16.16 0 13.878V11.89h1.02v1.988c0 1.713 1.37 3.09 3.06 3.09 1.688 0 3.062-1.383 3.062-3.09v-2.504l1.02 1.02z"/></g></symbol>'
    });

    /**
     * The editor UI controller class. It's a base class for the editor
     * main view controllers.
     *
     *		// An instance of EditorUI.
     *		new EditorUI( editor );
     *
     * See {@link ui.editorUI.EditorUIView}, {@link ui.iconManager.IconManager}.
     *
     * @memberOf ui.editorUI
     * @extends ui.Controller
     * @mixes utils.ObservaleMixin
     */

    var EditorUI = function (_Controller) {
    	inherits(EditorUI, _Controller);

    	/**
      * Creates an instance of {@link ui.editorUI.EditorUI} class.
      *
      * @param {ckeditor5.Editor} editor
      */

    	function EditorUI(editor) {
    		classCallCheck(this, EditorUI);


    		/**
       * @readonly
       * @member {ckeditor5.Editor} ui.editorUI.EditorUI#editor
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(EditorUI).call(this));

    		_this.editor = editor;

    		/**
       * @readonly
       * @member {ui.ComponentFactory} ui.editorUI.EditorUI#featureComponents
       */
    		_this.featureComponents = new ComponentFactory(editor);

    		_this.collections.add(new ControllerCollection('body'));
    		return _this;
    	}

    	/**
      * Initializes EditorUI instance.
      *
      * @returns {Promise}
      */


    	createClass(EditorUI, [{
    		key: 'init',
    		value: function init() {
    			this._setupIconManager();

    			return get(Object.getPrototypeOf(EditorUI.prototype), 'init', this).call(this);
    		}

    		/**
       * Injects the {@link ui.iconManager.IconManager} into DOM.
       *
       * @protected
       */

    	}, {
    		key: '_setupIconManager',
    		value: function _setupIconManager() {
    			/**
        * Icons available in the UI.
        *
        * @readonly
        * @member {Array} ui.editorUI.EditorUI#icons
        */
    			this.icons = iconManagerModel.icons;

    			this.collections.get('body').add(new IconManager(iconManagerModel, new IconManagerView()));
    		}
    	}]);
    	return EditorUI;
    }(Controller);

    mix(EditorUI, ObservableMixin);

    /**
     * The boxed editor UI controller class. This class controls an editor interface
     * consisting of a toolbar and an editable area, enclosed within a box.
     *
     *		// An instance of BoxedEditorUI.
     *		new BoxedEditorUI( editor );
     *
     * See {@link ui.editorUI.boxed.BoxedEditorUIView}.
     *
     * @member ui.editorUI.boxed
     * @extends ui.editorUI.EditorUI
     */

    var BoxedEditorUI = function (_EditorUI) {
    	inherits(BoxedEditorUI, _EditorUI);

    	/**
      * Creates a boxed editor UI instance.
      *
      * @param {ckeditor5.Editor} editor
      */

    	function BoxedEditorUI(editor) {
    		classCallCheck(this, BoxedEditorUI);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(BoxedEditorUI).call(this, editor));

    		_this.collections.add(new ControllerCollection('top'));
    		_this.collections.add(new ControllerCollection('main'));

    		var config = editor.config;

    		/**
       * The editor's width. Defaults to {@link ckeditor5.editor.config.ui.width}.
       *
       * Note: a specific creator that was used must support this setting.
       *
       * @observable
       * @property {Number} width
       */
    		_this.set('width', config.get('ui.width'));

    		/**
       * The editor's height. Defaults to {@link ckeditor5.editor.config.ui.height}.
       *
       * Note: a specific creator that was used must support this setting.
       *
       * @observable
       * @property {Number} height
       */
    		_this.set('height', config.get('ui.height'));
    		return _this;
    	}

    	return BoxedEditorUI;
    }(EditorUI);

    /**
     * The editable UI controller class. It glues the engine editable
     * {@link engine.view.RootEditableElement} with the UI.
     *
     *		// An instance of EditableUI.
     *		new EditableUI( editor, editable, new EditableUIView() );
     *
     * See {@link ui.editableUI.EditableUIView}.
     *
     * @memberOf ui.editableUI
     * @extends ui.Controller
     */

    var EditableUI = function (_Controller) {
      inherits(EditableUI, _Controller);

      /**
       * Creates an instance of {@link ui.editableUI.EditableUI} class.
       *
       * @param {engine.view.RootEditableElement} editable The editable element (in the engine).
       * Also the {@link ui.editableUI.EditableUIModel} for editable UI instance.
       * @param {ui.View} [view] An instance of EditableUIView.
       * @param {ckeditor5.Editor} [editor] The editor instance.
       */

      function EditableUI(editable, view, editor) {
        classCallCheck(this, EditableUI);


        /**
         * The editor instance.
         *
         * @readonly
         * @member {ckeditor5.Editor} ui.editableUI.EditableUI#editor
         */

        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(EditableUI).call(this, editable, view));

        _this.editor = editor;

        view.model.bind('isReadOnly', 'isFocused').to(editable);
        view.model.set('name', editable.rootName);
        return _this;
      }

      return EditableUI;
    }(Controller);

    /**
     * The editable UI view class.
     *
     * See {@link ui.editableUI.EditableUI}.
     *
     * @memberOf ui.editableUI
     * @extends ui.View
     */

    var EditableUIView = function (_View) {
    	inherits(EditableUIView, _View);

    	/**
      * Creates an instance of {@link ui.editableUI.EditableUIView} class.
      *
      * @param {utils.Locale} [locale] The {@link ckeditor5.Editor#locale editor's locale} instance.
      * @param {HTMLElement} [editableElement] The editable element. If not specified, this view
      * should create it. Otherwise, the existing element should be used.
      */

    	function EditableUIView(locale, editableElement) {
    		classCallCheck(this, EditableUIView);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(EditableUIView).call(this, locale));

    		var bind = _this.bind;

    		if (editableElement) {
    			_this.element = _this.editableElement = editableElement;
    		}

    		_this.template = new Template({
    			tag: 'div',
    			attributes: {
    				class: [bind.to('isFocused', function (value) {
    					return value ? 'ck-focused' : 'ck-blurred';
    				}), 'ck-editor__editable'],
    				contenteditable: bind.to('isReadOnly', function (value) {
    					return !value;
    				})
    			}
    		});

    		/**
       * The element which is the main editable element (usually the one with `contentEditable="true"`).
       *
       * @readonly
       * @member {HTMLElement} ui.editableUI.EditableUIView#editableElement
       */

    		/**
       * Model of this editable UI view.
       *
       * @member {ui.editableUI.EditableUIViewModel} ui.editableUI.EditableUIView#model
       */
    		return _this;
    	}

    	/**
      * Initializes the View by either applying the {@link template} to the existing
      * {@link editableElement} or assigns {@link element} as {@link editableElement}.
      */


    	createClass(EditableUIView, [{
    		key: 'init',
    		value: function init() {
    			if (this.editableElement) {
    				this.template.apply(this.editableElement);
    			} else {
    				this.editableElement = this.element;
    			}

    			get(Object.getPrototypeOf(EditableUIView.prototype), 'init', this).call(this);
    		}
    	}, {
    		key: 'destroy',
    		value: function destroy() {
    			get(Object.getPrototypeOf(EditableUIView.prototype), 'destroy', this).call(this);

    			this.editableElement.contentEditable = false;
    		}
    	}]);
    	return EditableUIView;
    }(View);

    /**
     * The inline editable UI class implementing an inline {@link ui.editableUI.EditableUIView}.
     *
     * See {@link ui.editableUI.EditableUI}, {@link ui.editableUI.EditableUIView}.
     *
     * @memberOf ui.editableUI.inline
     * @extends ui.editableUI.EditableUIView
     */

    var InlineEditableUIView = function (_EditableUIView) {
    	inherits(InlineEditableUIView, _EditableUIView);

    	/**
      * Creates an instance of the InlineEditableUIView class.
      *
      * @param {utils.Locale} [locale] The {@link ckeditor5.Editor#locale editor's locale} instance.
      * @param {HTMLElement} [editableElement] The editable element. If not specified, the {@link EditableUIView}
      * should create it. Otherwise, the existing element should be used.
      */

    	function InlineEditableUIView(locale, editableElement) {
    		classCallCheck(this, InlineEditableUIView);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(InlineEditableUIView).call(this, locale, editableElement));

    		var bind = _this.bind;
    		var t = _this.t;

    		var getLabel = function getLabel(value) {
    			return t('Rich Text Editor, %0', [value]);
    		};

    		Template.extend(_this.template, {
    			attributes: {
    				role: 'textbox',
    				'aria-label': bind.to('name', getLabel),
    				title: bind.to('name', getLabel),
    				class: 'ck-editor__editable_inline'
    			}
    		});
    		return _this;
    	}

    	return InlineEditableUIView;
    }(EditableUIView);

    /**
     * Mixin that injects the common Toolbar–like bindings.
     *
     * See {@link ui.bindings.Toolbar}.
     *
     * @mixin ui.bindings.ToolbarBindingsMixin
     */

    var ToolbarBindingsMixin = {
    	/**
      * Adds buttons to the toolbar. Buttons are taken from the {@link ui.editorUI.EditorUI#featureComponents}
      * factory.
      *
      * @param {String[]} buttons The name of the buttons to add to the toolbar.
      */

    	addButtons: function addButtons(buttons) {
    		var _iteratorNormalCompletion = true;
    		var _didIteratorError = false;
    		var _iteratorError = undefined;

    		try {
    			for (var _iterator = buttons[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    				var button = _step.value;

    				this.add('buttons', this.editor.ui.featureComponents.create(button));
    			}
    		} catch (err) {
    			_didIteratorError = true;
    			_iteratorError = err;
    		} finally {
    			try {
    				if (!_iteratorNormalCompletion && _iterator.return) {
    					_iterator.return();
    				}
    			} finally {
    				if (_didIteratorError) {
    					throw _iteratorError;
    				}
    			}
    		}
    	}
    };

    /**
     * The toolbar controller class.
     *
     *		const model = new Model();
     *
     *		// An instance of Toolbar.
     *		new Toolbar( model, new ToolbarView() );
     *
     * See {@link ui.toolbar.ToolbarView}.
     *
     * @memberOf ui.toolbar
     * @extends ui.Controller
     */

    var Toolbar = function (_Controller) {
      inherits(Toolbar, _Controller);

      /**
       * Creates an instance of {@link ui.toolbar.Toolbar} class.
       *
       * @param {ui.Model} model Model of this toolbar.
       * @param {ui.View} view View of this toolbar.
       */

      function Toolbar(model, view) {
        classCallCheck(this, Toolbar);

        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(Toolbar).call(this, model, view));

        _this.collections.add(new ControllerCollection('buttons'));
        return _this;
      }

      return Toolbar;
    }(Controller);

    /**
     * The sticky toolbar controller class.
     *
     *		const model = new Model( {
     *			isActive: false
     *		} );
     *
     *		// An instance of StickyToolbar.
     *		new StickyToolbar( model, new StickyToolbarView() );
     *
     * See {@link ui.stickyToolbar.StickyToolbarView}.
     *
     * @memberOf ui.stickyToolbar
     * @extends ui.Controller
     */

    var StickyToolbar$1 = function (_Toolbar) {
      inherits(StickyToolbar, _Toolbar);

      /**
       * Creates an instance of {@link ui.stickyToolbar.StickyToolbar} class.
       *
       * @param {ui.stickyToolbar.StickyToolbarModel} model Model of this sticky toolbar.
       * @param {ui.View} view View of this sticky toolbar.
       */

      function StickyToolbar(model, view) {
        classCallCheck(this, StickyToolbar);

        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(StickyToolbar).call(this, model, view));

        view.model.bind('isActive').to(model);
        return _this;
      }

      return StickyToolbar;
    }(Toolbar);

    /**
     * The editor sticky toolbar controller class.
     *
     * See {@link ui.stickyToolbar.StickyToolbar}.
     *
     * @memberOf ui.bindings
     * @extends ui.stickyToolbar.StickyToolbar
     */

    var StickyToolbar = function (_BaseStickyToolbar) {
    	inherits(StickyToolbar, _BaseStickyToolbar);

    	/**
      * Creates an instance of {@link ui.bindings.StickyToolbar} class.
      *
      * @param {ui.stickyToolbar.StickyToolbarModel} model Model of this sticky toolbar.
      * @param {ui.View} view View of this sticky toolbar.
      * @param {ckeditor5.Editor} editor
      */

    	function StickyToolbar(model, view, editor) {
    		classCallCheck(this, StickyToolbar);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(StickyToolbar).call(this, model, view));

    		_this.editor = editor;
    		return _this;
    	}

    	return StickyToolbar;
    }(StickyToolbar$1);

    mix(StickyToolbar, ToolbarBindingsMixin);

    /**
     * The toolbar view class.
     *
     * See {@link ui.toolbar.Toolbar}.
     *
     * @memberOf ui.toolbar
     * @extends ui.View
     */

    var ToolbarView = function (_View) {
    	inherits(ToolbarView, _View);

    	/**
      * @inheritDoc
      */

    	function ToolbarView() {
    		classCallCheck(this, ToolbarView);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ToolbarView).call(this));

    		_this.template = new Template({
    			tag: 'div',
    			attributes: {
    				class: ['ck-reset ck-toolbar']
    			}
    		});

    		_this.register('buttons', function (el) {
    			return el;
    		});
    		return _this;
    	}

    	return ToolbarView;
    }(View);

    /**
     * The sticky toolbar view class.
     *
     * See {@link ui.stickyToolbar.StickyToolbar}, {@link ui.toolbar.ToolbarView}.
     *
     * @memberOf ui.stickyToolbar
     * @extends ui.toolbar.ToolbarView
     */

    var StickyToolbarView = function (_ToolbarView) {
    	inherits(StickyToolbarView, _ToolbarView);

    	/**
      * @inheritDoc
      */

    	function StickyToolbarView() {
    		classCallCheck(this, StickyToolbarView);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(StickyToolbarView).call(this));

    		var bind = _this.bind;

    		_this.model.set('isSticky', false);

    		Template.extend(_this.template, {
    			attributes: {
    				// Toggle class of the toolbar when "sticky" state changes in the model.
    				class: bind.if('isSticky', 'ck-toolbar_sticky')
    			}
    		});

    		/**
       * Model of this sticky toolbar view.
       *
       * @member {ui.stickyToobar.StickyToolbarViewModel} ui.stickyToolbar.StickyToolbarView#model
       */
    		return _this;
    	}

    	createClass(StickyToolbarView, [{
    		key: 'init',
    		value: function init() {
    			var _this2 = this;

    			get(Object.getPrototypeOf(StickyToolbarView.prototype), 'init', this).call(this);

    			/**
        * A dummy element which visually fills the space as long as the
        * actual toolbar is sticky. It prevents flickering of the UI.
        *
        * @private
        * @property {HTMLElement} ui.stickyToobar.StickyToolbarView#_elementPlaceholder
        */
    			this._elementPlaceholder = document.createElement('div');
    			this._elementPlaceholder.classList.add('ck-toolbar__placeholder');
    			this.element.parentNode.insertBefore(this._elementPlaceholder, this.element);

    			// Update sticky state of the toolbar as the window is being scrolled.
    			this.listenTo(window, 'scroll', function () {
    				_this2._checkIfShouldBeSticky();
    			});

    			// Synchronize with `model.isActive` because sticking an inactive toolbar is pointless.
    			this.listenTo(this.model, 'change:isActive', function (evt, name, value) {
    				if (value) {
    					_this2._checkIfShouldBeSticky();
    				} else {
    					_this2._detach();
    				}
    			});
    		}

    		/**
       * Destroys the toolbar and removes the {@link _elementPlaceholder}.
       */

    	}, {
    		key: 'destroy',
    		value: function destroy() {
    			get(Object.getPrototypeOf(StickyToolbarView.prototype), 'destroy', this).call(this);

    			this._elementPlaceholder.remove();
    		}

    		/**
       * Analyzes the environment to decide whether the toolbar should
       * be sticky or not. Then, it uses {@link _stick} and {@link _detach}
       * methods to manage the state of the toolbar.
       *
       * @protected
       */

    	}, {
    		key: '_checkIfShouldBeSticky',
    		value: function _checkIfShouldBeSticky() {
    			var rectElement = this.model.isSticky ? this._elementPlaceholder : this.element;
    			var rect = rectElement.getBoundingClientRect();

    			if (rect.top < 0 && this.model.isActive) {
    				this._stick(rect);
    			} else {
    				this._detach();
    			}
    		}

    		/**
       * Sticks the toolbar to the top edge of the viewport simulating
       * CSS position:sticky. Also see {@link #_detach}.
       *
       * TODO: Possibly replaced by CSS in the future
       * http://caniuse.com/#feat=css-sticky
       *
       * @protected
       * @param {Object} regionRect An output of getBoundingClientRect native DOM method.
       */

    	}, {
    		key: '_stick',
    		value: function _stick(regionRect) {
    			// Setup placeholder.
    			Object.assign(this._elementPlaceholder.style, {
    				display: 'block',
    				height: regionRect.height + 'px'
    			});

    			// Stick the top region.
    			Object.assign(this.element.style, {
    				// Compensate 1px border which is added when becoming "sticky".
    				width: regionRect.width + 2 + 'px',
    				marginLeft: -window.scrollX - 1 + 'px'
    			});

    			this.model.isSticky = true;
    		}

    		/**
       * Detaches the toolbar from the top edge of the viewport.
       * See {@link #_stick}.
       *
       * @protected
       */

    	}, {
    		key: '_detach',
    		value: function _detach() {
    			// Release the placeholder.
    			Object.assign(this._elementPlaceholder.style, {
    				display: 'none'
    			});

    			// Detach the top region.
    			Object.assign(this.element.style, {
    				width: 'auto',
    				marginLeft: 'auto'
    			});

    			this.model.isSticky = false;
    		}
    	}]);
    	return StickyToolbarView;
    }(ToolbarView);

    /**
     * Classic editor UI. Uses inline editable and sticky toolbar, all
     * enclosed in a boxed UI.
     *
     * @memberOf editor-classic
     * @extends ui.editorUI.boxed.BoxedEditorUI
     */

    var ClassicEditorUI = function (_BoxedEditorUI) {
    	inherits(ClassicEditorUI, _BoxedEditorUI);

    	/**
      * Creates an instance of the classic editor UI.
      *
      * @param {ckeditor5.editor.Editor} editor
      */

    	function ClassicEditorUI(editor) {
    		classCallCheck(this, ClassicEditorUI);


    		/**
       * Toolbar controller.
       *
       * @readonly
       * @member {ui.toolbar.Toolbar} editor-classic.ClassicEditorUI#toolbar
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ClassicEditorUI).call(this, editor));

    		_this.toolbar = _this._createToolbar();

    		/**
       * Editable UI controller.
       *
       * @readonly
       * @member {ui.editableUI.EditableUI} editor-classic.ClassicEditorUI#editable
       */
    		_this.editable = _this._createEditableUI();
    		return _this;
    	}

    	/**
      * The editing host.
      *
      * @readonly
      * @type {HTMLElement}
      */


    	createClass(ClassicEditorUI, [{
    		key: 'init',


    		/**
       * @inheritDoc
       */
    		value: function init() {
    			var toolbar = this.editor.config.get('toolbar');

    			if (toolbar) {
    				this.toolbar.addButtons(toolbar);
    			}

    			return get(Object.getPrototypeOf(ClassicEditorUI.prototype), 'init', this).call(this);
    		}

    		/**
       * Creates editor sticky toolbar.
       *
       * @protected
       * @returns {ui.toolbar.Toolbar}
       */

    	}, {
    		key: '_createToolbar',
    		value: function _createToolbar() {
    			var editor = this.editor;

    			var model = new Model();
    			model.bind('isActive').to(editor.editing.view.getRoot(), 'isFocused');

    			var toolbar = new StickyToolbar(model, new StickyToolbarView(editor.locale), editor);
    			this.add('top', toolbar);

    			return toolbar;
    		}

    		/**
       * Creates editor main editable.
       *
       * @protected
       * @returns {ui.editableUI.EditableUI}
       */

    	}, {
    		key: '_createEditableUI',
    		value: function _createEditableUI() {
    			var editor = this.editor;

    			var editable = editor.editing.view.getRoot();
    			var editableUI = new EditableUI(editable, new InlineEditableUIView(editor.locale), editor);

    			this.add('main', editableUI);

    			return editableUI;
    		}
    	}, {
    		key: 'editableElement',
    		get: function get() {
    			return this.editable.view.element;
    		}
    	}]);
    	return ClassicEditorUI;
    }(BoxedEditorUI);

    /**
     * The editor UI view class. Base class for the editor main views.
     *
     * See {@link ui.editorUI.EditorUI}.
     *
     * @memberOf ui.editorUI
     * @extends ui.View
     */

    var EditorUIView = function (_View) {
    	inherits(EditorUIView, _View);

    	/**
      * Creates an instance of the editor UI view class.
      *
      * @param {utils.Locale} [locale] The {@link ckeditor5.Editor#locale editor's locale} instance.
      */

    	function EditorUIView(locale) {
    		classCallCheck(this, EditorUIView);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(EditorUIView).call(this, locale));

    		_this._createBodyRegion();

    		/**
       * The element holding elements of the 'body' region.
       *
       * @private
       * @member {HTMLElement} ui.editorUI.EditorUIView#_bodyRegionContainer
       */
    		return _this;
    	}

    	createClass(EditorUIView, [{
    		key: 'destroy',
    		value: function destroy() {
    			this._bodyRegionContainer.remove();
    			this._bodyRegionContainer = null;
    		}

    		/**
       * Creates and appends to `<body>` the 'body' region container.
       *
       * @private
       */

    	}, {
    		key: '_createBodyRegion',
    		value: function _createBodyRegion() {
    			var bodyElement = document.createElement('div');
    			document.body.appendChild(bodyElement);

    			new Template({
    				attributes: {
    					class: 'ck-body ck-reset-all'
    				}
    			}).apply(bodyElement);

    			this._bodyRegionContainer = bodyElement;

    			this.register('body', function () {
    				return bodyElement;
    			});
    		}
    	}]);
    	return EditorUIView;
    }(View);

    /**
     * The boxed editor UI view class. This class represents an editor interface
     * consisting of a toolbar and an editable area, enclosed within a box.
     *
     * See {@link ui.editorUI.boxed.BoxedEditorUI}.
     *
     * @member ui.editorUI.boxed
     * @extends ui.editorUI.EditorUIView
     */

    var BoxedEditorUIView = function (_EditorUIView) {
    	inherits(BoxedEditorUIView, _EditorUIView);

    	/**
      * @inheritDoc
      */

    	function BoxedEditorUIView(locale) {
    		classCallCheck(this, BoxedEditorUIView);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(BoxedEditorUIView).call(this, locale));

    		var t = _this.t;
    		var ariaLabelUid = uid();

    		_this.template = new Template({
    			tag: 'div',

    			attributes: {
    				class: ['ck-reset', 'ck-editor', 'ck-rounded-corners'],
    				role: 'application',
    				dir: 'ltr',
    				lang: locale.lang,
    				'aria-labelledby': 'cke-editor__aria-label_' + ariaLabelUid
    			},

    			children: [{
    				tag: 'span',
    				attributes: {
    					id: 'cke-editor__aria-label_' + ariaLabelUid,
    					class: 'cke-voice-label',
    					children: [
    					// TODO: Editor name?
    					t('Rich Text Editor')]
    				}
    			}, {
    				tag: 'div',
    				attributes: {
    					class: 'ck-editor__top ck-reset-all',
    					role: 'presentation'
    				}
    			}, {
    				tag: 'div',
    				attributes: {
    					class: 'ck-editor__main',
    					role: 'presentation'
    				}
    			}]
    		});

    		_this.register('top', '.ck-editor__top');
    		_this.register('main', '.ck-editor__main');
    		return _this;
    	}

    	return BoxedEditorUIView;
    }(EditorUIView);

    /**
     * Utility class allowing to hide existing HTML elements or replace them with given ones in a way that doesn't remove
     * the original elements from the DOM.
     *
     * @memberOf utils
     */

    var ElementReplacer = function () {
    	function ElementReplacer() {
    		classCallCheck(this, ElementReplacer);

    		/**
       * The elements replaced by {@link #replace} and their replacements.
       *
       * @private
       * @member {Array.<Object>} utils.ElementReplacer#_replacedElements
       */
    		this._replacedElements = [];
    	}

    	/**
      * Hides the `element` and, if specified, inserts the the given element next to it.
      *
      * The effect of this method can be reverted by {@link #restore}.
      *
      * @param {HTMLElement} element The element to replace.
      * @param {HTMLElement} [newElement] The replacement element. If not passed, then the `element` will just be hidden.
      */


    	createClass(ElementReplacer, [{
    		key: 'replace',
    		value: function replace(element, newElement) {
    			this._replacedElements.push({ element: element, newElement: newElement });

    			element.style.display = 'none';

    			if (newElement) {
    				element.parentNode.insertBefore(newElement, element.nextSibling);
    			}
    		}

    		/**
       * Restores what {@link #replace} did.
       */

    	}, {
    		key: 'restore',
    		value: function restore() {
    			this._replacedElements.forEach(function (_ref) {
    				var element = _ref.element;
    				var newElement = _ref.newElement;

    				element.style.display = '';

    				if (newElement) {
    					newElement.remove();
    				}
    			});

    			this._replacedElements = [];
    		}
    	}]);
    	return ElementReplacer;
    }();

    /**
     * Classic editor. Uses inline editable and sticky toolbar, all
     * enclosed in a boxed UI.
     *
     * @memberOf editor-classic
     * @extends ckeditor5.editor.StandardEditor
     */

    var ClassicEditor$1 = function (_StandardEditor) {
    	inherits(ClassicEditor, _StandardEditor);

    	/**
      * Creates an instance of the classic editor.
      *
      * @param {HTMLElement} element The DOM element that will be the source for the created editor.
      * The data will be loaded from it and loaded back to it once the editor is destroyed.
      * @param {Object} config The editor config.
      */

    	function ClassicEditor(element, config) {
    		classCallCheck(this, ClassicEditor);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ClassicEditor).call(this, element, config));

    		_this.document.createRoot();

    		_this.editing.createRoot('div');

    		_this.data.processor = new HtmlDataProcessor();

    		_this.ui = new ClassicEditorUI(_this);
    		_this.ui.view = new BoxedEditorUIView(_this.locale);

    		/**
       * The element replacer instance used to hide editor element.
       *
       * @protected
       * @member {utils.ElementReplacer} editor-classic.Classic#_elementReplacer
       */
    		_this._elementReplacer = new ElementReplacer();
    		return _this;
    	}

    	/**
      * Destroys the editor instance, releasing all resources used by it.
      *
      * Updates the original editor element with the data.
      *
      * @returns {Promise}
      */


    	createClass(ClassicEditor, [{
    		key: 'destroy',
    		value: function destroy() {
    			var _this2 = this;

    			this.updateEditorElement();
    			this._elementReplacer.restore();

    			return this.ui.destroy().then(function () {
    				return get(Object.getPrototypeOf(ClassicEditor.prototype), 'destroy', _this2).call(_this2);
    			});
    		}

    		/**
       * Creates a classic editor instance.
       *
       *		ClassicEditor.create( document.querySelector( '#editor' ), {
       *			features: [ 'delete', 'enter', 'typing', 'paragraph', 'undo', 'basic-styles/bold', 'basic-styles/italic' ],
       *			toolbar: [ 'bold', 'italic', 'undo', 'redo' ]
       *		} )
       *		.then( editor => {
       *			console.log( 'Editor was initialized', editor );
       *		} )
       *		.catch( err => {
       *			console.error( err.stack );
       *		} );
       *
       * @param {HTMLElement} element See {@link ckeditor5.editor.ClassicEditor#constructor}'s param.
       * @param {Object} config See {@link ckeditor5.editor.ClassicEditor#constructor}'s param.
       * @returns {Promise} Promise resolved once editor is ready.
       * @returns {ckeditor5.editor.StandardEditor} return.editor The editor instance.
       */

    	}], [{
    		key: 'create',
    		value: function create(element, config) {
    			return new Promise(function (resolve) {
    				var editor = new ClassicEditor(element, config);

    				resolve(editor.initPlugins().then(function () {
    					return editor._elementReplacer.replace(element, editor.ui.view.element);
    				}).then(function () {
    					return editor.ui.init();
    				}).then(function () {
    					return editor.editing.view.attachDomRoot(editor.ui.editableElement);
    				}).then(function () {
    					return editor.loadDataFromEditorElement();
    				}).then(function () {
    					return editor;
    				}));
    			});
    		}
    	}]);
    	return ClassicEditor;
    }(StandardEditor);

    /**
     * The base class for CKEditor feature classes. Features are main way to enhance CKEditor abilities with tools,
     * utilities, services and components.
     *
     * The main responsibilities for Feature are:
     * * setting required dependencies (see {@link ckeditor5.Plugin#requires},
     * * configuring, instantiating and registering commands to editor,
     * * registering converters to editor (if the feature operates on Tree Model),
     * * setting and registering UI components (if the feature uses it).
     *
     * @memberOf ckeditor5
     */

    var Feature = function (_Plugin) {
      inherits(Feature, _Plugin);

      function Feature() {
        classCallCheck(this, Feature);
        return possibleConstructorReturn(this, Object.getPrototypeOf(Feature).apply(this, arguments));
      }

      return Feature;
    }(Plugin);

    /**
     * The base class for CKEditor commands.
     *
     * Commands are main way to manipulate editor contents and state. They are mostly used by UI elements (or by other
     * commands) to make changes in Tree Model. Commands are available in every part of code that has access to
     * {@link ckeditor5.Editor} instance, since they are registered in it and executed through {@link ckeditor5.Editor#execute}.
     * Commands instances are available through {@link ckeditor5.Editor#commands}.
     *
     * This is an abstract base class for all commands.
     *
     * @memberOf ckeditor5.command
     * @mixes utils.ObservableMixin
     */

    var Command = function () {
    	/**
      * Creates a new Command instance.
      *
      * @param {ckeditor5.Editor} editor Editor on which this command will be used.
      */

    	function Command(editor) {
    		var _this = this;

    		classCallCheck(this, Command);

    		/**
       * Editor on which this command will be used.
       *
       * @readonly
       * @member {ckeditor5.Editor} ckeditor5.command.Command#editor
       */
    		this.editor = editor;

    		/**
       * Flag indicating whether a command is enabled or disabled.
       * A disabled command should do nothing upon it's execution.
       *
       * @observable
       * @member {Boolean} ckeditor5.command.Command#isEnabled
       */
    		this.set('isEnabled', true);

    		// If schema checking function is specified, add it to the `refreshState` listeners.
    		// Feature will be disabled if it does not apply to schema requirements.
    		if (this._checkEnabled) {
    			this.on('refreshState', function (evt, data) {
    				data.isEnabled = _this._checkEnabled();
    			});
    		}
    	}

    	createClass(Command, [{
    		key: 'destroy',
    		value: function destroy() {
    			this.stopListening();
    		}

    		/**
       * Fires `refreshState` event and checks it's resolve value to decide whether command should be enabled or not.
       * Other parts of code might listen to `refreshState` event on this command and add their callbacks. This
       * way the responsibility of deciding whether a command should be enabled is shared.
       *
       * @fires {@link ckeditor5.command.Command#refreshState refreshState}
       */

    	}, {
    		key: 'refreshState',
    		value: function refreshState() {
    			var data = { isEnabled: true };
    			this.fire('refreshState', data);

    			this.isEnabled = data.isEnabled;
    		}

    		/**
       * Executes the command if it is enabled.
       *
       * @protected
       * @param {*} param Parameter passed to {@link ckeditor5.command.Command#execute execute} method of this command.
       */

    	}, {
    		key: '_execute',
    		value: function _execute(param) {
    			if (this.isEnabled) {
    				this._doExecute(param);
    			}
    		}

    		/**
       * Disables the command. This should be used only by the command itself. Other parts of code should add
       * listeners to `refreshState` event.
       *
       * @protected
       */

    	}, {
    		key: '_disable',
    		value: function _disable() {
    			this.on('refreshState', disableCallback);
    			this.refreshState();
    		}

    		/**
       * Enables the command (internally). This should be used only by the command itself. Command will be enabled if
       * other listeners does not return false on `refreshState` event callbacks. Firing {@link ckeditor5.command.Command#_enable}
       * does not guarantee that {@link ckeditor5.command.Command#isEnabled} will be set to true, as it depends on other listeners.
       *
       * @protected
       */

    	}, {
    		key: '_enable',
    		value: function _enable() {
    			this.off('refreshState', disableCallback);
    			this.refreshState();
    		}

    		/**
       * Executes command.
       * This is an abstract method that should be overwritten in child classes.
       *
       * @protected
       */

    	}, {
    		key: '_doExecute',
    		value: function _doExecute() {}

    		/**
       * Checks if a command should be enabled according to its own rules. Mostly it will check schema to see if the command
       * is allowed to be executed in given position. This method can be defined in child class (but is not obligatory).
       * If it is defined, it will be added as a callback to `refreshState` event.
       *
       * @protected
       * @method ckeditor5.command.Command#_checkEnabled
       * @returns {Boolean} `true` if command should be enabled according to {@link engine.model.Document#schema}. `false` otherwise.
       */

    	}]);
    	return Command;
    }();

    function disableCallback(evt, data) {
    	data.isEnabled = false;
    }

    mix(Command, ObservableMixin);

    /**
     * Returns the number of items return by the iterator.
     *
     *		count( [ 1, 2, 3, 4, 5 ] ); // 5;
     *
     * @memberOf utils
     * @param {Iterable.<*>} iterator Any iterator.
     * @returns {Number} Number of items returned by that iterator.
     */

    function count(iterator) {
      var count = 0;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = iterator[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _ = _step.value;
          // jshint ignore:line
          count++;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return count;
    }

    /**
     * Change buffer allows to group atomic changes (like characters that have been typed) into
     * {@link engine.treeModel.batch.Batch batches}.
     *
     * Batches represent single undo steps, hence changes added to one single batch are undone together.
     *
     * The buffer has a configurable limit of atomic changes that it can accomodate. After the limit was
     * exceeded (see {@link typing.ChangeBuffer#input}), a new batch is created in {@link typing.ChangeBuffer#batch}.
     *
     * To use the change buffer you need to let it know about number of changes that has been added to the batch:
     *
     *		const buffer = new ChangeBuffer( document, LIMIT );
     *
     *		// Later on in your feature:
     *		buffer.batch.insert( pos, insertedCharacters );
     *		buffer.input( insertedCharacters.length );
     *
     * @memberOf typing
     */

    var ChangeBuffer = function () {
    	/**
      * Creates a new instance of the ChangeBuffer.
      *
      * @param {engine.treeModel.Document} document
      * @param {Number} [limit=20] Maximum number of atomic changes which can be contained in one batch.
      */

    	function ChangeBuffer(doc) {
    		var _this = this;

    		var limit = arguments.length <= 1 || arguments[1] === undefined ? 20 : arguments[1];
    		classCallCheck(this, ChangeBuffer);

    		/**
       * Instance of the document.
       *
       * @readonly
       * @property {engine.treeModel.Document} typing.ChangeBuffer#document
       */
    		this.document = doc;

    		/**
       * Number of atomic changes in the buffer. Once it exceeds the {@link typing.ChangeBuffer#limit},
       * {@link typing.ChangeBuffer#batch batch} is set to a new batch.
       *
       * @readonly
       * @property {Number} typing.ChangeBuffer#size
       */
    		this.size = 0;

    		/**
       * Maximum number of atomic changes which can be contained in one batch.
       *
       * @readonly
       * @property {Number} typing.ChangeBuffer#limit
       */
    		this.limit = limit;

    		this._changeCallback = function (evt, type, changes, batch) {
    			_this._onBatch(batch);
    		};

    		doc.on('change', this._changeCallback);

    		/**
       * The current batch instance.
       *
       * @private
       * @property typing.ChangeBuffer#_batch
       */

    		/**
       * The callback to document change event which later needs to be removed.
       *
       * @private
       * @property typing.ChangeBuffer#_changeCallback
       */
    	}

    	/**
      * Current batch to which a feature should add its deltas. Once the {@link typing.ChangeBuffer#size}
      * reach or exceeds the {@link typing.ChangeBuffer#limit}, then the batch is set to a new instance and size is reset.
      *
      * @type {engine.treeModel.batch.Batch}
      */


    	createClass(ChangeBuffer, [{
    		key: 'input',


    		/**
       * Input number of changes into the buffer. Once the {@link typing.ChangeBuffer#size}
       * reach or exceeds the {@link typing.ChangeBuffer#limit}, then the batch is set to a new instance and size is reset.
       *
       * @param {Number} changeCount Number of atomic changes to input.
       */
    		value: function input(changeCount) {
    			this.size += changeCount;

    			if (this.size >= this.limit) {
    				this._reset();
    			}
    		}

    		/**
       * Destroys the buffer.
       */

    	}, {
    		key: 'destroy',
    		value: function destroy() {
    			this.document.off('change', this._changeCallback);
    		}

    		/**
       * To be called in order to notify the buffer about batches which appeared in the document.
       * The method will check whether it is a new batch and in that case the buffer will be flushed.
       *
       * The reason why the buffer needs to be flushed whenever a new batch appears is that changes added afterwards
       * should be added to a new batch. For instance, when a user types, then inserts an image and then types again,
       * the characters typed after inserting the image should be added to a different batch than the characters typed before.
       *
       * @private
       * @param {engine.treeModel.batch.Batch} batch The batch which appears in the document.
       */

    	}, {
    		key: '_onBatch',
    		value: function _onBatch(batch) {
    			// One operation means a newly created batch.
    			if (batch.type != 'transparent' && batch !== this._batch && count(batch.getOperations()) <= 1) {
    				this._reset();
    			}
    		}

    		/**
       * Resets change buffer.
       *
       * @private
       */

    	}, {
    		key: '_reset',
    		value: function _reset() {
    			this._batch = null;
    			this.size = 0;
    		}
    	}, {
    		key: 'batch',
    		get: function get() {
    			if (!this._batch) {
    				this._batch = this.document.batch();
    			}

    			return this._batch;
    		}
    	}]);
    	return ChangeBuffer;
    }();

    /**
     * Delete command. Used by the {@link delete.Delete delete feature} to handle <kbd>Delete</kbd> and
     * <kbd>Backspace</kbd> keys.
     *
     * @member delete
     * @extends ckeditor5.command.Command
     */

    var DeleteCommand = function (_Command) {
    	inherits(DeleteCommand, _Command);

    	/**
      * Creates instance of the command;
      *
      * @param {ckeditor5.Editor} editor
      * @param {'FORWARD'|'BACKWARD'} direction The directionality of the delete (in what direction it should
      * consume the content when selection is collapsed).
      */

    	function DeleteCommand(editor, direction) {
    		classCallCheck(this, DeleteCommand);


    		/**
       * The directionality of the delete (in what direction it should
       * consume the content when selection is collapsed).
       *
       * @readonly
       * @member {'FORWARD'|'BACKWARD'} delete.DeleteCommand#direction
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(DeleteCommand).call(this, editor));

    		_this.direction = direction;

    		/**
       * Delete's change buffer used to group subsequent changes into batches.
       *
       * @readonly
       * @private
       * @member {typing.ChangeBuffer} delete.DeleteCommand#buffer
       */
    		_this._buffer = new ChangeBuffer(editor.document, editor.config.get('undo.step'));
    		return _this;
    	}

    	/**
      * Executes the command: depending on whether the selection is collapsed or not, deletes its contents
      * or piece of content in the {@link delete.DeleteCommand#direction defined direction}.
      *
      * @param {Object} [options] The command options.
      * @param {'CHARACTER'} [options.unit='CHARACTER'] See {@link engine.model.composer.modifySelection}'s options.
      */


    	createClass(DeleteCommand, [{
    		key: '_doExecute',
    		value: function _doExecute() {
    			var _this2 = this;

    			var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    			var doc = this.editor.document;

    			doc.enqueueChanges(function () {
    				var selection = Selection$1.createFromSelection(doc.selection);

    				// Try to extend the selection in the specified direction.
    				if (selection.isCollapsed) {
    					doc.composer.modifySelection(selection, { direction: _this2.direction, unit: options.unit });
    				}

    				// If selection is still collapsed, then there's nothing to delete.
    				if (selection.isCollapsed) {
    					return;
    				}

    				var changeCount = 0;

    				selection.getFirstRange().getMinimalFlatRanges().forEach(function (range) {
    					changeCount += count(range.getWalker({ singleCharacters: true, ignoreElementEnd: true, shallow: true }));
    				});

    				doc.composer.deleteContents(_this2._buffer.batch, selection, { merge: true });
    				_this2._buffer.input(changeCount);

    				doc.selection.setRanges(selection.getRanges(), selection.isBackward);
    			});
    		}
    	}]);
    	return DeleteCommand;
    }(Command);

    /**
     * Delete observer introduces the {@link engine.view.Document#delete} event.
     *
     * @memberOf delete
     * @extends engine.view.observer.Observer
     */

    var DeleteObserver = function (_Observer) {
    	inherits(DeleteObserver, _Observer);

    	function DeleteObserver(document) {
    		classCallCheck(this, DeleteObserver);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(DeleteObserver).call(this, document));

    		document.on('keydown', function (evt, data) {
    			var deleteData = {};

    			if (data.keyCode == keyCodes.delete) {
    				deleteData.direction = 'FORWARD';
    			} else if (data.keyCode == keyCodes.backspace) {
    				deleteData.direction = 'BACKWARD';
    			} else {
    				return;
    			}

    			deleteData.unit = data.altKey ? 'WORD' : 'CHARACTER';

    			document.fire('delete', new DomEventData(document, data.domEvent, deleteData));
    		});
    		return _this;
    	}

    	/**
      * @inheritDoc
      */


    	createClass(DeleteObserver, [{
    		key: 'observe',
    		value: function observe() {}
    	}]);
    	return DeleteObserver;
    }(Observer);

    /**
     * The delete and backspace feature. Handles <kbd>Delete</kbd> and <kbd>Backspace</kbd> keys in the editor.
     *
     * @memberOf delete
     * @extends ckeditor5.Feature
     */

    var Delete = function (_Feature) {
    	inherits(Delete, _Feature);

    	function Delete() {
    		classCallCheck(this, Delete);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(Delete).apply(this, arguments));
    	}

    	createClass(Delete, [{
    		key: 'init',
    		value: function init() {
    			var editor = this.editor;
    			var editingView = editor.editing.view;

    			editingView.addObserver(DeleteObserver);

    			editor.commands.set('forwardDelete', new DeleteCommand(editor, 'FORWARD'));
    			editor.commands.set('delete', new DeleteCommand(editor, 'BACKWARD'));

    			this.listenTo(editingView, 'delete', function (evt, data) {
    				editor.execute(data.direction == 'FORWARD' ? 'forwardDelete' : 'delete');
    				data.preventDefault();
    			});
    		}
    	}]);
    	return Delete;
    }(Feature);

    /**
     * Creates a set of changes which need to be applied to the input in order to transform
     * it into the output. This function can be used with strings or arrays.
     *
     *		const input = Array.from( 'abc' );
     *		const output = Array.from( 'xaby' );
     *		const changes = diffToChanges( diff( input, output ), output );
     *
     *		changes.forEach( change => {
     *			if ( change.type == 'INSERT' ) {
     *				input.splice( change.index, 0, ...change.values );
     *			} else if ( change.type == 'DELETE' ) {
     *				input.splice( change.index, change.howMany );
     *			}
     *		} );
     *
     *		input.join( '' ) == output.join( '' ); // -> true
     *
     * @method utils.diffToChanges
     * @param {Array.<'EQUAL'|'INSERT'|'DELETE'>} diff Result of {@link utils.diff}.
     * @param {String|Array} output The string or array which was passed as diff's output.
     * @returns {Array.<Object>} Set of changes (insert or delete) which need to be applied to the input
     * in order to transform it into the output.
     */

    function diffToChanges(diff, output) {
    	var changes = [];
    	var index = 0;
    	var lastOperation = void 0;

    	diff.forEach(function (change) {
    		if (change == 'EQUAL') {
    			pushLast();

    			index++;
    		} else if (change == 'INSERT') {
    			if (isContinuationOf('INSERT')) {
    				lastOperation.values.push(output[index]);
    			} else {
    				pushLast();

    				lastOperation = {
    					type: 'INSERT',
    					index: index,
    					values: [output[index]]
    				};
    			}

    			index++;
    		} else /* if ( change == 'DELETE' ) */{
    				if (isContinuationOf('DELETE')) {
    					lastOperation.howMany++;
    				} else {
    					pushLast();

    					lastOperation = {
    						type: 'DELETE',
    						index: index,
    						howMany: 1
    					};
    				}
    			}
    	});

    	pushLast();

    	return changes;

    	function pushLast() {
    		if (lastOperation) {
    			changes.push(lastOperation);
    			lastOperation = null;
    		}
    	}

    	function isContinuationOf(expected) {
    		return lastOperation && lastOperation.type == expected;
    	}
    }

    /**
     * The typing feature. Handles... typing.
     *
     * @memberOf typing
     * @extends ckeditor5.Feature
     */

    var Typing = function (_Feature) {
    	inherits(Typing, _Feature);

    	function Typing() {
    		classCallCheck(this, Typing);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(Typing).apply(this, arguments));
    	}

    	createClass(Typing, [{
    		key: 'init',

    		/**
       * @inheritDoc
       */
    		value: function init() {
    			var _this2 = this;

    			var editor = this.editor;
    			var editingView = editor.editing.view;

    			/**
        * Typing's change buffer used to group subsequent changes into batches.
        *
        * @protected
        * @member {typing.ChangeBuffer} typing.Typing#_buffer
        */
    			this._buffer = new ChangeBuffer(editor.document, editor.config.get('typing.undoStep') || 20);

    			// TODO The above default config value should be defines using editor.config.define() once it's fixed.

    			this.listenTo(editingView, 'keydown', function (evt, data) {
    				_this2._handleKeydown(data);
    			}, null, 9999); // LOWEST

    			this.listenTo(editingView, 'mutations', function (evt, mutations) {
    				_this2._handleMutations(mutations);
    			});
    		}

    		/**
       * @inheritDoc
       */

    	}, {
    		key: 'destroy',
    		value: function destroy() {
    			get(Object.getPrototypeOf(Typing.prototype), 'destroy', this).call(this);

    			this._buffer.destroy();
    			this._buffer = null;
    		}

    		/**
       * Handles keydown event. We need to guess whether such a keystroke is going to result
       * in typing. If so, then before character insertion happens, we need to delete
       * any selected content. Otherwise, a default browser deletion mechanism would be
       * triggered, resulting in:
       *
       * * hundreds of mutations which couldn't be handled,
       * * but most importantly, loss of a control over how content is being deleted.
       *
       * The method is used in a low-prior listener, hence allowing other listeners (e.g. delete or enter features)
       * to handle the event.
       *
       * @private
       * @param {engine.view.observer.keyObserver.KeyEventData} evtData
       */

    	}, {
    		key: '_handleKeydown',
    		value: function _handleKeydown(evtData) {
    			var _this3 = this;

    			var doc = this.editor.document;

    			if (isSafeKeystroke(evtData) || doc.selection.isCollapsed) {
    				return;
    			}

    			doc.enqueueChanges(function () {
    				doc.composer.deleteContents(_this3._buffer.batch, doc.selection);
    			});
    		}

    		/**
       * Handles DOM mutations.
       *
       * @param {Array.<engine.view.Document~MutatatedText|engine.view.Document~MutatatedChildren>} mutations
       */

    	}, {
    		key: '_handleMutations',
    		value: function _handleMutations(mutations) {
    			var doc = this.editor.document;
    			var handler = new MutationHandler(this.editor.editing, this._buffer);

    			doc.enqueueChanges(function () {
    				return handler.handle(mutations);
    			});
    		}
    	}]);
    	return Typing;
    }(Feature);

    var MutationHandler = function () {
    	/**
      * Creates instance of the mutation handler.
      *
      * @param {engine.EditingController} editing
      * @param {typing.ChangeBuffer} buffer
      */

    	function MutationHandler(editing, buffer) {
    		classCallCheck(this, MutationHandler);

    		/**
       * The editing controller.
       *
       * @member {engine.EditingController} typing.typing.MutationHandler#editing
       */
    		this.editing = editing;

    		/**
       * The change buffer.
       *
       * @member {engine.EditingController} typing.typing.MutationHandler#buffer
       */
    		this.buffer = buffer;

    		/**
       * Number of inserted characters which need to be feed to the {@link #buffer change buffer}
       * on {@link #commit}.
       *
       * @member {Number} typing.typing.MutationHandler#insertedCharacterCount
       */
    		this.insertedCharacterCount = 0;

    		/**
       * Position to which the selection should be moved on {@link #commit}.
       *
       * Note: Currently, the mutation handler will move selection to the position set by the
       * last consumer. Placing the selection right after the last change will work for many cases, but not
       * for ones like autocorrection or spellchecking. The caret should be placed after the whole piece
       * which was corrected (e.g. a word), not after the letter that was replaced.
       *
       * @member {engine.model.Position} typing.typing.MutationHandler#selectionPosition
       */
    	}

    	/**
      * Handle given mutations.
      *
      * @param {Array.<engine.view.Document~MutatatedText|engine.view.Document~MutatatedChildren>} mutations
      */


    	createClass(MutationHandler, [{
    		key: 'handle',
    		value: function handle(mutations) {
    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = mutations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var mutation = _step.value;

    					// Fortunately it will never be both.
    					this._handleTextMutation(mutation);
    					this._handleTextNodeInsertion(mutation);
    				}
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}

    			this.buffer.input(Math.max(this.insertedCharacterCount, 0));

    			if (this.selectionPosition) {
    				this.editing.model.selection.collapse(this.selectionPosition);
    			}
    		}
    	}, {
    		key: '_handleTextMutation',
    		value: function _handleTextMutation(mutation) {
    			if (mutation.type != 'text') {
    				return;
    			}

    			var diffResult = diff(mutation.oldText, mutation.newText);
    			var changes = diffToChanges(diffResult, mutation.newText);

    			var _iteratorNormalCompletion2 = true;
    			var _didIteratorError2 = false;
    			var _iteratorError2 = undefined;

    			try {
    				for (var _iterator2 = changes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    					var change = _step2.value;

    					var viewPos = new Position$1(mutation.node, change.index);
    					var modelPos = this.editing.mapper.toModelPosition(viewPos);

    					if (change.type == 'INSERT') {
    						var insertedText = change.values.join('');

    						this._insert(modelPos, insertedText);

    						this.selectionPosition = Position.createAt(modelPos.parent, modelPos.offset + insertedText.length);
    					} else /* if ( change.type == 'DELETE' ) */{
    							this._remove(new Range$1(modelPos, modelPos.getShiftedBy(change.howMany)), change.howMany);

    							this.selectionPosition = modelPos;
    						}
    				}
    			} catch (err) {
    				_didIteratorError2 = true;
    				_iteratorError2 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion2 && _iterator2.return) {
    						_iterator2.return();
    					}
    				} finally {
    					if (_didIteratorError2) {
    						throw _iteratorError2;
    					}
    				}
    			}
    		}
    	}, {
    		key: '_handleTextNodeInsertion',
    		value: function _handleTextNodeInsertion(mutation) {
    			if (mutation.type != 'children') {
    				return;
    			}

    			// One new node.
    			if (mutation.newChildren.length - mutation.oldChildren.length != 1) {
    				return;
    			}

    			// Which is text.
    			var diffResult = diff(mutation.oldChildren, mutation.newChildren, compare);
    			var changes = diffToChanges(diffResult, mutation.newChildren);

    			// In case of [ REMOVE, INSERT, INSERT ] the previous check will not exit.
    			if (changes.length > 1) {
    				return;
    			}

    			var change = changes[0];

    			if (!(change.values[0] instanceof Text$2)) {
    				return;
    			}

    			var viewPos = new Position$1(mutation.node, change.index);
    			var modelPos = this.editing.mapper.toModelPosition(viewPos);
    			var insertedText = change.values[0].data;

    			this._insert(modelPos, insertedText);

    			this.selectionPosition = Position.createAt(modelPos.parent, 'END');

    			function compare(oldChild, newChild) {
    				if (oldChild instanceof Text$2 && newChild instanceof Text$2) {
    					return oldChild.data === newChild.data;
    				} else {
    					return oldChild === newChild;
    				}
    			}
    		}
    	}, {
    		key: '_insert',
    		value: function _insert(position, text) {
    			this.buffer.batch.weakInsert(position, text);

    			this.insertedCharacterCount += text.length;
    		}
    	}, {
    		key: '_remove',
    		value: function _remove(range, length) {
    			this.buffer.batch.remove(range);

    			this.insertedCharacterCount -= length;
    		}
    	}]);
    	return MutationHandler;
    }();

    var safeKeycodes = [getCode('arrowUp'), getCode('arrowRight'), getCode('arrowDown'), getCode('arrowLeft'), 16, // Shift
    17, // Ctrl
    18, // Alt
    20, // CapsLock
    27, // Escape
    33, // PageUp
    34, // PageDown
    35, // Home
    36];

    // Function keys.
    // End
    for (var code = 112; code <= 135; code++) {
    	safeKeycodes.push(code);
    }

    // Returns true if a keystroke should not cause any content change caused by "typing".
    //
    // Note: this implementation is very simple and will need to be refined with time.
    //
    // @param {engine.view.observer.keyObserver.KeyEventData} keyData
    // @returns {Boolean}
    function isSafeKeystroke(keyData) {
    	// Keystrokes which contain Ctrl don't represent typing.
    	if (keyData.ctrlKey) {
    		return true;
    	}

    	return safeKeycodes.includes(keyData.keyCode);
    }

    /**
     * Base class for undo feature commands: {@link undo.UndoCommand} and {@link undo.RedoCommand}.
     *
     * @protected
     * @memberOf undo
     */

    var BaseCommand = function (_Command) {
    	inherits(BaseCommand, _Command);

    	function BaseCommand(editor) {
    		classCallCheck(this, BaseCommand);


    		/**
       * Stack of items stored by the command. These are pairs of:
       *
       * * {@link engine.model.Batch batch} saved by the command and,
       * * {@link engine.model.Selection selection} state at the moment of saving the batch.
       *
       * @protected
       * @member {Array} undo.BaseCommand#_stack
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(BaseCommand).call(this, editor));

    		_this._stack = [];

    		/**
       * Stores all batches that were created by this command.
       *
       * @protected
       * @member {WeakSet.<engine.model.Batch>} undo.BaseCommand#_createdBatches
       */
    		_this._createdBatches = new WeakSet();

    		// Refresh state, so command is inactive just after initialization.
    		_this.refreshState();
    		return _this;
    	}

    	/**
      * Stores a batch in the command, together with the selection state of the {@link engine.model.Document document}
      * created by the editor which this command is registered to.
      *
      * @param {engine.model.Batch} batch Batch to add.
      */


    	createClass(BaseCommand, [{
    		key: 'addBatch',
    		value: function addBatch(batch) {
    			var selection = {
    				ranges: Array.from(this.editor.document.selection.getRanges()),
    				isBackward: this.editor.document.selection.isBackward
    			};

    			this._stack.push({ batch: batch, selection: selection });
    			this.refreshState();
    		}

    		/**
       * Removes all items from the stack.
       */

    	}, {
    		key: 'clearStack',
    		value: function clearStack() {
    			this._stack = [];
    			this.refreshState();
    		}

    		/**
       * @inheritDoc
       */

    	}, {
    		key: '_checkEnabled',
    		value: function _checkEnabled() {
    			return this._stack.length > 0;
    		}
    	}]);
    	return BaseCommand;
    }(Command);

    function transformDelta(setToTransform, setToTransformBy) {
    	var isStrong = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

    	var results = [];

    	var _iteratorNormalCompletion = true;
    	var _didIteratorError = false;
    	var _iteratorError = undefined;

    	try {
    		for (var _iterator = setToTransform[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    			var toTransform = _step.value;

    			var to = [toTransform];

    			for (var t = 0; t < to.length; t++) {
    				var _iteratorNormalCompletion2 = true;
    				var _didIteratorError2 = false;
    				var _iteratorError2 = undefined;

    				try {
    					for (var _iterator2 = setToTransformBy[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    						var transformBy = _step2.value;

    						var transformed = transform(to[t], transformBy, isStrong);
    						to.splice.apply(to, [t, 1].concat(toConsumableArray(transformed)));
    						t = t - 1 + transformed.length;
    					}
    				} catch (err) {
    					_didIteratorError2 = true;
    					_iteratorError2 = err;
    				} finally {
    					try {
    						if (!_iteratorNormalCompletion2 && _iterator2.return) {
    							_iterator2.return();
    						}
    					} finally {
    						if (_didIteratorError2) {
    							throw _iteratorError2;
    						}
    					}
    				}
    			}

    			results = results.concat(to);
    		}
    	} catch (err) {
    		_didIteratorError = true;
    		_iteratorError = err;
    	} finally {
    		try {
    			if (!_iteratorNormalCompletion && _iterator.return) {
    				_iterator.return();
    			}
    		} finally {
    			if (_didIteratorError) {
    				throw _iteratorError;
    			}
    		}
    	}

    	return results;
    }

    /**
     * Undo command stores {@link engine.model.Batch batches} applied to the {@link engine.model.Document document}
     * and is able to undo a batch by reversing it and transforming by other batches from {@link engine.model.Document#history history}
     * that happened after the reversed batch.
     *
     * Undo command also takes care of restoring {@link engine.model.Document#selection selection} to the state before the
     * undone batch was applied.
     *
     * @memberOf undo
     * @extends undo.BaseCommand
     */

    var UndoCommand = function (_BaseCommand) {
    	inherits(UndoCommand, _BaseCommand);

    	function UndoCommand() {
    		classCallCheck(this, UndoCommand);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(UndoCommand).apply(this, arguments));
    	}

    	createClass(UndoCommand, [{
    		key: '_doExecute',

    		/**
       * Executes the command: reverts a {@link engine.model.Batch batch} added to the command's stack, transforms
       * and applies reverted version on the {@link engine.model.Document document} and removes the batch from the stack.
       * Then, restores {@link engine.model.Document#selection document selection}.
       *
       * @protected
       * @fires undo.UndoCommand#event:revert
       * @param {engine.model.Batch} [batch] Batch that should be undone. If not set, the last added batch will be undone.
       */
    		value: function _doExecute() {
    			var _this2 = this;

    			var batch = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

    			// If batch is not given, set `batchIndex` to the last index in command stack.
    			var batchIndex = batch ? this._stack.findIndex(function (a) {
    				return a.batch == batch;
    			}) : this._stack.length - 1;

    			var item = this._stack.splice(batchIndex, 1)[0];

    			// All changes has to be done in one `enqueueChanges` callback so other listeners will not
    			// step between consecutive deltas, or won't do changes to the document before selection is properly restored.
    			this.editor.document.enqueueChanges(function () {
    				_this2._undo(item.batch);
    				_this2._restoreSelection(item.selection.ranges, item.selection.isBackward, item.batch.baseVersion);
    			});

    			this.fire('revert', item.batch);
    			this.refreshState();
    		}

    		/**
       * Returns index in {@link undo.BaseCommand#_stack} pointing to the item that is storing a batch that has given
       * {@link engine.model.Batch#baseVersion}.
       *
       * @private
       * @param {Number} baseVersion Base version of the batch to find.
       * @returns {Number|null}
       */

    	}, {
    		key: '_getItemIndexFromBaseVersion',
    		value: function _getItemIndexFromBaseVersion(baseVersion) {
    			for (var i = 0; i < this._stack.length; i++) {
    				if (this._stack[i].batch.baseVersion == baseVersion) {
    					return i;
    				}
    			}

    			return null;
    		}

    		/**
       * Un-does a batch by reversing a batch from history, transforming that reversed batch and applying it. This is
       * a helper method for {@link undo.UndoCommand#_doExecute}.
       *
       * @private
       * @param {engine.model.Batch} batchToUndo Batch, which deltas will be reversed, transformed and applied.
       * @param {engine.model.Batch} undoingBatch Batch that will contain transformed and applied deltas from `batchToUndo`.
       * @param {engine.model.Document} document Document that is operated on by the command.
       */

    	}, {
    		key: '_undo',
    		value: function _undo(batchToUndo) {
    			var document = this.editor.document;

    			// All changes done by the command execution will be saved as one batch.
    			var undoingBatch = document.batch();
    			this._createdBatches.add(undoingBatch);

    			var history = document.history;
    			var deltasToUndo = batchToUndo.deltas.slice();
    			deltasToUndo.reverse();

    			// We will process each delta from `batchToUndo`, in reverse order. If there was deltas A, B and C in undone batch,
    			// we need to revert them in reverse order, so first reverse C, then B, then A.
    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = deltasToUndo[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var deltaToUndo = _step.value;

    					// Keep in mind that all algorithms return arrays. That's because the transformation might result in multiple
    					// deltas, so we need arrays to handle them anyway. To simplify algorithms, it is better to always have arrays
    					// in mind. For simplicity reasons, we will use singular form in descriptions and names.
    					var baseVersion = deltaToUndo.baseVersion;
    					var nextBaseVersion = baseVersion + deltaToUndo.operations.length;

    					// 1. Get updated version of the delta from the history.
    					// Batch stored in the undo command might have an outdated version of the delta that should be undone.
    					// To prevent errors, we will take an updated version of it from the history, basing on delta's `baseVersion`.
    					var updatedDeltaToUndo = history.getDelta(baseVersion);

    					// This is a safe valve in case of not finding delta to undo in history. This may come up if that delta
    					// got updated into no deltas, or removed from history.
    					if (updatedDeltaToUndo === null) {
    						continue;
    					}

    					// 2. Reverse delta from the history.
    					updatedDeltaToUndo.reverse();
    					var reversedDelta = [];

    					var _iteratorNormalCompletion2 = true;
    					var _didIteratorError2 = false;
    					var _iteratorError2 = undefined;

    					try {
    						for (var _iterator2 = updatedDeltaToUndo[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    							var delta = _step2.value;

    							reversedDelta.push(delta.getReversed());
    						}

    						// Stores history deltas transformed by `deltaToUndo`. Will be used later for updating document history.
    					} catch (err) {
    						_didIteratorError2 = true;
    						_iteratorError2 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion2 && _iterator2.return) {
    								_iterator2.return();
    							}
    						} finally {
    							if (_didIteratorError2) {
    								throw _iteratorError2;
    							}
    						}
    					}

    					var updatedHistoryDeltas = {};

    					// 3. Transform reversed delta by history deltas that happened after delta to undo. We have to bring
    					// reversed delta to the current state of document. While doing this, we will also update history deltas
    					// to the state which "does not remember" delta that we undo.
    					var _iteratorNormalCompletion3 = true;
    					var _didIteratorError3 = false;
    					var _iteratorError3 = undefined;

    					try {
    						for (var _iterator3 = history.getDeltas(nextBaseVersion)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
    							var historyDelta = _step3.value;

    							// 3.1. Transform selection range stored with history batch by reversed delta.
    							// It is important to keep stored selection ranges updated. As we are removing and updating deltas in the history,
    							// selection ranges would base on outdated history state.
    							var itemIndex = this._getItemIndexFromBaseVersion(historyDelta.baseVersion);

    							// `itemIndex` will be `null` for `historyDelta` if it is not the first delta in it's batch.
    							// This is fine, because we want to transform each selection only once, before transforming reversed delta
    							// by the first delta of the batch connected with the ranges.
    							if (itemIndex !== null) {
    								this._stack[itemIndex].selection.ranges = transformRangesByDeltas(this._stack[itemIndex].selection.ranges, reversedDelta);
    							}

    							// 3.2. Transform history delta by reversed delta. We need this to update document history.
    							var updatedHistoryDelta = transformDelta([historyDelta], reversedDelta, false);

    							// 3.3. Transform reversed delta by history delta (in state before transformation above).
    							reversedDelta = transformDelta(reversedDelta, [historyDelta], true);

    							// 3.4. Store updated history delta. Later, it will be updated in `history`.
    							if (!updatedHistoryDeltas[historyDelta.baseVersion]) {
    								updatedHistoryDeltas[historyDelta.baseVersion] = [];
    							}

    							updatedHistoryDeltas[historyDelta.baseVersion] = updatedHistoryDeltas[historyDelta.baseVersion].concat(updatedHistoryDelta);
    						}

    						// 4. After reversed delta has been transformed by all history deltas, apply it.
    					} catch (err) {
    						_didIteratorError3 = true;
    						_iteratorError3 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion3 && _iterator3.return) {
    								_iterator3.return();
    							}
    						} finally {
    							if (_didIteratorError3) {
    								throw _iteratorError3;
    							}
    						}
    					}

    					var _iteratorNormalCompletion4 = true;
    					var _didIteratorError4 = false;
    					var _iteratorError4 = undefined;

    					try {
    						for (var _iterator4 = reversedDelta[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
    							var _delta = _step4.value;

    							// Fix base version.
    							_delta.baseVersion = document.version;

    							// Before applying, add the delta to the `undoingBatch`.
    							undoingBatch.addDelta(_delta);

    							// Now, apply all operations of the delta.
    							var _iteratorNormalCompletion6 = true;
    							var _didIteratorError6 = false;
    							var _iteratorError6 = undefined;

    							try {
    								for (var _iterator6 = _delta.operations[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
    									var operation = _step6.value;

    									document.applyOperation(operation);
    								}
    							} catch (err) {
    								_didIteratorError6 = true;
    								_iteratorError6 = err;
    							} finally {
    								try {
    									if (!_iteratorNormalCompletion6 && _iterator6.return) {
    										_iterator6.return();
    									}
    								} finally {
    									if (_didIteratorError6) {
    										throw _iteratorError6;
    									}
    								}
    							}
    						}

    						// 5. Remove reversed delta from the history.
    					} catch (err) {
    						_didIteratorError4 = true;
    						_iteratorError4 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion4 && _iterator4.return) {
    								_iterator4.return();
    							}
    						} finally {
    							if (_didIteratorError4) {
    								throw _iteratorError4;
    							}
    						}
    					}

    					history.removeDelta(baseVersion);

    					// And all deltas that are reversing it.
    					// So the history looks like both original and reversing deltas never happened.
    					// That's why we have to update history deltas - some of them might have been basing on deltas that we are now removing.
    					var _iteratorNormalCompletion5 = true;
    					var _didIteratorError5 = false;
    					var _iteratorError5 = undefined;

    					try {
    						for (var _iterator5 = reversedDelta[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
    							var _delta2 = _step5.value;

    							history.removeDelta(_delta2.baseVersion);
    						}

    						// 6. Update history deltas in history.
    					} catch (err) {
    						_didIteratorError5 = true;
    						_iteratorError5 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion5 && _iterator5.return) {
    								_iterator5.return();
    							}
    						} finally {
    							if (_didIteratorError5) {
    								throw _iteratorError5;
    							}
    						}
    					}

    					for (var historyBaseVersion in updatedHistoryDeltas) {
    						history.updateDelta(Number(historyBaseVersion), updatedHistoryDeltas[historyBaseVersion]);
    					}
    				}
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}
    		}

    		/**
       * Restores {@link engine.model.Document#selection document selection} state after a batch has been undone. This
       * is a helper method for {@link undo.UndoCommand#_doExecute}.
       *
       * @private
       * @param {Array.<engine.model.Range>} ranges Ranges to be restored.
       * @param {Boolean} isBackward Flag describing if restored range was selected forward or backward.
       * @param {Number} baseVersion
       * @param {engine.model.Document} document Document that is operated on by the command.
       */

    	}, {
    		key: '_restoreSelection',
    		value: function _restoreSelection(ranges, isBackward, baseVersion) {
    			var document = this.editor.document;

    			// This will keep the transformed selection ranges.
    			var selectionRanges = [];

    			// Transform all ranges from the restored selection.
    			var _iteratorNormalCompletion7 = true;
    			var _didIteratorError7 = false;
    			var _iteratorError7 = undefined;

    			try {
    				for (var _iterator7 = ranges[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
    					var range = _step7.value;

    					var transformedRanges = transformSelectionRange(range, baseVersion, document);

    					// For each `range` from `ranges`, we take only one transformed range.
    					// This is because we want to prevent situation where single-range selection
    					// got transformed to multi-range selection. We will take the first range that
    					// is not in the graveyard.
    					var transformedRange = transformedRanges.find(function (range) {
    						return range.start.root != document.graveyard;
    					});

    					// `transformedRange` might be `undefined` if transformed range ended up in graveyard.
    					if (transformedRange) {
    						selectionRanges.push(transformedRange);
    					}
    				}

    				// `selectionRanges` may be empty if all ranges ended up in graveyard. If that is the case, do not restore selection.
    			} catch (err) {
    				_didIteratorError7 = true;
    				_iteratorError7 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion7 && _iterator7.return) {
    						_iterator7.return();
    					}
    				} finally {
    					if (_didIteratorError7) {
    						throw _iteratorError7;
    					}
    				}
    			}

    			if (selectionRanges.length) {
    				document.selection.setRanges(selectionRanges, isBackward);
    			}
    		}
    	}]);
    	return UndoCommand;
    }(BaseCommand);

    function transformSelectionRange(range, baseVersion, document) {
    	var history = document.history;

    	// We create `transformed` array. At the beginning it will have only the original range.
    	// During transformation the original range will change or even break into smaller ranges.
    	// After the range is broken into two ranges, we have to transform both of those ranges separately.
    	// For that reason, we keep all transformed ranges in one array and operate on it.
    	var transformed = [range];

    	// The ranges will be transformed by history deltas that happened after the selection got stored.
    	// Note, that at this point, the document history is already updated by undo command execution. We will
    	// not transform the range by deltas that got undone or their reversing counterparts.
    	transformed = transformRangesByDeltas(transformed, history.getDeltas(baseVersion));

    	// After `range` got transformed, we have an array of ranges. Some of those
    	// ranges may be "touching" -- they can be next to each other and could be merged.
    	// First, we have to sort those ranges because they don't have to be in an order.
    	transformed.sort(function (a, b) {
    		return a.start.isBefore(b.start) ? -1 : 1;
    	});

    	// Then, we check if two consecutive ranges are touching.
    	for (var i = 1; i < transformed.length; i++) {
    		var a = transformed[i - 1];
    		var b = transformed[i];

    		if (a.end.isTouching(b.start)) {
    			a.end = b.end;
    			transformed.splice(i, 1);
    			i--;
    		}
    	}

    	return transformed;
    }

    // Transforms given set of `ranges` by given set of `deltas`. Returns transformed `ranges`.
    function transformRangesByDeltas(ranges, deltas) {
    	var _iteratorNormalCompletion8 = true;
    	var _didIteratorError8 = false;
    	var _iteratorError8 = undefined;

    	try {
    		for (var _iterator8 = deltas[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
    			var delta = _step8.value;
    			var _iteratorNormalCompletion9 = true;
    			var _didIteratorError9 = false;
    			var _iteratorError9 = undefined;

    			try {
    				for (var _iterator9 = delta.operations[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
    					var operation = _step9.value;

    					// We look through all operations from all deltas.

    					for (var i = 0; i < ranges.length; i++) {
    						// We transform every range by every operation.
    						var result = void 0;

    						switch (operation.type) {
    							case 'insert':
    								result = ranges[i].getTransformedByInsertion(operation.position, operation.nodeList.length, true);
    								break;

    							case 'move':
    							case 'remove':
    							case 'reinsert':
    								result = ranges[i].getTransformedByMove(operation.sourcePosition, operation.targetPosition, operation.howMany, true);
    								break;
    						}

    						// If we have a transformation result, we substitute transformed range with it in `transformed` array.
    						// Keep in mind that the result is an array and may contain multiple ranges.
    						if (result) {
    							ranges.splice.apply(ranges, [i, 1].concat(toConsumableArray(result)));

    							// Fix iterator.
    							i = i + result.length - 1;
    						}
    					}
    				}
    			} catch (err) {
    				_didIteratorError9 = true;
    				_iteratorError9 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion9 && _iterator9.return) {
    						_iterator9.return();
    					}
    				} finally {
    					if (_didIteratorError9) {
    						throw _iteratorError9;
    					}
    				}
    			}
    		}
    	} catch (err) {
    		_didIteratorError8 = true;
    		_iteratorError8 = err;
    	} finally {
    		try {
    			if (!_iteratorNormalCompletion8 && _iterator8.return) {
    				_iterator8.return();
    			}
    		} finally {
    			if (_didIteratorError8) {
    				throw _iteratorError8;
    			}
    		}
    	}

    	return ranges;
    }

    /**
     * Redo command stores {@link engine.model.Batch batches} that were used to undo a batch by {@link undo.UndoCommand UndoCommand}.
     * It is able to redo a previously undone batch by reversing the undoing batches created by `UndoCommand`. Reversed batch is
     * also transformed by batches from {@link engine.model.Document#history history} that happened after it and are not other redo batches.
     *
     * Redo command also takes care of restoring {@link engine.model.Document#selection selection} to the state before
     * undone batch was applied.
     *
     * @memberOf undo
     * @extends undo.BaseCommand
     */

    var RedoCommand = function (_BaseCommand) {
    	inherits(RedoCommand, _BaseCommand);

    	function RedoCommand() {
    		classCallCheck(this, RedoCommand);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(RedoCommand).apply(this, arguments));
    	}

    	createClass(RedoCommand, [{
    		key: '_doExecute',

    		/**
       * Executes the command: reverts last {@link engine.model.Batch batch} added to the command's stack, applies
       * reverted and transformed version on the {@link engine.model.Document document} and removes the batch from the stack.
       * Then, restores {@link engine.model.Document#selection document selection}.
       *
       * @protected
       */
    		value: function _doExecute() {
    			var _this2 = this;

    			var item = this._stack.pop();

    			// All changes have to be done in one `enqueueChanges` callback so other listeners will not
    			// step between consecutive deltas, or won't do changes to the document before selection is properly restored.
    			this.editor.document.enqueueChanges(function () {
    				_this2._redo(item.batch);
    				_this2._restoreSelection(item.selection.ranges, item.selection.isBackward);
    			});

    			this.refreshState();
    		}

    		/**
       * Re-does a batch by reversing the batch that undone it, transforming that batch and applying it. This is
       * a helper method for {@link undo.RedoCommand#_doExecute}.
       *
       * @private
       * @param {engine.model.Batch} storedBatch Batch, which deltas will be reversed, transformed and applied.
       * @param {engine.model.Batch} redoingBatch Batch that will contain transformed and applied deltas from `storedBatch`.
       * @param {engine.model.Document} document Document that is operated on by the command.
       */

    	}, {
    		key: '_redo',
    		value: function _redo(storedBatch) {
    			var document = this.editor.document;

    			// All changes done by the command execution will be saved as one batch.
    			var redoingBatch = document.batch();
    			this._createdBatches.add(redoingBatch);

    			var deltasToRedo = storedBatch.deltas.slice();
    			deltasToRedo.reverse();

    			// We will process each delta from `storedBatch`, in reverse order. If there was deltas A, B and C in stored batch,
    			// we need to revert them in reverse order, so first reverse C, then B, then A.
    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = deltasToRedo[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var deltaToRedo = _step.value;

    					// Keep in mind that all algorithms return arrays. That's because the transformation might result in multiple
    					// deltas, so we need arrays to handle them anyway. To simplify algorithms, it is better to always have arrays
    					// in mind. For simplicity reasons, we will use singular form in descriptions and names.

    					var nextBaseVersion = deltaToRedo.baseVersion + deltaToRedo.operations.length;

    					// As stated above, convert delta to array of deltas.
    					var reversedDelta = [deltaToRedo.getReversed()];

    					// 1. Transform that delta by deltas from history that happened after it.
    					// Omit deltas from "redo" batches, because reversed delta already bases on them. Transforming by them
    					// again will result in incorrect deltas.
    					var _iteratorNormalCompletion2 = true;
    					var _didIteratorError2 = false;
    					var _iteratorError2 = undefined;

    					try {
    						for (var _iterator2 = document.history.getDeltas(nextBaseVersion)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    							var historyDelta = _step2.value;

    							if (!this._createdBatches.has(historyDelta.batch)) {
    								reversedDelta = transformDelta(reversedDelta, [historyDelta], true);
    							}
    						}

    						// 2. After reversed delta has been transformed by all history deltas, apply it.
    					} catch (err) {
    						_didIteratorError2 = true;
    						_iteratorError2 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion2 && _iterator2.return) {
    								_iterator2.return();
    							}
    						} finally {
    							if (_didIteratorError2) {
    								throw _iteratorError2;
    							}
    						}
    					}

    					var _iteratorNormalCompletion3 = true;
    					var _didIteratorError3 = false;
    					var _iteratorError3 = undefined;

    					try {
    						for (var _iterator3 = reversedDelta[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
    							var delta = _step3.value;

    							// Fix base version.
    							delta.baseVersion = document.version;

    							// Before applying, add the delta to the `redoingBatch`.
    							redoingBatch.addDelta(delta);

    							// Now, apply all operations of the delta.
    							var _iteratorNormalCompletion4 = true;
    							var _didIteratorError4 = false;
    							var _iteratorError4 = undefined;

    							try {
    								for (var _iterator4 = delta.operations[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
    									var operation = _step4.value;

    									document.applyOperation(operation);
    								}
    							} catch (err) {
    								_didIteratorError4 = true;
    								_iteratorError4 = err;
    							} finally {
    								try {
    									if (!_iteratorNormalCompletion4 && _iterator4.return) {
    										_iterator4.return();
    									}
    								} finally {
    									if (_didIteratorError4) {
    										throw _iteratorError4;
    									}
    								}
    							}
    						}
    					} catch (err) {
    						_didIteratorError3 = true;
    						_iteratorError3 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion3 && _iterator3.return) {
    								_iterator3.return();
    							}
    						} finally {
    							if (_didIteratorError3) {
    								throw _iteratorError3;
    							}
    						}
    					}
    				}
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}
    		}

    		/**
       * Restores {@link engine.model.Document#selection document selection} state after a batch has been re-done. This
       * is a helper method for {@link undo.RedoCommand#_doExecute}.
       *
       * @private
       * @param {Array.<engine.model.Range>} ranges Ranges to be restored.
       * @param {Boolean} isBackward Flag describing if restored range was selected forward or backward.
       */

    	}, {
    		key: '_restoreSelection',
    		value: function _restoreSelection(ranges, isBackward) {
    			this.editor.document.selection.setRanges(ranges, isBackward);
    		}
    	}]);
    	return RedoCommand;
    }(BaseCommand);

    /**
     * Undo engine feature.
     *
     * Undo brings in possibility to undo and redo changes done in the model by deltas through
     * the {@link engine.model.Document#batch Batch API}.
     *
     * @memberOf undo
     * @extends ckeditor5.Feature
     */

    var UndoEngine = function (_Feature) {
    	inherits(UndoEngine, _Feature);

    	/**
      * @inheritDoc
      */

    	function UndoEngine(editor) {
    		classCallCheck(this, UndoEngine);


    		/**
       * Command which manages undo {@link engine.model.Batch batches} stack (history).
       * Created and registered during {@link undo.UndoEngine#init feature initialization}.
       *
       * @private
       * @member {undo.UndoEngineCommand} undo.UndoEngine#_undoCommand
       */

    		/**
       * Command which manages redo {@link engine.model.Batch batches} stack (history).
       * Created and registered during {@link undo.UndoEngine#init feature initialization}.
       *
       * @private
       * @member {undo.UndoEngineCommand} undo.UndoEngine#_redoCommand
       */

    		/**
       * Keeps track of which batch has been registered in Undo.
       *
       * @private
       * @member {WeakSet.<engine.model.Batch>} undo.UndoEngine#_batchRegistry
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(UndoEngine).call(this, editor));

    		_this._batchRegistry = new WeakSet();
    		return _this;
    	}

    	/**
      * @inheritDoc
      */


    	createClass(UndoEngine, [{
    		key: 'init',
    		value: function init() {
    			var _this2 = this;

    			// Create commands.
    			this._undoCommand = new UndoCommand(this.editor);
    			this._redoCommand = new RedoCommand(this.editor);

    			// Register command to the editor.
    			this.editor.commands.set('undo', this._undoCommand);
    			this.editor.commands.set('redo', this._redoCommand);

    			this.listenTo(this.editor.document, 'change', function (evt, type, changes, batch) {
    				// If changes are not a part of a batch or this is not a new batch, omit those changes.
    				if (_this2._batchRegistry.has(batch) || batch.type == 'transparent') {
    					return;
    				} else {
    					if (_this2._undoCommand._createdBatches.has(batch)) {
    						// If this batch comes from `undoCommand`, add it to `redoCommand` stack.
    						_this2._redoCommand.addBatch(batch);
    					} else if (_this2._redoCommand._createdBatches.has(batch)) {
    						// If this batch comes from `redoCommand`, add it to `undoCommand` stack.
    						_this2._undoCommand.addBatch(batch);
    					} else {
    						// A default batch - these are new changes in the document, not introduced by undo feature.
    						// Add them to `undoCommand` stack and clear `redoCommand` stack.
    						_this2._undoCommand.addBatch(batch);
    						_this2._redoCommand.clearStack();
    					}
    				}

    				// Add the batch to the registry so it will not be processed again.
    				_this2._batchRegistry.add(batch);
    			});
    		}
    	}]);
    	return UndoEngine;
    }(Feature);

    /**
     * The icon controller class.
     *
     *		const model = new Model( {
     *			name: 'bold',
     *			align: 'LEFT'
     *		} );
     *
     *		// An instance of "bold" Icon, aligned to the left.
     *		new Icon( model, new IconView() );
     *
     * See {@link ui.icon.IconView}, {@link ui.iconManager.IconManager}.
     *
     * @memberOf ui.icon
     * @extends ui.Controller
     */

    var Icon = function (_Controller) {
      inherits(Icon, _Controller);

      /**
       * Creates an instance of {@link ui.icon.Icon} class.
       *
       * @param {ui.icon.IconModel} model Model of this icon.
       * @param {ui.View} view View of this icon.
       */

      function Icon(model, view) {
        classCallCheck(this, Icon);

        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(Icon).call(this, model, view));

        view.model.bind('name', 'align').to(model);
        return _this;
      }

      return Icon;
    }(Controller);

    /**
     * The icon view class.
     *
     * See {@link ui.icon.Icon}.
     *
     * @memberOf ui.icon
     * @extends ui.View
     */

    var IconView = function (_View) {
    	inherits(IconView, _View);

    	/**
      * @inheritDoc
      */

    	function IconView() {
    		classCallCheck(this, IconView);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(IconView).call(this));

    		var bind = _this.bind;

    		_this.template = new Template({
    			tag: 'svg',
    			ns: 'http://www.w3.org/2000/svg',
    			attributes: {
    				class: ['ck-icon', bind.to('align', function (a) {
    					return a ? 'ck-icon-' + a.toLowerCase() : '';
    				})]
    			},
    			children: [{
    				tag: 'use',
    				ns: 'http://www.w3.org/2000/svg',
    				attributes: {
    					href: {
    						ns: 'http://www.w3.org/1999/xlink',
    						value: bind.to('name', function (i) {
    							return '#ck-icon-' + i;
    						})
    					}
    				}
    			}]
    		});

    		/**
       * Model of this icon view.
       *
       * @member {ui.icon.IconViewModel} ui.icon.IconView#model
       */
    		return _this;
    	}

    	return IconView;
    }(View);

    /**
     * The button controller class. It uses {@link ui.icon.Icon} component
     * to display an icon.
     *
     *		const model = new Model( {
     *			label: 'Bold',
     *			isEnabled: true,
     *			isOn: false,
     *			icon: 'bold',
     *			iconAlign: 'LEFT'
     *		} );
     *
     *		// An instance of Button with a label and an icon.
     *		new Button( model, new ButtonView() );
     *
     * See {@link ui.button.ButtonView}.
     *
     * @memberOf ui.button
     * @extends ui.Controller
     */

    var Button = function (_Controller) {
      inherits(Button, _Controller);

      /**
       * Creates an instance of {@link ui.button.Button} class.
       *
       * @param {ui.button.ButtonModel} model Model of this Button.
       * @param {ui.View} view View of this Button.
       */

      function Button(model, view) {
        classCallCheck(this, Button);

        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(Button).call(this, model, view));

        view.model.bind('label', 'isOn', 'isEnabled', 'noText').to(model);

        if (model.icon) {
          view.model.bind('icon', 'iconAlign').to(model);
        }

        view.model.on('click', function () {
          return model.fire('execute');
        });
        return _this;
      }

      /**
       * @inheritDoc
       */


      createClass(Button, [{
        key: 'init',
        value: function init() {
          if (this.model.icon) {
            this.collections.add(new ControllerCollection('children'));

            var iconModel = new Model();
            iconModel.bind('name', 'align').to(this.model, 'icon', 'iconAlign');

            this.add('children', new Icon(iconModel, new IconView()));
          }

          return get(Object.getPrototypeOf(Button.prototype), 'init', this).call(this);
        }
      }]);
      return Button;
    }(Controller);

    /**
     * The button view class.
     *
     * See {@link ui.button.Button}.
     *
     * @memberOf ui.button
     * @extends ui.View
     */

    var ButtonView = function (_View) {
    	inherits(ButtonView, _View);

    	/**
      * @inheritDoc
      */

    	function ButtonView() {
    		classCallCheck(this, ButtonView);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ButtonView).call(this));

    		var bind = _this.bind;

    		_this.template = new Template({
    			tag: 'button',

    			attributes: {
    				class: ['ck-button', bind.to('isEnabled', function (value) {
    					return value ? 'ck-enabled' : 'ck-disabled';
    				}), bind.to('isOn', function (value) {
    					return value ? 'ck-on' : 'ck-off';
    				}), bind.if('noText', 'ck-button-notext')]
    			},

    			children: [{
    				tag: 'span',

    				attributes: {
    					class: ['ck-button__label']
    				},

    				children: [{
    					text: bind.to('label')
    				}]
    			}],

    			on: {
    				mousedown: bind.to(function (evt) {
    					evt.preventDefault();
    				}),

    				click: bind.to(function () {
    					// We can't make the button disabled using the disabled attribute, because it won't be focusable.
    					// Though, shouldn't this condition be moved to the button controller?
    					if (_this.model.isEnabled) {
    						_this.model.fire('click');
    					}
    				})
    			}
    		});

    		_this.register('children', function (el) {
    			return el;
    		});

    		/**
       * Model of this button view.
       *
       * @member {ui.button.ButtonViewModel} ui.button.ButtonView#model
       */
    		return _this;
    	}

    	return ButtonView;
    }(View);

    /**
     * Undo feature. Introduces the "Undo" and "Redo" buttons to the editor.
     *
     * Below is the explanation of undo mechanism working together with {@link engine.model.CompressedHistory CompressedHistory}:
     *
     * Whenever a {@link engine.model.Delta delta} is applied to the {@link engine.model.Document document}, it is saved to
     * `CompressedHistory` as is. The {@link engine.model.Batch batch} that owns that delta is also saved, in {@link undo.UndoCommand},
     * together with selection that was on the document before the delta was applied. Batch is saved instead of delta because
     * changes are undone batch-by-batch, not delta-by-delta and batch is seen as one undo step.
     *
     * After some changes happen to the document, we can represent `CompressedHistory` and `UndoCommand` stack as follows:
     *
     *		  history                           undo stack
     *		===========             ==================================
     *		[delta A1]              [batch A with selection before A1]
     *		[delta B1]              [batch B with selection before B1]
     *		[delta B2]              [batch C with selection before C1]
     *		[delta C1]
     *		[delta C2]
     *		[delta B3]
     *		[delta C3]
     *
     * Where deltas starting by the same letter are from same batch.
     *
     * Undoing a batch means that we need to generate set of deltas which will reverse effects of that batch. I.e. if batch
     * added several letters, undoing batch should remove them. It is important to apply undoing deltas in reversed order,
     * so if batch has delta `X`, `Y`, `Z` we should apply reversed deltas `Zr`, `Yr` and `Xr`. In other case, reversed delta
     * `Xr` would operate on wrong document state, because delta `X` does not know that delta `Y` and `Z` happened.
     *
     * After deltas from undone batch got {@link engine.model.Delta#getReversed reversed} we need to make sure if they are
     * ready to be applied. In our scenario, delta `C3` is the last delta so `C3r` bases on up-to-date document state so
     * it can be applied to the document.
     *
     *		  history                           undo stack
     *		===========             ==================================
     *		[delta A1 ]             [batch A with selection before A1]
     *		[delta B1 ]             [batch B with selection before B1]
     *		[delta B2 ]             [   processing undoing batch C   ]
     *		[delta C1 ]
     *		[delta C2 ]
     *		[delta B3 ]
     *		[delta C3 ]
     *		[delta C3r]
     *
     * Next is delta `C2`, reversed to `C2r`. `C2r` bases on `C2`, so it bases on wrong document state. It needs to be
     * transformed by deltas from history that happened after it, so it "knows" about them. Let `C2' = C2r * B3 * C3 * C3r`,
     * where `*` means "transformed by". As can be seen, `C2r` is transformed by a delta which is undone afterwards anyway.
     * This brings two problems: lower effectiveness (obvious) and incorrect results. Bad results come from the fact that
     * operational transformation algorithms assume there is no connection between two transformed operations when resolving
     * conflicts, which is true for, i.e. collaborative editing, but is not true for undo algorithm.
     *
     * To prevent both problems, `CompressedHistory` introduces an API to {@link engine.model.CompressedDelta#removeDelta remove}
     * deltas from history. It is used to remove undone and undoing deltas after they are applied. It feels right - delta is
     * undone/reversed = "removed", there should be no sign of it in history (fig. 1). `---` symbolizes removed delta.
     *
     *		history (fig. 1)            history (fig. 2)            history (fig. 3)
     *		================            ================            ================
     *		   [delta A1]                  [delta A1]                  [delta A1]
     *		   [delta B1]                  [delta B1]                  [delta B1]
     *		   [delta B2]                  [delta B2]                  [delta B2]
     *		   [delta C1]                  [delta C1]                  [---C1---]
     *		   [delta C2]                  [---C2---]                  [---C2---]
     *		   [delta B3]                  [delta B3]                  [delta B3]
     *		   [---C3---]                  [---C3---]                  [---C3---]
     *		   [---C3r--]                  [---C3r--]                  [---C3r--]
     *		                               [---C2'--]                  [---C2'--]
     *		                                                           [---C1'--]
     *
     * Now we can transform `C2r` only by `B3` and remove both it and `C2` (fig. 2). Same with `C1` (fig. 3). `'` symbolizes
     * reversed delta that was later transformed.
     *
     * But what about that selection? For batch `C`, undo feature remembers selection just before `C1` was applied. It can be
     * visualized between delta `B2` and `B3` (see fig. 3). As can be seen, some operations were applied to the document since the selection
     * state was remembered. Setting document selection as it was remembered would be incorrect. It feels natural that
     * selection state should also be transformed by deltas from history. Same pattern applies as with transforming deltas - ranges
     * should not be transformed by undone and undoing deltas. Thankfully, those deltas are already removed from history.
     *
     * Unfortunately, a problem appears with delta `B3`. It still remembers context of deltas `C2` and `C1` on which it bases.
     * It is an obvious error: i.e. transforming by that delta would lead to wrong results or "repeating" history would
     * produce different document than actual.
     *
     * To prevent this situation, we have to also {@link engine.model.CompressedHistory#updateDelta update} `B3` in history.
     * It should be kept in a state that "does not remember" deltas that has been removed from the history. It is easily
     * achieved while transforming reversed delta. I.e., when `C2r` is transformed by `B3`, at the same time we transform
     * `B3` by `C2r`. Transforming `B3` that remembers `C2` by delta reversing `C2` effectively makes `B3` "forget" about `C2`.
     * By doing those transformation we effectively make `B3` base on `B2` which is a correct state of history (fig. 4).
     *
     *		     history (fig. 4)                         history (fig. 5)
     *		===========================            ===============================
     *		        [delta A1]                               [---A1---]
     *		        [delta B1]                         [delta B1 "without A1"]
     *		        [delta B2]                         [delta B2 "without A1"]
     *		        [---C1---]                               [---C1---]
     *		        [---C2---]                               [---C2---]
     *		[delta B3 "without C2, C1"]            [delta B3 "without C2, C1, A1"]
     *		        [---C3---]                               [---C3---]
     *		        [---C3r--]                               [---C3r--]
     *		        [---C2'--]                               [---C2'--]
     *		        [---C1'--]                               [---C1'--]
     *		                                                 [---A1'--]
     *
     * Selective undo works on the same basis, however instead of undoing the last batch in undo stack, any batch can be undone.
     * Same algorithm applies: deltas from batch (i.e. `A1`) are reversed and then transformed by deltas stored in history,
     * simultaneously updating them. Then deltas are applied to the document and removed from history (fig. 5).
     *
     * @memberOf undo
     * @extends ckeditor5.Feature
     */

    var Undo = function (_Feature) {
      inherits(Undo, _Feature);

      function Undo() {
        classCallCheck(this, Undo);
        return possibleConstructorReturn(this, Object.getPrototypeOf(Undo).apply(this, arguments));
      }

      createClass(Undo, [{
        key: 'init',


        /**
         * @inheritDoc
         */
        value: function init() {
          var editor = this.editor;
          var t = editor.t;

          this._addButton('undo', t('Undo'));
          this._addButton('redo', t('Redo'));

          editor.keystrokes.set('CTRL+Z', 'undo');
          editor.keystrokes.set('CTRL+Y', 'redo');
          editor.keystrokes.set('CTRL+SHIFT+Z', 'redo');
        }

        /**
         * Creates a button for the specified command.
         *
         * @private
         * @param {String} name Command name.
         * @param {String} label Button label.
         */

      }, {
        key: '_addButton',
        value: function _addButton(name, label) {
          var editor = this.editor;

          var command = editor.commands.get(name);

          var model = new Model({
            isOn: false,
            label: label,
            noText: true,
            icon: name,
            iconAlign: 'LEFT'
          });

          model.bind('isEnabled').to(command, 'isEnabled');

          this.listenTo(model, 'execute', function () {
            return editor.execute(name);
          });

          editor.ui.featureComponents.add(name, Button, ButtonView, model);
        }
      }], [{
        key: 'requires',

        /**
         * @inheritDoc
         */
        get: function get() {
          return [UndoEngine];
        }
      }]);
      return Undo;
    }(Feature);

    /**
     * Provides chainable, high-level API to easily build basic model-to-view converters that are appended to given
     * dispatchers. In many cases, this is the API that should be used to specify how abstract model elements and
     * attributes should be represented in the view (and then later in DOM). Instances of this class are created by
     * {@link engine.conversion.BuildModelConverterFor}.
     *
     * If you need more complex converters, see {@link engine.conversion.ModelConversionDispatcher},
     * {@link engine.conversion.modelToView}, {@link engine.conversion.ModelConsumable}, {@link engine.conversion.Mapper}.
     *
     * Using this API it is possible to create three kinds of converters:
     *
     * 1. Model element to view element converter. This is a converter that takes the model element and represents it
     * in the view.
     *
     *		BuildModelConverterFor( dispatcher ).fromElement( 'paragraph' ).toElement( 'p' );
     *		BuildModelConverterFor( dispatcher ).fromElement( 'image' ).toElement( 'img' );
     *
     * 2. Model attribute to view attribute converter. This is a converter that operates on model element attributes
     * and converts them to view element attributes. It is suitable for elements like `image` (`src`, `title` attributes).
     *
     *		BuildModelConverterFor( dispatcher ).fromElement( 'image' ).toElement( 'img' );
     *		BuildModelConverterFor( dispatcher ).fromAttribute( 'src' ).toAttribute();
     *
     * 3. Model attribute to view element converter. This is a converter that takes model attributes and represents them
     * as view elements. Those view elements are wrapping view elements are node that correspond to model elements and
     * nodes which had converter attribute. It is suitable for attributes like `bold`, where `bold` attribute set on model
     * text nodes is converter to `strong` view element.
     *
     *		BuildModelConverterFor( dispatcher ).fromAttribute( 'bold' ).toElement( 'strong' );
     *
     * It is possible to provide various different parameters for {@link engine.conversion.ModelConverterBuilder#toElement}
     * and {@link engine.conversion.ModelConverterBuilder#toAttribute} methods. See their descriptions to learn more.
     *
     * It is also possible to {@link engine.conversion.ModelConverterBuilder#withPriority change default priority}
     * of created converters to decide which converter should be fired earlier and which later. This is useful if you provide
     * a general converter but want to provide different converter for a specific-case (i.e. given model element is converted
     * always to given view element, but if it has given attribute it is converter to other view element). For this,
     * use {@link engine.conversion.ModelConverterBuilder#withPriority withPriority} right after `from...` method.
     *
     * Note that `to...` methods are "terminators", which means that should be the last one used in building converter.
     *
     * You can use {@link engine.conversion.ViewConverterBuilder} to create "opposite" converters - from view to model.
     *
     * @memberOf engine.conversion
     */

    var ModelConverterBuilder = function () {
    	/**
      * Creates `ModelConverterBuilder` with given `dispatchers` registered to it.
      *
      * @param {Array.<engine.conversion.ModelConversionDispatcher>} dispatchers Dispatchers to which converters will
      * be attached.
      */

    	function ModelConverterBuilder(dispatchers) {
    		classCallCheck(this, ModelConverterBuilder);

    		/**
       * Dispatchers to which converters will be attached.
       *
       * @type {Array.<engine.conversion.ModelConversionDispatcher>}
       * @private
       */
    		this._dispatchers = dispatchers;

    		/**
       * Contains data about registered "from" query.
       *
       * @type {Object}
       * @private
       */
    		this._from = null;
    	}

    	/**
      * Registers what model element should be converted.
      *
      * @chainable
      * @param {String} elementName Name of element to convert.
      * @returns {engine.conversion.ModelConverterBuilder}
      */


    	createClass(ModelConverterBuilder, [{
    		key: 'fromElement',
    		value: function fromElement(elementName) {
    			this._from = {
    				type: 'element',
    				name: elementName,
    				priority: null
    			};

    			return this;
    		}

    		/**
       * Registers what model attribute should be converted.
       *
       * @chainable
       * @param {String} key Key of attribute to convert.
       * @returns {engine.conversion.ModelConverterBuilder}
       */

    	}, {
    		key: 'fromAttribute',
    		value: function fromAttribute(key) {
    			this._from = {
    				type: 'attribute',
    				key: key,
    				priority: null
    			};

    			return this;
    		}

    		/**
       * Changes default priority for built converter. The lower the number, the earlier converter will be fired.
       * Default priority is `10`.
       *
       * **Note:** Keep in mind that event priority, that is set by this modifier, is used for attribute priority
       * when {@link engine.view.Writer} is used. This changes how model attributes converter to view elements are
       * ordered, i.e.: `<strong><em>foo</em></strong>` vs `<em><strong>foo</strong></em>`. Using priority you can also
       * prevent node merging, i.e.: `<span class="bold"><span class="theme">foo</span><span>` vs `<span class="bold theme">foo</span>`.
       * If you want to prevent merging, just set different priority for both converters.
       *
       *		BuildModelConverterFor( dispatcher ).fromAttribute( 'bold' ).withPriority( 2 ).toElement( 'strong' );
       *		BuildModelConverterFor( dispatcher ).fromAttribute( 'italic' ).withPriority( 3 ).toElement( 'em' );
       *
       * @chainable
       * @param {Number} priority Converter priority.
       * @returns {engine.conversion.ModelConverterBuilder}
       */

    	}, {
    		key: 'withPriority',
    		value: function withPriority(priority) {
    			this._from.priority = priority;

    			return this;
    		}

    		/**
       * Registers what view element will be created by converter.
       *
       * Method accepts various ways of providing how the view element will be created. You can pass view element name as
       * `string`, view element instance which will be cloned and used, or creator function which returns view element that
       * will be used. Keep in mind that when you view element instance or creator function, it has to be/return a
       * proper type of view element: {@link engine.view.ViewContainerElement ViewContainerElement} if you convert
       * from element or {@link engine.view.ViewAttributeElement ViewAttributeElement} if you convert from attribute.
       *
       *		BuildModelConverterFor( dispatcher ).fromElement( 'paragraph' ).toElement( 'p' );
       *
       *		BuildModelConverterFor( dispatcher ).fromElement( 'image' ).toElement( new ViewContainerElement( 'img' ) );
       *
       *		BuildModelConverterFor( dispatcher )
       *			.fromElement( 'header' )
       *			.toElement( ( data ) => new ViewContainerElement( 'h' + data.item.getAttribute( 'level' ) ) );
       *
       *		BuildModelConverterFor( dispatcher ).fromAttribute( 'bold' ).toElement( new ViewAttributeElement( 'strong' ) );
       *
       * Creator function will be passed different values depending whether conversion is from element or from attribute:
       *
       * * from element: dispatcher's {@link engine.conversion.ModelConversionDispatcher#event:insert insert event} parameters
       * will be passed,
       * * from attribute: there is one parameter and it is attribute value.
       *
       * This method also registers model selection to view selection converter, if conversion is from attribute.
       *
       * This method creates the converter and adds it as a callback to a proper
       * {@link engine.conversion.ModelConversionDispatcher conversion dispatcher} event.
       *
       * @param {String|engine.view.ViewElement|Function} element Element created by converter.
       */

    	}, {
    		key: 'toElement',
    		value: function toElement(element) {
    			var priority = this._from.priority === null ? 10 : this._from.priority;

    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = this._dispatchers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var dispatcher = _step.value;

    					if (this._from.type == 'element') {
    						// From model element to view element -> insert element.
    						element = typeof element == 'string' ? new ContainerElement(element) : element;

    						dispatcher.on('insert:' + this._from.name, insertElement(element), null, priority);
    					} else {
    						// From model attribute to view element -> wrap and unwrap.
    						element = typeof element == 'string' ? new AttributeElement(element) : element;

    						dispatcher.on('addAttribute:' + this._from.key, wrap(element), null, priority);
    						dispatcher.on('changeAttribute:' + this._from.key, wrap(element), null, priority);
    						dispatcher.on('removeAttribute:' + this._from.key, unwrap(element), null, priority);

    						dispatcher.on('selectionAttribute:' + this._from.key, convertSelectionAttribute(element), null, priority);
    					}
    				}
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}
    		}

    		/**
       * Registers what view attribute will be created by converter. Keep in mind, that only model attribute to
       * view attribute conversion is supported.
       *
       * Method accepts various ways of providing how the view attribute will be created:
       *
       * * for no passed parameter, attribute key and value will be converted 1-to-1 to view attribute,
       * * if you pass one `string`, it will be used as new attribute key while attribute value will be copied,
       * * if you pass two `string`s, first one will be used as new attribute key and second one as new attribute value,
       * * if you pass a function, it is expected to return an object with `key` and `value` properties representing attribute key and value.
       * This function will be passed model attribute value and model attribute key as first two parameters and then
       * all dispatcher's {engine.conversion.ModelConversionDispatcher#event:changeAttribute changeAttribute event} parameters.
       *
       *		BuildModelConverterFor( dispatcher ).fromAttribute( 'class' ).toAttribute( '' );
       *
       *		BuildModelConverterFor( dispatcher ).fromAttribute( 'linkTitle' ).toAttribute( 'title' );
       *
       *		BuildModelConverterFor( dispatcher ).fromAttribute( 'highlighted' ).toAttribute( 'style', 'background:yellow' );
       *
       *		BuildModelConverterFor( dispatcher )
       *			.fromAttribute( 'theme' )
       *			.toAttribute( ( value ) => ( { key: 'class', value: value + '-theme' } ) );
       *
       * This method creates the converter and adds it as a callback to a proper
       * {@link engine.conversion.ModelConversionDispatcher conversion dispatcher} event.
       *
       * @param {String|Function} [keyOrCreator] Attribute key or a creator function.
       * @param {*} [value] Attribute value.
       */

    	}, {
    		key: 'toAttribute',
    		value: function toAttribute(keyOrCreator, value) {
    			if (this._from.type == 'element') {
    				// Converting from model element to view attribute is unsupported.
    				return;
    			}

    			var attributeCreator = void 0;

    			if (!keyOrCreator) {
    				// If `keyOrCreator` is not set, we assume default behavior which is 1:1 attribute re-write.
    				// This is also a default behavior for `setAttribute` converter when no attribute creator is passed.
    				attributeCreator = undefined;
    			} else if (typeof keyOrCreator == 'string') {
    				// `keyOrCreator` is an attribute key.

    				if (value) {
    					// If value is set, create "dumb" creator that always returns the same object.
    					attributeCreator = function attributeCreator() {
    						return { key: keyOrCreator, value: value };
    					};
    				} else {
    					// If value is not set, take it from the passed parameter.
    					attributeCreator = function attributeCreator(value) {
    						return { key: keyOrCreator, value: value };
    					};
    				}
    			} else {
    				// `keyOrCreator` is an attribute creator function.
    				attributeCreator = keyOrCreator;
    			}

    			var _iteratorNormalCompletion2 = true;
    			var _didIteratorError2 = false;
    			var _iteratorError2 = undefined;

    			try {
    				for (var _iterator2 = this._dispatchers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    					var dispatcher = _step2.value;

    					dispatcher.on('addAttribute:' + this._from.key, setAttribute(attributeCreator), null, this._from.priority || 10);
    					dispatcher.on('changeAttribute:' + this._from.key, setAttribute(attributeCreator), null, this._from.priority || 10);
    					dispatcher.on('removeAttribute:' + this._from.key, removeAttribute(attributeCreator), null, this._from.priority || 10);
    				}
    			} catch (err) {
    				_didIteratorError2 = true;
    				_iteratorError2 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion2 && _iterator2.return) {
    						_iterator2.return();
    					}
    				} finally {
    					if (_didIteratorError2) {
    						throw _iteratorError2;
    					}
    				}
    			}
    		}
    	}]);
    	return ModelConverterBuilder;
    }();

    /**
     * Entry point for model-to-view converters builder. This chainable API makes it easy to create basic, most common
     * model-to-view converters and attach them to provided dispatchers. The method returns an instance of
     * {@link engine.conversion.ModelConverterBuilder}.
     *
     * @external engine.conversion.BuildModelConverterFor
     * @memberOf engine.conversion
     * @param {...engine.conversion.ModelConversionDispatcher} dispatchers One or more dispatchers which
     * the built converter will be attached to.
     */


    function BuildModelConverterFor() {
    	for (var _len = arguments.length, dispatchers = Array(_len), _key = 0; _key < _len; _key++) {
    		dispatchers[_key] = arguments[_key];
    	}

    	return new ModelConverterBuilder(dispatchers);
    }

    /**
     * View matcher class.
     * Instance of this class can be used to find {@link engine.view.Element elements} that match given pattern.
     *
     * @memberOf engine.view
     */

    var Matcher = function () {
    	/**
      * Creates new instance of Matcher.
      *
      * @param {String|RegExp|Object} [pattern] Match patterns. See {@link engine.view.Matcher#add add method} for
      * more information.
      */

    	function Matcher() {
    		classCallCheck(this, Matcher);

    		this._patterns = [];

    		this.add.apply(this, arguments);
    	}

    	/**
      * Adds pattern or patterns to matcher instance.
      *
      * Example patterns matching element's name:
      *
      *		// String.
      *		matcher.add( 'div' );
      *		matcher.add( { name: 'div' } );
      *
      *		// Regular expression.
      *		matcher.add( /^\w/ );
      *		matcher.add( { name: /^\w/ } );
      *
      * Example pattern matching element's attributes:
      *
      *		matcher.add( {
      *			attributes: {
      *				title: 'foobar',
      *				foo: /^\w+/
      *			}
      *		} );
      *
      * Example patterns matching element's classes:
      *
      *		// Single class.
      *		matcher.add( {
      *			class: 'foobar'
      *		} );
      *
      *		// Single class using regular expression.
      *		matcher.add( {
      *			class: /foo.../
      *		} );
      *
      *		// Multiple classes to match.
      *		matcher.add( {
      *			class: [ 'baz', 'bar', /foo.../ ]
      *		} ):
      *
      * Example pattern matching element's styles:
      *
      *		matcher.add( {
      *			style: {
      *				position: 'absolute',
      *				color: /^\w*blue$/
      *			}
      *		} );
      *
      * Example function pattern:
      *
      *		matcher.add( ( element ) => {
      *			// Result of this function will be included in `match`
      *			// property of the object returned from matcher.match() call.
      *			if ( element.name === 'div' && element.getChildCount() > 0 ) {
      *				return { name: true };
      *			}
      *
      *			return null;
      *		} );
      *
      * Multiple patterns can be added in one call:
      *
      * 		matcher.add( 'div', { class: 'foobar' } );
      *
      * @param {Object|String|RegExp|function} pattern Object describing pattern details. If string or regular expression
      * is provided it will be used to match element's name. Pattern can be also provided in a form
      * of a function - then this function will be called with each {@link engine.view.Element element} as a parameter.
      * Function's return value will be stored under `match` key of the object returned from
      * {@link engine.view.Matcher#match match} or {@link engine.view.Matcher#matchAll matchAll} methods.
      * @param {String|RegExp} [pattern.name] Name or regular expression to match element's name.
      * @param {Object} [pattern.attribute] Object with key-value pairs representing attributes to match. Each object key
      * represents attribute name. Value under that key can be either a string or a regular expression and it will be
      * used to match attribute value.
      * @param {String|RegExp|Array} [pattern.class] Class name or array of class names to match. Each name can be
      * provided in a form of string or regular expression.
      * @param {Object} [pattern.style] Object with key-value pairs representing styles to match. Each object key
      * represents style name. Value under that key can be either a string or a regular expression and it will be used
      * to match style value.
      */


    	createClass(Matcher, [{
    		key: 'add',
    		value: function add() {
    			for (var _len = arguments.length, pattern = Array(_len), _key = 0; _key < _len; _key++) {
    				pattern[_key] = arguments[_key];
    			}

    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = pattern[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var item = _step.value;

    					// String or RegExp pattern is used as element's name.
    					if (typeof item == 'string' || item instanceof RegExp) {
    						item = { name: item };
    					}

    					// Single class name/RegExp can be provided.
    					if (item.class && (typeof item.class == 'string' || item.class instanceof RegExp)) {
    						item.class = [item.class];
    					}

    					this._patterns.push(item);
    				}
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}
    		}

    		/**
       * Matches elements for currently stored patterns. Returns match information about first found
       * {@link engine.view.Element element}, otherwise returns `null`.
       *
       * Example of returned object:
       *
       *		{
       *			element: <instance of found element>,
       *			pattern: <pattern used to match found element>,
       *			match: {
       *				name: true,
      	 *				attributes: [ 'title', 'href' ],
       *				classes: [ 'foo' ],
      	 *				styles: [ 'color', 'position' ]
       *			}
       *		}
       *
       * @see engine.view.Matcher#add
       * @see engine.view.Matcher#matchAll
       * @param {...core.view.Element} element View element to match against stored patterns.
       * @returns {Object|null} result
       * @returns {core.view.Element} result.element Matched view element.
       * @returns {Object|String|RegExp|function} result.pattern Pattern that was used to find matched element.
       * @returns {Object} result.match Object representing matched element parts.
       * @returns {Boolean} [result.match.name] True if name of the element was matched.
       * @returns {Array} [result.match.attribute] Array with matched attribute names.
       * @returns {Array} [result.match.class] Array with matched class names.
       * @returns {Array} [result.match.style] Array with matched style names.
       */

    	}, {
    		key: 'match',
    		value: function match() {
    			for (var _len2 = arguments.length, element = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    				element[_key2] = arguments[_key2];
    			}

    			var _iteratorNormalCompletion2 = true;
    			var _didIteratorError2 = false;
    			var _iteratorError2 = undefined;

    			try {
    				for (var _iterator2 = element[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    					var singleElement = _step2.value;
    					var _iteratorNormalCompletion3 = true;
    					var _didIteratorError3 = false;
    					var _iteratorError3 = undefined;

    					try {
    						for (var _iterator3 = this._patterns[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
    							var _pattern = _step3.value;

    							var match = isElementMatching(singleElement, _pattern);

    							if (match) {
    								return {
    									element: singleElement,
    									pattern: _pattern,
    									match: match
    								};
    							}
    						}
    					} catch (err) {
    						_didIteratorError3 = true;
    						_iteratorError3 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion3 && _iterator3.return) {
    								_iterator3.return();
    							}
    						} finally {
    							if (_didIteratorError3) {
    								throw _iteratorError3;
    							}
    						}
    					}
    				}
    			} catch (err) {
    				_didIteratorError2 = true;
    				_iteratorError2 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion2 && _iterator2.return) {
    						_iterator2.return();
    					}
    				} finally {
    					if (_didIteratorError2) {
    						throw _iteratorError2;
    					}
    				}
    			}

    			return null;
    		}

    		/**
       * Matches elements for currently stored patterns. Returns array of match information with all found
       * {@link engine.view.Element elements}. If no element is found - returns `null`.
       *
       * @see engine.view.Matcher#add
       * @see engine.view.Matcher#match
       * @param {...engine.view.Element} element View element to match against stored patterns.
       * @returns {Array.<Object>|null} Array with match information about found elements or `null`. For more information
       * see {@link engine.view.Matcher#match match method} description.
       */

    	}, {
    		key: 'matchAll',
    		value: function matchAll() {
    			var results = [];

    			for (var _len3 = arguments.length, element = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    				element[_key3] = arguments[_key3];
    			}

    			var _iteratorNormalCompletion4 = true;
    			var _didIteratorError4 = false;
    			var _iteratorError4 = undefined;

    			try {
    				for (var _iterator4 = element[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
    					var singleElement = _step4.value;
    					var _iteratorNormalCompletion5 = true;
    					var _didIteratorError5 = false;
    					var _iteratorError5 = undefined;

    					try {
    						for (var _iterator5 = this._patterns[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
    							var _pattern2 = _step5.value;

    							var match = isElementMatching(singleElement, _pattern2);

    							if (match) {
    								results.push({
    									element: singleElement,
    									pattern: _pattern2,
    									match: match
    								});
    							}
    						}
    					} catch (err) {
    						_didIteratorError5 = true;
    						_iteratorError5 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion5 && _iterator5.return) {
    								_iterator5.return();
    							}
    						} finally {
    							if (_didIteratorError5) {
    								throw _iteratorError5;
    							}
    						}
    					}
    				}
    			} catch (err) {
    				_didIteratorError4 = true;
    				_iteratorError4 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion4 && _iterator4.return) {
    						_iterator4.return();
    					}
    				} finally {
    					if (_didIteratorError4) {
    						throw _iteratorError4;
    					}
    				}
    			}

    			return results.length > 0 ? results : null;
    		}

    		/**
       * Returns the name of the element to match if there is exactly one pattern added to the matcher instance
       * and it matches element name defined by `string` (not `RegExp`). Otherwise, returns `null`.
       *
       * @returns {String|null} Element name trying to match.
       */

    	}, {
    		key: 'getElementName',
    		value: function getElementName() {
    			return this._patterns.length == 1 && this._patterns[0].name && !(this._patterns[0].name instanceof RegExp) ? this._patterns[0].name : null;
    		}
    	}]);
    	return Matcher;
    }();

    function isElementMatching(element, pattern) {
    	// If pattern is provided as function - return result of that function;
    	if (typeof pattern == 'function') {
    		return pattern(element);
    	}

    	var match = {};
    	// Check element's name.
    	if (pattern.name) {
    		match.name = matchName(pattern.name, element.name);

    		if (!match.name) {
    			return null;
    		}
    	}

    	// Check element's attributes.
    	if (pattern.attribute) {
    		match.attribute = matchAttributes(pattern.attribute, element);

    		if (!match.attribute) {
    			return null;
    		}
    	}

    	// Check element's classes.
    	if (pattern.class) {
    		match.class = matchClasses(pattern.class, element);

    		if (!match.class) {
    			return false;
    		}
    	}

    	// Check element's styles.
    	if (pattern.style) {
    		match.style = matchStyles(pattern.style, element);

    		if (!match.style) {
    			return false;
    		}
    	}

    	return match;
    }

    // Checks if name can be matched by provided pattern.
    //
    // @param {String|RegExp} pattern
    // @param {String} name
    // @returns {Boolean} Returns `true` if name can be matched, `false` otherwise.
    function matchName(pattern, name) {
    	// If pattern is provided as RegExp - test against this regexp.
    	if (pattern instanceof RegExp) {
    		return pattern.test(name);
    	}

    	return pattern === name;
    }

    // Checks if attributes of provided element can be matched against provided patterns.
    //
    // @param {Object} patterns Object with information about attributes to match. Each key of the object will be
    // used as attribute name. Value of each key can be a string or regular expression to match against attribute value.
    // @param {engine.view.Element} element Element which attributes will be tested.
    // @returns {Array|null} Returns array with matched attribute names or `null` if no attributes were matched.
    function matchAttributes(patterns, element) {
    	var match = [];

    	for (var name in patterns) {
    		var pattern = patterns[name];

    		if (element.hasAttribute(name)) {
    			var attribute = element.getAttribute(name);

    			if (pattern instanceof RegExp) {
    				if (pattern.test(attribute)) {
    					match.push(name);
    				} else {
    					return null;
    				}
    			} else if (attribute === pattern) {
    				match.push(name);
    			} else {
    				return null;
    			}
    		} else {
    			return null;
    		}
    	}

    	return match;
    }

    // Checks if classes of provided element can be matched against provided patterns.
    //
    // @param {Array.<String|RegExp>} patterns Array of strings or regular expressions to match against element's classes.
    // @param {engine.view.Element} element Element which classes will be tested.
    // @returns {Array|null} Returns array with matched class names or `null` if no classes were matched.
    function matchClasses(patterns, element) {
    	var match = [];

    	var _iteratorNormalCompletion6 = true;
    	var _didIteratorError6 = false;
    	var _iteratorError6 = undefined;

    	try {
    		for (var _iterator6 = patterns[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
    			var pattern = _step6.value;

    			if (pattern instanceof RegExp) {
    				var classes = element.getClassNames();

    				var _iteratorNormalCompletion7 = true;
    				var _didIteratorError7 = false;
    				var _iteratorError7 = undefined;

    				try {
    					for (var _iterator7 = classes[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
    						var name = _step7.value;

    						if (pattern.test(name)) {
    							match.push(name);
    						}
    					}
    				} catch (err) {
    					_didIteratorError7 = true;
    					_iteratorError7 = err;
    				} finally {
    					try {
    						if (!_iteratorNormalCompletion7 && _iterator7.return) {
    							_iterator7.return();
    						}
    					} finally {
    						if (_didIteratorError7) {
    							throw _iteratorError7;
    						}
    					}
    				}

    				if (match.length === 0) {
    					return null;
    				}
    			} else if (element.hasClass(pattern)) {
    				match.push(pattern);
    			} else {
    				return null;
    			}
    		}
    	} catch (err) {
    		_didIteratorError6 = true;
    		_iteratorError6 = err;
    	} finally {
    		try {
    			if (!_iteratorNormalCompletion6 && _iterator6.return) {
    				_iterator6.return();
    			}
    		} finally {
    			if (_didIteratorError6) {
    				throw _iteratorError6;
    			}
    		}
    	}

    	return match;
    }

    // Checks if styles of provided element can be matched against provided patterns.
    //
    // @param {Object} patterns Object with information about styles to match. Each key of the object will be
    // used as style name. Value of each key can be a string or regular expression to match against style value.
    // @param {engine.view.Element} element Element which styles will be tested.
    // @returns {Array|null} Returns array with matched style names or `null` if no styles were matched.
    function matchStyles(patterns, element) {
    	var match = [];

    	for (var name in patterns) {
    		var pattern = patterns[name];

    		if (element.hasStyle(name)) {
    			var style = element.getStyle(name);

    			if (pattern instanceof RegExp) {
    				if (pattern.test(style)) {
    					match.push(name);
    				} else {
    					return null;
    				}
    			} else if (style === pattern) {
    				match.push(name);
    			} else {
    				return null;
    			}
    		} else {
    			return null;
    		}
    	}

    	return match;
    }

    /**
     * Provides chainable, high-level API to easily build basic view-to-model converters that are appended to given
     * dispatchers. View-to-model converters are used when external data is added to the editor, i.e. when a user pastes
     * HTML content to the editor. Then, converters are used to translate this structure, possibly removing unknown/incorrect
     * nodes, and add it to the model. Also multiple, different elements might be translated into the same thing in the
     * model, i.e. `<b>` and `<strong>` elements might be converted to `bold` attribute (even though `bold` attribute will
     * be then converted only to `<strong>` tag). Instances of this class are created by {@link engine.conversion.BuildViewConverterFor}.
     *
     * If you need more complex converters, see {@link engine.conversion.ViewConversionDispatcher},
     * {@link engine.conversion.viewToModel}, {@link engine.conversion.ViewConsumable}.
     *
     * Using this API it is possible to create various kind of converters:
     *
     * 1. View element to model element:
     *
     *		BuildViewConverterFor( dispatcher ).fromElement( 'p' ).toElement( 'paragraph' );
     *
     * 2. View element to model attribute:
     *
     *		BuildViewConverterFor( dispatcher ).fromElement( 'b' ).fromElement( 'strong' ).toAttribute( 'bold', 'true' );
     *
     * 3. View attribute to model attribute:
     *
     *		BuildViewConverterFor( dispatcher ).fromAttribute( 'style', { 'font-weight': 'bold' } ).toAttribute( 'bold', 'true' );
     *		BuildViewConverterFor( dispatcher )
     *			.fromAttribute( 'class' )
     *			.toAttribute( ( viewElement ) => ( { class: viewElement.getAttribute( 'class' ) } ) );
     *
     * 4. View elements and attributes to model attribute:
     *
     *		BuildViewConverterFor( dispatcher )
     *			.fromElement( 'b' ).fromElement( 'strong' ).fromAttribute( 'style', { 'font-weight': 'bold' } )
     *			.toAttribute( 'bold', 'true' );
     *
     * 5. View {@link engine.view.Matcher view element matcher instance} or {@link engine.view.Matcher#add matcher pattern}
     * to model element or attribute:
     *
     *		const matcher = new ViewMatcher();
     *		matcher.add( 'div', { class: 'quote' } );
     *		BuildViewConverterFor( dispatcher ).from( matcher ).toElement( 'quote' );
     *
     *		BuildViewConverterFor( dispatcher ).from( { name: 'span', class: 'bold' } ).toAttribute( 'bold', 'true' );
     *
     * Note, that converters built using `ViewConverterBuilder` automatically check {@link engine.model.Schema schema}
     * if created model structure is valid. If given conversion would be invalid according to schema, it is ignored.
     *
     * It is possible to provide creator functions as parameters for {@link engine.conversion.ViewConverterBuilder#toElement}
     * and {@link engine.conversion.ViewConverterBuilder#toAttribute} methods. See their descriptions to learn more.
     *
     * By default, converter will {@link engine.conversion.ViewConsumable#consume consume} every value specified in
     * given `from...` query, i.e. `.from( { name: 'span', class: 'bold' } )` will make converter consume both `span` name
     * and `bold` class. It is possible to change this behavior using {@link engine.conversion.ViewConverterBuilder#consuming consuming}
     * modifier. The modifier alters the last `fromXXX` query used before it. To learn more about consuming values,
     * see {@link engine.conversion.ViewConsumable}.
     *
     * It is also possible to {@link engine.conversion.ViewConverterBuilder#withPriority change default priority}
     * of created converters to decide which converter should be fired earlier and which later. This is useful if you provide
     * a general converter but want to provide different converter for a specific-case (i.e. given view element is converted
     * always to given model element, but if it has given class it is converter to other model element). For this,
     * use {@link engine.conversion.ViewConverterBuilder#withPriority withPriority} modifier. The modifier alters
     * the last `from...` query used before it.
     *
     * Note that `to...` methods are "terminators", which means that should be the last one used in building converter.
     *
     * You can use {@link engine.conversion.ModelConverterBuilder} to create "opposite" converters - from model to view.
     *
     * @memberOf engine.conversion
     */

    var ViewConverterBuilder = function () {
    	/**
      * Creates `ViewConverterBuilder` with given `dispatchers` registered to it.
      *
      * @param {Array.<engine.conversion.ViewConversionDispatcher>} dispatchers Dispatchers to which converters will
      * be attached.
      */

    	function ViewConverterBuilder(dispatchers) {
    		classCallCheck(this, ViewConverterBuilder);

    		/**
       * Dispatchers to which converters will be attached.
       *
       * @type {Array.<engine.conversion.ViewConversionDispatcher>}
       * @private
       */
    		this._dispatchers = dispatchers;

    		/**
       * Stores "from" queries.
       *
       * @type {Array}
       * @private
       */
    		this._from = [];
    	}

    	/**
      * Registers what view element should be converted.
      *
      *		BuildViewConverterFor( dispatcher ).fromElement( 'p' ).toElement( 'paragraph' );
      *
      * @chainable
      * @param {String} elementName View element name.
      * @returns {engine.conversion.ViewConverterBuilder}
      */


    	createClass(ViewConverterBuilder, [{
    		key: 'fromElement',
    		value: function fromElement(elementName) {
    			return this.from({ name: elementName });
    		}

    		/**
       * Registers what view attribute should be converted.
       *
       *		BuildViewConverterFor( dispatcher ).fromAttribute( 'style', { 'font-weight': 'bold' } ).toAttribute( 'bold', 'true' );
       *
       * @chainable
       * @param {String|RegExp} key View attribute key.
       * @param {String|RegExp} [value] View attribute value.
       * @returns {engine.conversion.ViewConverterBuilder}
       */

    	}, {
    		key: 'fromAttribute',
    		value: function fromAttribute(key) {
    			var value = arguments.length <= 1 || arguments[1] === undefined ? /.*/ : arguments[1];

    			var pattern = {};
    			pattern[key] = value;

    			return this.from(pattern);
    		}

    		/**
       * Registers what view pattern should be converted. The method accepts either {@link engine.view.Matcher view matcher}
       * or view matcher pattern.
       *
       *		const matcher = new ViewMatcher();
       *		matcher.add( 'div', { class: 'quote' } );
       *		BuildViewConverterFor( dispatcher ).from( matcher ).toElement( 'quote' );
       *
       *		BuildViewConverterFor( dispatcher ).from( { name: 'span', class: 'bold' } ).toAttribute( 'bold', 'true' );
       *
       * @chainable
       * @param {Object|engine.view.Matcher} matcher View matcher or view matcher pattern.
       * @returns {engine.conversion.ViewConverterBuilder}
       */

    	}, {
    		key: 'from',
    		value: function from(matcher) {
    			if (!(matcher instanceof Matcher)) {
    				matcher = new Matcher(matcher);
    			}

    			this._from.push({
    				matcher: matcher,
    				consume: false,
    				priority: null
    			});

    			return this;
    		}

    		/**
       * Modifies which consumable values will be {@link engine.conversion.ViewConsumable#consume consumed} by built converter.
       * It modifies the last `from...` query. Can be used after each `from...` query in given chain. Useful for providing
       * more specific matches.
       *
       *		// This converter will only handle class bold conversion (to proper attribute) but span element
       *		// conversion will have to be done in separate converter.
       *		// Without consuming modifier, the converter would consume both class and name, so a converter for
       *		// span element would not be fired.
       *		BuildViewConverterFor( dispatcher )
       *			.from( { name: 'span', class: 'bold' } ).consuming( { class: 'bold' } )
       *			.toAttribute( 'bold', 'true' } );
       *
       *		BuildViewConverterFor( dispatcher )
       *			.fromElement( 'img' ).consuming( { name: true, attributes: [ 'src', 'title' ] } )
       *			.toElement( ( viewElement ) => new ModelElement( 'image', { src: viewElement.getAttribute( 'src' ),
       *																		title: viewElement.getAttribute( 'title' ) } );
       *
       * **Note:** All and only values from passed object has to be consumable on converted view element. This means that
       * using `consuming` method, you can either make looser conversion conditions (like in first example) or tighter
       * conversion conditions (like in second example). So, the view element, to be converter, has to match query of
       * `from...` method and then have to have enough consumable values to consume.
       *
       * @see engine.conversion.ViewConsumable
       * @chainable
       * @param {Object} consume Values to consume.
       * @returns {engine.conversion.ViewConverterBuilder}
       */

    	}, {
    		key: 'consuming',
    		value: function consuming(consume) {
    			var lastFrom = this._from[this._from.length - 1];
    			lastFrom.consume = consume;

    			return this;
    		}

    		/**
       * Changes default priority for built converter. It modifies the last `from...` query. Can be used after each
       * `from...` query in given chain. Useful for overwriting converters. The lower the number, the earlier converter will be fired.
       *
       *		BuildViewConverterFor( dispatcher ).fromElement( 'p' ).toElement( 'paragraph' );
       *		// Register converter with proper priority, otherwise "p" element would get consumed by first
       *		// converter and the second converter would not be fired.
       *		BuildViewConverterFor( dispatcher )
       *			.from( { name: 'p', class: 'custom' } ).withPriority( 9 )
       *			.toElement( 'customParagraph' );
       *
       * **Note:** `ViewConverterBuilder` takes care so all `toElement` conversions takes place before all `toAttribute`
       * conversions. This is done by setting default `toElement` priority to `10` and `toAttribute` priority to `1000`.
       * It is recommended to set converter priority for `toElement` conversions below `500` and `toAttribute` priority
       * above `500`. It is important that model elements are created before attributes, otherwise attributes would
       * not be applied or other errors may occur.
       *
       * @chainable
       * @param {Number} priority Converter priority.
       * @returns {engine.conversion.ViewConverterBuilder}
       */

    	}, {
    		key: 'withPriority',
    		value: function withPriority(priority) {
    			var lastFrom = this._from[this._from.length - 1];
    			lastFrom.priority = priority;

    			return this;
    		}

    		/**
       * Registers what model element will be created by converter.
       *
       * Method accepts two ways of providing what kind of model element will be created. You can pass model element
       * name as a `string` or a function that will return model element instance. If you provide creator function,
       * it will be passed converted view element as first and only parameter.
       *
       *		BuildViewConverterFor( dispatcher ).fromElement( 'p' ).toElement( 'paragraph' );
       *		BuildViewConverterFor( dispatcher )
       *			.fromElement( 'img' )
       *			.toElement( ( viewElement ) => new ModelElement( 'image', { src: viewElement.getAttribute( 'src' ) } );
       *
       * @param {String|Function} element Model element name or model element creator function.
       */

    	}, {
    		key: 'toElement',
    		value: function toElement(element) {
    			var eventCallbackGen = function eventCallbackGen(from) {
    				return function (evt, data, consumable, conversionApi) {
    					// There is one callback for all patterns in the matcher.
    					// This will be usually just one pattern but we support matchers with many patterns too.
    					var matchAll = from.matcher.matchAll(data.input);

    					// If there is no match, this callback should not do anything.
    					if (!matchAll) {
    						return;
    					}

    					// Now, for every match between matcher and actual element, we will try to consume the match.
    					var _iteratorNormalCompletion = true;
    					var _didIteratorError = false;
    					var _iteratorError = undefined;

    					try {
    						for (var _iterator = matchAll[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    							var match = _step.value;

    							// Create model element basing on creator function or element name.
    							var modelElement = element instanceof Function ? element(data.input) : new Element(element);

    							// Check whether generated structure is okay with `Schema`.
    							// TODO: Make it more sane after .getAttributeKeys() is available for ModelElement.
    							var keys = Array.from(modelElement.getAttributes()).map(function (attribute) {
    								return attribute[0];
    							});

    							if (!conversionApi.schema.check({ name: modelElement.name, attributes: keys, inside: data.context })) {
    								continue;
    							}

    							// Try to consume appropriate values from consumable values list.
    							if (!consumable.consume(data.input, from.consume || match.match)) {
    								continue;
    							}

    							// If everything is fine, we are ready to start the conversion.
    							// Add newly created `modelElement` to the parents stack.
    							data.context.push(modelElement);

    							// Convert children of converted view element and append them to `modelElement`.
    							modelElement.appendChildren(conversionApi.convertChildren(data.input, consumable, data));

    							// Remove created `modelElement` from the parents stack.
    							data.context.pop();

    							// Add `modelElement` as a result.
    							data.output = modelElement;

    							// Prevent multiple conversion if there are other correct matches.
    							break;
    						}
    					} catch (err) {
    						_didIteratorError = true;
    						_iteratorError = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion && _iterator.return) {
    								_iterator.return();
    							}
    						} finally {
    							if (_didIteratorError) {
    								throw _iteratorError;
    							}
    						}
    					}
    				};
    			};

    			this._setCallback(eventCallbackGen, 10);
    		}

    		/**
       * Registers what model attribute will be created by converter.
       *
       * Method accepts two ways of providing what kind of model attribute will be created. You can either pass two strings
       * representing attribute key and attribute value or a function that returns an object with `key` and `value` properties.
       * If you provide creator function, it will be passed converted view element as first and only parameter.
       *
       *		BuildViewConverterFor( dispatcher ).fromAttribute( 'style', { 'font-weight': 'bold' } ).toAttribute( 'bold', 'true' );
       *		BuildViewConverterFor( dispatcher )
       *			.fromAttribute( 'class' )
       *			.toAttribute( ( viewElement ) => ( { key: 'class', value: viewElement.getAttribute( 'class' ) } ) );
       *
       * @param {String|Function} keyOrCreator Attribute key or a creator function.
       * @param {String} [value] Attribute value. Required if `keyOrCreator` is a `string`. Ignored otherwise.
       */

    	}, {
    		key: 'toAttribute',
    		value: function toAttribute(keyOrCreator, value) {
    			var eventCallbackGen = function eventCallbackGen(from) {
    				return function (evt, data, consumable, conversionApi) {
    					// There is one callback for all patterns in the matcher.
    					// This will be usually just one pattern but we support matchers with many patterns too.
    					var matchAll = from.matcher.matchAll(data.input);

    					// If there is no match, this callback should not do anything.
    					if (!matchAll) {
    						return;
    					}

    					// Now, for every match between matcher and actual element, we will try to consume the match.
    					var _iteratorNormalCompletion2 = true;
    					var _didIteratorError2 = false;
    					var _iteratorError2 = undefined;

    					try {
    						for (var _iterator2 = matchAll[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    							var match = _step2.value;

    							// Try to consume appropriate values from consumable values list.
    							if (!consumable.consume(data.input, from.consume || match.match)) {
    								continue;
    							}

    							// Since we are converting to attribute we need an output on which we will set the attribute.
    							// If the output is not created yet, we will create it.
    							if (!data.output) {
    								data.output = conversionApi.convertChildren(data.input, consumable, data);
    							}

    							// Use attribute creator function, if provided.
    							var attribute = keyOrCreator instanceof Function ? keyOrCreator(data.input) : { key: keyOrCreator, value: value };

    							// Set attribute on current `output`. `Schema` is checked inside this helper function.
    							setAttributeOn(data.output, attribute, data, conversionApi);

    							// Prevent multiple conversion if there are other correct matches.
    							break;
    						}
    					} catch (err) {
    						_didIteratorError2 = true;
    						_iteratorError2 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion2 && _iterator2.return) {
    								_iterator2.return();
    							}
    						} finally {
    							if (_didIteratorError2) {
    								throw _iteratorError2;
    							}
    						}
    					}
    				};
    			};

    			this._setCallback(eventCallbackGen, 1000);
    		}

    		/**
       * Helper function that uses given callback generator to created callback function and sets it on registered dispatchers.
       *
       * @param eventCallbackGen
       * @param defaultPriority
       * @private
       */

    	}, {
    		key: '_setCallback',
    		value: function _setCallback(eventCallbackGen, defaultPriority) {
    			// We will add separate event callback for each registered `from` entry.
    			var _iteratorNormalCompletion3 = true;
    			var _didIteratorError3 = false;
    			var _iteratorError3 = undefined;

    			try {
    				for (var _iterator3 = this._from[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
    					var from = _step3.value;

    					// We have to figure out event name basing on matcher's patterns.
    					// If there is exactly one pattern and it has `name` property we will used that name.
    					var matcherElementName = from.matcher.getElementName();
    					var eventName = matcherElementName ? 'element:' + matcherElementName : 'element';
    					var eventCallback = eventCallbackGen(from);

    					var priority = from.priority === null ? defaultPriority : from.priority;

    					// Add event to each registered dispatcher.
    					var _iteratorNormalCompletion4 = true;
    					var _didIteratorError4 = false;
    					var _iteratorError4 = undefined;

    					try {
    						for (var _iterator4 = this._dispatchers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
    							var dispatcher = _step4.value;

    							dispatcher.on(eventName, eventCallback, null, priority);
    						}
    					} catch (err) {
    						_didIteratorError4 = true;
    						_iteratorError4 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion4 && _iterator4.return) {
    								_iterator4.return();
    							}
    						} finally {
    							if (_didIteratorError4) {
    								throw _iteratorError4;
    							}
    						}
    					}
    				}
    			} catch (err) {
    				_didIteratorError3 = true;
    				_iteratorError3 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion3 && _iterator3.return) {
    						_iterator3.return();
    					}
    				} finally {
    					if (_didIteratorError3) {
    						throw _iteratorError3;
    					}
    				}
    			}
    		}
    	}]);
    	return ViewConverterBuilder;
    }();

    // Helper function that sets given attributes on given `engine.model.Item` or `engine.model.DocumentFragment`.


    function setAttributeOn(toChange, attribute, data, conversionApi) {
    	if (isIterable(toChange)) {
    		var _iteratorNormalCompletion5 = true;
    		var _didIteratorError5 = false;
    		var _iteratorError5 = undefined;

    		try {
    			for (var _iterator5 = toChange[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
    				var node = _step5.value;

    				setAttributeOn(node, attribute, data, conversionApi);
    			}
    		} catch (err) {
    			_didIteratorError5 = true;
    			_iteratorError5 = err;
    		} finally {
    			try {
    				if (!_iteratorNormalCompletion5 && _iterator5.return) {
    					_iterator5.return();
    				}
    			} finally {
    				if (_didIteratorError5) {
    					throw _iteratorError5;
    				}
    			}
    		}

    		return;
    	}

    	// TODO: Make it more sane after .getAttributeKeys() is available for ModelElement.
    	var keys = Array.from(toChange.getAttributes()).map(function (attribute) {
    		return attribute[0];
    	}).concat(attribute.key);

    	var schemaQuery = {
    		name: toChange.name || '$text',
    		attributes: keys,
    		inside: data.context
    	};

    	if (conversionApi.schema.check(schemaQuery)) {
    		toChange.setAttribute(attribute.key, attribute.value);
    	}
    }

    /**
     * Entry point for view-to-model converters builder. This chainable API makes it easy to create basic, most common
     * view-to-model converters and attach them to provided dispatchers. The method returns an instance of
     * {@link engine.conversion.ViewConverterBuilder}.
     *
     * @external engine.conversion.BuildViewConverterFor
     * @memberOf engine.conversion
     * @param {...engine.conversion.ViewConversionDispatcher} dispatchers One or more dispatchers to which
     * the built converter will be attached.
     */
    function BuildViewConverterFor() {
    	for (var _len = arguments.length, dispatchers = Array(_len), _key = 0; _key < _len; _key++) {
    		dispatchers[_key] = arguments[_key];
    	}

    	return new ViewConverterBuilder(dispatchers);
    }

    /**
     * An extension of basic {@link ckeditor5.command.Command} class, which provides utilities for a command that sets a single
     * attribute on a text or element with value `true`. AttributeCommand uses {@link engine.model.Document#selection} to
     * decide which nodes (if any) should be changed, and applies or removes attributes from them.
     * See {@link engine.view.Converter#execute} for more.
     *
     * The command checks {@link engine.model.Document#schema} to decide if it should be enabled.
     * See {@link engine.view.Converter#checkSchema} for more.
     *
     * @memberOf ckeditor5.command
     */

    var AttributeCommand = function (_Command) {
    	inherits(AttributeCommand, _Command);

    	/**
      * @see ckeditor5.command.Command
      * @param {ckeditor5.Editor} editor
      * @param {String} attributeKey Attribute that will be set by the command.
      */

    	function AttributeCommand(editor, attributeKey) {
    		classCallCheck(this, AttributeCommand);


    		/**
       * Attribute that will be set by the command.
       *
       * @member {String} ckeditor5.command.AttributeCommand#attributeKey
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(AttributeCommand).call(this, editor));

    		_this.attributeKey = attributeKey;

    		/**
       * Flag indicating whether command is active. For collapsed selection it means that typed characters will have
       * the command's attribute set. For range selection it means that all nodes inside have the attribute applied.
       *
       * @observable
       * @member {Boolean} ckeditor5.command.AttributeCommand#value
       */
    		_this.set('value', false);

    		_this.listenTo(_this.editor.document.selection, 'change:attribute', function () {
    			_this.value = _this.editor.document.selection.hasAttribute(_this.attributeKey);
    		});
    		return _this;
    	}

    	/**
      * Checks {@link engine.model.Document#schema} to decide if the command should be enabled:
      * * if selection is on range, the command is enabled if any of nodes in that range can have bold,
      * * if selection is collapsed, the command is enabled if text with bold is allowed in that node.
      *
      * @private
      * @returns {Boolean}
      */


    	createClass(AttributeCommand, [{
    		key: '_checkEnabled',
    		value: function _checkEnabled() {
    			var selection = this.editor.document.selection;
    			var schema = this.editor.document.schema;

    			if (selection.isCollapsed) {
    				// Check whether schema allows for a test with `attributeKey` in caret position.
    				return schema.check({ name: '$text', inside: selection.getFirstPosition(), attributes: this.attributeKey });
    			} else {
    				var ranges = selection.getRanges();

    				// For all ranges, check nodes in them until you find a node that is allowed to have `attributeKey` attribute.
    				var _iteratorNormalCompletion = true;
    				var _didIteratorError = false;
    				var _iteratorError = undefined;

    				try {
    					for (var _iterator = ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    						var range = _step.value;

    						var walker = new TreeWalker({ boundaries: range, mergeCharacters: true });
    						var last = walker.position;
    						var step = walker.next();

    						// Walk the range.
    						while (!step.done) {
    							// If returned item does not have name property, it is a model.TextFragment.
    							var name = step.value.item.name || '$text';

    							if (schema.check({ name: name, inside: last, attributes: this.attributeKey })) {
    								// If we found a node that is allowed to have the attribute, return true.
    								return true;
    							}

    							last = walker.position;
    							step = walker.next();
    						}
    					}
    				} catch (err) {
    					_didIteratorError = true;
    					_iteratorError = err;
    				} finally {
    					try {
    						if (!_iteratorNormalCompletion && _iterator.return) {
    							_iterator.return();
    						}
    					} finally {
    						if (_didIteratorError) {
    							throw _iteratorError;
    						}
    					}
    				}
    			}

    			// If we haven't found such node, return false.
    			return false;
    		}

    		/**
       * Executes the command: adds or removes attributes to nodes or selection.
       *
       * If the command is active (`value == true`), it will remove attributes. Otherwise, it will set attributes.
       *
       * The execution result differs, depending on the {@link engine.model.Document#selection}:
       * * if selection is on a range, the command applies the attribute on all nodes in that ranges
       * (if they are allowed to have this attribute by the{@link engine.model.Schema schema}),
       * * if selection is collapsed in non-empty node, the command applies attribute to the {@link engine.model.Document#selection}
       * itself (note that typed characters copy attributes from selection),
       * * if selection is collapsed in empty node, the command applies attribute to the parent node of selection (note
       * that selection inherits all attributes from a node if it is in empty node).
       *
       * If the command is disabled (`isEnabled == false`) when it is executed, nothing will happen.
       *
       * @private
       * @param {Boolean} [forceValue] If set it will force command behavior. If `true`, command will apply attribute,
       * otherwise command will remove attribute. If not set, command will look for it's current value to decide what it should do.
       */

    	}, {
    		key: '_doExecute',
    		value: function _doExecute(forceValue) {
    			var _this2 = this;

    			var document = this.editor.document;
    			var selection = document.selection;
    			var value = forceValue === undefined ? !this.value : forceValue;

    			if (selection.isCollapsed) {
    				if (value) {
    					selection.setAttribute(this.attributeKey, true);
    				} else {
    					selection.removeAttribute(this.attributeKey);
    				}
    			} else {
    				// If selection has non-collapsed ranges, we change attribute on nodes inside those ranges.
    				document.enqueueChanges(function () {
    					var ranges = _this2._getSchemaValidRanges(selection.getRanges());

    					// Keep it as one undo step.
    					var batch = document.batch();

    					var _iteratorNormalCompletion2 = true;
    					var _didIteratorError2 = false;
    					var _iteratorError2 = undefined;

    					try {
    						for (var _iterator2 = ranges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    							var range = _step2.value;

    							if (value) {
    								batch.setAttr(_this2.attributeKey, value, range);
    							} else {
    								batch.removeAttr(_this2.attributeKey, range);
    							}
    						}
    					} catch (err) {
    						_didIteratorError2 = true;
    						_iteratorError2 = err;
    					} finally {
    						try {
    							if (!_iteratorNormalCompletion2 && _iterator2.return) {
    								_iterator2.return();
    							}
    						} finally {
    							if (_didIteratorError2) {
    								throw _iteratorError2;
    							}
    						}
    					}
    				});
    			}
    		}

    		/**
       * Walks through given array of ranges and removes parts of them that are not allowed by schema to have the
       * attribute set. This is done by breaking a range in two and omitting the not allowed part.
       *
       * @private
       * @param {Array.<engine.model.Range>} ranges Ranges to be validated.
       * @returns {Array.<engine.model.Range>} Ranges without invalid parts.
       */

    	}, {
    		key: '_getSchemaValidRanges',
    		value: function _getSchemaValidRanges(ranges) {
    			var validRanges = [];

    			var _iteratorNormalCompletion3 = true;
    			var _didIteratorError3 = false;
    			var _iteratorError3 = undefined;

    			try {
    				for (var _iterator3 = ranges[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
    					var range = _step3.value;

    					var walker = new TreeWalker({ boundaries: range, mergeCharacters: true });
    					var step = walker.next();

    					var last = range.start;
    					var from = range.start;
    					var to = range.end;

    					while (!step.done) {
    						var name = step.value.item.name || '$text';

    						if (!this.editor.document.schema.check({ name: name, inside: last, attributes: this.attributeKey })) {
    							if (!from.isEqual(last)) {
    								validRanges.push(new Range$1(from, last));
    							}

    							from = walker.position;
    						}

    						last = walker.position;
    						step = walker.next();
    					}

    					if (from && !from.isEqual(to)) {
    						validRanges.push(new Range$1(from, to));
    					}
    				}
    			} catch (err) {
    				_didIteratorError3 = true;
    				_iteratorError3 = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion3 && _iterator3.return) {
    						_iterator3.return();
    					}
    				} finally {
    					if (_didIteratorError3) {
    						throw _iteratorError3;
    					}
    				}
    			}

    			return validRanges;
    		}
    	}]);
    	return AttributeCommand;
    }(Command);

    var BOLD = 'bold';

    var BoldEngine = function (_Feature) {
    	inherits(BoldEngine, _Feature);

    	function BoldEngine() {
    		classCallCheck(this, BoldEngine);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(BoldEngine).apply(this, arguments));
    	}

    	createClass(BoldEngine, [{
    		key: 'init',
    		value: function init() {
    			var editor = this.editor;
    			var data = editor.data;
    			var editing = editor.editing;

    			// Allow bold attribute on all inline nodes.
    			editor.document.schema.allow({ name: '$inline', attributes: [BOLD] });

    			// Build converter from model to view for data and editing pipelines.
    			BuildModelConverterFor(data.modelToView, editing.modelToView).fromAttribute(BOLD).toElement('strong');

    			// Build converter from view to model for data pipeline.
    			BuildViewConverterFor(data.viewToModel).fromElement('strong').fromElement('b').fromAttribute('style', { 'font-weight': 'bold' }).toAttribute(BOLD, true);

    			// Create bold command.
    			editor.commands.set(BOLD, new AttributeCommand(editor, BOLD));
    		}
    	}]);
    	return BoldEngine;
    }(Feature);

    var Bold = function (_Feature) {
    	inherits(Bold, _Feature);

    	function Bold() {
    		classCallCheck(this, Bold);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(Bold).apply(this, arguments));
    	}

    	createClass(Bold, [{
    		key: 'init',
    		value: function init() {
    			var editor = this.editor;
    			var t = editor.t;
    			var command = editor.commands.get('bold');

    			// Create button model.
    			var buttonModel = new Model({
    				isEnabled: true,
    				isOn: false,
    				label: t('Bold'),
    				noText: true,
    				icon: 'bold',
    				iconAlign: 'LEFT'
    			});

    			// Bind button model to command.
    			buttonModel.bind('isOn', 'isEnabled').to(command, 'value', 'isEnabled');

    			// Execute command.
    			this.listenTo(buttonModel, 'execute', function () {
    				return editor.execute('bold');
    			});

    			// Add bold button to feature components.
    			editor.ui.featureComponents.add('bold', Button, ButtonView, buttonModel);

    			// Set the CTRL+B keystroke.
    			editor.keystrokes.set('CTRL+B', 'bold');
    		}
    	}], [{
    		key: 'requires',
    		get: function get() {
    			return [BoldEngine];
    		}
    	}]);
    	return Bold;
    }(Feature);

    var ITALIC = 'italic';

    var ItalicEngine = function (_Feature) {
    	inherits(ItalicEngine, _Feature);

    	function ItalicEngine() {
    		classCallCheck(this, ItalicEngine);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(ItalicEngine).apply(this, arguments));
    	}

    	createClass(ItalicEngine, [{
    		key: 'init',
    		value: function init() {
    			var editor = this.editor;
    			var data = editor.data;
    			var editing = editor.editing;

    			// Allow italic attribute on all inline nodes.
    			editor.document.schema.allow({ name: '$inline', attributes: [ITALIC] });

    			// Build converter from model to view for data and editing pipelines.
    			BuildModelConverterFor(data.modelToView, editing.modelToView).fromAttribute(ITALIC).toElement('em');

    			// Build converter from view to model for data pipeline.
    			BuildViewConverterFor(data.viewToModel).fromElement('em').fromElement('i').fromAttribute('style', { 'font-style': 'italic' }).toAttribute(ITALIC, true);

    			// Create italic command.
    			editor.commands.set(ITALIC, new AttributeCommand(editor, ITALIC));
    		}
    	}]);
    	return ItalicEngine;
    }(Feature);

    var Italic = function (_Feature) {
    	inherits(Italic, _Feature);

    	function Italic() {
    		classCallCheck(this, Italic);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(Italic).apply(this, arguments));
    	}

    	createClass(Italic, [{
    		key: 'init',
    		value: function init() {
    			var editor = this.editor;
    			var t = editor.t;
    			var command = editor.commands.get('italic');

    			// Create button model.
    			var buttonModel = new Model({
    				isEnabled: true,
    				isOn: false,
    				label: t('Italic'),
    				noText: true,
    				icon: 'italic',
    				iconAlign: 'LEFT'
    			});

    			// Bind button model to command.
    			buttonModel.bind('isOn', 'isEnabled').to(command, 'value', 'isEnabled');

    			// Execute command.
    			this.listenTo(buttonModel, 'execute', function () {
    				return editor.execute('italic');
    			});

    			// Add bold button to feature components.
    			editor.ui.featureComponents.add('italic', Button, ButtonView, buttonModel);

    			// Set the CTRL+I keystroke.
    			editor.keystrokes.set('CTRL+I', 'italic');
    		}
    	}], [{
    		key: 'requires',
    		get: function get() {
    			return [ItalicEngine];
    		}
    	}]);
    	return Italic;
    }(Feature);

    /**
     * A paragraph feature for editor.
     * Introduces `<paragraph>` element in the model which renders as `<p>` in the DOM and data.
     *
     * @memberOf paragraph
     * @extends ckeditor5.Feature
     */

    var Paragraph = function (_Feature) {
    	inherits(Paragraph, _Feature);

    	function Paragraph() {
    		classCallCheck(this, Paragraph);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(Paragraph).apply(this, arguments));
    	}

    	createClass(Paragraph, [{
    		key: 'init',

    		/**
       * @inheritDoc
       */
    		value: function init() {
    			var editor = this.editor;
    			var data = editor.data;
    			var editing = editor.editing;

    			// Schema.
    			editor.document.schema.registerItem('paragraph', '$block');

    			// Build converter from model to view for data and editing pipelines.
    			BuildModelConverterFor(data.modelToView, editing.modelToView).fromElement('paragraph').toElement('p');

    			// Build converter from view to model for data pipeline.
    			BuildViewConverterFor(data.viewToModel).fromElement('p').toElement('paragraph');
    		}
    	}]);
    	return Paragraph;
    }(Feature);

    /**
     * Headings command. Used by the {@link headings.Headings headings feature}.
     *
     * @memberOf headings
     * @extends ckeditor5.command.Command
     */

    var HeadingsCommand = function (_Command) {
    	inherits(HeadingsCommand, _Command);

    	/**
      * Creates instance of the command.
      *
      * @param {ckeditor5.editor.Editor} editor Editor instance.
      * @param {Array.<headings.HeadingsFormat>} formats Headings formats to be used by command's instance.
      */

    	function HeadingsCommand(editor, formats) {
    		classCallCheck(this, HeadingsCommand);


    		/**
       * Headings formats used by this command.
       *
       * @readonly
       * @member {headings.HeadingsFormat} headings.HeadingsCommand#formats
       */

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(HeadingsCommand).call(this, editor));

    		_this.formats = formats;

    		/**
       * Currently selected headings format.
       *
       * @readonly
       * @observable
       * @member {headings.HeadingsFormat} headings.HeadingsCommand#value
       */
    		_this.set('value', _this.defaultFormat);

    		// Listen on selection change and set current command's format to format in current selection.
    		_this.listenTo(editor.document.selection, 'change', function () {
    			var position = editor.document.selection.getFirstPosition();
    			var block = findTopmostBlock(position);

    			if (block) {
    				var format = _this._getFormatById(block.name);

    				// TODO: What should happen if format is not found?
    				_this.value = format;
    			}
    		});
    		return _this;
    	}

    	/**
      * The default format.
      *
      * @type {headings.HeadingsFormat}
      */


    	createClass(HeadingsCommand, [{
    		key: '_doExecute',


    		/**
       * Executes the command if it is enabled.
       *
       * @param {String} [formatId] Identifier of the headings format that should be applied. It should be one of the
       * {@link headings.HeadingsFormat} provided to the command's constructor. If this parameter is not provided, value
       * from {@link headings.HeadingsCommand#defaultFormat defaultFormat} will be used.
       */
    		value: function _doExecute() {
    			var _this2 = this;

    			var formatId = arguments.length <= 0 || arguments[0] === undefined ? this.defaultFormat.id : arguments[0];

    			// TODO: What should happen if format is not found?
    			var doc = this.editor.document;
    			var selection = doc.selection;
    			var startPosition = selection.getFirstPosition();
    			var elements = [];
    			// Storing selection ranges and direction to fix selection after renaming. See ckeditor5-engine#367.
    			var ranges = [].concat(toConsumableArray(selection.getRanges()));
    			var isSelectionBackward = selection.isBackward;
    			// If current format is same as new format - toggle already applied format back to default one.
    			var shouldRemove = formatId === this.value.id;

    			// Collect elements to change format.
    			// This implementation may not be future proof but it's satisfactory at this stage.
    			if (selection.isCollapsed) {
    				var block = findTopmostBlock(startPosition);

    				if (block) {
    					elements.push(block);
    				}
    			} else {
    				var _iteratorNormalCompletion = true;
    				var _didIteratorError = false;
    				var _iteratorError = undefined;

    				try {
    					for (var _iterator = ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    						var range = _step.value;

    						var startBlock = findTopmostBlock(range.start);
    						var endBlock = findTopmostBlock(range.end, false);

    						elements.push(startBlock);

    						while (startBlock !== endBlock) {
    							startBlock = startBlock.nextSibling;
    							elements.push(startBlock);
    						}
    					}
    				} catch (err) {
    					_didIteratorError = true;
    					_iteratorError = err;
    				} finally {
    					try {
    						if (!_iteratorNormalCompletion && _iterator.return) {
    							_iterator.return();
    						}
    					} finally {
    						if (_didIteratorError) {
    							throw _iteratorError;
    						}
    					}
    				}
    			}

    			doc.enqueueChanges(function () {
    				var batch = doc.batch();

    				var _iteratorNormalCompletion2 = true;
    				var _didIteratorError2 = false;
    				var _iteratorError2 = undefined;

    				try {
    					for (var _iterator2 = elements[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
    						var element = _step2.value;

    						// When removing applied format.
    						if (shouldRemove) {
    							if (element.name === formatId) {
    								batch.rename(_this2.defaultFormat.id, element);
    							}
    						}
    						// When applying new format.
    						else {
    								batch.rename(formatId, element);
    							}
    					}

    					// If range's selection start/end is placed directly in renamed block - we need to restore it's position
    					// after renaming, because renaming puts new element there.
    				} catch (err) {
    					_didIteratorError2 = true;
    					_iteratorError2 = err;
    				} finally {
    					try {
    						if (!_iteratorNormalCompletion2 && _iterator2.return) {
    							_iterator2.return();
    						}
    					} finally {
    						if (_didIteratorError2) {
    							throw _iteratorError2;
    						}
    					}
    				}

    				doc.selection.setRanges(ranges, isSelectionBackward);
    			});
    		}

    		/**
       * Returns format by given id.
       *
       * @private
       * @param {String} id
       * @returns {headings.HeadingsFormat}
       */

    	}, {
    		key: '_getFormatById',
    		value: function _getFormatById(id) {
    			return this.formats.find(function (item) {
    				return item.id === id;
    			});
    		}
    	}, {
    		key: 'defaultFormat',
    		get: function get() {
    			// See https://github.com/ckeditor/ckeditor5/issues/98.
    			return this._getFormatById('paragraph');
    		}
    	}]);
    	return HeadingsCommand;
    }(Command);

    function findTopmostBlock(position) {
    	var nodeAfter = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

    	var parent = position.parent;

    	// If position is placed inside root - get element after/before it.
    	if (parent instanceof RootElement) {
    		return nodeAfter ? position.nodeAfter : position.nodeBefore;
    	}

    	while (!(parent.parent instanceof RootElement)) {
    		parent = parent.parent;
    	}

    	return parent;
    }

    var formats = [{ id: 'paragraph', viewElement: 'p', label: 'Paragraph' }, { id: 'heading1', viewElement: 'h2', label: 'Heading 1' }, { id: 'heading2', viewElement: 'h3', label: 'Heading 2' }, { id: 'heading3', viewElement: 'h4', label: 'Heading 3' }];

    /**
     * The headings feature. Handles switching between block formats - different headings and paragraph.
     * This class represents the engine part of the Headings feature.
     *
     * @memberOf headings
     * @extends ckeditor5.Feature
     */

    var HeadingsEngine = function (_Feature) {
    	inherits(HeadingsEngine, _Feature);

    	function HeadingsEngine() {
    		classCallCheck(this, HeadingsEngine);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(HeadingsEngine).apply(this, arguments));
    	}

    	createClass(HeadingsEngine, [{
    		key: 'init',


    		/**
       * @inheritDoc
       */
    		value: function init() {
    			var editor = this.editor;
    			var data = editor.data;
    			var editing = editor.editing;

    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = formats[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var format = _step.value;

    					// Skip paragraph - it is defined in required Paragraph feature.
    					if (format.id !== 'paragraph') {
    						// Schema.
    						editor.document.schema.registerItem(format.id, '$block');

    						// Build converter from model to view for data and editing pipelines.
    						BuildModelConverterFor(data.modelToView, editing.modelToView).fromElement(format.id).toElement(format.viewElement);

    						// Build converter from view to model for data pipeline.
    						BuildViewConverterFor(data.viewToModel).fromElement(format.viewElement).toElement(format.id);
    					}
    				}

    				// Register command.
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}

    			var command = new HeadingsCommand(editor, formats);
    			editor.commands.set('headings', command);
    		}
    	}], [{
    		key: 'requires',

    		/**
       * @inheritDoc
       */
    		get: function get() {
    			return [Paragraph];
    		}
    	}]);
    	return HeadingsEngine;
    }(Feature);

    /**
     * The dropdown button view class.
     *
     * See {@link ui.dropdown.Dropdown}, {@link ui.button.Button}, {@link ui.button.ButtonView}.
     *
     * @memberOf ui.dropdown
     * @extends ui.button.ButtonView
     */

    var DropdownButtonView = function (_ButtonView) {
    	inherits(DropdownButtonView, _ButtonView);

    	/**
      * @inheritDoc
      */

    	function DropdownButtonView() {
    		classCallCheck(this, DropdownButtonView);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(DropdownButtonView).call(this));

    		Template.extend(_this.template, {
    			attributes: {
    				class: 'ck-dropdown__button'
    			}
    		});
    		return _this;
    	}

    	return DropdownButtonView;
    }(ButtonView);

    /**
     * The dropdown panel controller class.
     *
     *		const model = new Model( {
     *			isVisible: false,
     *		} );
     *
     *		// An instance of DropdownPanelView.
     *		new DropdownPanel( model, new DropdownPanelView() );
     *
     * See {@link ui.dropdown.DropdownPanelView}.
     *
     * @memberOf ui.dropdown
     * @extends ui.Controller
     */

    var DropdownPanel = function (_Controller) {
      inherits(DropdownPanel, _Controller);

      /**
       * Creates an instance of {@link ui.dropdown.DropdownPanel} class.
       *
       * @param {ui.dropdown.DropdownPanel} model Model of this dropdown panel.
       * @param {ui.View} view View of this dropdown panel.
       */

      function DropdownPanel(model, view) {
        classCallCheck(this, DropdownPanel);

        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(DropdownPanel).call(this, model, view));

        view.model.bind('isVisible').to(model);

        _this.collections.add(new ControllerCollection('content'));
        return _this;
      }

      return DropdownPanel;
    }(Controller);

    /**
     * The dropdown panel view class.
     *
     * See {@link ui.dropdown.DropdownPanel}.
     *
     * @memberOf ui.dropdown
     * @extends ui.View
     */

    var DropdownPanelView = function (_View) {
    	inherits(DropdownPanelView, _View);

    	/**
      * @inheritDoc
      */

    	function DropdownPanelView() {
    		classCallCheck(this, DropdownPanelView);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(DropdownPanelView).call(this));

    		var bind = _this.bind;

    		_this.template = new Template({
    			tag: 'div',

    			attributes: {
    				class: ['ck-reset', 'ck-dropdown__panel', bind.if('isVisible', 'ck-dropdown__panel-visible')]
    			}
    		});

    		_this.register('content', function (el) {
    			return el;
    		});

    		/**
       * Model of this dropdown panel view.
       *
       * @member {ui.dropdown.DropdownPanelViewModel} ui.dropdown.DropdownPanelView#model
       */
    		return _this;
    	}

    	return DropdownPanelView;
    }(View);

    /**
     * The dropdown controller class.
     *
     *		const model = new Model( {
     *			label: 'Dropdown',
     *			isEnabled: true,
     *			inOn: false
     *		} );
     *
     *		// An instance of Dropdown.
     *		new Dropdown( model, new DropdownView() );
     *
     * See {@link ui.dropdown.DropdownView}.
     *
     * @memberOf ui.dropdown
     * @extends ui.Controller
     */

    var Dropdown = function (_Controller) {
    	inherits(Dropdown, _Controller);

    	/**
      * Creates an instance of {@link ui.dropdown.Dropdown} class.
      *
      * @param {ui.dropdown.DropdownModel} model Model of this dropdown.
      * @param {ui.View} view View of this dropdown.
      */

    	function Dropdown(model, view) {
    		classCallCheck(this, Dropdown);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(Dropdown).call(this, model, view));

    		_this.collections.add(new ControllerCollection('main'));

    		_this._createButton();
    		_this._createPanel();
    		return _this;
    	}

    	/**
      * Creates {@link ui.dropdown.Dropdown#button} of this dropdown.
      *
      * @protected
      */


    	createClass(Dropdown, [{
    		key: '_createButton',
    		value: function _createButton() {
    			var model = this.model;
    			var viewModel = this.view.model;
    			var buttonModel = new Model();

    			// Button needs a separate Model because otherwise it would fire #execute event
    			// on the model shared between multiple dropdowns (they would all open at the same time).
    			buttonModel.bind('label', 'isOn', 'isEnabled').to(model);

    			/**
        * Button of this dropdown.
        *
        * @readonly
        * @member {ui.button.Button} ui.dropdown.Dropdown#button
        */
    			this.add('main', this.button = new Button(buttonModel, new DropdownButtonView()));

    			// When ui.dropdown.Dropdown#button is clicked switch the open/closed state of the Dropdown.
    			this.listenTo(buttonModel, 'execute', function () {
    				return viewModel.isOpen = !viewModel.isOpen;
    			});
    		}

    		/**
       * Creates {@link ui.dropdown.Dropdown#panel} of this dropdown.
       *
       * @protected
       */

    	}, {
    		key: '_createPanel',
    		value: function _createPanel() {
    			var panelModel = new Model();

    			panelModel.bind('isVisible').to(this.view.model, 'isOpen');

    			/**
        * Panel of this dropdown.
        *
        * @readonly
        * @member {ui.dropdown.DropdownPanel} ui.dropdown.Dropdown#panel
        */
    			this.add('main', this.panel = new DropdownPanel(panelModel, new DropdownPanelView()));
    		}
    	}]);
    	return Dropdown;
    }(Controller);

    /**
     * The list item controller class.
     *
     * @memberOf ui.list
     * @extends ui.Controller
     */

    var ListItem = function (_Controller) {
      inherits(ListItem, _Controller);

      /**
       * Creates an instance of {@link ui.list.ListItem} class.
       *
       * @param {ui.list.ListItemModel} model Model of this list item.
       * @param {ui.View} view View of this list item.
       */

      function ListItem(model, view) {
        classCallCheck(this, ListItem);

        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ListItem).call(this, model, view));

        view.model.bind('label').to(model);

        if (model.style) {
          view.model.bind('style').to(model);
        }

        view.model.on('click', function () {
          return model.fire('execute');
        });
        return _this;
      }

      return ListItem;
    }(Controller);

    /**
     * The list item view class.
     *
     * See {@link ui.list.ListItem}.
     *
     * @memberOf ui.list
     * @extends ui.View
     */

    var ListItemView = function (_View) {
    	inherits(ListItemView, _View);

    	/**
      * @inheritDoc
      */

    	function ListItemView() {
    		classCallCheck(this, ListItemView);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ListItemView).call(this));

    		var bind = _this.bind;

    		_this.template = new Template({
    			tag: 'li',

    			attributes: {
    				class: ['ck-reset', 'ck-list__item'],
    				style: bind.to('style')
    			},

    			children: [{
    				text: bind.to('label')
    			}],

    			on: {
    				click: bind.to('click')
    			}
    		});

    		/**
       * Model of this list item view.
       *
       * @member {ui.list.ListItemViewModel} ui.list.ListItemView#model
       */
    		return _this;
    	}

    	return ListItemView;
    }(View);

    /**
     * The list controller class.
     *
     *		const itemsCollection = new Collection();
     *
     *		itemsCollection.add( new Model( { label: 'foo' } ) );
     *		itemsCollection.add( new Model( { label: 'bar' } ) );
     *
     *		const model = new Model( {
     *			items: itemsCollection
     *		} );
     *
     *		// An instance of List filled up with the `itemsCollection`.
     *		// Any change to `itemsCollection` will be reflected in DOM.
     *		new List( model, new ListView() );
     *
     * See {@link ui.list.ListView}, {@link ui.list.ListItem}.
     *
     * @memberOf ui.list
     * @extends ui.Controller
     */

    var List = function (_Controller) {
    	inherits(List, _Controller);

    	/**
      * Creates an instance of {@link ui.list.List} class.
      *
      * @param {ui.list.ListModel} model Model of this list.
      * @param {ui.View} view View of this list.
      */

    	function List(model, view) {
    		classCallCheck(this, List);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(List).call(this, model, view));

    		_this.collections.add(new ControllerCollection('list'));
    		return _this;
    	}

    	createClass(List, [{
    		key: 'init',
    		value: function init() {
    			var _this2 = this;

    			// Initially populate "list" controller collection with children from model.items.
    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = this.model.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var itemModel = _step.value;

    					this._addListItem(itemModel);
    				}

    				// Synchronize adding to model#items collection with "list" controller collection.
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}

    			this.model.items.on('add', function (evt, itemModel, index) {
    				_this2._addListItem(itemModel, index);
    			});

    			// Synchronize removal from model#items collection with "list" controller collection.
    			this.model.items.on('remove', function (evt, itemModel) {
    				_this2._removeListItem(itemModel);
    			});

    			return get(Object.getPrototypeOf(List.prototype), 'init', this).call(this);
    		}

    		/**
       * Adds an item to "list" collection and activates event bubbling
       * between item view and the list.
       *
       * @protected
       * @param {utils.Observable} itemModel
       * @param {Number} index
       */

    	}, {
    		key: '_addListItem',
    		value: function _addListItem(itemModel, index) {
    			var _this3 = this;

    			var listItemController = new ListItem(itemModel, new ListItemView());

    			// Save model#label in controller instance so it can be later
    			// retrieved from "list" collection easily by that model.
    			listItemController.id = itemModel.label;

    			// TODO: Some event delegation?
    			this.listenTo(itemModel, 'execute', function () {
    				_this3.model.fire('execute', itemModel);
    			});

    			this.add('list', listItemController, index);
    		}

    		/**
       * Removes an item from "list" collection and deactivates event bubbling
       * between item view and the list.
       *
       * @protected
       * @param {utils.Observable} itemModel
       */

    	}, {
    		key: '_removeListItem',
    		value: function _removeListItem(itemModel) {
    			this.stopListening(itemModel, 'execute');

    			this.remove('list', itemModel.label);
    		}
    	}]);
    	return List;
    }(Controller);

    /**
     * The list view class.
     *
     * See {@link ui.list.List}.
     *
     * @memberOf ui.list
     * @extends ui.View
     */

    var ListView = function (_View) {
    	inherits(ListView, _View);

    	/**
      * @inheritDoc
      */

    	function ListView() {
    		classCallCheck(this, ListView);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ListView).call(this));

    		_this.template = new Template({
    			tag: 'ul',

    			attributes: {
    				class: ['ck-reset', 'ck-list']
    			}
    		});

    		_this.register('list', function (el) {
    			return el;
    		});
    		return _this;
    	}

    	return ListView;
    }(View);

    /**
     * The list dropdown controller class. It represents a dropdown
     * with a {@link ui.list.List} component.
     *
     *		const model = new Model( {
     *			label: 'List Dropdown',
     *			isEnabled: true,
     *			isOn: false,
     *			content: {@link ui.dropdown.list.ListDropdownModel#content}
     *		} );
     *
     *		// An instance of Dropdown.
     *		new ListDropdown( model, new ListDropdownView() );
     *
     * See {@link ui.dropdown.list.ListDropdownView}.
     *
     * @memberOf ui.dropdown.list
     * @extends ui.dropdown.Dropdown
     */

    var ListDropdown = function (_Dropdown) {
      inherits(ListDropdown, _Dropdown);

      /**
       * Creates an instance of {@link ui.dropdown.list.ListDropdown} class.
       *
       * @param {ui.dropdown.list.ListDropdownModel} model Model of this list dropdown.
       * @param {ui.View} view View of this list dropdown.
       */

      function ListDropdown(model, view) {
        classCallCheck(this, ListDropdown);

        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ListDropdown).call(this, model, view));

        var listModel = _this.model.content;

        // Collapse the dropdown when an item in the panel is clicked.
        _this.listenTo(listModel, 'execute', function () {
          view.model.isOpen = false;
        });

        /**
         * List of this list dropdown.
         *
         * @readonly
         * @member {ui.list.List} ui.dropdown.list.ListDropdown#list
         */
        _this.list = new List(listModel, new ListView());

        _this.panel.add('content', _this.list);
        return _this;
      }

      return ListDropdown;
    }(Dropdown);

    /**
     * The dropdown view class.
     *
     * See {@link ui.dropdown.Dropdown}.
     *
     * @memberOf ui.dropdown
     * @extends ui.View
     */

    var DropdownView = function (_View) {
    	inherits(DropdownView, _View);

    	/**
      * @inheritDoc
      */

    	function DropdownView() {
    		classCallCheck(this, DropdownView);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(DropdownView).call(this));

    		_this.model.set('isOpen', false);

    		_this.template = new Template({
    			tag: 'div',

    			attributes: {
    				class: ['ck-dropdown']
    			}
    		});

    		_this.register('main', function (el) {
    			return el;
    		});

    		/**
       * Model of this dropdown view.
       *
       * @member {ui.dropdown.DropdownViewModel} ui.dropdown.DropdownView#model
       */
    		return _this;
    	}

    	return DropdownView;
    }(View);

    /**
     * The list dropdown view class.
     *
     * See {@link ui.dropdown.list.ListDropdown}.
     *
     * @memberOf ui.dropdown.list
     * @extends ui.dropdown.DropdownView
     */

    var ListDropdownView = function (_DropdownView) {
    	inherits(ListDropdownView, _DropdownView);

    	/**
      * @inheritDoc
      */

    	function ListDropdownView() {
    		classCallCheck(this, ListDropdownView);

    		var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ListDropdownView).call(this));

    		_this.listenTo(_this.model, 'change:isOpen', function (evt, name, value) {
    			if (value) {
    				// TODO: It will probably be focus/blur-based rather than click. It should be bound
    				// to focusmanager of some sort.
    				_this.listenTo(document, 'click', function (evtInfo, _ref) {
    					var domEvtTarget = _ref.target;

    					// Collapse the dropdown when the webpage outside of the component is clicked.
    					if (_this.element != domEvtTarget && !_this.element.contains(domEvtTarget)) {
    						_this.model.isOpen = false;
    					}
    				});
    			} else {
    				_this.stopListening(document);
    			}
    		});
    		return _this;
    	}

    	return ListDropdownView;
    }(DropdownView);

    /**
     * The headings feature. Introduces a "headings" drop-down and a command which allow switching paragraphs into headings.
     *
     * @memberOf headings
     * @extends ckeditor5.Feature
     */

    var Headings = function (_Feature) {
    	inherits(Headings, _Feature);

    	function Headings() {
    		classCallCheck(this, Headings);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(Headings).apply(this, arguments));
    	}

    	createClass(Headings, [{
    		key: 'init',


    		/**
       * @inheritDoc
       */
    		value: function init() {
    			var editor = this.editor;
    			var command = editor.commands.get('headings');
    			var formats = command.formats;
    			var collection = new Collection();

    			// Add formats to collection.
    			var _iteratorNormalCompletion = true;
    			var _didIteratorError = false;
    			var _iteratorError = undefined;

    			try {
    				for (var _iterator = formats[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    					var format = _step.value;

    					collection.add(new Model({
    						id: format.id,
    						label: format.label
    					}));
    				}

    				// Create item list model.
    			} catch (err) {
    				_didIteratorError = true;
    				_iteratorError = err;
    			} finally {
    				try {
    					if (!_iteratorNormalCompletion && _iterator.return) {
    						_iterator.return();
    					}
    				} finally {
    					if (_didIteratorError) {
    						throw _iteratorError;
    					}
    				}
    			}

    			var itemListModel = new Model({
    				items: collection
    			});

    			// Create dropdown model.
    			var dropdownModel = new Model({
    				isEnabled: true,
    				isOn: false,
    				label: 'Headings',
    				content: itemListModel
    			});

    			// Bind dropdown model to command.
    			dropdownModel.bind('isEnabled').to(command, 'isEnabled');
    			dropdownModel.bind('label').to(command, 'value', function (format) {
    				return format.label;
    			});

    			// Execute command when item from dropdown is selected.
    			this.listenTo(itemListModel, 'execute', function (evt, itemModel) {
    				editor.execute('headings', itemModel.id);
    				editor.editing.view.focus();
    			});

    			editor.ui.featureComponents.add('headings', ListDropdown, ListDropdownView, dropdownModel);
    		}
    	}], [{
    		key: 'requires',

    		/**
       * @inheritDoc
       */
    		get: function get() {
    			return [HeadingsEngine];
    		}
    	}]);
    	return Headings;
    }(Feature);

    /**
     * Enter command. Used by the {@link enter.Enter enter feature} to handle the <kbd>Enter</kbd> key.
     *
     * @member enter
     * @extends ckeditor5.command.Command
     */

    var EnterCommand = function (_Command) {
    	inherits(EnterCommand, _Command);

    	function EnterCommand() {
    		classCallCheck(this, EnterCommand);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(EnterCommand).apply(this, arguments));
    	}

    	createClass(EnterCommand, [{
    		key: '_doExecute',
    		value: function _doExecute() {
    			var doc = this.editor.document;

    			doc.enqueueChanges(function () {
    				enterBlock(doc.batch(), doc.selection, { defaultBlockName: 'paragraph' });
    			});
    		}
    	}]);
    	return EnterCommand;
    }(Command);

    function enterBlock(batch, selection) {
    	var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    	var defaultBlockName = options.defaultBlockName;
    	var doc = batch.doc;
    	var isSelectionEmpty = selection.isCollapsed;
    	var range = selection.getFirstRange();
    	var startElement = range.start.parent;
    	var endElement = range.end.parent;

    	// Don't touch the root.
    	if (startElement.root == startElement) {
    		if (!isSelectionEmpty) {
    			doc.composer.deleteContents(batch, selection);
    		}

    		return;
    	}

    	if (isSelectionEmpty) {
    		splitBlock(batch, selection, range.start, defaultBlockName);
    	} else {
    		var shouldMerge = range.start.isAtStart() && range.end.isAtEnd();
    		var isContainedWithinOneElement = startElement == endElement;

    		doc.composer.deleteContents(batch, selection, { merge: shouldMerge });

    		// Fully selected elements.
    		//
    		// <h>[xx</h><p>yy]<p>	-> <h>^</h>				-> <p>^</p>
    		// <h>[xxyy]</h>		-> <h>^</h>				-> <p>^</p>
    		if (shouldMerge) {
    			// We'll lose the ref to the renamed element, so let's keep a position inside it
    			// (offsets won't change, so it will stay in place). See ckeditor5-engine#367.
    			var pos = Position.createFromPosition(selection.focus);
    			var newBlockName = getNewBlockName(doc, startElement, defaultBlockName);

    			if (startElement.name != newBlockName) {
    				batch.rename(newBlockName, startElement);
    			}

    			selection.collapse(pos);
    		}
    		// Partially selected elements.
    		//
    		// <h>x[xx]x</h>		-> <h>x^x</h>			-> <h>x</h><h>^x</h>
    		else if (isContainedWithinOneElement) {
    				splitBlock(batch, selection, selection.focus, defaultBlockName);
    			}
    			// Selection over multilpe elements.
    			//
    			// <h>x[x</h><p>y]y<p>	-> <h>x^</h><p>y</p>	-> <h>x</h><p>^y</p>
    			else {
    					selection.collapse(endElement);
    				}
    	}
    }

    function splitBlock(batch, selection, splitPos, defaultBlockName) {
    	var doc = batch.doc;
    	var parent = splitPos.parent;

    	if (splitPos.isAtEnd()) {
    		var newElement = new Element(getNewBlockName(doc, parent, defaultBlockName));

    		batch.insert(Position.createAfter(parent), newElement);

    		selection.collapse(newElement);
    	} else {
    		// TODO After ckeditor5-engine#340 is fixed we'll be able to base on splitPos's location.
    		var endPos = LivePosition.createFromPosition(splitPos);
    		endPos.stickiness = 'STICKS_TO_NEXT';

    		batch.split(splitPos);

    		selection.collapse(endPos);

    		endPos.detach();
    	}
    }

    function getNewBlockName(doc, startElement, defaultBlockName) {
    	if (doc.schema.check({ name: defaultBlockName, inside: startElement.parent.name })) {
    		return defaultBlockName;
    	}

    	return startElement.name;
    }

    /**
     * Enter observer introduce the {@link engine.view.Document#enter} event.
     *
     * @memberOf enter
     * @extends engine.view.observer.Observer
     */

    var EnterObserver = function (_Observer) {
      inherits(EnterObserver, _Observer);

      function EnterObserver(document) {
        classCallCheck(this, EnterObserver);

        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(EnterObserver).call(this, document));

        document.on('keydown', function (evt, data) {
          if (_this.isEnabled && data.keyCode == keyCodes.enter) {
            document.fire('enter', new DomEventData(document, data.domEvent));
          }
        });
        return _this;
      }

      /**
       * @inheritDoc
       */


      createClass(EnterObserver, [{
        key: 'observe',
        value: function observe() {}
      }]);
      return EnterObserver;
    }(Observer);

    /**
     * The enter feature. Handles the <kbd>Enter</kbd> and <kbd>Shift + Enter</kbd> keys in the editor.
     *
     * @memberOf enter
     * @extends ckeditor5.Feature
     */

    var Enter = function (_Feature) {
    	inherits(Enter, _Feature);

    	function Enter() {
    		classCallCheck(this, Enter);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(Enter).apply(this, arguments));
    	}

    	createClass(Enter, [{
    		key: 'init',
    		value: function init() {
    			var editor = this.editor;
    			var editingView = editor.editing.view;

    			editingView.addObserver(EnterObserver);

    			editor.commands.set('enter', new EnterCommand(editor));

    			// TODO We may use keystroke handler for that.
    			this.listenTo(editingView, 'enter', function (evt, data) {
    				editor.execute('enter');
    				data.preventDefault();
    			});
    		}
    	}]);
    	return Enter;
    }(Feature);

    var ClassicEditor = function (_Classic) {
    	inherits(ClassicEditor, _Classic);

    	function ClassicEditor() {
    		classCallCheck(this, ClassicEditor);
    		return possibleConstructorReturn(this, Object.getPrototypeOf(ClassicEditor).apply(this, arguments));
    	}

    	createClass(ClassicEditor, null, [{
    		key: 'create',
    		value: function create(element) {
    			var config = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    			if (!config.features) {
    				config.features = [];
    			}

    			config.features = [].concat(toConsumableArray(config.features), [Delete, Typing, Undo, Bold, Italic, Headings, Paragraph, Enter]);

    			return ClassicEditor$1.create(element, config);
    		}
    	}]);
    	return ClassicEditor;
    }(ClassicEditor$1);

    return ClassicEditor;

}());